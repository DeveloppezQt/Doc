<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en">
<db:info>
<db:title>QRhiTexture Class</db:title>
<db:productname>QtGui</db:productname>
<db:edition>Qt 6.8.3 Reference Documentation</db:edition>
<db:titleabbrev>Qt GUI Reference Documentation</db:titleabbrev>
<db:abstract>
<db:para>Texture resource.</db:para>
<db:para>This class was introduced in Qt 6.6.</db:para>
</db:abstract>
<db:pubdate>2025-06-29</db:pubdate>
<db:date>2025-06-29</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:variablelist>
<db:varlistentry>
<db:term>Header</db:term>
<db:listitem>
<db:para>rhi/qrhi.h</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Since</db:term>
<db:listitem>
<db:para>Qt 6.6</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>CMake</db:term>
<db:listitem>
<db:para>find_package(Qt6 REQUIRED COMPONENTS Gui)</db:para>
<db:para>target_link_libraries(mytarget PRIVATE Qt6::GuiPrivate)</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>qmake</db:term>
<db:listitem>
<db:para>QT += gui-private</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Inherits</db:term>
<db:listitem>
<db:para><db:link xlink:href="qrhiresource.xml" xlink:role="class">QRhiResource</db:link></db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Inherited By</db:term>
<db:listitem>
<db:para/>
</db:listitem>
</db:varlistentry>
</db:variablelist>
<db:section xml:id="details">
<db:title>Detailed Description</db:title>
<db:para>A <db:link xlink:href="qrhitexture.xml">QRhiTexture</db:link> encapsulates a native texture object, such as a <db:code>VkImage</db:code> or <db:code>MTLTexture</db:code>.</db:para>
<db:para>A <db:link xlink:href="qrhitexture.xml">QRhiTexture</db:link> instance is always created by calling <db:link xlink:href="qrhi.xml#newTexture">the QRhi's newTexture() function</db:link>. This creates no native graphics resources. To do that, call create() after setting the appropriate options, such as the format and size, although in most cases these are already set based on the arguments passed to <db:link xlink:href="qrhi.xml#newTexture">newTexture</db:link>().</db:para>
<db:para>Setting the <db:link xlink:href="qrhitexture.xml#Flag-enum">flags</db:link> correctly is essential, otherwise various errors can occur depending on the underlying <db:link xlink:href="qrhi.xml">QRhi</db:link> backend and graphics API. For example, when a texture will be rendered into from a render pass via <db:link xlink:href="qrhitexturerendertarget.xml">QRhiTextureRenderTarget</db:link>, the texture must be created with the <db:link xlink:href="qrhitexture.xml#Flag-enum">RenderTarget</db:link> flag set. Similarly, when the texture is going to be <db:link xlink:href="qrhiresourceupdatebatch.xml#readBackTexture">read back</db:link>, the <db:link xlink:href="qrhitexture.xml#Flag-enum">UsedAsTransferSource</db:link> flag must be set upfront. Mipmapped textures must have the <db:link xlink:href="qrhitexture.xml#Flag-enum">MipMapped</db:link> flag set. And so on. It is not possible to change the flags once create() has succeeded. To release the existing and create a new native texture object with the changed settings, call the setters and call create() again. This then might be a potentially expensive operation.</db:para>
<db:section xml:id="example-usage">
<db:title>Example usage</db:title>
<db:para>To create a 2D texture with a size of 512x512 pixels and set its contents to all green:</db:para>
<db:programlisting language="cpp">QRhiTexture *texture = rhi-&gt;newTexture(QRhiTexture::RGBA8, QSize(512, 512));
if (!texture-&gt;create()) { error(); }
QRhiResourceUpdateBatch *batch = rhi-&gt;nextResourceUpdateBatch();
QImage image(512, 512, QImage::Format_RGBA8888);
image.fill(Qt::green);
batch-&gt;uploadTexture(texture, image);
// ...
commandBuffer-&gt;resourceUpdate(batch); // or, alternatively, pass 'batch' to a beginPass() call
</db:programlisting>
</db:section>
<db:section xml:id="common-patterns">
<db:title>Common patterns</db:title>
<db:para>A call to create() destroys any existing native resources if create() was successfully called before. If those native resources are still in use by an in-flight frame (i.e., there's a chance they are still read by the GPU), the destroying of those resources is deferred automatically. Thus a very common and convenient pattern to safely change the size of an already existing texture is the following. In practice this drops and creates a whole new native texture resource underneath, so it is not necessarily a cheap operation, but is more convenient and still faster than the alternatives, because by not destroying the <db:code>texture</db:code> object itself, all references to it stay valid in other data structures (e.g., in any QShaderResourceBinding the <db:link xlink:href="qrhitexture.xml">QRhiTexture</db:link> is referenced from).</db:para>
<db:programlisting language="cpp">// determine newSize, e.g. based on the swapchain's output size or other factors
if (texture-&gt;pixelSize() != newSize) {
    texture-&gt;setPixelSize(newSize);
    if (!texture-&gt;create()) { error(); }
}
// continue using texture, fill it with new data
</db:programlisting>
<db:note>
<db:para>This is a RHI API with limited compatibility guarantees, see <db:link xlink:href="qrhi.xml">QRhi</db:link> for details.</db:para>
</db:note>
</db:section>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qrhiresourceupdatebatch.xml">QRhiResourceUpdateBatch</db:link></db:member>
<db:member><db:link xlink:href="qrhi.xml">QRhi</db:link></db:member>
<db:member><db:link xlink:href="qrhitexturerendertarget.xml">QRhiTextureRenderTarget</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="member-type-documentation">
<db:title>Member Type Documentation</db:title>
<db:section xml:id="Flag-enum">
<db:title>enum QRhiTexture::Flag</db:title>
<db:bridgehead renderas="sect2">flags QRhiTexture::Flags</db:bridgehead>
<db:para>Flag values to specify how the texture is going to be used. Not honoring the flags set before create() and attempting to use the texture in ways that was not declared upfront can lead to unspecified behavior or decreased performance depending on the backend and the underlying graphics API.</db:para>
<db:informaltable>
<db:thead>
<db:tr>
<db:th>Constant</db:th>
<db:th>Value</db:th>
<db:th>Description</db:th>
</db:tr>
</db:thead>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qrhitexture.xml">QRhiTexture</db:link></db:emphasis>::RenderTarget</db:code></db:para>
</db:td>
<db:td><db:code>1 &lt;&lt; 0</db:code></db:td>
<db:td>
<db:para>The texture going to be used in combination with <db:link xlink:href="qrhitexturerendertarget.xml">QRhiTextureRenderTarget</db:link>.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qrhitexture.xml">QRhiTexture</db:link></db:emphasis>::CubeMap</db:code></db:para>
</db:td>
<db:td><db:code>1 &lt;&lt; 2</db:code></db:td>
<db:td>
<db:para>The texture is a cubemap. Such textures have 6 layers, one for each face in the order of +X, -X, +Y, -Y, +Z, -Z. Cubemap textures cannot be multisample.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qrhitexture.xml">QRhiTexture</db:link></db:emphasis>::MipMapped</db:code></db:para>
</db:td>
<db:td><db:code>1 &lt;&lt; 3</db:code></db:td>
<db:td>
<db:para>The texture has mipmaps. The appropriate mip count is calculated automatically and can also be retrieved via <db:link xlink:href="qrhi.xml#mipLevelsForSize">QRhi::mipLevelsForSize</db:link>(). The images for the mip levels have to be provided in the texture uploaded or generated via <db:link xlink:href="qrhiresourceupdatebatch.xml#generateMips">QRhiResourceUpdateBatch::generateMips</db:link>(). Multisample textures cannot have mipmaps.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qrhitexture.xml">QRhiTexture</db:link></db:emphasis>::sRGB</db:code></db:para>
</db:td>
<db:td><db:code>1 &lt;&lt; 4</db:code></db:td>
<db:td>
<db:para>Use an sRGB format.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qrhitexture.xml">QRhiTexture</db:link></db:emphasis>::UsedAsTransferSource</db:code></db:para>
</db:td>
<db:td><db:code>1 &lt;&lt; 5</db:code></db:td>
<db:td>
<db:para>The texture is used as the source of a texture copy or readback, meaning the texture is given as the source in <db:link xlink:href="qrhiresourceupdatebatch.xml#copyTexture">QRhiResourceUpdateBatch::copyTexture</db:link>() or <db:link xlink:href="qrhiresourceupdatebatch.xml#readBackTexture">QRhiResourceUpdateBatch::readBackTexture</db:link>().</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qrhitexture.xml">QRhiTexture</db:link></db:emphasis>::UsedWithGenerateMips</db:code></db:para>
</db:td>
<db:td><db:code>1 &lt;&lt; 6</db:code></db:td>
<db:td>
<db:para>The texture is going to be used with <db:link xlink:href="qrhiresourceupdatebatch.xml#generateMips">QRhiResourceUpdateBatch::generateMips</db:link>().</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qrhitexture.xml">QRhiTexture</db:link></db:emphasis>::UsedWithLoadStore</db:code></db:para>
</db:td>
<db:td><db:code>1 &lt;&lt; 7</db:code></db:td>
<db:td>
<db:para>The texture is going to be used with image load/store operations, for example, in a compute shader.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qrhitexture.xml">QRhiTexture</db:link></db:emphasis>::UsedAsCompressedAtlas</db:code></db:para>
</db:td>
<db:td><db:code>1 &lt;&lt; 8</db:code></db:td>
<db:td>
<db:para>The texture has a compressed format and the dimensions of subresource uploads may not match the texture size.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qrhitexture.xml">QRhiTexture</db:link></db:emphasis>::ExternalOES</db:code></db:para>
</db:td>
<db:td><db:code>1 &lt;&lt; 9</db:code></db:td>
<db:td>
<db:para>The texture should use the GL_TEXTURE_EXTERNAL_OES target with OpenGL. This flag is ignored with other graphics APIs.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qrhitexture.xml">QRhiTexture</db:link></db:emphasis>::ThreeDimensional</db:code></db:para>
</db:td>
<db:td><db:code>1 &lt;&lt; 10</db:code></db:td>
<db:td>
<db:para>The texture is a 3D texture. Such textures should be created with the <db:link xlink:href="qrhi.xml#newTexture">QRhi::newTexture</db:link>() overload taking a depth in addition to width and height. A 3D texture can have mipmaps but cannot be multisample. When rendering into, or uploading data to a 3D texture, the <db:code>layer</db:code> specified in the render target's color attachment or the upload description refers to a single slice in range [0..depth-1]. The underlying graphics API may not support 3D textures at run time. Support is indicated by the <db:link xlink:href="qrhi.xml#Feature-enum">QRhi::ThreeDimensionalTextures</db:link> feature.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qrhitexture.xml">QRhiTexture</db:link></db:emphasis>::TextureRectangleGL</db:code></db:para>
</db:td>
<db:td><db:code>1 &lt;&lt; 11</db:code></db:td>
<db:td>
<db:para>The texture should use the GL_TEXTURE_RECTANGLE target with OpenGL. This flag is ignored with other graphics APIs. Just like ExternalOES, this flag is useful when working with platform APIs where native OpenGL texture objects received from the platform are wrapped in a <db:link xlink:href="qrhitexture.xml">QRhiTexture</db:link>, and the platform can only provide textures for a non-2D texture target.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qrhitexture.xml">QRhiTexture</db:link></db:emphasis>::TextureArray</db:code></db:para>
</db:td>
<db:td><db:code>1 &lt;&lt; 12</db:code></db:td>
<db:td>
<db:para>The texture is a texture array, i.e. a single texture object that is a homogeneous array of 2D textures. Texture arrays are created with <db:link xlink:href="qrhi.xml#newTextureArray">QRhi::newTextureArray</db:link>(). The underlying graphics API may not support texture array objects at run time. Support is indicated by the <db:link xlink:href="qrhi.xml#Feature-enum">QRhi::TextureArrays</db:link> feature. When rendering into, or uploading data to a texture array, the <db:code>layer</db:code> specified in the render target's color attachment or the upload description selects a single element in the array.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qrhitexture.xml">QRhiTexture</db:link></db:emphasis>::OneDimensional</db:code></db:para>
</db:td>
<db:td><db:code>1 &lt;&lt; 13</db:code></db:td>
<db:td>
<db:para>The texture is a 1D texture. Such textures can be created by passing a 0 height and depth to <db:link xlink:href="qrhi.xml#newTexture">QRhi::newTexture</db:link>(). Note that there can be limitations on one dimensional textures depending on the underlying graphics API. For example, rendering to them or using them with mipmap-based filtering may be unsupported. This is indicated by the <db:link xlink:href="qrhi.xml#Feature-enum">QRhi::OneDimensionalTextures</db:link> and <db:link xlink:href="qrhi.xml#Feature-enum">QRhi::OneDimensionalTextureMipmaps</db:link> feature flags.</db:para>
</db:td>
</db:tr>
</db:informaltable>
<db:para>The <db:code>Flags</db:code> type is a typedef for <db:code><db:link xlink:href="qflags.xml">QFlags</db:link>&lt;Flag&gt;. </db:code>It stores an OR combination of <db:code>Flag</db:code> values.</db:para>
</db:section>
<db:section xml:id="Format-enum">
<db:title>enum QRhiTexture::Format</db:title>
<db:para>Specifies the texture format. See also <db:link xlink:href="qrhi.xml#isTextureFormatSupported">QRhi::isTextureFormatSupported</db:link>() and note that flags() can modify the format when <db:link xlink:href="qrhitexture.xml#Flag-enum">QRhiTexture::sRGB</db:link> is set.</db:para>
<db:informaltable>
<db:thead>
<db:tr>
<db:th>Constant</db:th>
<db:th>Value</db:th>
<db:th>Description</db:th>
</db:tr>
</db:thead>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qrhitexture.xml">QRhiTexture</db:link></db:emphasis>::UnknownFormat</db:code></db:para>
</db:td>
<db:td><db:code>0</db:code></db:td>
<db:td>
<db:para>Not a valid format. This cannot be passed to setFormat().</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qrhitexture.xml">QRhiTexture</db:link></db:emphasis>::RGBA8</db:code></db:para>
</db:td>
<db:td><db:code>1</db:code></db:td>
<db:td>
<db:para>Four component, unsigned normalized 8 bit per component. Always supported.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qrhitexture.xml">QRhiTexture</db:link></db:emphasis>::BGRA8</db:code></db:para>
</db:td>
<db:td><db:code>2</db:code></db:td>
<db:td>
<db:para>Four component, unsigned normalized 8 bit per component.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qrhitexture.xml">QRhiTexture</db:link></db:emphasis>::R8</db:code></db:para>
</db:td>
<db:td><db:code>3</db:code></db:td>
<db:td>
<db:para>One component, unsigned normalized 8 bit.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qrhitexture.xml">QRhiTexture</db:link></db:emphasis>::RG8</db:code></db:para>
</db:td>
<db:td><db:code>4</db:code></db:td>
<db:td>
<db:para>Two components, unsigned normalized 8 bit.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qrhitexture.xml">QRhiTexture</db:link></db:emphasis>::R16</db:code></db:para>
</db:td>
<db:td><db:code>5</db:code></db:td>
<db:td>
<db:para>One component, unsigned normalized 16 bit.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qrhitexture.xml">QRhiTexture</db:link></db:emphasis>::RG16</db:code></db:para>
</db:td>
<db:td><db:code>6</db:code></db:td>
<db:td>
<db:para>Two component, unsigned normalized 16 bit.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qrhitexture.xml">QRhiTexture</db:link></db:emphasis>::RED_OR_ALPHA8</db:code></db:para>
</db:td>
<db:td><db:code>7</db:code></db:td>
<db:td>
<db:para>Either same as R8, or is a similar format with the component swizzled to alpha, depending on <db:link xlink:href="qrhi.xml#Feature-enum">RedOrAlpha8IsRed</db:link>.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qrhitexture.xml">QRhiTexture</db:link></db:emphasis>::RGBA16F</db:code></db:para>
</db:td>
<db:td><db:code>8</db:code></db:td>
<db:td>
<db:para>Four components, 16-bit float per component.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qrhitexture.xml">QRhiTexture</db:link></db:emphasis>::RGBA32F</db:code></db:para>
</db:td>
<db:td><db:code>9</db:code></db:td>
<db:td>
<db:para>Four components, 32-bit float per component.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qrhitexture.xml">QRhiTexture</db:link></db:emphasis>::R16F</db:code></db:para>
</db:td>
<db:td><db:code>10</db:code></db:td>
<db:td>
<db:para>One component, 16-bit float.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qrhitexture.xml">QRhiTexture</db:link></db:emphasis>::R32F</db:code></db:para>
</db:td>
<db:td><db:code>11</db:code></db:td>
<db:td>
<db:para>One component, 32-bit float.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qrhitexture.xml">QRhiTexture</db:link></db:emphasis>::RGB10A2</db:code></db:para>
</db:td>
<db:td><db:code>12</db:code></db:td>
<db:td>
<db:para>Four components, unsigned normalized 10 bit R, G, and B, 2-bit alpha. This is a packed format so native endianness applies. Note that there is no BGR10A2. This is because RGB10A2 maps to DXGI_FORMAT_R10G10B10A2_UNORM with D3D, MTLPixelFormatRGB10A2Unorm with Metal, VK_FORMAT_A2B10G10R10_UNORM_PACK32 with Vulkan, and GL_RGB10_A2/GL_RGB/GL_UNSIGNED_INT_2_10_10_10_REV on OpenGL (ES). This is the only universally supported RGB30 option. The corresponding <db:link xlink:href="qimage.xml">QImage</db:link> formats are <db:link xlink:href="qimage.xml#Format-enum">QImage::Format_BGR30</db:link> and <db:link xlink:href="qimage.xml#Format-enum">QImage::Format_A2BGR30_Premultiplied</db:link>.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qrhitexture.xml">QRhiTexture</db:link></db:emphasis>::D16</db:code></db:para>
</db:td>
<db:td><db:code>13</db:code></db:td>
<db:td>
<db:para>16-bit depth (normalized unsigned integer)</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qrhitexture.xml">QRhiTexture</db:link></db:emphasis>::D24</db:code></db:para>
</db:td>
<db:td><db:code>14</db:code></db:td>
<db:td>
<db:para>24-bit depth (normalized unsigned integer)</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qrhitexture.xml">QRhiTexture</db:link></db:emphasis>::D24S8</db:code></db:para>
</db:td>
<db:td><db:code>15</db:code></db:td>
<db:td>
<db:para>24-bit depth (normalized unsigned integer), 8 bit stencil</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qrhitexture.xml">QRhiTexture</db:link></db:emphasis>::D32F</db:code></db:para>
</db:td>
<db:td><db:code>16</db:code></db:td>
<db:td>
<db:para>32-bit depth (32-bit float)</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qrhitexture.xml">QRhiTexture</db:link></db:emphasis>::BC1</db:code></db:para>
</db:td>
<db:td><db:code>17</db:code></db:td>
<db:td/>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qrhitexture.xml">QRhiTexture</db:link></db:emphasis>::BC2</db:code></db:para>
</db:td>
<db:td><db:code>18</db:code></db:td>
<db:td/>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qrhitexture.xml">QRhiTexture</db:link></db:emphasis>::BC3</db:code></db:para>
</db:td>
<db:td><db:code>19</db:code></db:td>
<db:td/>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qrhitexture.xml">QRhiTexture</db:link></db:emphasis>::BC4</db:code></db:para>
</db:td>
<db:td><db:code>20</db:code></db:td>
<db:td/>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qrhitexture.xml">QRhiTexture</db:link></db:emphasis>::BC5</db:code></db:para>
</db:td>
<db:td><db:code>21</db:code></db:td>
<db:td/>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qrhitexture.xml">QRhiTexture</db:link></db:emphasis>::BC6H</db:code></db:para>
</db:td>
<db:td><db:code>22</db:code></db:td>
<db:td/>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qrhitexture.xml">QRhiTexture</db:link></db:emphasis>::BC7</db:code></db:para>
</db:td>
<db:td><db:code>23</db:code></db:td>
<db:td/>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qrhitexture.xml">QRhiTexture</db:link></db:emphasis>::ETC2_RGB8</db:code></db:para>
</db:td>
<db:td><db:code>24</db:code></db:td>
<db:td/>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qrhitexture.xml">QRhiTexture</db:link></db:emphasis>::ETC2_RGB8A1</db:code></db:para>
</db:td>
<db:td><db:code>25</db:code></db:td>
<db:td/>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qrhitexture.xml">QRhiTexture</db:link></db:emphasis>::ETC2_RGBA8</db:code></db:para>
</db:td>
<db:td><db:code>26</db:code></db:td>
<db:td/>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qrhitexture.xml">QRhiTexture</db:link></db:emphasis>::ASTC_4x4</db:code></db:para>
</db:td>
<db:td><db:code>27</db:code></db:td>
<db:td/>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qrhitexture.xml">QRhiTexture</db:link></db:emphasis>::ASTC_5x4</db:code></db:para>
</db:td>
<db:td><db:code>28</db:code></db:td>
<db:td/>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qrhitexture.xml">QRhiTexture</db:link></db:emphasis>::ASTC_5x5</db:code></db:para>
</db:td>
<db:td><db:code>29</db:code></db:td>
<db:td/>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qrhitexture.xml">QRhiTexture</db:link></db:emphasis>::ASTC_6x5</db:code></db:para>
</db:td>
<db:td><db:code>30</db:code></db:td>
<db:td/>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qrhitexture.xml">QRhiTexture</db:link></db:emphasis>::ASTC_6x6</db:code></db:para>
</db:td>
<db:td><db:code>31</db:code></db:td>
<db:td/>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qrhitexture.xml">QRhiTexture</db:link></db:emphasis>::ASTC_8x5</db:code></db:para>
</db:td>
<db:td><db:code>32</db:code></db:td>
<db:td/>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qrhitexture.xml">QRhiTexture</db:link></db:emphasis>::ASTC_8x6</db:code></db:para>
</db:td>
<db:td><db:code>33</db:code></db:td>
<db:td/>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qrhitexture.xml">QRhiTexture</db:link></db:emphasis>::ASTC_8x8</db:code></db:para>
</db:td>
<db:td><db:code>34</db:code></db:td>
<db:td/>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qrhitexture.xml">QRhiTexture</db:link></db:emphasis>::ASTC_10x5</db:code></db:para>
</db:td>
<db:td><db:code>35</db:code></db:td>
<db:td/>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qrhitexture.xml">QRhiTexture</db:link></db:emphasis>::ASTC_10x6</db:code></db:para>
</db:td>
<db:td><db:code>36</db:code></db:td>
<db:td/>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qrhitexture.xml">QRhiTexture</db:link></db:emphasis>::ASTC_10x8</db:code></db:para>
</db:td>
<db:td><db:code>37</db:code></db:td>
<db:td/>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qrhitexture.xml">QRhiTexture</db:link></db:emphasis>::ASTC_10x10</db:code></db:para>
</db:td>
<db:td><db:code>38</db:code></db:td>
<db:td/>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qrhitexture.xml">QRhiTexture</db:link></db:emphasis>::ASTC_12x10</db:code></db:para>
</db:td>
<db:td><db:code>39</db:code></db:td>
<db:td/>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qrhitexture.xml">QRhiTexture</db:link></db:emphasis>::ASTC_12x12</db:code></db:para>
</db:td>
<db:td><db:code>40</db:code></db:td>
<db:td/>
</db:tr>
</db:informaltable>
</db:section>
</db:section>
<db:section xml:id="member-function-documentation">
<db:title>Member Function Documentation</db:title>
<db:section xml:id="createFrom">
<db:title>[virtual] bool QRhiTexture::createFrom(QRhiTexture::NativeTexture <db:emphasis>src</db:emphasis>)</db:title>
<db:para>Similar to create(), except that no new native textures are created. Instead, the native texture resources specified by <db:code role="parameter">src</db:code> is used.</db:para>
<db:para>This allows importing an existing native texture object (which must belong to the same device or sharing context, depending on the graphics API) from an external graphics engine.</db:para>
<db:para>Returns true if the specified existing native texture object has been successfully wrapped as a non-owning <db:link xlink:href="qrhitexture.xml">QRhiTexture</db:link>.</db:para>
<db:note>
<db:para>format(), pixelSize(), sampleCount(), and flags() must still be set correctly. Passing incorrect sizes and other values to <db:link xlink:href="qrhi.xml#newTexture">QRhi::newTexture</db:link>() and then following it with a createFrom() expecting that the native texture object alone is sufficient to deduce such values is <db:emphasis role="bold">wrong</db:emphasis> and will lead to problems.</db:para>
</db:note>
<db:note>
<db:para><db:link xlink:href="qrhitexture.xml">QRhiTexture</db:link> does not take ownership of the texture object. destroy() does not free the object or any associated memory.</db:para>
</db:note>
<db:para>The opposite of this operation, exposing a <db:link xlink:href="qrhitexture.xml">QRhiTexture</db:link>-created native texture object to a foreign engine, is possible via <db:link xlink:href="qrhitexture.xml#nativeTexture">nativeTexture</db:link>().</db:para>
<db:note>
<db:para>When importing a 3D texture, or a texture array object, or, with OpenGL ES, an external texture, it is then especially important to set the corresponding flags (<db:link xlink:href="qrhitexture.xml#Flag-enum">ThreeDimensional</db:link>, <db:link xlink:href="qrhitexture.xml#Flag-enum">TextureArray</db:link>, <db:link xlink:href="qrhitexture.xml#Flag-enum">ExternalOES</db:link>) via setFlags() before calling this function.</db:para>
</db:note>
</db:section>
<db:section xml:id="nativeTexture">
<db:title>[virtual] QRhiTexture::NativeTexture QRhiTexture::nativeTexture()</db:title>
<db:para>Returns the underlying native resources for this texture. The returned value will be empty if exposing the underlying native resources is not supported by the backend.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qrhitexture.xml#createFrom">createFrom</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="resourceType">
<db:title>[override virtual] QRhiResource::Type QRhiTexture::resourceType() const</db:title>
<db:para>Returns the resource type.</db:para>
</db:section>
<db:section xml:id="setNativeLayout">
<db:title>[virtual] void QRhiTexture::setNativeLayout(int <db:emphasis>layout</db:emphasis>)</db:title>
<db:para>With some graphics APIs, such as Vulkan, integrating custom rendering code that uses the graphics API directly needs special care when it comes to image layouts. This function allows communicating the expected <db:code role="parameter">layout</db:code> the image backing the <db:link xlink:href="qrhitexture.xml">QRhiTexture</db:link> is in after the native rendering commands.</db:para>
<db:para>For example, consider rendering into a <db:link xlink:href="qrhitexture.xml">QRhiTexture</db:link>'s VkImage directly with Vulkan in a code block enclosed by <db:link xlink:href="qrhicommandbuffer.xml#beginExternal">QRhiCommandBuffer::beginExternal</db:link>() and <db:link xlink:href="qrhicommandbuffer.xml#endExternal">QRhiCommandBuffer::endExternal</db:link>(), followed by using the image for texture sampling in a <db:link xlink:href="qrhi.xml">QRhi</db:link>-based render pass. To avoid potentially incorrect image layout transitions, this function can be used to indicate what the image layout will be once the commands recorded in said code block complete.</db:para>
<db:para>Calling this function makes sense only after <db:link xlink:href="qrhicommandbuffer.xml#endExternal">QRhiCommandBuffer::endExternal</db:link>() and before a subsequent <db:link xlink:href="qrhicommandbuffer.xml#beginPass">QRhiCommandBuffer::beginPass</db:link>().</db:para>
<db:para>This function has no effect with <db:link xlink:href="qrhi.xml">QRhi</db:link> backends where the underlying graphics API does not expose a concept of image layouts.</db:para>
<db:note>
<db:para>With Vulkan <db:code role="parameter">layout</db:code> is a <db:code>VkImageLayout</db:code>. With Direct 3D 12 <db:code role="parameter">layout</db:code> is a value composed of the bits from <db:code>D3D12_RESOURCE_STATES</db:code>.</db:para>
</db:note>
</db:section>
</db:section>
</db:article>
