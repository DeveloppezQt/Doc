<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en">
<db:info>
<db:title>CMake Manual</db:title>
<db:productname>QtDoc</db:productname>
<db:edition>Qt 5.8.0 Reference Documentation</db:edition>
<db:titleabbrev>Qt Reference Documentation</db:titleabbrev>
<db:abstract>
<db:para>Qt Reference Documentation.</db:para></db:abstract>
<db:pubdate>2025-06-29</db:pubdate>
<db:date>2025-06-29</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:para><db:code>CMake</db:code> is a tool that helps simplify the build process for development projects across different platforms. <db:code>CMake</db:code> automates the generation of buildsystems such as Makefiles and Visual Studio project files.</db:para>
<db:para><db:code>CMake</db:code> is a 3rd party tool with its own <db:link xlink:href="http://www.cmake.org/cmake/help/documentation.html">documentation</db:link>. The rest of this manual details the specifics of how to use Qt 5 with <db:code>CMake</db:code>. The minimum version required to use Qt5 is <db:code>CMake</db:code> 2.8.3, but 2.8.11 is recommended.</db:para>
<db:section xml:id="getting-started">
<db:title>Getting Started</db:title>
<db:para>The first requirement when using <db:code>CMake</db:code> is to use <db:code>find_package</db:code> to locate the libraries and header files shipped with Qt. These libraries and header files can then be used to build libraries and applications based on Qt.</db:para>
<db:para>The recommended way to use Qt libraries and headers with <db:code>CMake</db:code> 2.8.11 is to use the <db:code>target_link_libraries</db:code> command. In <db:code>CMake</db:code> 2.8.11 and later versions, this command automatically adds appropriate include directories, compile definitions, the position-independent-code flag, and links to the qtmain.lib library on Windows.</db:para>
<db:para>To build a helloworld GUI executable, typical usage would be:</db:para>
<db:programlisting language="cpp">cmake_minimum_required(VERSION 2.8.11)

project(testproject)

# Find includes in corresponding build directories
set(CMAKE_INCLUDE_CURRENT_DIR ON)
# Instruct CMake to run moc automatically when needed.
set(CMAKE_AUTOMOC ON)

# Find the QtWidgets library
find_package(Qt5Widgets)

# Tell CMake to create the helloworld executable
add_executable(helloworld WIN32 main.cpp)

# Use the Widgets module from Qt 5.
target_link_libraries(helloworld Qt5::Widgets)
</db:programlisting>
<db:para>Note that setting the minimum required CMake version to 2.8.11 is required for automatic linking to the qtmain.lib library on Windows.</db:para>
<db:para>In order for <db:code>find_package</db:code> to be successful, Qt 5 must be found below the CMAKE_PREFIX_PATH, or the Qt5&lt;Module&gt;_DIR must be set in the <db:code>CMake</db:code> cache to the location of the Qt5WidgetsConfig.cmake file. The easiest way to use <db:code>CMake</db:code> is to set the CMAKE_PREFIX_PATH environment variable to the install prefix of Qt 5.</db:para>
<db:para>The CMAKE_AUTOMOC setting runs moc automatically when required. For more on this feature see the <db:link xlink:href="http://www.cmake.org/cmake/help/v2.8.11/cmake.html#prop_tgt:AUTOMOC">CMake AUTOMOC documentation</db:link></db:para>
<db:section xml:id="imported-targets">
<db:title>Imported targets</db:title>
<db:para>Imported targets are created for each Qt module. Imported target names should be preferred instead of using a variable like Qt5&lt;Module&gt;_LIBRARIES in CMake commands such as <db:code>target_link_libraries</db:code>. The actual path to the library can be obtained using the <db:link xlink:href="http://www.cmake.org/cmake/help/v2.8.11/cmake.html#prop_tgt:LOCATION">LOCATION property</db:link>:</db:para>
<db:programlisting language="cpp">find_package(Qt5Core)

get_target_property(QtCore_location Qt5::Core LOCATION)
</db:programlisting>
<db:para>Note however that it is rare to require the full location to the library in <db:code>CMake</db:code> code. Most <db:code>CMake</db:code> APIs are aware of imported targets and can automatically use them instead of the full path.</db:para>
<db:para>Each module in Qt 5 has a library target with the naming convention Qt5::&lt;Module&gt; which can be used for this purpose.</db:para>
<db:para>Imported targets are created with the configurations Qt was configured with. That is, if Qt was configured with the -debug switch, an imported target with the configuration DEBUG will be created. If Qt was configured with the -release switch an imported target with the configuration RELEASE will be created. If Qt was configured with the -debug-and-release switch (the default on windows), then imported targets will be created with both RELEASE and DEBUG configurations.</db:para>
<db:para>If your project has custom CMake build configurations, it may be necessary to set a mapping from your custom configuration to either the debug or release Qt configuration.</db:para>
<db:programlisting language="cpp">find_package(Qt5Core)

set(CMAKE_CXX_FLAGS_COVERAGE &quot;${CMAKE_CXX_FLAGS_RELEASE} -fprofile-arcs -ftest-coverage&quot;)

# set up a mapping so that the Release configuration for the Qt imported target is
# used in the COVERAGE CMake configuration.
set_target_properties(Qt5::Core PROPERTIES MAP_IMPORTED_CONFIG_COVERAGE &quot;RELEASE&quot;)
</db:programlisting>
<db:para>Plugins are also available as <db:code>IMPORTED</db:code> targets in CMake. The <db:link xlink:href="qtnetwork-index.xml">Qt Network</db:link>, <db:link xlink:href="qtsql-index.xml">Qt SQL</db:link>, <db:link xlink:href="qtgui-index.xml">Qt GUI</db:link>, and <db:link xlink:href="qtwidgets-index.xml">Qt Widgets</db:link> modules have plugins associated. They provide a list of plugins in the <db:code>Qt5</db:code><db:emphasis>&lt;Module&gt;</db:emphasis><db:code>_PLUGINS</db:code> variable.</db:para>
<db:programlisting language="cpp">foreach(plugin ${Qt5Network_PLUGINS})
  get_target_property(_loc ${plugin} LOCATION)
  message(&quot;Plugin ${plugin} is at location ${_loc}&quot;)
endforeach()
</db:programlisting>
</db:section>
<db:section xml:id="using-qt-5-with-cmake-older-than-3-1-0">
<db:title>Using Qt 5 with <db:code>CMake</db:code> older than 3.1.0</db:title>
<db:para>Qt 5.7 requires C++11 support. <db:code>CMake</db:code> starting from version 3.1.0 implicitly adds the minimum required compiler flags (e.g. <db:code>-std=gnu++11</db:code>) to the Qt5 module targets. If you use <db:code>CMake</db:code> version older than 3.1.0, you need to add the needed <db:code>-std=...</db:code> to the targets linking against Qt5 modules yourself.</db:para>
<db:para>If you use Qt 5.7 and a <db:code>CMake</db:code> version above 3.1.0, plus require a more recent C++ standard version, use the CMake way of selecting the standard version, or specify features required and let CMake compute the flags. Example:</db:para>
<db:programlisting language="cpp">set(CMAKE_CXX_STANDARD 14)
</db:programlisting>
<db:para>Also see: <db:link xlink:href="https://cmake.org/cmake/help/v3.1/manual/cmake-compile-features.7.html">CMake cmake-compile-features Documentation</db:link></db:para>
</db:section>
<db:section xml:id="using-qt-5-with-cmake-older-than-2-8-12">
<db:title>Using Qt 5 with <db:code>CMake</db:code> older than 2.8.12</db:title>
<db:para>It is also necessary when using an older <db:code>CMake</db:code> to add Qt5&lt;Module&gt;_EXECUTABLE_COMPILE_FLAGS to the CMAKE_CXX_FLAGS so that the -fPIC flags are added to the compile flags if necessary (as is the default with Qt 5).</db:para>
</db:section>
<db:section xml:id="using-qt-5-with-cmake-older-than-2-8-11">
<db:title>Using Qt 5 with <db:code>CMake</db:code> older than 2.8.11</db:title>
<db:para>The recommended way to use Qt libraries and headers with <db:code>CMake</db:code> prior to 2.8.11 is to use the <db:code>qt5_use_modules</db:code> macro.</db:para>
<db:para>Note that it is necessary to use <db:code>find_package</db:code> to find a Qt module before using the macro. See the documentation for the <db:link xlink:href="http://www.cmake.org/cmake/help/v2.8.11/cmake.html#command:find_package">CMake find_package Documentation</db:link> command for the full options it supports.</db:para>
<db:para>The <db:code>qt5_use_modules</db:code> macro encapsulates all of the variable usage required to use a Qt module. It automatically finds the modules given to it on the command line if they have not already been found.</db:para>
<db:programlisting language="cpp">find_package(Qt5Widgets)

add_executable(helloworld WIN32 main.cpp)

qt5_use_modules(helloworld Widgets)
</db:programlisting>
</db:section>
<db:section xml:id="using-qt-5-with-cmake-older-than-2-8-9">
<db:title>Using Qt 5 with <db:code>CMake</db:code> older than 2.8.9</db:title>
<db:para>If using <db:code>CMake</db:code> older than 2.8.9, the <db:code>qt5_use_modules</db:code> macro is not available. Attempting to use it will result in an error.</db:para>
<db:para>To use Qt 5 with versions of <db:code>CMake</db:code> older than 2.8.9, it is necessary to use the <db:code>target_link_libraries</db:code>, <db:code>include_directories</db:code>, and <db:code>add_definitions</db:code> commands, and to manually specify moc requirements with either <db:code>qt5_generate_moc</db:code> or <db:code>qt5_wrap_cpp</db:code>:</db:para>
<db:programlisting language="cpp">cmake_minimum_required(VERSION 2.8.3)

project(testproject)

# Find includes in corresponding build directories
set(CMAKE_INCLUDE_CURRENT_DIR ON)

# Find the QtWidgets library
find_package(Qt5Widgets)

# Add the include directories for the Qt 5 Widgets module to
# the compile lines.
include_directories(${Qt5Widgets_INCLUDE_DIRS})

# Use the compile definitions defined in the Qt 5 Widgets module
add_definitions(${Qt5Widgets_DEFINITIONS})

# Add compiler flags for building executables (-fPIE)
set(CMAKE_CXX_FLAGS &quot;${CMAKE_CXX_FLAGS} ${Qt5Widgets_EXECUTABLE_COMPILE_FLAGS}&quot;)

qt5_generate_moc(main.cpp main.moc)

# Tell CMake to create the helloworld executable
add_executable(helloworld main.cpp main.moc)

#Link the helloworld executable to the Qt 5 widgets library.
target_link_libraries(helloworld Qt5::Widgets)
</db:programlisting>
</db:section>
</db:section>
<db:section xml:id="variable-reference">
<db:title>Variable Reference</db:title>
<db:section xml:id="module-variables">
<db:title>Module variables</db:title>
<db:para>The result of a <db:code>find_package</db:code> call is that imported targets will be created for use with <db:code>target_link_libraries</db:code>, some variables will be populated with information required to configure the build, and macros will be made available for use. The name of the imported target for each module matches the name of the module with a prefix of 'Qt5::', for example Qt5::Widgets. All of the package-specific variables have a consistent name with a prefix of the name of the package. For example, <db:code>find_package</db:code>(Qt5Widgets) will make the following variables available if successfully found:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para>Qt5Widgets_VERSION String describing the version of the module.</db:para>
</db:listitem>
<db:listitem>
<db:para>Qt5Widgets_VERSION_STRING Same as Qt5Widgets_VERSION. Deprecated, use Qt5Widgets_VERSION instead.</db:para>
</db:listitem>
<db:listitem>
<db:para>Qt5Widgets_LIBRARIES List of libraries for use with the target_link_libraries command.</db:para>
</db:listitem>
<db:listitem>
<db:para>Qt5Widgets_INCLUDE_DIRS List of directories for use with the include_directories command.</db:para>
</db:listitem>
<db:listitem>
<db:para>Qt5Widgets_DEFINITIONS List of definitions for use with add_definitions.</db:para>
</db:listitem>
<db:listitem>
<db:para>Qt5Widgets_COMPILE_DEFINITIONS List of definitions for use with the COMPILE_DEFINITIONS target property.</db:para>
</db:listitem>
<db:listitem>
<db:para>Qt5Widgets_FOUND Boolean describing whether the module was found successfully.</db:para>
</db:listitem>
<db:listitem>
<db:para>Qt5Widgets_EXECUTABLE_COMPILE_FLAGS String of flags to be used when building executables.</db:para>
</db:listitem>
</db:itemizedlist>
<db:para>Equivalents of those variables will be available for all packages found with a <db:code>find_package</db:code> call. Note that the variables are case-sensitive.</db:para>
</db:section>
<db:section xml:id="installation-variables">
<db:title>Installation variables</db:title>
<db:para>Additionally, several other variables are available which do not relate to a particular package, but to the Qt installation itself.</db:para>
<db:itemizedlist>
<db:listitem>
<db:para>QT_VISIBILITY_AVAILABLE Boolean describing whether Qt was built with hidden visibility.</db:para>
</db:listitem>
<db:listitem>
<db:para>QT_LIBINFIX String containing the infix used in library names.</db:para>
</db:listitem>
</db:itemizedlist>
</db:section>
</db:section>
<db:section xml:id="macro-reference">
<db:title>Macro Reference</db:title>
<db:section xml:id="qt5core-macros">
<db:title>Qt5Core macros</db:title>
<db:para>Macros available when Qt5Core is found.</db:para>
<db:informaltable style="generic">
<db:thead>
<db:tr>
<db:th>
<db:para>Macro</db:para>
</db:th>
<db:th>
<db:para>Description</db:para>
</db:th>
</db:tr>
</db:thead>
<db:tr valign="top">
<db:td>
<db:para>qt5_wrap_cpp(outfiles inputfile ... OPTIONS ...)</db:para>
</db:td>
<db:td>
<db:para>Create moc code from a list of files containing Qt class with the <db:link xlink:href="qobject.xml#Q_OBJECT">Q_OBJECT</db:link> declaration. Per-directory preprocessor definitions are also added. Options may be given to moc, such as those found when executing &quot;moc -help&quot;.</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>qt5_add_resources(outfiles inputfile ... OPTIONS ...)</db:para>
</db:td>
<db:td>
<db:para>Create code from a list of Qt resource files. Options may be given to rcc, such as those found when executing &quot;rcc -help&quot;.</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>qt5_add_binary_resources(target inputfile ... OPTIONS ... DESTINATION ...)</db:para>
</db:td>
<db:td>
<db:para>Create an RCC file from a list of Qt resource files. Options may be given to rcc, such as those found when executing &quot;rcc -help&quot;. A destination may be given to use a different filename or path for the RCC file.</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>qt5_generate_moc(inputfile outputfile )</db:para>
</db:td>
<db:td>
<db:para>Creates a rule to run moc on infile and create outfile. Use this if for some reason QT5_WRAP_CPP() isn't appropriate, e.g. because you need a custom filename for the moc file or something similar.</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>qt5_use_modules(target [LINK_PUBLIC|LINK_PRIVATE] module ... )</db:para>
</db:td>
<db:td>
<db:para>Indicates that the target uses the named Qt 5 modules. The target will be linked to the specified modules, use the include directories installed by those modules, use the COMPILE_DEFINITIONS set by those modules, and use the COMPILE_FLAGS set by the modules. The LINK_PRIVATE or LINK_PUBLIC specifiers can optionally be specified. If LINK_PRIVATE is specified then the modules are not made part of the link interface of the target. See the documentation for <db:link xlink:href="http://www.cmake.org/cmake/help/v2.8.11/cmake.html#command:target_link_libraries">target_link_libraries</db:link> for more information.</db:para>
<db:para>Note that this macro is only available if using <db:code>CMake</db:code> 2.8.9 or later. This macro is obsolete. Use target_link_libraries with IMPORTED targets instead.</db:para>
</db:td>
</db:tr>
</db:informaltable>
</db:section>
<db:section xml:id="qt5widgets-macros">
<db:title>Qt5Widgets macros</db:title>
<db:para>Macros available when Qt5Widgets is found.</db:para>
<db:informaltable style="generic">
<db:thead>
<db:tr>
<db:th>
<db:para>Macro</db:para>
</db:th>
<db:th>
<db:para>Description</db:para>
</db:th>
</db:tr>
</db:thead>
<db:tr valign="top">
<db:td>
<db:para>qt5_wrap_ui(outfiles inputfile ... OPTIONS ...)</db:para>
</db:td>
<db:td>
<db:para>Create code from a list of Qt designer ui files. Options may be given to uic, such as those found when executing &quot;uic -help&quot;</db:para>
</db:td>
</db:tr>
</db:informaltable>
</db:section>
<db:section xml:id="qt5dbus-macros">
<db:title>Qt5DBus macros</db:title>
<db:para>Macros available when Qt5DBus is found.</db:para>
<db:informaltable style="generic">
<db:thead>
<db:tr>
<db:th>
<db:para>Macro</db:para>
</db:th>
<db:th>
<db:para>Description</db:para>
</db:th>
</db:tr>
</db:thead>
<db:tr valign="top">
<db:td>
<db:para>qt5_add_dbus_interface(outfiles interface basename)</db:para>
</db:td>
<db:td>
<db:para>Create the interface header and implementation files with the given basename from the given interface xml file and add it to the list of sources</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>qt5_add_dbus_interfaces(outfiles inputfile ... )</db:para>
</db:td>
<db:td>
<db:para>Create the interface header and implementation files for all listed interface xml files the name will be automatically determined from the name of the xml file</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>qt5_add_dbus_adaptor(outfiles xmlfile parentheader parentclassname [basename] [classname])</db:para>
</db:td>
<db:td>
<db:para>Create a dbus adaptor (header and implementation file) from the xml file describing the interface, and add it to the list of sources. The adaptor forwards the calls to a parent class, defined in parentheader and named parentclassname. The name of the generated files will be &lt;basename&gt;adaptor.{cpp,h} where basename defaults to the basename of the xml file. If &lt;classname&gt; is provided, then it will be used as the classname of the adaptor itself.</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>qt5_generate_dbus_interface( header [interfacename] OPTIONS ...)</db:para>
</db:td>
<db:td>
<db:para>Generate the xml interface file from the given header. If the optional argument interfacename is omitted, the name of the interface file is constructed from the basename of the header with the suffix .xml appended. Options may be given to qdbuscpp2xml, such as those found when executing &quot;qdbuscpp2xml –help&quot;</db:para>
</db:td>
</db:tr>
</db:informaltable>
</db:section>
<db:section xml:id="qt5linguisttools-macros">
<db:title>Qt5LinguistTools macros</db:title>
<db:para>Macros available when Qt5LinguistTools is found.</db:para>
<db:informaltable style="generic">
<db:thead>
<db:tr>
<db:th>
<db:para>Macro</db:para>
</db:th>
<db:th>
<db:para>Description</db:para>
</db:th>
</db:tr>
</db:thead>
<db:tr valign="top">
<db:td>
<db:para>qt5_create_translation( qm_files directories ... sources ... ts_files ... OPTIONS ...)</db:para>
</db:td>
<db:td>
<db:para>Out: qm_files In: Directories sources ts_files Options: flags to pass to lupdate, such as -extensions to specify Extensions for a directory scan. Generates commands to create .ts (via lupdate) and .qm (via lrelease) - files from directories and/or sources. The ts files are created and/or updated in the source tree (unless given with full paths). The qm files are generated in the build tree. Updating the translations can be done by adding the qm_files to the source list of your library/executable, so they are always updated, or by adding a custom target to control when they get updated/generated.</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>qt5_add_translation( qm_files ts_files ... )</db:para>
</db:td>
<db:td>
<db:para>Out: qm_files In: ts_files Generates commands to create .qm from .ts - files. The generated filenames can be found in qm_files. The ts_files must exist and are not updated in any way.</db:para>
</db:td>
</db:tr>
</db:informaltable>
</db:section>
</db:section>
</db:article>
