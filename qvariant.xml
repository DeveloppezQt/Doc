<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en">
<db:info>
<db:title>QVariant Class</db:title>
<db:productname>QtCore</db:productname>
<db:edition>Qt 5.6.3 Reference Documentation</db:edition>
<db:titleabbrev>Qt Core Reference Documentation</db:titleabbrev>
<db:abstract>
<db:para>The <db:link xlink:href="qvariant.xml">QVariant</db:link> class acts like a union for the most common Qt data types.</db:para>
</db:abstract>
<db:pubdate>2025-06-29</db:pubdate>
<db:date>2025-06-29</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:variablelist>
<db:varlistentry>
<db:term>Header</db:term>
<db:listitem>
<db:para>QVariant</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>qmake</db:term>
<db:listitem>
<db:para>QT += core</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Group</db:term>
<db:listitem>
<db:para>QVariant is part of <db:simplelist><db:member>objectmodel</db:member><db:member><db:link xlink:href="shared.xml">Implicitly Shared Classes</db:link></db:member></db:simplelist>
</db:para>
</db:listitem>
</db:varlistentry>
</db:variablelist>
<db:section xml:id="details">
<db:title>Detailed Description</db:title>
<db:para>Because C++ forbids unions from including types that have non-default constructors or destructors, most interesting Qt classes cannot be used in unions. Without <db:link xlink:href="qvariant.xml">QVariant</db:link>, this would be a problem for <db:link xlink:href="qobject.xml#property">QObject::property</db:link>() and for database work, etc.</db:para>
<db:para>A <db:link xlink:href="qvariant.xml">QVariant</db:link> object holds a single value of a single <db:link xlink:href="qvariant.xml#type">type</db:link>() at a time. (Some <db:link xlink:href="qvariant.xml#type">type</db:link>()s are multi-valued, for example a string list.) You can find out what type, T, the variant holds, convert it to a different type using <db:link xlink:href="qvariant.xml#convert">convert</db:link>(), get its value using one of the toT() functions (e.g., <db:link xlink:href="qvariant.xml#toSize">toSize</db:link>()) and check whether the type can be converted to a particular type using <db:link xlink:href="qvariant.xml#canConvert">canConvert</db:link>().</db:para>
<db:para>The methods named toT() (e.g., <db:link xlink:href="qvariant.xml#toInt">toInt</db:link>(), <db:link xlink:href="qvariant.xml#toString">toString</db:link>()) are const. If you ask for the stored type, they return a copy of the stored object. If you ask for a type that can be generated from the stored type, toT() copies and converts and leaves the object itself unchanged. If you ask for a type that cannot be generated from the stored type, the result depends on the type; see the function documentation for details.</db:para>
<db:para>Here is some example code to demonstrate the use of <db:link xlink:href="qvariant.xml">QVariant</db:link>:</db:para>
<db:programlisting language="cpp">QDataStream out(...);
QVariant v(123);                // The variant now contains an int
int x = v.toInt();              // x = 123
out &lt;&lt; v;                       // Writes a type tag and an int to out
v = QVariant(&quot;hello&quot;);          // The variant now contains a QByteArray
v = QVariant(tr(&quot;hello&quot;));      // The variant now contains a QString
int y = v.toInt();              // y = 0 since v cannot be converted to an int
QString s = v.toString();       // s = tr(&quot;hello&quot;)  (see QObject::tr())
out &lt;&lt; v;                       // Writes a type tag and a QString to out
...
QDataStream in(...);            // (opening the previously written stream)
in &gt;&gt; v;                        // Reads an Int variant
int z = v.toInt();              // z = 123
qDebug(&quot;Type is %s&quot;,            // prints &quot;Type is int&quot;
        v.typeName());
v = v.toInt() + 100;            // The variant now hold the value 223
v = QVariant(QStringList());
</db:programlisting>
<db:para>You can even store <db:link xlink:href="qlist.xml">QList</db:link>&lt;<db:link xlink:href="qvariant.xml">QVariant</db:link>&gt; and <db:link xlink:href="qmap.xml">QMap</db:link>&lt;<db:link xlink:href="qstring.xml">QString</db:link>, <db:link xlink:href="qvariant.xml">QVariant</db:link>&gt; values in a variant, so you can easily construct arbitrarily complex data structures of arbitrary types. This is very powerful and versatile, but may prove less memory and speed efficient than storing specific types in standard data structures.</db:para>
<db:para><db:link xlink:href="qvariant.xml">QVariant</db:link> also supports the notion of null values, where you can have a defined type with no value set. However, note that <db:link xlink:href="qvariant.xml">QVariant</db:link> types can only be cast when they have had a value set.</db:para>
<db:programlisting language="cpp">QVariant x, y(QString()), z(QString(&quot;&quot;));
x.convert(QVariant::Int);
// x.isNull() == true
// y.isNull() == true, z.isNull() == false
</db:programlisting>
<db:para><db:link xlink:href="qvariant.xml">QVariant</db:link> can be extended to support other types than those mentioned in the <db:link xlink:href="qvariant.xml#Type-enum" role="deprecated">Type</db:link> enum. See the <db:link xlink:href="qmetatype.xml">QMetaType</db:link> documentation for details.</db:para>
<db:section xml:id="a-note-on-gui-types">
<db:title>A Note on GUI Types</db:title>
<db:para>Because <db:link xlink:href="qvariant.xml">QVariant</db:link> is part of the Qt Core module, it cannot provide conversion functions to data types defined in Qt GUI, such as <db:link xlink:href="qcolor.xml">QColor</db:link>, <db:link xlink:href="qimage.xml">QImage</db:link>, and <db:link xlink:href="qpixmap.xml">QPixmap</db:link>. In other words, there is no <db:code>toColor()</db:code> function. Instead, you can use the QVariant::value() or the <db:link xlink:href="qvariant.xml#qvariant_cast">qvariant_cast</db:link>() template function. For example:</db:para>
<db:programlisting language="cpp">QVariant variant;
...
QColor color = variant.value&lt;QColor&gt;();
</db:programlisting>
<db:para>The inverse conversion (e.g., from <db:link xlink:href="qcolor.xml">QColor</db:link> to <db:link xlink:href="qvariant.xml">QVariant</db:link>) is automatic for all data types supported by <db:link xlink:href="qvariant.xml">QVariant</db:link>, including GUI-related types:</db:para>
<db:programlisting language="cpp">QColor color = palette().background().color();
QVariant variant = color;
</db:programlisting>
</db:section>
<db:section xml:id="using-canconvert-and-convert-consecutively">
<db:title>Using canConvert() and convert() Consecutively</db:title>
<db:para>When using <db:link xlink:href="qvariant.xml#canConvert">canConvert</db:link>() and <db:link xlink:href="qvariant.xml#convert">convert</db:link>() consecutively, it is possible for <db:link xlink:href="qvariant.xml#canConvert">canConvert</db:link>() to return true, but <db:link xlink:href="qvariant.xml#convert">convert</db:link>() to return false. This is typically because <db:link xlink:href="qvariant.xml#canConvert">canConvert</db:link>() only reports the general ability of <db:link xlink:href="qvariant.xml">QVariant</db:link> to convert between types given suitable data; it is still possible to supply data which cannot actually be converted.</db:para>
<db:para>For example, <db:link xlink:href="qvariant.xml#canConvert">canConvert</db:link>(Int) would return true when called on a variant containing a string because, in principle, <db:link xlink:href="qvariant.xml">QVariant</db:link> is able to convert strings of numbers to integers. However, if the string contains non-numeric characters, it cannot be converted to an integer, and any attempt to convert it will fail. Hence, it is important to have both functions return true for a successful conversion.</db:para>
</db:section>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="member-function-documentation">
<db:title>Member Function Documentation</db:title>
<db:section xml:id="QVariant">
<db:title>[noexcept] QVariant::QVariant()</db:title>
<db:para>Constructs an invalid variant.</db:para>
</db:section>
<db:section xml:id="QVariant-1">
<db:title>QVariant::QVariant(QChar <db:emphasis>c</db:emphasis>)</db:title>
<db:para>Constructs a new variant with a char value, <db:code role="parameter">c</db:code>.</db:para>
</db:section>
<db:section xml:id="QVariant-36">
<db:title>[since 5.0] QVariant::QVariant(const QUuid &amp;<db:emphasis>val</db:emphasis>)</db:title>
<db:para>Constructs a new variant with an uuid value, <db:code role="parameter">val</db:code>.</db:para>
<db:para>This function was introduced in Qt 5.0.</db:para>
</db:section>
<db:section xml:id="QVariant-38">
<db:title>QVariant::QVariant(const char *<db:emphasis>val</db:emphasis>)</db:title>
<db:para>Constructs a new variant with a string value of <db:code role="parameter">val</db:code>. The variant creates a deep copy of <db:code role="parameter">val</db:code> into a <db:link xlink:href="qstring.xml">QString</db:link> assuming UTF-8 encoding on the input <db:code role="parameter">val</db:code>.</db:para>
<db:para>Note that <db:code role="parameter">val</db:code> is converted to a <db:link xlink:href="qstring.xml">QString</db:link> for storing in the variant and <db:link xlink:href="qvariant.xml#userType">QVariant::userType</db:link>() will return <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QString</db:link> for the variant.</db:para>
<db:para>You can disable this operator by defining <db:code>QT_NO_CAST_FROM_ASCII</db:code> when you compile your applications.</db:para>
</db:section>
<db:section xml:id="QVariant-39">
<db:title>QVariant::QVariant(double <db:emphasis>val</db:emphasis>)</db:title>
<db:para>Constructs a new variant with a floating point value, <db:code role="parameter">val</db:code>.</db:para>
</db:section>
<db:section xml:id="QVariant-40">
<db:title>[since 4.6] QVariant::QVariant(float <db:emphasis>val</db:emphasis>)</db:title>
<db:para>Constructs a new variant with a floating point value, <db:code role="parameter">val</db:code>.</db:para>
<db:para>This function was introduced in Qt 4.6.</db:para>
</db:section>
<db:section xml:id="QVariant-41">
<db:title>QVariant::QVariant(int <db:emphasis>val</db:emphasis>)</db:title>
<db:para>Constructs a new variant with an integer value, <db:code role="parameter">val</db:code>.</db:para>
</db:section>
<db:section xml:id="QVariant-42">
<db:title>QVariant::QVariant(qlonglong <db:emphasis>val</db:emphasis>)</db:title>
<db:para>Constructs a new variant with a long long integer value, <db:code role="parameter">val</db:code>.</db:para>
</db:section>
<db:section xml:id="QVariant-43">
<db:title>QVariant::QVariant(qulonglong <db:emphasis>val</db:emphasis>)</db:title>
<db:para>Constructs a new variant with an unsigned long long integer value, <db:code role="parameter">val</db:code>.</db:para>
</db:section>
<db:section xml:id="QVariant-44">
<db:title>QVariant::QVariant(uint <db:emphasis>val</db:emphasis>)</db:title>
<db:para>Constructs a new variant with an unsigned integer value, <db:code role="parameter">val</db:code>.</db:para>
</db:section>
<db:section xml:id="QVariant-45">
<db:title>QVariant::QVariant(int <db:emphasis>typeId</db:emphasis>, const void *<db:emphasis>copy</db:emphasis>)</db:title>
<db:para>Constructs variant of type <db:code role="parameter">typeId</db:code>, and initializes with <db:code role="parameter">copy</db:code> if <db:code role="parameter">copy</db:code> is not 0.</db:para>
<db:para>Note that you have to pass the address of the variable you want stored.</db:para>
<db:para>Usually, you never have to use this constructor, use QVariant::fromValue() instead to construct variants from the pointer types represented by <db:code>QMetaType::VoidStar</db:code>, and <db:code>QMetaType::QObjectStar</db:code>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="">QVariant::fromValue()</db:link></db:member>
<db:member><db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::Type</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="QVariant-2">
<db:title>QVariant::QVariant(QDataStream &amp;<db:emphasis>s</db:emphasis>)</db:title>
<db:para>Reads the variant from the data stream, <db:code role="parameter">s</db:code>.</db:para>
</db:section>
<db:section xml:id="QVariant-3">
<db:title>QVariant::QVariant(QLatin1String <db:emphasis>val</db:emphasis>)</db:title>
<db:para>Constructs a new variant with a string value, <db:code role="parameter">val</db:code>.</db:para>
</db:section>
<db:section xml:id="QVariant-5">
<db:title>QVariant::QVariant(QVariant::Type <db:emphasis>type</db:emphasis>)</db:title>
<db:para>Constructs a null variant of type <db:code role="parameter">type</db:code>.</db:para>
</db:section>
<db:section xml:id="QVariant-6">
<db:title>QVariant::QVariant(bool <db:emphasis>val</db:emphasis>)</db:title>
<db:para>Constructs a new variant with a boolean value, <db:code role="parameter">val</db:code>.</db:para>
</db:section>
<db:section xml:id="QVariant-7">
<db:title>QVariant::QVariant(const QBitArray &amp;<db:emphasis>val</db:emphasis>)</db:title>
<db:para>Constructs a new variant with a bitarray value, <db:code role="parameter">val</db:code>.</db:para>
</db:section>
<db:section xml:id="QVariant-8">
<db:title>QVariant::QVariant(const QByteArray &amp;<db:emphasis>val</db:emphasis>)</db:title>
<db:para>Constructs a new variant with a bytearray value, <db:code role="parameter">val</db:code>.</db:para>
</db:section>
<db:section xml:id="QVariant-9">
<db:title>QVariant::QVariant(const QDate &amp;<db:emphasis>val</db:emphasis>)</db:title>
<db:para>Constructs a new variant with a date value, <db:code role="parameter">val</db:code>.</db:para>
</db:section>
<db:section xml:id="QVariant-10">
<db:title>QVariant::QVariant(const QDateTime &amp;<db:emphasis>val</db:emphasis>)</db:title>
<db:para>Constructs a new variant with a date/time value, <db:code role="parameter">val</db:code>.</db:para>
</db:section>
<db:section xml:id="QVariant-11">
<db:title>[since 4.7] QVariant::QVariant(const QEasingCurve &amp;<db:emphasis>val</db:emphasis>)</db:title>
<db:para>Constructs a new variant with an easing curve value, <db:code role="parameter">val</db:code>.</db:para>
<db:para>This function was introduced in Qt 4.7.</db:para>
</db:section>
<db:section xml:id="QVariant-12">
<db:title>QVariant::QVariant(const QHash&lt;QString, QVariant&gt; &amp;<db:emphasis>val</db:emphasis>)</db:title>
<db:para>Constructs a new variant with a hash of <db:link xlink:href="qvariant.xml">QVariant</db:link>s, <db:code role="parameter">val</db:code>.</db:para>
</db:section>
<db:section xml:id="QVariant-13">
<db:title>[since 5.0] QVariant::QVariant(const QJsonArray &amp;<db:emphasis>val</db:emphasis>)</db:title>
<db:para>Constructs a new variant with a json array value, <db:code role="parameter">val</db:code>.</db:para>
<db:para>This function was introduced in Qt 5.0.</db:para>
</db:section>
<db:section xml:id="QVariant-14">
<db:title>[since 5.0] QVariant::QVariant(const QJsonDocument &amp;<db:emphasis>val</db:emphasis>)</db:title>
<db:para>Constructs a new variant with a json document value, <db:code role="parameter">val</db:code>.</db:para>
<db:para>This function was introduced in Qt 5.0.</db:para>
</db:section>
<db:section xml:id="QVariant-15">
<db:title>[since 5.0] QVariant::QVariant(const QJsonObject &amp;<db:emphasis>val</db:emphasis>)</db:title>
<db:para>Constructs a new variant with a json object value, <db:code role="parameter">val</db:code>.</db:para>
<db:para>This function was introduced in Qt 5.0.</db:para>
</db:section>
<db:section xml:id="QVariant-16">
<db:title>[since 5.0] QVariant::QVariant(const QJsonValue &amp;<db:emphasis>val</db:emphasis>)</db:title>
<db:para>Constructs a new variant with a json value, <db:code role="parameter">val</db:code>.</db:para>
<db:para>This function was introduced in Qt 5.0.</db:para>
</db:section>
<db:section xml:id="QVariant-17">
<db:title>QVariant::QVariant(const QLine &amp;<db:emphasis>val</db:emphasis>)</db:title>
<db:para>Constructs a new variant with a line value of <db:code role="parameter">val</db:code>.</db:para>
</db:section>
<db:section xml:id="QVariant-18">
<db:title>QVariant::QVariant(const QLineF &amp;<db:emphasis>val</db:emphasis>)</db:title>
<db:para>Constructs a new variant with a line value of <db:code role="parameter">val</db:code>.</db:para>
</db:section>
<db:section xml:id="QVariant-19">
<db:title>QVariant::QVariant(const QList&lt;QVariant&gt; &amp;<db:emphasis>val</db:emphasis>)</db:title>
<db:para>Constructs a new variant with a list value, <db:code role="parameter">val</db:code>.</db:para>
</db:section>
<db:section xml:id="QVariant-20">
<db:title>QVariant::QVariant(const QLocale &amp;<db:emphasis>l</db:emphasis>)</db:title>
<db:para>Constructs a new variant with a locale value, <db:code role="parameter">l</db:code>.</db:para>
</db:section>
<db:section xml:id="QVariant-21">
<db:title>QVariant::QVariant(const QMap&lt;QString, QVariant&gt; &amp;<db:emphasis>val</db:emphasis>)</db:title>
<db:para>Constructs a new variant with a map of <db:link xlink:href="qvariant.xml">QVariant</db:link>s, <db:code role="parameter">val</db:code>.</db:para>
</db:section>
<db:section xml:id="QVariant-22">
<db:title>[since 5.0] QVariant::QVariant(const QModelIndex &amp;<db:emphasis>val</db:emphasis>)</db:title>
<db:para>Constructs a new variant with a <db:link xlink:href="qmodelindex.xml">QModelIndex</db:link> value, <db:code role="parameter">val</db:code>.</db:para>
<db:para>This function was introduced in Qt 5.0.</db:para>
</db:section>
<db:section xml:id="QVariant-23">
<db:title>[since 5.5] QVariant::QVariant(const QPersistentModelIndex &amp;<db:emphasis>val</db:emphasis>)</db:title>
<db:para>Constructs a new variant with a <db:link xlink:href="qpersistentmodelindex.xml">QPersistentModelIndex</db:link> value, <db:code role="parameter">val</db:code>.</db:para>
<db:para>This function was introduced in Qt 5.5.</db:para>
</db:section>
<db:section xml:id="QVariant-24">
<db:title>QVariant::QVariant(const QPoint &amp;<db:emphasis>val</db:emphasis>)</db:title>
<db:para>Constructs a new variant with a point value of <db:code role="parameter">val</db:code>.</db:para>
</db:section>
<db:section xml:id="QVariant-25">
<db:title>QVariant::QVariant(const QPointF &amp;<db:emphasis>val</db:emphasis>)</db:title>
<db:para>Constructs a new variant with a point value of <db:code role="parameter">val</db:code>.</db:para>
</db:section>
<db:section xml:id="QVariant-26">
<db:title>QVariant::QVariant(const QRect &amp;<db:emphasis>val</db:emphasis>)</db:title>
<db:para>Constructs a new variant with a rect value of <db:code role="parameter">val</db:code>.</db:para>
</db:section>
<db:section xml:id="QVariant-27">
<db:title>QVariant::QVariant(const QRectF &amp;<db:emphasis>val</db:emphasis>)</db:title>
<db:para>Constructs a new variant with a rect value of <db:code role="parameter">val</db:code>.</db:para>
</db:section>
<db:section xml:id="QVariant-28">
<db:title>QVariant::QVariant(const QRegExp &amp;<db:emphasis>regExp</db:emphasis>)</db:title>
<db:para>Constructs a new variant with the regexp value <db:code role="parameter">regExp</db:code>.</db:para>
</db:section>
<db:section xml:id="QVariant-29">
<db:title>[since 5.0] QVariant::QVariant(const QRegularExpression &amp;<db:emphasis>re</db:emphasis>)</db:title>
<db:para>Constructs a new variant with the regular expression value <db:code role="parameter">re</db:code>.</db:para>
<db:para>This function was introduced in Qt 5.0.</db:para>
</db:section>
<db:section xml:id="QVariant-30">
<db:title>QVariant::QVariant(const QSize &amp;<db:emphasis>val</db:emphasis>)</db:title>
<db:para>Constructs a new variant with a size value of <db:code role="parameter">val</db:code>.</db:para>
</db:section>
<db:section xml:id="QVariant-31">
<db:title>QVariant::QVariant(const QSizeF &amp;<db:emphasis>val</db:emphasis>)</db:title>
<db:para>Constructs a new variant with a size value of <db:code role="parameter">val</db:code>.</db:para>
</db:section>
<db:section xml:id="QVariant-32">
<db:title>QVariant::QVariant(const QString &amp;<db:emphasis>val</db:emphasis>)</db:title>
<db:para>Constructs a new variant with a string value, <db:code role="parameter">val</db:code>.</db:para>
</db:section>
<db:section xml:id="QVariant-33">
<db:title>QVariant::QVariant(const QStringList &amp;<db:emphasis>val</db:emphasis>)</db:title>
<db:para>Constructs a new variant with a string list value, <db:code role="parameter">val</db:code>.</db:para>
</db:section>
<db:section xml:id="QVariant-34">
<db:title>QVariant::QVariant(const QTime &amp;<db:emphasis>val</db:emphasis>)</db:title>
<db:para>Constructs a new variant with a time value, <db:code role="parameter">val</db:code>.</db:para>
</db:section>
<db:section xml:id="QVariant-35">
<db:title>QVariant::QVariant(const QUrl &amp;<db:emphasis>val</db:emphasis>)</db:title>
<db:para>Constructs a new variant with a url value of <db:code role="parameter">val</db:code>.</db:para>
</db:section>
<db:section xml:id="QVariant-37">
<db:title>QVariant::QVariant(const QVariant &amp;<db:emphasis>p</db:emphasis>)</db:title>
<db:para>Constructs a copy of the variant, <db:code role="parameter">p</db:code>, passed as the argument to this constructor.</db:para>
</db:section>
<db:section xml:id="QVariant-4">
<db:title>[noexcept, since 5.2] QVariant::QVariant(QVariant &amp;&amp;<db:emphasis>other</db:emphasis>)</db:title>
<db:para>Move-constructs a <db:link xlink:href="qvariant.xml">QVariant</db:link> instance, making it point at the same object that <db:code role="parameter">other</db:code> was pointing to.</db:para>
<db:para>This function was introduced in Qt 5.2.</db:para>
</db:section>
<db:section xml:id="dtor.QVariant">
<db:title>[noexcept] QVariant::~QVariant()</db:title>
<db:para>Destroys the <db:link xlink:href="qvariant.xml">QVariant</db:link> and the contained object.</db:para>
<db:para>Note that subclasses that reimplement <db:link xlink:href="qvariant.xml#clear">clear</db:link>() should reimplement the destructor to call <db:link xlink:href="qvariant.xml#clear">clear</db:link>(). This destructor calls <db:link xlink:href="qvariant.xml#clear">clear</db:link>(), but because it is the destructor, <db:link xlink:href="qvariant.xml#clear">QVariant::clear</db:link>() is called rather than a subclass's <db:link xlink:href="qvariant.xml#clear">clear</db:link>().</db:para>
</db:section>
<db:section xml:id="canConvert">
<db:title>bool QVariant::canConvert(int <db:emphasis>targetTypeId</db:emphasis>) const</db:title>
<db:para>Returns <db:code>true</db:code> if the variant's type can be cast to the requested type, <db:code role="parameter">targetTypeId</db:code>. Such casting is done automatically when calling the <db:link xlink:href="qvariant.xml#toInt">toInt</db:link>(), <db:link xlink:href="qvariant.xml#toBool">toBool</db:link>(), ... methods.</db:para>
<db:para>The following casts are done automatically:</db:para>
<db:informaltable style="generic">
<db:thead>
<db:tr>
<db:th>
<db:para>Type</db:para>
</db:th>
<db:th>
<db:para>Automatically Cast To</db:para>
</db:th>
</db:tr>
</db:thead>
<db:tr valign="top">
<db:td>
<db:para><db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::Bool</db:link></db:para>
</db:td>
<db:td>
<db:para><db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QChar</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::Double</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::Int</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::LongLong</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QString</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::UInt</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::ULongLong</db:link></db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para><db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QByteArray</db:link></db:para>
</db:td>
<db:td>
<db:para><db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::Double</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::Int</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::LongLong</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QString</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::UInt</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::ULongLong</db:link></db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para><db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QChar</db:link></db:para>
</db:td>
<db:td>
<db:para><db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::Bool</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::Int</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::UInt</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::LongLong</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::ULongLong</db:link></db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para><db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QColor</db:link></db:para>
</db:td>
<db:td>
<db:para><db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QString</db:link></db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para><db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QDate</db:link></db:para>
</db:td>
<db:td>
<db:para><db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QDateTime</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QString</db:link></db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para><db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QDateTime</db:link></db:para>
</db:td>
<db:td>
<db:para><db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QDate</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QString</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QTime</db:link></db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para><db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::Double</db:link></db:para>
</db:td>
<db:td>
<db:para><db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::Bool</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::Int</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::LongLong</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QString</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::UInt</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::ULongLong</db:link></db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para><db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QFont</db:link></db:para>
</db:td>
<db:td>
<db:para><db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QString</db:link></db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para><db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::Int</db:link></db:para>
</db:td>
<db:td>
<db:para><db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::Bool</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QChar</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::Double</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::LongLong</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QString</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::UInt</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::ULongLong</db:link></db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para><db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QKeySequence</db:link></db:para>
</db:td>
<db:td>
<db:para><db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::Int</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QString</db:link></db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para><db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QVariantList</db:link></db:para>
</db:td>
<db:td>
<db:para><db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QStringList</db:link> (if the list's items can be converted to QStrings)</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para><db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::LongLong</db:link></db:para>
</db:td>
<db:td>
<db:para><db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::Bool</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QByteArray</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QChar</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::Double</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::Int</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QString</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::UInt</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::ULongLong</db:link></db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para><db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QPoint</db:link></db:para>
</db:td>
<db:td>
<db:para><db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QPointF</db:link></db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para><db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QRect</db:link></db:para>
</db:td>
<db:td>
<db:para><db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QRectF</db:link></db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para><db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QString</db:link></db:para>
</db:td>
<db:td>
<db:para><db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::Bool</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QByteArray</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QChar</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QColor</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QDate</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QDateTime</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::Double</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QFont</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::Int</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QKeySequence</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::LongLong</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QStringList</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QTime</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::UInt</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::ULongLong</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QUuid</db:link></db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para><db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QStringList</db:link></db:para>
</db:td>
<db:td>
<db:para><db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QVariantList</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QString</db:link> (if the list contains exactly one item)</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para><db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QTime</db:link></db:para>
</db:td>
<db:td>
<db:para><db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QString</db:link></db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para><db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::UInt</db:link></db:para>
</db:td>
<db:td>
<db:para><db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::Bool</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QChar</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::Double</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::Int</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::LongLong</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QString</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::ULongLong</db:link></db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para><db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::ULongLong</db:link></db:para>
</db:td>
<db:td>
<db:para><db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::Bool</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QChar</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::Double</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::Int</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::LongLong</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QString</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::UInt</db:link></db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para><db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QUuid</db:link></db:para>
</db:td>
<db:td>
<db:para><db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QString</db:link></db:para>
</db:td>
</db:tr>
</db:informaltable>
<db:para>A <db:link xlink:href="qvariant.xml">QVariant</db:link> containing a pointer to a type derived from <db:link xlink:href="qobject.xml">QObject</db:link> will also return true for this function if a qobject_cast to the type described by <db:code role="parameter">targetTypeId</db:code> would succeed. Note that this only works for <db:link xlink:href="qobject.xml">QObject</db:link> subclasses which use the <db:link xlink:href="qobject.xml#Q_OBJECT">Q_OBJECT</db:link> macro.</db:para>
<db:para>A <db:link xlink:href="qvariant.xml">QVariant</db:link> containing a sequential container will also return true for this function if the <db:code role="parameter">targetTypeId</db:code> is <db:link xlink:href="qvariant.xml#QVariantList-typedef">QVariantList</db:link>. It is possible to iterate over the contents of the container without extracting it as a (copied) <db:link xlink:href="qvariant.xml#QVariantList-typedef">QVariantList</db:link>:</db:para>
<db:programlisting language="cpp">QList&lt;int&gt; intList;
intList.push_back(7);
intList.push_back(11);
intList.push_back(42);

QVariant variant = QVariant::fromValue(intList);
if (variant.canConvert&lt;QVariantList&gt;()) {
    QSequentialIterable iterable = variant.value&lt;QSequentialIterable&gt;();
    // Can use foreach:
    foreach (const QVariant &amp;v, iterable) {
        qDebug() &lt;&lt; v;
    }
    // Can use C++11 range-for:
    for (const QVariant &amp;v : iterable) {
        qDebug() &lt;&lt; v;
    }
    // Can use iterators:
    QSequentialIterable::const_iterator it = iterable.begin();
    const QSequentialIterable::const_iterator end = iterable.end();
    for ( ; it != end; ++it) {
        qDebug() &lt;&lt; *it;
    }
}

</db:programlisting>
<db:para>This requires that the value_type of the container is itself a metatype.</db:para>
<db:para>Similarly, a <db:link xlink:href="qvariant.xml">QVariant</db:link> containing a sequential container will also return true for this function the <db:code role="parameter">targetTypeId</db:code> is <db:link xlink:href="qvariant.xml#QVariantHash-typedef">QVariantHash</db:link> or <db:link xlink:href="qvariant.xml#QVariantMap-typedef">QVariantMap</db:link>. It is possible to iterate over the contents of the container without extracting it as a (copied) <db:link xlink:href="qvariant.xml#QVariantHash-typedef">QVariantHash</db:link> or <db:link xlink:href="qvariant.xml#QVariantMap-typedef">QVariantMap</db:link>:</db:para>
<db:programlisting language="cpp">QHash&lt;int, QString&gt; mapping;
mapping.insert(7, &quot;Seven&quot;);
mapping.insert(11, &quot;Eleven&quot;);
mapping.insert(42, &quot;Forty-two&quot;);

QVariant variant = QVariant::fromValue(mapping);
if (variant.canConvert&lt;QVariantHash&gt;()) {
    QAssociativeIterable iterable = variant.value&lt;QAssociativeIterable&gt;();
    // Can use foreach over the values:
    foreach (const QVariant &amp;v, iterable) {
        qDebug() &lt;&lt; v;
    }
    // Can use C++11 range-for over the values:
    for (const QVariant &amp;v : iterable) {
        qDebug() &lt;&lt; v;
    }
    // Can use iterators:
    QAssociativeIterable::const_iterator it = iterable.begin();
    const QAssociativeIterable::const_iterator end = iterable.end();
    for ( ; it != end; ++it) {
        qDebug() &lt;&lt; *it; // The current value
        qDebug() &lt;&lt; it.key();
        qDebug() &lt;&lt; it.value();
    }
}

</db:programlisting>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qvariant.xml#convert">convert</db:link>()</db:member>
<db:member><db:link xlink:href="qsequentialiterable.xml">QSequentialIterable</db:link></db:member>
<db:member><db:link xlink:href="qmetatype.xml#Q_DECLARE_SEQUENTIAL_CONTAINER_METATYPE">Q_DECLARE_SEQUENTIAL_CONTAINER_METATYPE</db:link>()</db:member>
<db:member><db:link xlink:href="qassociativeiterable.xml">QAssociativeIterable</db:link></db:member>
<db:member><db:link xlink:href="qmetatype.xml#Q_DECLARE_ASSOCIATIVE_CONTAINER_METATYPE">Q_DECLARE_ASSOCIATIVE_CONTAINER_METATYPE</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="clear">
<db:title>void QVariant::clear()</db:title>
<db:para>Convert this variant to type <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::UnknownType</db:link> and free up any resources used.</db:para>
</db:section>
<db:section xml:id="convert">
<db:title>bool QVariant::convert(int <db:emphasis>targetTypeId</db:emphasis>)</db:title>
<db:para>Casts the variant to the requested type, <db:code role="parameter">targetTypeId</db:code>. If the cast cannot be done, the variant is cleared. Returns <db:code>true</db:code> if the current type of the variant was successfully cast; otherwise returns <db:code>false</db:code>.</db:para>
<db:para>A <db:link xlink:href="qvariant.xml">QVariant</db:link> containing a pointer to a type derived from <db:link xlink:href="qobject.xml">QObject</db:link> will also convert and return true for this function if a qobject_cast to the type described by <db:code role="parameter">targetTypeId</db:code> would succeed. Note that this only works for <db:link xlink:href="qobject.xml">QObject</db:link> subclasses which use the <db:link xlink:href="qobject.xml#Q_OBJECT">Q_OBJECT</db:link> macro.</db:para>
<db:warning>
<db:para>For historical reasons, converting a null <db:link xlink:href="qvariant.xml">QVariant</db:link> results in a null value of the desired type (e.g., an empty string for <db:link xlink:href="qstring.xml">QString</db:link>) and a result of false.</db:para>
</db:warning>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qvariant.xml#canConvert">canConvert</db:link>()</db:member>
<db:member><db:link xlink:href="qvariant.xml#clear">clear</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="isNull">
<db:title>bool QVariant::isNull() const</db:title>
<db:para>Returns <db:code>true</db:code> if this is a null variant, false otherwise. A variant is considered null if it contains a default constructed value or a built-in type instance that has an isNull method, in which case the result would be the same as calling isNull on the wrapped object.</db:para>
<db:warning>
<db:para>The result of the function doesn't affect == operator, which means that two values can be equal even if one of them is null and another is not.</db:para>
</db:warning>
</db:section>
<db:section xml:id="isValid">
<db:title>bool QVariant::isValid() const</db:title>
<db:para>Returns <db:code>true</db:code> if the storage type of this variant is not <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::UnknownType</db:link>; otherwise returns <db:code>false</db:code>.</db:para>
</db:section>
<db:section xml:id="nameToType">
<db:title>[static] QVariant::Type QVariant::nameToType(const char *<db:emphasis>name</db:emphasis>)</db:title>
<db:para>Converts the string representation of the storage type given in <db:code role="parameter">name</db:code>, to its enum representation.</db:para>
<db:para>If the string representation cannot be converted to any enum representation, the variant is set to <db:code>Invalid</db:code>.</db:para>
</db:section>
<db:section xml:id="swap">
<db:title>[noexcept, since 4.8] void QVariant::swap(QVariant &amp;<db:emphasis>other</db:emphasis>)</db:title>
<db:para>Swaps variant <db:code role="parameter">other</db:code> with this variant. This operation is very fast and never fails.</db:para>
<db:para>This function was introduced in Qt 4.8.</db:para>
</db:section>
<db:section xml:id="toBitArray">
<db:title>QBitArray QVariant::toBitArray() const</db:title>
<db:para>Returns the variant as a <db:link xlink:href="qbitarray.xml">QBitArray</db:link> if the variant has <db:link xlink:href="qvariant.xml#userType">userType</db:link>() <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QBitArray</db:link>; otherwise returns an empty bit array.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qvariant.xml#canConvert">canConvert</db:link>()</db:member>
<db:member><db:link xlink:href="qvariant.xml#convert">convert</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="toBool">
<db:title>bool QVariant::toBool() const</db:title>
<db:para>Returns the variant as a bool if the variant has <db:link xlink:href="qvariant.xml#userType">userType</db:link>() Bool.</db:para>
<db:para>Returns <db:code>true</db:code> if the variant has <db:link xlink:href="qvariant.xml#userType">userType</db:link>() <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::Bool</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QChar</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::Double</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::Int</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::LongLong</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::UInt</db:link>, or <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::ULongLong</db:link> and the value is non-zero, or if the variant has type <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QString</db:link> or <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QByteArray</db:link> and its lower-case content is not one of the following: empty, &quot;0&quot; or &quot;false&quot;; otherwise returns <db:code>false</db:code>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qvariant.xml#canConvert">canConvert</db:link>()</db:member>
<db:member><db:link xlink:href="qvariant.xml#convert">convert</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="toByteArray">
<db:title>QByteArray QVariant::toByteArray() const</db:title>
<db:para>Returns the variant as a <db:link xlink:href="qbytearray.xml">QByteArray</db:link> if the variant has <db:link xlink:href="qvariant.xml#userType">userType</db:link>() <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QByteArray</db:link> or <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QString</db:link> (converted using <db:link xlink:href="qstring.xml#fromUtf8">QString::fromUtf8</db:link>()); otherwise returns an empty byte array.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qvariant.xml#canConvert">canConvert</db:link>()</db:member>
<db:member><db:link xlink:href="qvariant.xml#convert">convert</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="toChar">
<db:title>QChar QVariant::toChar() const</db:title>
<db:para>Returns the variant as a <db:link xlink:href="qchar.xml">QChar</db:link> if the variant has <db:link xlink:href="qvariant.xml#userType">userType</db:link>() <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QChar</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::Int</db:link>, or <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::UInt</db:link>; otherwise returns an invalid <db:link xlink:href="qchar.xml">QChar</db:link>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qvariant.xml#canConvert">canConvert</db:link>()</db:member>
<db:member><db:link xlink:href="qvariant.xml#convert">convert</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="toDate">
<db:title>QDate QVariant::toDate() const</db:title>
<db:para>Returns the variant as a <db:link xlink:href="qdate.xml">QDate</db:link> if the variant has <db:link xlink:href="qvariant.xml#userType">userType</db:link>() <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QDate</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QDateTime</db:link>, or <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QString</db:link>; otherwise returns an invalid date.</db:para>
<db:para>If the <db:link xlink:href="qvariant.xml#type">type</db:link>() is <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QString</db:link>, an invalid date will be returned if the string cannot be parsed as a <db:link xlink:href="qt.xml#DateFormat-enum">Qt::ISODate</db:link> format date.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qvariant.xml#canConvert">canConvert</db:link>()</db:member>
<db:member><db:link xlink:href="qvariant.xml#convert">convert</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="toDateTime">
<db:title>QDateTime QVariant::toDateTime() const</db:title>
<db:para>Returns the variant as a <db:link xlink:href="qdatetime.xml">QDateTime</db:link> if the variant has <db:link xlink:href="qvariant.xml#userType">userType</db:link>() <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QDateTime</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QDate</db:link>, or <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QString</db:link>; otherwise returns an invalid date/time.</db:para>
<db:para>If the <db:link xlink:href="qvariant.xml#type">type</db:link>() is <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QString</db:link>, an invalid date/time will be returned if the string cannot be parsed as a <db:link xlink:href="qt.xml#DateFormat-enum">Qt::ISODate</db:link> format date/time.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qvariant.xml#canConvert">canConvert</db:link>()</db:member>
<db:member><db:link xlink:href="qvariant.xml#convert">convert</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="toDouble">
<db:title>double QVariant::toDouble(bool *<db:emphasis>ok</db:emphasis> = Q_NULLPTR) const</db:title>
<db:para>Returns the variant as a double if the variant has <db:link xlink:href="qvariant.xml#userType">userType</db:link>() <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::Double</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::Float</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::Bool</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QByteArray</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::Int</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::LongLong</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QString</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::UInt</db:link>, or <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::ULongLong</db:link>; otherwise returns 0.0.</db:para>
<db:para>If <db:code role="parameter">ok</db:code> is non-null: <db:code>*</db:code><db:code role="parameter">ok</db:code> is set to true if the value could be converted to a double; otherwise <db:code>*</db:code><db:code role="parameter">ok</db:code> is set to false.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qvariant.xml#canConvert">canConvert</db:link>()</db:member>
<db:member><db:link xlink:href="qvariant.xml#convert">convert</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="toEasingCurve">
<db:title>[since 4.7] QEasingCurve QVariant::toEasingCurve() const</db:title>
<db:para>Returns the variant as a <db:link xlink:href="qeasingcurve.xml">QEasingCurve</db:link> if the variant has <db:link xlink:href="qvariant.xml#userType">userType</db:link>() <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QEasingCurve</db:link>; otherwise returns a default easing curve.</db:para>
<db:para>This function was introduced in Qt 4.7.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qvariant.xml#canConvert">canConvert</db:link>()</db:member>
<db:member><db:link xlink:href="qvariant.xml#convert">convert</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="toFloat">
<db:title>[since 4.6] float QVariant::toFloat(bool *<db:emphasis>ok</db:emphasis> = Q_NULLPTR) const</db:title>
<db:para>Returns the variant as a float if the variant has <db:link xlink:href="qvariant.xml#userType">userType</db:link>() <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::Double</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::Float</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::Bool</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QByteArray</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::Int</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::LongLong</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QString</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::UInt</db:link>, or <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::ULongLong</db:link>; otherwise returns 0.0.</db:para>
<db:para>If <db:code role="parameter">ok</db:code> is non-null: <db:code>*</db:code><db:code role="parameter">ok</db:code> is set to true if the value could be converted to a double; otherwise <db:code>*</db:code><db:code role="parameter">ok</db:code> is set to false.</db:para>
<db:para>This function was introduced in Qt 4.6.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qvariant.xml#canConvert">canConvert</db:link>()</db:member>
<db:member><db:link xlink:href="qvariant.xml#convert">convert</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="toHash">
<db:title>QHash&lt;QString, QVariant&gt; QVariant::toHash() const</db:title>
<db:para>Returns the variant as a <db:link xlink:href="qhash.xml#the-qhash-hashing-function">QHash</db:link>&lt;<db:link xlink:href="qstring.xml">QString</db:link>, <db:link xlink:href="qvariant.xml">QVariant</db:link>&gt; if the variant has <db:link xlink:href="qvariant.xml#type">type</db:link>() <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QVariantHash</db:link>; otherwise returns an empty map.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qvariant.xml#canConvert">canConvert</db:link>()</db:member>
<db:member><db:link xlink:href="qvariant.xml#convert">convert</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="toInt">
<db:title>int QVariant::toInt(bool *<db:emphasis>ok</db:emphasis> = Q_NULLPTR) const</db:title>
<db:para>Returns the variant as an int if the variant has <db:link xlink:href="qvariant.xml#userType">userType</db:link>() <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::Int</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::Bool</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QByteArray</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QChar</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::Double</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::LongLong</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QString</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::UInt</db:link>, or <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::ULongLong</db:link>; otherwise returns 0.</db:para>
<db:para>If <db:code role="parameter">ok</db:code> is non-null: <db:code>*</db:code><db:code role="parameter">ok</db:code> is set to true if the value could be converted to an int; otherwise <db:code>*</db:code><db:code role="parameter">ok</db:code> is set to false.</db:para>
<db:para><db:emphasis role="bold">Warning:</db:emphasis> If the value is convertible to a <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::LongLong</db:link> but is too large to be represented in an int, the resulting arithmetic overflow will not be reflected in <db:code role="parameter">ok</db:code>. A simple workaround is to use <db:link xlink:href="qstring.xml#toInt">QString::toInt</db:link>().</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qvariant.xml#canConvert">canConvert</db:link>()</db:member>
<db:member><db:link xlink:href="qvariant.xml#convert">convert</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="toJsonArray">
<db:title>[since 5.0] QJsonArray QVariant::toJsonArray() const</db:title>
<db:para>Returns the variant as a <db:link xlink:href="qjsonarray.xml">QJsonArray</db:link> if the variant has <db:link xlink:href="qvariant.xml#userType">userType</db:link>() <db:link xlink:href="qjsonarray.xml">QJsonArray</db:link>; otherwise returns a default constructed <db:link xlink:href="qjsonarray.xml">QJsonArray</db:link>.</db:para>
<db:para>This function was introduced in Qt 5.0.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qvariant.xml#canConvert">canConvert</db:link>()</db:member>
<db:member><db:link xlink:href="qvariant.xml#convert">convert</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="toJsonDocument">
<db:title>[since 5.0] QJsonDocument QVariant::toJsonDocument() const</db:title>
<db:para>Returns the variant as a <db:link xlink:href="qjsondocument.xml">QJsonDocument</db:link> if the variant has <db:link xlink:href="qvariant.xml#userType">userType</db:link>() <db:link xlink:href="qjsondocument.xml">QJsonDocument</db:link>; otherwise returns a default constructed <db:link xlink:href="qjsondocument.xml">QJsonDocument</db:link>.</db:para>
<db:para>This function was introduced in Qt 5.0.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qvariant.xml#canConvert">canConvert</db:link>()</db:member>
<db:member><db:link xlink:href="qvariant.xml#convert">convert</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="toJsonObject">
<db:title>[since 5.0] QJsonObject QVariant::toJsonObject() const</db:title>
<db:para>Returns the variant as a <db:link xlink:href="qjsonobject.xml">QJsonObject</db:link> if the variant has <db:link xlink:href="qvariant.xml#userType">userType</db:link>() <db:link xlink:href="qjsonobject.xml">QJsonObject</db:link>; otherwise returns a default constructed <db:link xlink:href="qjsonobject.xml">QJsonObject</db:link>.</db:para>
<db:para>This function was introduced in Qt 5.0.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qvariant.xml#canConvert">canConvert</db:link>()</db:member>
<db:member><db:link xlink:href="qvariant.xml#convert">convert</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="toJsonValue">
<db:title>[since 5.0] QJsonValue QVariant::toJsonValue() const</db:title>
<db:para>Returns the variant as a <db:link xlink:href="qjsonvalue.xml">QJsonValue</db:link> if the variant has <db:link xlink:href="qvariant.xml#userType">userType</db:link>() <db:link xlink:href="qjsonvalue.xml">QJsonValue</db:link>; otherwise returns a default constructed <db:link xlink:href="qjsonvalue.xml">QJsonValue</db:link>.</db:para>
<db:para>This function was introduced in Qt 5.0.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qvariant.xml#canConvert">canConvert</db:link>()</db:member>
<db:member><db:link xlink:href="qvariant.xml#convert">convert</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="toLine">
<db:title>QLine QVariant::toLine() const</db:title>
<db:para>Returns the variant as a <db:link xlink:href="qline.xml">QLine</db:link> if the variant has <db:link xlink:href="qvariant.xml#userType">userType</db:link>() <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QLine</db:link>; otherwise returns an invalid <db:link xlink:href="qline.xml">QLine</db:link>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qvariant.xml#canConvert">canConvert</db:link>()</db:member>
<db:member><db:link xlink:href="qvariant.xml#convert">convert</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="toLineF">
<db:title>QLineF QVariant::toLineF() const</db:title>
<db:para>Returns the variant as a <db:link xlink:href="qlinef.xml">QLineF</db:link> if the variant has <db:link xlink:href="qvariant.xml#userType">userType</db:link>() <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QLineF</db:link>; otherwise returns an invalid <db:link xlink:href="qlinef.xml">QLineF</db:link>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qvariant.xml#canConvert">canConvert</db:link>()</db:member>
<db:member><db:link xlink:href="qvariant.xml#convert">convert</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="toList">
<db:title>QList&lt;QVariant&gt; QVariant::toList() const</db:title>
<db:para>Returns the variant as a <db:link xlink:href="qvariant.xml#QVariantList-typedef">QVariantList</db:link> if the variant has <db:link xlink:href="qvariant.xml#userType">userType</db:link>() <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QVariantList</db:link> or <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QStringList</db:link>; otherwise returns an empty list.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qvariant.xml#canConvert">canConvert</db:link>()</db:member>
<db:member><db:link xlink:href="qvariant.xml#convert">convert</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="toLocale">
<db:title>QLocale QVariant::toLocale() const</db:title>
<db:para>Returns the variant as a <db:link xlink:href="qlocale.xml">QLocale</db:link> if the variant has <db:link xlink:href="qvariant.xml#userType">userType</db:link>() <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QLocale</db:link>; otherwise returns an invalid <db:link xlink:href="qlocale.xml">QLocale</db:link>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qvariant.xml#canConvert">canConvert</db:link>()</db:member>
<db:member><db:link xlink:href="qvariant.xml#convert">convert</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="toLongLong">
<db:title>qlonglong QVariant::toLongLong(bool *<db:emphasis>ok</db:emphasis> = Q_NULLPTR) const</db:title>
<db:para>Returns the variant as a long long int if the variant has <db:link xlink:href="qvariant.xml#userType">userType</db:link>() <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::LongLong</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::Bool</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QByteArray</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QChar</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::Double</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::Int</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QString</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::UInt</db:link>, or <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::ULongLong</db:link>; otherwise returns 0.</db:para>
<db:para>If <db:code role="parameter">ok</db:code> is non-null: <db:code>*</db:code><db:code>ok</db:code> is set to true if the value could be converted to an int; otherwise <db:code>*</db:code><db:code>ok</db:code> is set to false.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qvariant.xml#canConvert">canConvert</db:link>()</db:member>
<db:member><db:link xlink:href="qvariant.xml#convert">convert</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="toMap">
<db:title>QMap&lt;QString, QVariant&gt; QVariant::toMap() const</db:title>
<db:para>Returns the variant as a <db:link xlink:href="qmap.xml">QMap</db:link>&lt;<db:link xlink:href="qstring.xml">QString</db:link>, <db:link xlink:href="qvariant.xml">QVariant</db:link>&gt; if the variant has <db:link xlink:href="qvariant.xml#type">type</db:link>() <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QVariantMap</db:link>; otherwise returns an empty map.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qvariant.xml#canConvert">canConvert</db:link>()</db:member>
<db:member><db:link xlink:href="qvariant.xml#convert">convert</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="toModelIndex">
<db:title>[since 5.0] QModelIndex QVariant::toModelIndex() const</db:title>
<db:para>Returns the variant as a <db:link xlink:href="qmodelindex.xml">QModelIndex</db:link> if the variant has <db:link xlink:href="qvariant.xml#userType">userType</db:link>() <db:link xlink:href="qmodelindex.xml">QModelIndex</db:link>; otherwise returns a default constructed <db:link xlink:href="qmodelindex.xml">QModelIndex</db:link>.</db:para>
<db:para>This function was introduced in Qt 5.0.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qvariant.xml#canConvert">canConvert</db:link>()</db:member>
<db:member><db:link xlink:href="qvariant.xml#convert">convert</db:link>()</db:member>
<db:member><db:link xlink:href="qvariant.xml#toPersistentModelIndex">toPersistentModelIndex</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="toPersistentModelIndex">
<db:title>[since 5.5] QPersistentModelIndex QVariant::toPersistentModelIndex() const</db:title>
<db:para>Returns the variant as a <db:link xlink:href="qpersistentmodelindex.xml">QPersistentModelIndex</db:link> if the variant has <db:link xlink:href="qvariant.xml#userType">userType</db:link>() <db:link xlink:href="qpersistentmodelindex.xml">QPersistentModelIndex</db:link>; otherwise returns a default constructed <db:link xlink:href="qpersistentmodelindex.xml">QPersistentModelIndex</db:link>.</db:para>
<db:para>This function was introduced in Qt 5.5.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qvariant.xml#canConvert">canConvert</db:link>()</db:member>
<db:member><db:link xlink:href="qvariant.xml#convert">convert</db:link>()</db:member>
<db:member><db:link xlink:href="qvariant.xml#toModelIndex">toModelIndex</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="toPoint">
<db:title>QPoint QVariant::toPoint() const</db:title>
<db:para>Returns the variant as a <db:link xlink:href="qpoint.xml">QPoint</db:link> if the variant has <db:link xlink:href="qvariant.xml#userType">userType</db:link>() <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QPointF</db:link> or <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QPointF</db:link>; otherwise returns a null <db:link xlink:href="qpoint.xml">QPoint</db:link>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qvariant.xml#canConvert">canConvert</db:link>()</db:member>
<db:member><db:link xlink:href="qvariant.xml#convert">convert</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="toPointF">
<db:title>QPointF QVariant::toPointF() const</db:title>
<db:para>Returns the variant as a <db:link xlink:href="qpointf.xml">QPointF</db:link> if the variant has <db:link xlink:href="qvariant.xml#userType">userType</db:link>() <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QPoint</db:link> or <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QPointF</db:link>; otherwise returns a null <db:link xlink:href="qpointf.xml">QPointF</db:link>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qvariant.xml#canConvert">canConvert</db:link>()</db:member>
<db:member><db:link xlink:href="qvariant.xml#convert">convert</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="toReal">
<db:title>[since 4.6] qreal QVariant::toReal(bool *<db:emphasis>ok</db:emphasis> = Q_NULLPTR) const</db:title>
<db:para>Returns the variant as a qreal if the variant has <db:link xlink:href="qvariant.xml#userType">userType</db:link>() <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::Double</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::Float</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::Bool</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QByteArray</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::Int</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::LongLong</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QString</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::UInt</db:link>, or <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::ULongLong</db:link>; otherwise returns 0.0.</db:para>
<db:para>If <db:code role="parameter">ok</db:code> is non-null: <db:code>*</db:code><db:code role="parameter">ok</db:code> is set to true if the value could be converted to a double; otherwise <db:code>*</db:code><db:code role="parameter">ok</db:code> is set to false.</db:para>
<db:para>This function was introduced in Qt 4.6.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qvariant.xml#canConvert">canConvert</db:link>()</db:member>
<db:member><db:link xlink:href="qvariant.xml#convert">convert</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="toRect">
<db:title>QRect QVariant::toRect() const</db:title>
<db:para>Returns the variant as a <db:link xlink:href="qrect.xml">QRect</db:link> if the variant has <db:link xlink:href="qvariant.xml#userType">userType</db:link>() <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QRect</db:link>; otherwise returns an invalid <db:link xlink:href="qrect.xml">QRect</db:link>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qvariant.xml#canConvert">canConvert</db:link>()</db:member>
<db:member><db:link xlink:href="qvariant.xml#convert">convert</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="toRectF">
<db:title>QRectF QVariant::toRectF() const</db:title>
<db:para>Returns the variant as a <db:link xlink:href="qrectf.xml">QRectF</db:link> if the variant has <db:link xlink:href="qvariant.xml#userType">userType</db:link>() <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QRect</db:link> or <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QRectF</db:link>; otherwise returns an invalid <db:link xlink:href="qrectf.xml">QRectF</db:link>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qvariant.xml#canConvert">canConvert</db:link>()</db:member>
<db:member><db:link xlink:href="qvariant.xml#convert">convert</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="toRegExp">
<db:title>[since 4.1] QRegExp QVariant::toRegExp() const</db:title>
<db:para>Returns the variant as a <db:link xlink:href="qregexp.xml">QRegExp</db:link> if the variant has <db:link xlink:href="qvariant.xml#userType">userType</db:link>() <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QRegExp</db:link>; otherwise returns an empty <db:link xlink:href="qregexp.xml">QRegExp</db:link>.</db:para>
<db:para>This function was introduced in Qt 4.1.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qvariant.xml#canConvert">canConvert</db:link>()</db:member>
<db:member><db:link xlink:href="qvariant.xml#convert">convert</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="toRegularExpression">
<db:title>[since 5.0] QRegularExpression QVariant::toRegularExpression() const</db:title>
<db:para>Returns the variant as a <db:link xlink:href="qregularexpression.xml">QRegularExpression</db:link> if the variant has <db:link xlink:href="qvariant.xml#userType">userType</db:link>() <db:link xlink:href="qregularexpression.xml">QRegularExpression</db:link>; otherwise returns an empty <db:link xlink:href="qregularexpression.xml">QRegularExpression</db:link>.</db:para>
<db:para>This function was introduced in Qt 5.0.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qvariant.xml#canConvert">canConvert</db:link>()</db:member>
<db:member><db:link xlink:href="qvariant.xml#convert">convert</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="toSize">
<db:title>QSize QVariant::toSize() const</db:title>
<db:para>Returns the variant as a <db:link xlink:href="qsize.xml">QSize</db:link> if the variant has <db:link xlink:href="qvariant.xml#userType">userType</db:link>() <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QSize</db:link>; otherwise returns an invalid <db:link xlink:href="qsize.xml">QSize</db:link>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qvariant.xml#canConvert">canConvert</db:link>()</db:member>
<db:member><db:link xlink:href="qvariant.xml#convert">convert</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="toSizeF">
<db:title>QSizeF QVariant::toSizeF() const</db:title>
<db:para>Returns the variant as a <db:link xlink:href="qsizef.xml">QSizeF</db:link> if the variant has <db:link xlink:href="qvariant.xml#userType">userType</db:link>() <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QSizeF</db:link>; otherwise returns an invalid <db:link xlink:href="qsizef.xml">QSizeF</db:link>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qvariant.xml#canConvert">canConvert</db:link>()</db:member>
<db:member><db:link xlink:href="qvariant.xml#convert">convert</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="toString">
<db:title>QString QVariant::toString() const</db:title>
<db:para>Returns the variant as a <db:link xlink:href="qstring.xml">QString</db:link> if the variant has <db:link xlink:href="qvariant.xml#userType">userType</db:link>() <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QString</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::Bool</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QByteArray</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QChar</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QDate</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QDateTime</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::Double</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::Int</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::LongLong</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QStringList</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QTime</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::UInt</db:link>, or <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::ULongLong</db:link>; otherwise returns an empty string.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qvariant.xml#canConvert">canConvert</db:link>()</db:member>
<db:member><db:link xlink:href="qvariant.xml#convert">convert</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="toStringList">
<db:title>QStringList QVariant::toStringList() const</db:title>
<db:para>Returns the variant as a <db:link xlink:href="qstringlist.xml">QStringList</db:link> if the variant has <db:link xlink:href="qvariant.xml#userType">userType</db:link>() <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QStringList</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QString</db:link>, or <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QVariantList</db:link> of a type that can be converted to <db:link xlink:href="qstring.xml">QString</db:link>; otherwise returns an empty list.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qvariant.xml#canConvert">canConvert</db:link>()</db:member>
<db:member><db:link xlink:href="qvariant.xml#convert">convert</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="toTime">
<db:title>QTime QVariant::toTime() const</db:title>
<db:para>Returns the variant as a <db:link xlink:href="qtime.xml">QTime</db:link> if the variant has <db:link xlink:href="qvariant.xml#userType">userType</db:link>() <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QTime</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QDateTime</db:link>, or <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QString</db:link>; otherwise returns an invalid time.</db:para>
<db:para>If the <db:link xlink:href="qvariant.xml#type">type</db:link>() is <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QString</db:link>, an invalid time will be returned if the string cannot be parsed as a <db:link xlink:href="qt.xml#DateFormat-enum">Qt::ISODate</db:link> format time.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qvariant.xml#canConvert">canConvert</db:link>()</db:member>
<db:member><db:link xlink:href="qvariant.xml#convert">convert</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="toUInt">
<db:title>uint QVariant::toUInt(bool *<db:emphasis>ok</db:emphasis> = Q_NULLPTR) const</db:title>
<db:para>Returns the variant as an unsigned int if the variant has <db:link xlink:href="qvariant.xml#userType">userType</db:link>() <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::UInt</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::Bool</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QByteArray</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QChar</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::Double</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::Int</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::LongLong</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QString</db:link>, or <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::ULongLong</db:link>; otherwise returns 0.</db:para>
<db:para>If <db:code role="parameter">ok</db:code> is non-null: <db:code>*</db:code><db:code role="parameter">ok</db:code> is set to true if the value could be converted to an unsigned int; otherwise <db:code>*</db:code><db:code role="parameter">ok</db:code> is set to false.</db:para>
<db:para><db:emphasis role="bold">Warning:</db:emphasis> If the value is convertible to a <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::ULongLong</db:link> but is too large to be represented in an unsigned int, the resulting arithmetic overflow will not be reflected in <db:code role="parameter">ok</db:code>. A simple workaround is to use <db:link xlink:href="qstring.xml#toUInt">QString::toUInt</db:link>().</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qvariant.xml#canConvert">canConvert</db:link>()</db:member>
<db:member><db:link xlink:href="qvariant.xml#convert">convert</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="toULongLong">
<db:title>qulonglong QVariant::toULongLong(bool *<db:emphasis>ok</db:emphasis> = Q_NULLPTR) const</db:title>
<db:para>Returns the variant as an unsigned long long int if the variant has <db:link xlink:href="qvariant.xml#type">type</db:link>() <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::ULongLong</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::Bool</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QByteArray</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QChar</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::Double</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::Int</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::LongLong</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QString</db:link>, or <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::UInt</db:link>; otherwise returns 0.</db:para>
<db:para>If <db:code role="parameter">ok</db:code> is non-null: <db:code>*</db:code><db:code role="parameter">ok</db:code> is set to true if the value could be converted to an int; otherwise <db:code>*</db:code><db:code role="parameter">ok</db:code> is set to false.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qvariant.xml#canConvert">canConvert</db:link>()</db:member>
<db:member><db:link xlink:href="qvariant.xml#convert">convert</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="toUrl">
<db:title>QUrl QVariant::toUrl() const</db:title>
<db:para>Returns the variant as a <db:link xlink:href="qurl.xml">QUrl</db:link> if the variant has <db:link xlink:href="qvariant.xml#userType">userType</db:link>() <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QUrl</db:link>; otherwise returns an invalid <db:link xlink:href="qurl.xml">QUrl</db:link>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qvariant.xml#canConvert">canConvert</db:link>()</db:member>
<db:member><db:link xlink:href="qvariant.xml#convert">convert</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="toUuid">
<db:title>[since 5.0] QUuid QVariant::toUuid() const</db:title>
<db:para>Returns the variant as a <db:link xlink:href="quuid.xml">QUuid</db:link> if the variant has <db:link xlink:href="qvariant.xml#type">type</db:link>() <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QUuid</db:link> or <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QString</db:link>; otherwise returns a default-constructed <db:link xlink:href="quuid.xml">QUuid</db:link>.</db:para>
<db:para>This function was introduced in Qt 5.0.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qvariant.xml#canConvert">canConvert</db:link>()</db:member>
<db:member><db:link xlink:href="qvariant.xml#convert">convert</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="type">
<db:title>QVariant::Type QVariant::type() const</db:title>
<db:para>Returns the storage type of the value stored in the variant. Although this function is declared as returning QVariant::Type, the return value should be interpreted as <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::Type</db:link>. In particular, QVariant::UserType is returned here only if the value is equal or greater than <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::User</db:link>.</db:para>
<db:para>Note that return values in the ranges QVariant::Char through QVariant::RegExp and QVariant::Font through QVariant::Transform correspond to the values in the ranges <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QChar</db:link> through <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QRegExp</db:link> and <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QFont</db:link> through <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QQuaternion</db:link>.</db:para>
<db:para>Pay particular attention when working with char and <db:link xlink:href="qchar.xml">QChar</db:link> variants. Note that there is no <db:link xlink:href="qvariant.xml">QVariant</db:link> constructor specifically for type char, but there is one for <db:link xlink:href="qchar.xml">QChar</db:link>. For a variant of type <db:link xlink:href="qchar.xml">QChar</db:link>, this function returns QVariant::Char, which is the same as <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QChar</db:link>, but for a variant of type <db:code>char</db:code>, this function returns <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::Char</db:link>, which is <db:emphasis>not</db:emphasis> the same as QVariant::Char.</db:para>
<db:para>Also note that the types <db:code>void*</db:code>, <db:code>long</db:code>, <db:code>short</db:code>, <db:code>unsigned</db:code> <db:code>long</db:code>, <db:code>unsigned</db:code> <db:code>short</db:code>, <db:code>unsigned</db:code> <db:code>char</db:code>, <db:code>float</db:code>, <db:code>QObject*</db:code>, and <db:code>QWidget*</db:code> are represented in <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::Type</db:link> but not in QVariant::Type, and they can be returned by this function. However, they are considered to be user defined types when tested against QVariant::Type.</db:para>
<db:para>To test whether an instance of <db:link xlink:href="qvariant.xml">QVariant</db:link> contains a data type that is compatible with the data type you are interested in, use <db:link xlink:href="qvariant.xml#canConvert">canConvert</db:link>().</db:para>
</db:section>
<db:section xml:id="typeName">
<db:title>const char *QVariant::typeName() const</db:title>
<db:para>Returns the name of the type stored in the variant. The returned strings describe the C++ datatype used to store the data: for example, &quot;<db:link xlink:href="qfont.xml">QFont</db:link>&quot;, &quot;<db:link xlink:href="qstring.xml">QString</db:link>&quot;, or &quot;<db:link xlink:href="qvariant.xml#QVariantList-typedef">QVariantList</db:link>&quot;. An Invalid variant returns 0.</db:para>
</db:section>
<db:section xml:id="typeToName">
<db:title>[static] const char *QVariant::typeToName(int <db:emphasis>typeId</db:emphasis>)</db:title>
<db:para>Converts the int representation of the storage type, <db:code role="parameter">typeId</db:code>, to its string representation.</db:para>
<db:para>Returns a null pointer if the type is <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::UnknownType</db:link> or doesn't exist.</db:para>
</db:section>
<db:section xml:id="userType">
<db:title>int QVariant::userType() const</db:title>
<db:para>Returns the storage type of the value stored in the variant. For non-user types, this is the same as <db:link xlink:href="qvariant.xml#type">type</db:link>().</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qvariant.xml#type">type</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="operator-not-eq">
<db:title>bool QVariant::operator!=(const QVariant &amp;<db:emphasis>v</db:emphasis>) const</db:title>
<db:para>Compares this <db:link xlink:href="qvariant.xml">QVariant</db:link> with <db:code role="parameter">v</db:code> and returns <db:code>true</db:code> if they are not equal; otherwise returns <db:code>false</db:code>.</db:para>
<db:warning>
<db:para>To make this function work with a custom type registered with qRegisterMetaType(), its comparison operator must be registered using QMetaType::registerComparators().</db:para>
</db:warning>
</db:section>
<db:section xml:id="operator-lt">
<db:title>bool QVariant::operator&lt;(const QVariant &amp;<db:emphasis>v</db:emphasis>) const</db:title>
<db:para>Compares this <db:link xlink:href="qvariant.xml">QVariant</db:link> with <db:code role="parameter">v</db:code> and returns <db:code>true</db:code> if this is less than <db:code role="parameter">v</db:code>.</db:para>
<db:note>
<db:para>Comparability might not be availabe for the type stored in this <db:link xlink:href="qvariant.xml">QVariant</db:link> or in <db:code role="parameter">v</db:code>.</db:para>
</db:note>
<db:warning>
<db:para>To make this function work with a custom type registered with qRegisterMetaType(), its comparison operator must be registered using QMetaType::registerComparators().</db:para>
</db:warning>
</db:section>
<db:section xml:id="operator-lt-eq">
<db:title>bool QVariant::operator&lt;=(const QVariant &amp;<db:emphasis>v</db:emphasis>) const</db:title>
<db:para>Compares this <db:link xlink:href="qvariant.xml">QVariant</db:link> with <db:code role="parameter">v</db:code> and returns <db:code>true</db:code> if this is less or equal than <db:code role="parameter">v</db:code>.</db:para>
<db:note>
<db:para>Comparability might not be available for the type stored in this <db:link xlink:href="qvariant.xml">QVariant</db:link> or in <db:code role="parameter">v</db:code>.</db:para>
</db:note>
<db:warning>
<db:para>To make this function work with a custom type registered with qRegisterMetaType(), its comparison operator must be registered using QMetaType::registerComparators().</db:para>
</db:warning>
</db:section>
<db:section xml:id="operator-eq">
<db:title>[noexcept, since 5.2] QVariant &amp;QVariant::operator=(QVariant &amp;&amp;<db:emphasis>other</db:emphasis>)</db:title>
<db:para>Move-assigns <db:code role="parameter">other</db:code> to this <db:link xlink:href="qvariant.xml">QVariant</db:link> instance.</db:para>
<db:para>This function was introduced in Qt 5.2.</db:para>
</db:section>
<db:section xml:id="operator-eq-1">
<db:title>QVariant &amp;QVariant::operator=(const QVariant &amp;<db:emphasis>variant</db:emphasis>)</db:title>
<db:para>Assigns the value of the variant <db:code role="parameter">variant</db:code> to this variant.</db:para>
</db:section>
<db:section xml:id="operator-eq-eq">
<db:title>bool QVariant::operator==(const QVariant &amp;<db:emphasis>v</db:emphasis>) const</db:title>
<db:para>Compares this <db:link xlink:href="qvariant.xml">QVariant</db:link> with <db:code role="parameter">v</db:code> and returns <db:code>true</db:code> if they are equal; otherwise returns <db:code>false</db:code>.</db:para>
<db:para><db:link xlink:href="qvariant.xml">QVariant</db:link> uses the equality operator of the <db:link xlink:href="qvariant.xml#type">type</db:link>() it contains to check for equality. <db:link xlink:href="qvariant.xml">QVariant</db:link> will try to <db:link xlink:href="qvariant.xml#convert">convert</db:link>() <db:code role="parameter">v</db:code> if its type is not the same as this variant's type. See <db:link xlink:href="qvariant.xml#canConvert">canConvert</db:link>() for a list of possible conversions.</db:para>
<db:warning>
<db:para>To make this function work with a custom type registered with qRegisterMetaType(), its comparison operator must be registered using QMetaType::registerComparators().</db:para>
</db:warning>
</db:section>
<db:section xml:id="operator-gt">
<db:title>bool QVariant::operator&gt;(const QVariant &amp;<db:emphasis>v</db:emphasis>) const</db:title>
<db:para>Compares this <db:link xlink:href="qvariant.xml">QVariant</db:link> with <db:code role="parameter">v</db:code> and returns <db:code>true</db:code> if this is larger than <db:code role="parameter">v</db:code>.</db:para>
<db:note>
<db:para>Comparability might not be available for the type stored in this <db:link xlink:href="qvariant.xml">QVariant</db:link> or in <db:code role="parameter">v</db:code>.</db:para>
</db:note>
<db:warning>
<db:para>To make this function work with a custom type registered with qRegisterMetaType(), its comparison operator must be registered using QMetaType::registerComparators().</db:para>
</db:warning>
</db:section>
<db:section xml:id="operator-gt-eq">
<db:title>bool QVariant::operator&gt;=(const QVariant &amp;<db:emphasis>v</db:emphasis>) const</db:title>
<db:para>Compares this <db:link xlink:href="qvariant.xml">QVariant</db:link> with <db:code role="parameter">v</db:code> and returns <db:code>true</db:code> if this is larger or equal than <db:code role="parameter">v</db:code>.</db:para>
<db:note>
<db:para>Comparability might not be available for the type stored in this <db:link xlink:href="qvariant.xml">QVariant</db:link> or in <db:code role="parameter">v</db:code>.</db:para>
</db:note>
<db:warning>
<db:para>To make this function work with a custom type registered with qRegisterMetaType(), its comparison operator must be registered using QMetaType::registerComparators().</db:para>
</db:warning>
</db:section>
</db:section>
<db:section xml:id="related-non-members">
<db:title>Related Non-Members</db:title>
<db:section xml:id="QVariantHash-typedef">
<db:title>[since 4.5] QVariantHash</db:title>
<db:para>Synonym for <db:link xlink:href="qhash.xml#the-qhash-hashing-function">QHash</db:link>&lt;<db:link xlink:href="qstring.xml">QString</db:link>, <db:link xlink:href="qvariant.xml">QVariant</db:link>&gt;.</db:para>
<db:para>This typedef was introduced in Qt 4.5.</db:para>
</db:section>
<db:section xml:id="QVariantList-typedef">
<db:title>QVariantList</db:title>
<db:para>Synonym for <db:link xlink:href="qlist.xml">QList</db:link>&lt;<db:link xlink:href="qvariant.xml">QVariant</db:link>&gt;.</db:para>
</db:section>
<db:section xml:id="QVariantMap-typedef">
<db:title>QVariantMap</db:title>
<db:para>Synonym for <db:link xlink:href="qmap.xml">QMap</db:link>&lt;<db:link xlink:href="qstring.xml">QString</db:link>, <db:link xlink:href="qvariant.xml">QVariant</db:link>&gt;.</db:para>
</db:section>
<db:section xml:id="qvariant_cast">
<db:title>QVariant qvariant_cast(const QVariant &amp;<db:emphasis>value</db:emphasis>)</db:title>
<db:para>Returns the given <db:code role="parameter">value</db:code> converted to the template type <db:code>T</db:code>.</db:para>
<db:para>This function is equivalent to QVariant::value().</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="">QVariant::value()</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="operator-not-eq-1">
<db:title>bool operator!=(const QVariant &amp;<db:emphasis>v1</db:emphasis>, const QVariant &amp;<db:emphasis>v2</db:emphasis>)</db:title>
<db:para>Returns <db:code>false</db:code> if <db:code role="parameter">v1</db:code> and <db:code role="parameter">v2</db:code> are equal; otherwise returns <db:code>true</db:code>.</db:para>
<db:warning>
<db:para>To make this function work with a custom type registered with qRegisterMetaType(), its comparison operator must be registered using QMetaType::registerComparators().</db:para>
</db:warning>
</db:section>
<db:section xml:id="operator-eq-eq-2">
<db:title>bool operator==(const QVariant &amp;<db:emphasis>v1</db:emphasis>, const QVariant &amp;<db:emphasis>v2</db:emphasis>)</db:title>
<db:para>Returns <db:code>true</db:code> if <db:code role="parameter">v1</db:code> and <db:code role="parameter">v2</db:code> are equal; otherwise returns <db:code>false</db:code>.</db:para>
<db:para>If <db:code role="parameter">v1</db:code> and <db:code role="parameter">v2</db:code> have the same <db:link xlink:href="qvariant.xml#type">type</db:link>(), the type's equality operator is used for comparison. If not, it is attempted to <db:link xlink:href="qvariant.xml#convert">convert</db:link>() <db:code role="parameter">v2</db:code> to the same type as <db:code role="parameter">v1</db:code>. See <db:link xlink:href="qvariant.xml#canConvert">canConvert</db:link>() for a list of possible conversions.</db:para>
<db:para>The result of the function is not affected by the result of <db:link xlink:href="qvariant.xml#isNull">QVariant::isNull</db:link>, which means that two values can be equal even if one of them is null and another is not.</db:para>
<db:warning>
<db:para>To make this function work with a custom type registered with qRegisterMetaType(), its comparison operator must be registered using QMetaType::registerComparators().</db:para>
</db:warning>
</db:section>
</db:section>
<db:section xml:id="obsolete">
<db:title>Obsolete Members for QVariant</db:title>
<db:para><db:emphasis role="bold">The following members of class <db:link xlink:href="qvariant.xml">QVariant</db:link> are deprecated.</db:emphasis> We strongly advise against using them in new code.</db:para>
<db:section xml:id="obsolete-member-type-documentation">
<db:title>Obsolete Member Type Documentation</db:title>
<db:section xml:id="Type-enum">
<db:title>[deprecated] enum QVariant::Type</db:title>
<db:para>This enum is deprecated. We strongly advise against using it in new code.</db:para>
<db:para>Use <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::Type</db:link> instead</db:para>
<db:para>This enum type defines the types of variable that a <db:link xlink:href="qvariant.xml">QVariant</db:link> can contain.</db:para>
<db:informaltable>
<db:thead>
<db:tr>
<db:th>Constant</db:th>
<db:th>Value</db:th>
<db:th>Description</db:th>
</db:tr>
</db:thead>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qvariant.xml">QVariant</db:link></db:emphasis>::Invalid</db:code></db:para>
</db:td>
<db:td><db:code>QMetaType::UnknownType</db:code></db:td>
<db:td>
<db:para>no type</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qvariant.xml">QVariant</db:link></db:emphasis>::BitArray</db:code></db:para>
</db:td>
<db:td><db:code>QMetaType::QBitArray</db:code></db:td>
<db:td>
<db:para>a <db:link xlink:href="qbitarray.xml">QBitArray</db:link></db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qvariant.xml">QVariant</db:link></db:emphasis>::Bitmap</db:code></db:para>
</db:td>
<db:td><db:code>QMetaType::QBitmap</db:code></db:td>
<db:td>
<db:para>a <db:link xlink:href="qbitmap.xml">QBitmap</db:link></db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qvariant.xml">QVariant</db:link></db:emphasis>::Bool</db:code></db:para>
</db:td>
<db:td><db:code>QMetaType::Bool</db:code></db:td>
<db:td>
<db:para>a bool</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qvariant.xml">QVariant</db:link></db:emphasis>::Brush</db:code></db:para>
</db:td>
<db:td><db:code>QMetaType::QBrush</db:code></db:td>
<db:td>
<db:para>a <db:link xlink:href="qbrush.xml">QBrush</db:link></db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qvariant.xml">QVariant</db:link></db:emphasis>::ByteArray</db:code></db:para>
</db:td>
<db:td><db:code>QMetaType::QByteArray</db:code></db:td>
<db:td>
<db:para>a <db:link xlink:href="qbytearray.xml">QByteArray</db:link></db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qvariant.xml">QVariant</db:link></db:emphasis>::Char</db:code></db:para>
</db:td>
<db:td><db:code>QMetaType::QChar</db:code></db:td>
<db:td>
<db:para>a <db:link xlink:href="qchar.xml">QChar</db:link></db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qvariant.xml">QVariant</db:link></db:emphasis>::Color</db:code></db:para>
</db:td>
<db:td><db:code>QMetaType::QColor</db:code></db:td>
<db:td>
<db:para>a <db:link xlink:href="qcolor.xml">QColor</db:link></db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qvariant.xml">QVariant</db:link></db:emphasis>::Cursor</db:code></db:para>
</db:td>
<db:td><db:code>QMetaType::QCursor</db:code></db:td>
<db:td>
<db:para>a <db:link xlink:href="qcursor.xml">QCursor</db:link></db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qvariant.xml">QVariant</db:link></db:emphasis>::Date</db:code></db:para>
</db:td>
<db:td><db:code>QMetaType::QDate</db:code></db:td>
<db:td>
<db:para>a <db:link xlink:href="qdate.xml">QDate</db:link></db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qvariant.xml">QVariant</db:link></db:emphasis>::DateTime</db:code></db:para>
</db:td>
<db:td><db:code>QMetaType::QDateTime</db:code></db:td>
<db:td>
<db:para>a <db:link xlink:href="qdatetime.xml">QDateTime</db:link></db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qvariant.xml">QVariant</db:link></db:emphasis>::Double</db:code></db:para>
</db:td>
<db:td><db:code>QMetaType::Double</db:code></db:td>
<db:td>
<db:para>a double</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qvariant.xml">QVariant</db:link></db:emphasis>::EasingCurve</db:code></db:para>
</db:td>
<db:td><db:code>QMetaType::QEasingCurve</db:code></db:td>
<db:td>
<db:para>a <db:link xlink:href="qeasingcurve.xml">QEasingCurve</db:link></db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qvariant.xml">QVariant</db:link></db:emphasis>::Uuid</db:code></db:para>
</db:td>
<db:td><db:code>QMetaType::QUuid</db:code></db:td>
<db:td>
<db:para>a <db:link xlink:href="quuid.xml">QUuid</db:link></db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qvariant.xml">QVariant</db:link></db:emphasis>::ModelIndex</db:code></db:para>
</db:td>
<db:td><db:code>QMetaType::QModelIndex</db:code></db:td>
<db:td>
<db:para>a <db:link xlink:href="qmodelindex.xml">QModelIndex</db:link></db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qvariant.xml">QVariant</db:link></db:emphasis>::PersistentModelIndex</db:code></db:para>
</db:td>
<db:td><db:code>QMetaType::QPersistentModelIndex</db:code></db:td>
<db:td>
<db:para>a <db:link xlink:href="qpersistentmodelindex.xml">QPersistentModelIndex</db:link> (since 5.5)</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qvariant.xml">QVariant</db:link></db:emphasis>::Font</db:code></db:para>
</db:td>
<db:td><db:code>QMetaType::QFont</db:code></db:td>
<db:td>
<db:para>a <db:link xlink:href="qfont.xml">QFont</db:link></db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qvariant.xml">QVariant</db:link></db:emphasis>::Hash</db:code></db:para>
</db:td>
<db:td><db:code>QMetaType::QVariantHash</db:code></db:td>
<db:td>
<db:para>a <db:link xlink:href="qvariant.xml#QVariantHash-typedef">QVariantHash</db:link></db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qvariant.xml">QVariant</db:link></db:emphasis>::Icon</db:code></db:para>
</db:td>
<db:td><db:code>QMetaType::QIcon</db:code></db:td>
<db:td>
<db:para>a <db:link xlink:href="qicon.xml">QIcon</db:link></db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qvariant.xml">QVariant</db:link></db:emphasis>::Image</db:code></db:para>
</db:td>
<db:td><db:code>QMetaType::QImage</db:code></db:td>
<db:td>
<db:para>a <db:link xlink:href="qimage.xml">QImage</db:link></db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qvariant.xml">QVariant</db:link></db:emphasis>::Int</db:code></db:para>
</db:td>
<db:td><db:code>QMetaType::Int</db:code></db:td>
<db:td>
<db:para>an int</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qvariant.xml">QVariant</db:link></db:emphasis>::KeySequence</db:code></db:para>
</db:td>
<db:td><db:code>QMetaType::QKeySequence</db:code></db:td>
<db:td>
<db:para>a <db:link xlink:href="qkeysequence.xml">QKeySequence</db:link></db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qvariant.xml">QVariant</db:link></db:emphasis>::Line</db:code></db:para>
</db:td>
<db:td><db:code>QMetaType::QLine</db:code></db:td>
<db:td>
<db:para>a <db:link xlink:href="qline.xml">QLine</db:link></db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qvariant.xml">QVariant</db:link></db:emphasis>::LineF</db:code></db:para>
</db:td>
<db:td><db:code>QMetaType::QLineF</db:code></db:td>
<db:td>
<db:para>a <db:link xlink:href="qlinef.xml">QLineF</db:link></db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qvariant.xml">QVariant</db:link></db:emphasis>::List</db:code></db:para>
</db:td>
<db:td><db:code>QMetaType::QVariantList</db:code></db:td>
<db:td>
<db:para>a <db:link xlink:href="qvariant.xml#QVariantList-typedef">QVariantList</db:link></db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qvariant.xml">QVariant</db:link></db:emphasis>::Locale</db:code></db:para>
</db:td>
<db:td><db:code>QMetaType::QLocale</db:code></db:td>
<db:td>
<db:para>a <db:link xlink:href="qlocale.xml">QLocale</db:link></db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qvariant.xml">QVariant</db:link></db:emphasis>::LongLong</db:code></db:para>
</db:td>
<db:td><db:code>QMetaType::LongLong</db:code></db:td>
<db:td>
<db:para>a <db:link xlink:href="qtglobal.xml#qlonglong-typedef">qlonglong</db:link></db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qvariant.xml">QVariant</db:link></db:emphasis>::Map</db:code></db:para>
</db:td>
<db:td><db:code>QMetaType::QVariantMap</db:code></db:td>
<db:td>
<db:para>a <db:link xlink:href="qvariant.xml#QVariantMap-typedef">QVariantMap</db:link></db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qvariant.xml">QVariant</db:link></db:emphasis>::Matrix</db:code></db:para>
</db:td>
<db:td><db:code>QMetaType::QMatrix</db:code></db:td>
<db:td>
<db:para>a <db:link xlink:href="qmatrix.xml">QMatrix</db:link></db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qvariant.xml">QVariant</db:link></db:emphasis>::Transform</db:code></db:para>
</db:td>
<db:td><db:code>QMetaType::QTransform</db:code></db:td>
<db:td>
<db:para>a <db:link xlink:href="qtransform.xml">QTransform</db:link></db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qvariant.xml">QVariant</db:link></db:emphasis>::Matrix4x4</db:code></db:para>
</db:td>
<db:td><db:code>QMetaType::QMatrix4x4</db:code></db:td>
<db:td>
<db:para>a <db:link xlink:href="qmatrix4x4.xml">QMatrix4x4</db:link></db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qvariant.xml">QVariant</db:link></db:emphasis>::Palette</db:code></db:para>
</db:td>
<db:td><db:code>QMetaType::QPalette</db:code></db:td>
<db:td>
<db:para>a <db:link xlink:href="qpalette.xml">QPalette</db:link></db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qvariant.xml">QVariant</db:link></db:emphasis>::Pen</db:code></db:para>
</db:td>
<db:td><db:code>QMetaType::QPen</db:code></db:td>
<db:td>
<db:para>a <db:link xlink:href="qpen.xml">QPen</db:link></db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qvariant.xml">QVariant</db:link></db:emphasis>::Pixmap</db:code></db:para>
</db:td>
<db:td><db:code>QMetaType::QPixmap</db:code></db:td>
<db:td>
<db:para>a <db:link xlink:href="qpixmap.xml">QPixmap</db:link></db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qvariant.xml">QVariant</db:link></db:emphasis>::Point</db:code></db:para>
</db:td>
<db:td><db:code>QMetaType::QPoint</db:code></db:td>
<db:td>
<db:para>a <db:link xlink:href="qpoint.xml">QPoint</db:link></db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qvariant.xml">QVariant</db:link></db:emphasis>::PointF</db:code></db:para>
</db:td>
<db:td><db:code>QMetaType::QPointF</db:code></db:td>
<db:td>
<db:para>a <db:link xlink:href="qpointf.xml">QPointF</db:link></db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qvariant.xml">QVariant</db:link></db:emphasis>::Polygon</db:code></db:para>
</db:td>
<db:td><db:code>QMetaType::QPolygon</db:code></db:td>
<db:td>
<db:para>a <db:link xlink:href="qpolygon.xml">QPolygon</db:link></db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qvariant.xml">QVariant</db:link></db:emphasis>::PolygonF</db:code></db:para>
</db:td>
<db:td><db:code>QMetaType::QPolygonF</db:code></db:td>
<db:td>
<db:para>a <db:link xlink:href="qpolygonf.xml">QPolygonF</db:link></db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qvariant.xml">QVariant</db:link></db:emphasis>::Quaternion</db:code></db:para>
</db:td>
<db:td><db:code>QMetaType::QQuaternion</db:code></db:td>
<db:td>
<db:para>a <db:link xlink:href="qquaternion.xml">QQuaternion</db:link></db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qvariant.xml">QVariant</db:link></db:emphasis>::Rect</db:code></db:para>
</db:td>
<db:td><db:code>QMetaType::QRect</db:code></db:td>
<db:td>
<db:para>a <db:link xlink:href="qrect.xml">QRect</db:link></db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qvariant.xml">QVariant</db:link></db:emphasis>::RectF</db:code></db:para>
</db:td>
<db:td><db:code>QMetaType::QRectF</db:code></db:td>
<db:td>
<db:para>a <db:link xlink:href="qrectf.xml">QRectF</db:link></db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qvariant.xml">QVariant</db:link></db:emphasis>::RegExp</db:code></db:para>
</db:td>
<db:td><db:code>QMetaType::QRegExp</db:code></db:td>
<db:td>
<db:para>a <db:link xlink:href="qregexp.xml">QRegExp</db:link></db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qvariant.xml">QVariant</db:link></db:emphasis>::RegularExpression</db:code></db:para>
</db:td>
<db:td><db:code>QMetaType::QRegularExpression</db:code></db:td>
<db:td>
<db:para>a <db:link xlink:href="qregularexpression.xml">QRegularExpression</db:link></db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qvariant.xml">QVariant</db:link></db:emphasis>::Region</db:code></db:para>
</db:td>
<db:td><db:code>QMetaType::QRegion</db:code></db:td>
<db:td>
<db:para>a <db:link xlink:href="qregion.xml">QRegion</db:link></db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qvariant.xml">QVariant</db:link></db:emphasis>::Size</db:code></db:para>
</db:td>
<db:td><db:code>QMetaType::QSize</db:code></db:td>
<db:td>
<db:para>a <db:link xlink:href="qsize.xml">QSize</db:link></db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qvariant.xml">QVariant</db:link></db:emphasis>::SizeF</db:code></db:para>
</db:td>
<db:td><db:code>QMetaType::QSizeF</db:code></db:td>
<db:td>
<db:para>a <db:link xlink:href="qsizef.xml">QSizeF</db:link></db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qvariant.xml">QVariant</db:link></db:emphasis>::SizePolicy</db:code></db:para>
</db:td>
<db:td><db:code>QMetaType::QSizePolicy</db:code></db:td>
<db:td>
<db:para>a <db:link xlink:href="qsizepolicy.xml">QSizePolicy</db:link></db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qvariant.xml">QVariant</db:link></db:emphasis>::String</db:code></db:para>
</db:td>
<db:td><db:code>QMetaType::QString</db:code></db:td>
<db:td>
<db:para>a <db:link xlink:href="qstring.xml">QString</db:link></db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qvariant.xml">QVariant</db:link></db:emphasis>::StringList</db:code></db:para>
</db:td>
<db:td><db:code>QMetaType::QStringList</db:code></db:td>
<db:td>
<db:para>a <db:link xlink:href="qstringlist.xml">QStringList</db:link></db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qvariant.xml">QVariant</db:link></db:emphasis>::TextFormat</db:code></db:para>
</db:td>
<db:td><db:code>QMetaType::QTextFormat</db:code></db:td>
<db:td>
<db:para>a <db:link xlink:href="qtextformat.xml">QTextFormat</db:link></db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qvariant.xml">QVariant</db:link></db:emphasis>::TextLength</db:code></db:para>
</db:td>
<db:td><db:code>QMetaType::QTextLength</db:code></db:td>
<db:td>
<db:para>a <db:link xlink:href="qtextlength.xml">QTextLength</db:link></db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qvariant.xml">QVariant</db:link></db:emphasis>::Time</db:code></db:para>
</db:td>
<db:td><db:code>QMetaType::QTime</db:code></db:td>
<db:td>
<db:para>a <db:link xlink:href="qtime.xml">QTime</db:link></db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qvariant.xml">QVariant</db:link></db:emphasis>::UInt</db:code></db:para>
</db:td>
<db:td><db:code>QMetaType::UInt</db:code></db:td>
<db:td>
<db:para>a <db:link xlink:href="qtglobal.xml#uint-typedef">uint</db:link></db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qvariant.xml">QVariant</db:link></db:emphasis>::ULongLong</db:code></db:para>
</db:td>
<db:td><db:code>QMetaType::ULongLong</db:code></db:td>
<db:td>
<db:para>a <db:link xlink:href="qtglobal.xml#qulonglong-typedef">qulonglong</db:link></db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qvariant.xml">QVariant</db:link></db:emphasis>::Url</db:code></db:para>
</db:td>
<db:td><db:code>QMetaType::QUrl</db:code></db:td>
<db:td>
<db:para>a <db:link xlink:href="qurl.xml">QUrl</db:link></db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qvariant.xml">QVariant</db:link></db:emphasis>::Vector2D</db:code></db:para>
</db:td>
<db:td><db:code>QMetaType::QVector2D</db:code></db:td>
<db:td>
<db:para>a <db:link xlink:href="qvector2d.xml">QVector2D</db:link></db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qvariant.xml">QVariant</db:link></db:emphasis>::Vector3D</db:code></db:para>
</db:td>
<db:td><db:code>QMetaType::QVector3D</db:code></db:td>
<db:td>
<db:para>a <db:link xlink:href="qvector3d.xml">QVector3D</db:link></db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qvariant.xml">QVariant</db:link></db:emphasis>::Vector4D</db:code></db:para>
</db:td>
<db:td><db:code>QMetaType::QVector4D</db:code></db:td>
<db:td>
<db:para>a <db:link xlink:href="qvector4d.xml">QVector4D</db:link></db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qvariant.xml">QVariant</db:link></db:emphasis>::UserType</db:code></db:para>
</db:td>
<db:td><db:code>QMetaType::User</db:code></db:td>
<db:td>
<db:para>Base value for user-defined types.</db:para>
</db:td>
</db:tr>
</db:informaltable>
</db:section>
</db:section>
</db:section>
</db:article>
