<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en">
<db:info>
<db:title>QVariant Class</db:title>
<db:productname>QtCore</db:productname>
<db:edition>Qt 6.8.3 Reference Documentation</db:edition>
<db:titleabbrev>Qt Core Reference Documentation</db:titleabbrev>
<db:abstract>
<db:para>The <db:link xlink:href="qvariant.xml">QVariant</db:link> class acts like a union for the most common Qt data types.</db:para>
<db:para>This class is <db:emphasis>equality-comparable</db:emphasis>.</db:para>
</db:abstract>
<db:pubdate>2025-06-29</db:pubdate>
<db:date>2025-06-29</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:variablelist>
<db:varlistentry>
<db:term>Header</db:term>
<db:listitem>
<db:para>QVariant</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>CMake</db:term>
<db:listitem>
<db:para>find_package(Qt6 REQUIRED COMPONENTS Core)</db:para>
<db:para>target_link_libraries(mytarget PRIVATE Qt6::Core)</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>qmake</db:term>
<db:listitem>
<db:para>QT += core</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Group</db:term>
<db:listitem>
<db:para>QVariant is part of <db:simplelist><db:member>objectmodel</db:member><db:member><db:link xlink:href="shared.xml">Implicitly Shared Classes</db:link></db:member></db:simplelist>
</db:para>
</db:listitem>
</db:varlistentry>
</db:variablelist>
<db:section xml:id="details">
<db:title>Detailed Description</db:title>
<db:para>Because C++ forbids unions from including types that have non-default constructors or destructors, most interesting Qt classes cannot be used in unions. Without <db:link xlink:href="qvariant.xml">QVariant</db:link>, this would be a problem for <db:link xlink:href="qobject.xml#property">QObject::property</db:link>() and for database work, etc.</db:para>
<db:para>A <db:link xlink:href="qvariant.xml">QVariant</db:link> object holds a single value of a single <db:link xlink:href="qvariant.xml#typeId">typeId</db:link>() at a time. (Some types are multi-valued, for example a string list.) You can find out what type, T, the variant holds, convert it to a different type using <db:link xlink:href="qvariant.xml#convert">convert</db:link>(), get its value using one of the toT() functions (e.g., <db:link xlink:href="qvariant.xml#toSize">toSize</db:link>()), and check whether the type can be converted to a particular type using <db:link xlink:href="qvariant.xml#canConvert">canConvert</db:link>().</db:para>
<db:para>The methods named toT() (e.g., <db:link xlink:href="qvariant.xml#toInt">toInt</db:link>(), <db:link xlink:href="qvariant.xml#toString">toString</db:link>()) are const. If you ask for the stored type, they return a copy of the stored object. If you ask for a type that can be generated from the stored type, toT() copies and converts and leaves the object itself unchanged. If you ask for a type that cannot be generated from the stored type, the result depends on the type; see the function documentation for details.</db:para>
<db:para>Here is some example code to demonstrate the use of <db:link xlink:href="qvariant.xml">QVariant</db:link>:</db:para>
<db:programlisting language="cpp">QDataStream out(...);
QVariant v(123);                // The variant now contains an int
int x = v.toInt();              // x = 123
out &lt;&lt; v;                       // Writes a type tag and an int to out
v = QVariant(tr(&quot;hello&quot;));      // The variant now contains a QString
int y = v.toInt();              // y = 0 since v cannot be converted to an int
QString s = v.toString();       // s = tr(&quot;hello&quot;)  (see QObject::tr())
out &lt;&lt; v;                       // Writes a type tag and a QString to out
...
QDataStream in(...);            // (opening the previously written stream)
in &gt;&gt; v;                        // Reads an Int variant
int z = v.toInt();              // z = 123
qDebug(&quot;Type is %s&quot;,            // prints &quot;Type is int&quot;
        v.typeName());
v = v.toInt() + 100;            // The variant now holds the value 223
v = QVariant(QStringList());    // The variant now holds a QStringList
</db:programlisting>
<db:para>You can even store <db:link xlink:href="qlist.xml">QList</db:link>&lt;<db:link xlink:href="qvariant.xml">QVariant</db:link>&gt; and <db:link xlink:href="qmap.xml">QMap</db:link>&lt;<db:link xlink:href="qstring.xml">QString</db:link>, <db:link xlink:href="qvariant.xml">QVariant</db:link>&gt; values in a variant, so you can easily construct arbitrarily complex data structures of arbitrary types. This is very powerful and versatile, but may prove less memory and speed efficient than storing specific types in standard data structures.</db:para>
<db:para><db:link xlink:href="qvariant.xml">QVariant</db:link> also supports the notion of null values. A variant is null if the variant contains no initialized value, or contains a null pointer.</db:para>
<db:programlisting language="cpp">QVariant x;                                // x.isNull() == true
QVariant y = QVariant::fromValue(nullptr); // y.isNull() == true
</db:programlisting>
<db:para><db:link xlink:href="qvariant.xml">QVariant</db:link> can be extended to support other types than those mentioned in the <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::Type</db:link> enum. See <db:link xlink:href="custom-types.xml">Creating Custom Qt Types</db:link> for details.</db:para>
<db:section xml:id="a-note-on-gui-types">
<db:title>A Note on GUI Types</db:title>
<db:para>Because <db:link xlink:href="qvariant.xml">QVariant</db:link> is part of the Qt Core module, it cannot provide conversion functions to data types defined in Qt GUI, such as QColor, QImage, and QPixmap. In other words, there is no toColor() function. Instead, you can use the <db:link xlink:href="qvariant.xml#value">QVariant::value</db:link>() or the <db:link xlink:href="qvariant.xml#qvariant_cast">qvariant_cast</db:link>() template function. For example:</db:para>
<db:programlisting language="cpp">QVariant variant;
...
QColor color = variant.value&lt;QColor&gt;();
</db:programlisting>
<db:para>The inverse conversion (e.g., from QColor to <db:link xlink:href="qvariant.xml">QVariant</db:link>) is automatic for all data types supported by <db:link xlink:href="qvariant.xml">QVariant</db:link>, including GUI-related types:</db:para>
<db:programlisting language="cpp">QColor color = palette().background().color();
QVariant variant = color;
</db:programlisting>
</db:section>
<db:section xml:id="using-canconvert-and-convert-consecutively">
<db:title>Using canConvert() and convert() Consecutively</db:title>
<db:para>When using <db:link xlink:href="qvariant.xml#canConvert">canConvert</db:link>() and <db:link xlink:href="qvariant.xml#convert">convert</db:link>() consecutively, it is possible for <db:link xlink:href="qvariant.xml#canConvert">canConvert</db:link>() to return true, but <db:link xlink:href="qvariant.xml#convert">convert</db:link>() to return false. This is typically because <db:link xlink:href="qvariant.xml#canConvert">canConvert</db:link>() only reports the general ability of <db:link xlink:href="qvariant.xml">QVariant</db:link> to convert between types given suitable data; it is still possible to supply data which cannot actually be converted.</db:para>
<db:para>For example, canConvert(QMetaType::fromType&lt;int&gt;()) would return true when called on a variant containing a string because, in principle, <db:link xlink:href="qvariant.xml">QVariant</db:link> is able to convert strings of numbers to integers. However, if the string contains non-numeric characters, it cannot be converted to an integer, and any attempt to convert it will fail. Hence, it is important to have both functions return true for a successful conversion.</db:para>
</db:section>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="member-function-documentation">
<db:title>Member Function Documentation</db:title>
<db:section xml:id="typeId">
<db:title>int QVariant::typeId() const</db:title>
<db:bridgehead renderas="sect2" xml:id="userType">int QVariant::userType() const</db:bridgehead>
<db:para>Returns the storage type of the value stored in the variant. This is the same as <db:link xlink:href="qvariant.xml#metaType">metaType</db:link>().id().</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qvariant.xml#metaType">metaType</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="constData">
<db:title>const void *QVariant::constData() const</db:title>
<db:bridgehead renderas="sect2" xml:id="data-1">const void *QVariant::data() const</db:bridgehead>
<db:para>Returns a pointer to the contained object as a generic void* that cannot be written to.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qvariant.xml#get_if">get_if</db:link>()</db:member>
<db:member><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="QVariant">
<db:title>[noexcept] QVariant::QVariant()</db:title>
<db:para>Constructs an invalid variant.</db:para>
</db:section>
<db:section xml:id="QVariant-1">
<db:title>[noexcept] QVariant::QVariant(QChar <db:emphasis>c</db:emphasis>)</db:title>
<db:para>Constructs a new variant with a char value, <db:code role="parameter">c</db:code>.</db:para>
</db:section>
<db:section xml:id="QVariant-36">
<db:title>QVariant::QVariant(const char *<db:emphasis>val</db:emphasis>)</db:title>
<db:para>Constructs a new variant with a string value of <db:code role="parameter">val</db:code>. The variant creates a deep copy of <db:code role="parameter">val</db:code> into a <db:link xlink:href="qstring.xml">QString</db:link> assuming UTF-8 encoding on the input <db:code role="parameter">val</db:code>.</db:para>
<db:para>Note that <db:code role="parameter">val</db:code> is converted to a <db:link xlink:href="qstring.xml">QString</db:link> for storing in the variant and <db:link xlink:href="qvariant.xml#userType">QVariant::userType</db:link>() will return <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QString</db:link> for the variant.</db:para>
<db:para>You can disable this operator by defining QT_NO_CAST_FROM_ASCII when you compile your applications.</db:para>
</db:section>
<db:section xml:id="QVariant-37">
<db:title>[noexcept] QVariant::QVariant(double <db:emphasis>val</db:emphasis>)</db:title>
<db:para>Constructs a new variant with a floating point value, <db:code role="parameter">val</db:code>.</db:para>
</db:section>
<db:section xml:id="QVariant-38">
<db:title>[noexcept] QVariant::QVariant(float <db:emphasis>val</db:emphasis>)</db:title>
<db:para>Constructs a new variant with a floating point value, <db:code role="parameter">val</db:code>.</db:para>
</db:section>
<db:section xml:id="QVariant-39">
<db:title>[noexcept] QVariant::QVariant(int <db:emphasis>val</db:emphasis>)</db:title>
<db:para>Constructs a new variant with an integer value, <db:code role="parameter">val</db:code>.</db:para>
</db:section>
<db:section xml:id="QVariant-40">
<db:title>[noexcept] QVariant::QVariant(qlonglong <db:emphasis>val</db:emphasis>)</db:title>
<db:para>Constructs a new variant with a long long integer value, <db:code role="parameter">val</db:code>.</db:para>
</db:section>
<db:section xml:id="QVariant-41">
<db:title>[noexcept] QVariant::QVariant(qulonglong <db:emphasis>val</db:emphasis>)</db:title>
<db:para>Constructs a new variant with an unsigned long long integer value, <db:code role="parameter">val</db:code>.</db:para>
</db:section>
<db:section xml:id="QVariant-42">
<db:title>[noexcept] QVariant::QVariant(uint <db:emphasis>val</db:emphasis>)</db:title>
<db:para>Constructs a new variant with an unsigned integer value, <db:code role="parameter">val</db:code>.</db:para>
</db:section>
<db:section xml:id="QVariant-43">
<db:title>[explicit] QVariant::QVariant(QMetaType <db:emphasis>type</db:emphasis>, const void *<db:emphasis>copy</db:emphasis> = nullptr)</db:title>
<db:para>Constructs a variant of type <db:code role="parameter">type</db:code>, and initializes it with a copy of *copy if <db:code role="parameter">copy</db:code> is not nullptr (in which case, <db:code role="parameter">copy</db:code> must point to an object of type <db:code role="parameter">type</db:code>).</db:para>
<db:para>Note that you have to pass the address of the object you want stored.</db:para>
<db:para>Usually, you never have to use this constructor, use <db:link xlink:href="qvariant.xml#fromValue">QVariant::fromValue</db:link>() instead to construct variants from the pointer types represented by QMetaType::VoidStar, and QMetaType::QObjectStar.</db:para>
<db:para>If <db:code role="parameter">type</db:code> does not support copy construction and <db:code role="parameter">copy</db:code> is not nullptr, the variant will be invalid. Similarly, if <db:code role="parameter">copy</db:code> is nullptr and <db:code role="parameter">type</db:code> does not support default construction, the variant will be invalid.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qvariant.xml#fromMetaType">QVariant::fromMetaType</db:link></db:member>
<db:member><db:link xlink:href="qvariant.xml#fromValue">QVariant::fromValue</db:link>()</db:member>
<db:member><db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::Type</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="QVariant-52">
<db:title>[explicit noexcept(...), since 6.6] QVariant::QVariant(<db:emphasis>std::in_place_type_t&lt;T&gt;</db:emphasis>, Args &amp;&amp;... <db:emphasis>args</db:emphasis>)</db:title>
<db:para>Constructs a new variant containing a value of type T. The contained value is is initialized with the arguments std::forward&lt;Args&gt;(args)....</db:para>
<db:para>This overload only participates in overload resolution if T can be constructed from <db:code role="parameter">args</db:code>.</db:para>
<db:para>This constructor is provided for STL/std::any compatibility.</db:para>
<db:para>This is an overloaded function.</db:para>
<db:para>This function was introduced in Qt 6.6.</db:para>
</db:section>
<db:section xml:id="QVariant-53">
<db:title>[explicit noexcept(...), since 6.6] QVariant::QVariant(<db:emphasis>std::in_place_type_t&lt;T&gt;</db:emphasis>, std::initializer_list&lt;U&gt; <db:emphasis>il</db:emphasis>, Args &amp;&amp;... <db:emphasis>args</db:emphasis>)</db:title>
<db:para>This is an overloaded function.</db:para>
<db:para>This overload exists to support types with constructors taking an initializer_list. It behaves otherwise equivalent to the non-initializer list in_place_type_t overload.</db:para>
<db:para>This function was introduced in Qt 6.6.</db:para>
</db:section>
<db:section xml:id="QVariant-2">
<db:title>[noexcept] QVariant::QVariant(QDate <db:emphasis>val</db:emphasis>)</db:title>
<db:para>Constructs a new variant with a date value, <db:code role="parameter">val</db:code>.</db:para>
</db:section>
<db:section xml:id="QVariant-3">
<db:title>QVariant::QVariant(QLatin1StringView <db:emphasis>val</db:emphasis>)</db:title>
<db:para>Constructs a new variant with a <db:link xlink:href="qstring.xml">QString</db:link> value from the Latin-1 string viewed by <db:code role="parameter">val</db:code>.</db:para>
</db:section>
<db:section xml:id="QVariant-4">
<db:title>[noexcept(...)] QVariant::QVariant(QLine <db:emphasis>val</db:emphasis>)</db:title>
<db:para>Constructs a new variant with a line value of <db:code role="parameter">val</db:code>.</db:para>
</db:section>
<db:section xml:id="QVariant-5">
<db:title>[noexcept(...)] QVariant::QVariant(QLineF <db:emphasis>val</db:emphasis>)</db:title>
<db:para>Constructs a new variant with a line value of <db:code role="parameter">val</db:code>.</db:para>
</db:section>
<db:section xml:id="QVariant-6">
<db:title>[noexcept] QVariant::QVariant(QPoint <db:emphasis>val</db:emphasis>)</db:title>
<db:para>Constructs a new variant with a point value of <db:code role="parameter">val</db:code>.</db:para>
</db:section>
<db:section xml:id="QVariant-7">
<db:title>[noexcept(...)] QVariant::QVariant(QPointF <db:emphasis>val</db:emphasis>)</db:title>
<db:para>Constructs a new variant with a point value of <db:code role="parameter">val</db:code>.</db:para>
</db:section>
<db:section xml:id="QVariant-8">
<db:title>[noexcept(...)] QVariant::QVariant(QRect <db:emphasis>val</db:emphasis>)</db:title>
<db:para>Constructs a new variant with a rect value of <db:code role="parameter">val</db:code>.</db:para>
</db:section>
<db:section xml:id="QVariant-9">
<db:title>[noexcept(...)] QVariant::QVariant(QRectF <db:emphasis>val</db:emphasis>)</db:title>
<db:para>Constructs a new variant with a rect value of <db:code role="parameter">val</db:code>.</db:para>
</db:section>
<db:section xml:id="QVariant-10">
<db:title>[noexcept] QVariant::QVariant(QSize <db:emphasis>val</db:emphasis>)</db:title>
<db:para>Constructs a new variant with a size value of <db:code role="parameter">val</db:code>.</db:para>
</db:section>
<db:section xml:id="QVariant-11">
<db:title>[noexcept(...)] QVariant::QVariant(QSizeF <db:emphasis>val</db:emphasis>)</db:title>
<db:para>Constructs a new variant with a size value of <db:code role="parameter">val</db:code>.</db:para>
</db:section>
<db:section xml:id="QVariant-12">
<db:title>[noexcept] QVariant::QVariant(QTime <db:emphasis>val</db:emphasis>)</db:title>
<db:para>Constructs a new variant with a time value, <db:code role="parameter">val</db:code>.</db:para>
</db:section>
<db:section xml:id="QVariant-13">
<db:title>[noexcept(...)] QVariant::QVariant(QUuid <db:emphasis>val</db:emphasis>)</db:title>
<db:para>Constructs a new variant with an uuid value, <db:code role="parameter">val</db:code>.</db:para>
</db:section>
<db:section xml:id="QVariant-16">
<db:title>[noexcept] QVariant::QVariant(bool <db:emphasis>val</db:emphasis>)</db:title>
<db:para>Constructs a new variant with a boolean value, <db:code role="parameter">val</db:code>.</db:para>
</db:section>
<db:section xml:id="QVariant-17">
<db:title>[noexcept] QVariant::QVariant(const QBitArray &amp;<db:emphasis>val</db:emphasis>)</db:title>
<db:para>Constructs a new variant with a bitarray value, <db:code role="parameter">val</db:code>.</db:para>
</db:section>
<db:section xml:id="QVariant-18">
<db:title>[noexcept] QVariant::QVariant(const QByteArray &amp;<db:emphasis>val</db:emphasis>)</db:title>
<db:para>Constructs a new variant with a bytearray value, <db:code role="parameter">val</db:code>.</db:para>
</db:section>
<db:section xml:id="QVariant-19">
<db:title>[noexcept] QVariant::QVariant(const QDateTime &amp;<db:emphasis>val</db:emphasis>)</db:title>
<db:para>Constructs a new variant with a date/time value, <db:code role="parameter">val</db:code>.</db:para>
</db:section>
<db:section xml:id="QVariant-20">
<db:title>QVariant::QVariant(const QEasingCurve &amp;<db:emphasis>val</db:emphasis>)</db:title>
<db:para>Constructs a new variant with an easing curve value, <db:code role="parameter">val</db:code>.</db:para>
</db:section>
<db:section xml:id="QVariant-21">
<db:title>[noexcept] QVariant::QVariant(const QHash&lt;QString, QVariant&gt; &amp;<db:emphasis>val</db:emphasis>)</db:title>
<db:para>Constructs a new variant with a hash of <db:link xlink:href="qvariant.xml">QVariant</db:link>s, <db:code role="parameter">val</db:code>.</db:para>
</db:section>
<db:section xml:id="QVariant-22">
<db:title>[noexcept] QVariant::QVariant(const QJsonArray &amp;<db:emphasis>val</db:emphasis>)</db:title>
<db:para>Constructs a new variant with a json array value, <db:code role="parameter">val</db:code>.</db:para>
</db:section>
<db:section xml:id="QVariant-23">
<db:title>QVariant::QVariant(const QJsonDocument &amp;<db:emphasis>val</db:emphasis>)</db:title>
<db:para>Constructs a new variant with a json document value, <db:code role="parameter">val</db:code>.</db:para>
</db:section>
<db:section xml:id="QVariant-24">
<db:title>[noexcept] QVariant::QVariant(const QJsonObject &amp;<db:emphasis>val</db:emphasis>)</db:title>
<db:para>Constructs a new variant with a json object value, <db:code role="parameter">val</db:code>.</db:para>
</db:section>
<db:section xml:id="QVariant-25">
<db:title>[noexcept(...)] QVariant::QVariant(const QJsonValue &amp;<db:emphasis>val</db:emphasis>)</db:title>
<db:para>Constructs a new variant with a json value, <db:code role="parameter">val</db:code>.</db:para>
</db:section>
<db:section xml:id="QVariant-26">
<db:title>[noexcept] QVariant::QVariant(const QList&lt;QVariant&gt; &amp;<db:emphasis>val</db:emphasis>)</db:title>
<db:para>Constructs a new variant with a list value, <db:code role="parameter">val</db:code>.</db:para>
</db:section>
<db:section xml:id="QVariant-27">
<db:title>[noexcept] QVariant::QVariant(const QLocale &amp;<db:emphasis>l</db:emphasis>)</db:title>
<db:para>Constructs a new variant with a locale value, <db:code role="parameter">l</db:code>.</db:para>
</db:section>
<db:section xml:id="QVariant-28">
<db:title>[noexcept] QVariant::QVariant(const QMap&lt;QString, QVariant&gt; &amp;<db:emphasis>val</db:emphasis>)</db:title>
<db:para>Constructs a new variant with a map of <db:link xlink:href="qvariant.xml">QVariant</db:link>s, <db:code role="parameter">val</db:code>.</db:para>
</db:section>
<db:section xml:id="QVariant-29">
<db:title>[noexcept(...)] QVariant::QVariant(const QModelIndex &amp;<db:emphasis>val</db:emphasis>)</db:title>
<db:para>Constructs a new variant with a <db:link xlink:href="qmodelindex.xml">QModelIndex</db:link> value, <db:code role="parameter">val</db:code>.</db:para>
</db:section>
<db:section xml:id="QVariant-30">
<db:title>QVariant::QVariant(const QPersistentModelIndex &amp;<db:emphasis>val</db:emphasis>)</db:title>
<db:para>Constructs a new variant with a <db:link xlink:href="qpersistentmodelindex.xml">QPersistentModelIndex</db:link> value, <db:code role="parameter">val</db:code>.</db:para>
</db:section>
<db:section xml:id="QVariant-31">
<db:title>[noexcept] QVariant::QVariant(const QRegularExpression &amp;<db:emphasis>re</db:emphasis>)</db:title>
<db:para>Constructs a new variant with the regular expression value <db:code role="parameter">re</db:code>.</db:para>
</db:section>
<db:section xml:id="QVariant-32">
<db:title>[noexcept] QVariant::QVariant(const QString &amp;<db:emphasis>val</db:emphasis>)</db:title>
<db:para>Constructs a new variant with a string value, <db:code role="parameter">val</db:code>.</db:para>
</db:section>
<db:section xml:id="QVariant-33">
<db:title>[noexcept] QVariant::QVariant(const QStringList &amp;<db:emphasis>val</db:emphasis>)</db:title>
<db:para>Constructs a new variant with a string list value, <db:code role="parameter">val</db:code>.</db:para>
</db:section>
<db:section xml:id="QVariant-34">
<db:title>[noexcept] QVariant::QVariant(const QUrl &amp;<db:emphasis>val</db:emphasis>)</db:title>
<db:para>Constructs a new variant with a url value of <db:code role="parameter">val</db:code>.</db:para>
</db:section>
<db:section xml:id="QVariant-35">
<db:title>QVariant::QVariant(const QVariant &amp;<db:emphasis>p</db:emphasis>)</db:title>
<db:para>Constructs a copy of the variant, <db:code role="parameter">p</db:code>, passed as the argument to this constructor.</db:para>
</db:section>
<db:section xml:id="QVariant-14">
<db:title>[noexcept] QVariant::QVariant(QVariant &amp;&amp;<db:emphasis>other</db:emphasis>)</db:title>
<db:para>Move-constructs a <db:link xlink:href="qvariant.xml">QVariant</db:link> instance, making it point at the same object that <db:code role="parameter">other</db:code> was pointing to.</db:para>
</db:section>
<db:section xml:id="dtor.QVariant">
<db:title>[noexcept] QVariant::~QVariant()</db:title>
<db:para>Destroys the <db:link xlink:href="qvariant.xml">QVariant</db:link> and the contained object.</db:para>
</db:section>
<db:section xml:id="canConvert">
<db:title>bool QVariant::canConvert() const</db:title>
<db:para>Returns true if the variant can be converted to the template type T, otherwise false.</db:para>
<db:para>Example:</db:para>
<db:programlisting language="cpp">QVariant v = 42;

v.canConvert&lt;int&gt;();              // returns true
v.canConvert&lt;QString&gt;();          // returns true

MyCustomStruct s;
v.setValue(s);

v.canConvert&lt;int&gt;();              // returns false
v.canConvert&lt;MyCustomStruct&gt;();   // returns true
</db:programlisting>
<db:para>A <db:link xlink:href="qvariant.xml">QVariant</db:link> containing a pointer to a type derived from <db:link xlink:href="qobject.xml">QObject</db:link> will also return true for this function if a <db:link xlink:href="qobject.xml#qobject_cast">qobject_cast</db:link> to the template type T would succeed. Note that this only works for <db:link xlink:href="qobject.xml">QObject</db:link> subclasses which use the <db:link xlink:href="qobject.xml#Q_OBJECT">Q_OBJECT</db:link> macro.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qvariant.xml#convert">convert</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="canConvert-1">
<db:title>[since 6.0] bool QVariant::canConvert(QMetaType <db:emphasis>type</db:emphasis>) const</db:title>
<db:para>Returns true if the variant's type can be cast to the requested type, <db:code role="parameter">type</db:code>. Such casting is done automatically when calling the <db:link xlink:href="qvariant.xml#toInt">toInt</db:link>(), <db:link xlink:href="qvariant.xml#toBool">toBool</db:link>(), ... methods.</db:para>
<db:para>This function was introduced in Qt 6.0.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qmetatype.xml#canConvert">QMetaType::canConvert</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="canView">
<db:title>bool QVariant::canView() const</db:title>
<db:para>Returns true if a mutable view of the template type T can be created on this variant, otherwise false.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qvariant.xml#value">value</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="clear">
<db:title>void QVariant::clear()</db:title>
<db:para>Convert this variant to type <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::UnknownType</db:link> and free up any resources used.</db:para>
</db:section>
<db:section xml:id="compare">
<db:title>[static, since 6.0] QPartialOrdering QVariant::compare(const QVariant &amp;<db:emphasis>lhs</db:emphasis>, const QVariant &amp;<db:emphasis>rhs</db:emphasis>)</db:title>
<db:para>Compares the objects at <db:code role="parameter">lhs</db:code> and <db:code role="parameter">rhs</db:code> for ordering.</db:para>
<db:para>Returns <db:link xlink:href="qpartialordering.xml#Unordered-var">QPartialOrdering::Unordered</db:link> if comparison is not supported or the values are unordered. Otherwise, returns <db:link xlink:href="qpartialordering.xml#Less-var">QPartialOrdering::Less</db:link>, <db:link xlink:href="qpartialordering.xml#Equivalent-var">QPartialOrdering::Equivalent</db:link> or <db:link xlink:href="qpartialordering.xml#Greater-var">QPartialOrdering::Greater</db:link> if <db:code role="parameter">lhs</db:code> is less than, equivalent to or greater than <db:code role="parameter">rhs</db:code>, respectively.</db:para>
<db:para>If the variants contain data with a different metatype, the values are considered unordered unless they are both of numeric or pointer types, where regular numeric or pointer comparison rules will be used.</db:para>
<db:note>
<db:para>: If a numeric comparison is done and at least one value is NaN, <db:link xlink:href="qpartialordering.xml#Unordered-var">QPartialOrdering::Unordered</db:link> is returned.</db:para>
</db:note>
<db:para>If both variants contain data of the same metatype, the method will use the <db:link xlink:href="qmetatype.xml#compare">QMetaType::compare</db:link> method to determine the ordering of the two variants, which can also indicate that it can't establish an ordering between the two values.</db:para>
<db:para>This function was introduced in Qt 6.0.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qmetatype.xml#compare">QMetaType::compare</db:link>()</db:member>
<db:member><db:link xlink:href="qmetatype.xml#isOrdered">QMetaType::isOrdered</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="convert">
<db:title>[since 6.0] bool QVariant::convert(QMetaType <db:emphasis>targetType</db:emphasis>)</db:title>
<db:para>Casts the variant to the requested type, <db:code role="parameter">targetType</db:code>. If the cast cannot be done, the variant is still changed to the requested type, but is left in a cleared null state similar to that constructed by <db:link xlink:href="qvariant.xml">QVariant</db:link>(Type).</db:para>
<db:para>Returns true if the current type of the variant was successfully cast; otherwise returns false.</db:para>
<db:para>A <db:link xlink:href="qvariant.xml">QVariant</db:link> containing a pointer to a type derived from <db:link xlink:href="qobject.xml">QObject</db:link> will also convert and return true for this function if a <db:link xlink:href="qobject.xml#qobject_cast">qobject_cast</db:link> to the type described by <db:code role="parameter">targetType</db:code> would succeed. Note that this only works for <db:link xlink:href="qobject.xml">QObject</db:link> subclasses which use the <db:link xlink:href="qobject.xml#Q_OBJECT">Q_OBJECT</db:link> macro.</db:para>
<db:note>
<db:para>converting QVariants that are null due to not being initialized or having failed a previous conversion will always fail, changing the type, remaining null, and returning false.</db:para>
</db:note>
<db:para>This function was introduced in Qt 6.0.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qvariant.xml#canConvert">canConvert</db:link>()</db:member>
<db:member><db:link xlink:href="qvariant.xml#clear">clear</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="data">
<db:title>void *QVariant::data()</db:title>
<db:para>Returns a pointer to the contained object as a generic void* that can be written to.</db:para>
<db:para>This function detaches the <db:link xlink:href="qvariant.xml">QVariant</db:link>. When called on a <db:link xlink:href="qvariant.xml#isNull">null-QVariant</db:link>, the <db:link xlink:href="qvariant.xml">QVariant</db:link> will not be null after the call.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qvariant.xml#get_if">get_if</db:link>()</db:member>
<db:member><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="emplace">
<db:title>[since 6.6] T &amp;QVariant::emplace(Args &amp;&amp;... <db:emphasis>args</db:emphasis>)</db:title>
<db:para>Replaces the object currently held in *this with an object of type T, constructed from <db:code role="parameter">args</db:code>.... If *this was non-null, the previously held object is destroyed first. If possible, this method will reuse memory allocated by the <db:link xlink:href="qvariant.xml">QVariant</db:link>. Returns a reference to the newly-created object.</db:para>
<db:para>This function was introduced in Qt 6.6.</db:para>
</db:section>
<db:section xml:id="emplace-1">
<db:title>[since 6.6] T &amp;QVariant::emplace(std::initializer_list&lt;U&gt; <db:emphasis>list</db:emphasis>, Args &amp;&amp;... <db:emphasis>args</db:emphasis>)</db:title>
<db:para>This is an overloaded function.</db:para>
<db:para>This overload exists to support types with constructors taking an initializer_list. It behaves otherwise equivalent to the non-initializer list overload.</db:para>
<db:para>This function was introduced in Qt 6.6.</db:para>
</db:section>
<db:section xml:id="fromMetaType">
<db:title>[static, since 6.7] QVariant QVariant::fromMetaType(QMetaType <db:emphasis>type</db:emphasis>, const void *<db:emphasis>copy</db:emphasis> = nullptr)</db:title>
<db:para>Creates a variant of type <db:code role="parameter">type</db:code>, and initializes it with a copy of *copy if <db:code role="parameter">copy</db:code> is not nullptr (in which case, <db:code role="parameter">copy</db:code> must point to an object of type <db:code role="parameter">type</db:code>).</db:para>
<db:para>Note that you have to pass the address of the object you want stored.</db:para>
<db:para>Usually, you never have to use this constructor, use <db:link xlink:href="qvariant.xml#fromValue">QVariant::fromValue</db:link>() instead to construct variants from the pointer types represented by QMetaType::VoidStar, and QMetaType::QObjectStar.</db:para>
<db:para>If <db:code role="parameter">type</db:code> does not support copy construction and <db:code role="parameter">copy</db:code> is not nullptr, the variant will be invalid. Similarly, if <db:code role="parameter">copy</db:code> is nullptr and <db:code role="parameter">type</db:code> does not support default construction, the variant will be invalid.</db:para>
<db:para>Returns the <db:link xlink:href="qvariant.xml">QVariant</db:link> created as described above.</db:para>
<db:para>This function was introduced in Qt 6.7.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qvariant.xml#fromValue">QVariant::fromValue</db:link>()</db:member>
<db:member><db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::Type</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="fromStdVariant">
<db:title>[static] QVariant QVariant::fromStdVariant(const std::variant&lt;Types...&gt; &amp;<db:emphasis>value</db:emphasis>)</db:title>
<db:para>Returns a <db:link xlink:href="qvariant.xml">QVariant</db:link> with the type and value of the active variant of <db:code role="parameter">value</db:code>. If the active type is std::monostate a default <db:link xlink:href="qvariant.xml">QVariant</db:link> is returned.</db:para>
<db:note>
<db:para>With this method you do not need to register the variant as a Qt metatype, since the std::variant is resolved before being stored. The component types should be registered however.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qvariant.xml#fromValue">fromValue</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="fromStdVariant-1">
<db:title>[static, since 6.6] QVariant QVariant::fromStdVariant(std::variant&lt;Types...&gt; &amp;&amp;<db:emphasis>value</db:emphasis>)</db:title>
<db:para>This is an overloaded function.</db:para>
<db:para>This function was introduced in Qt 6.6.</db:para>
</db:section>
<db:section xml:id="fromValue">
<db:title>[static] QVariant QVariant::fromValue(const T &amp;<db:emphasis>value</db:emphasis>)</db:title>
<db:para>Returns a <db:link xlink:href="qvariant.xml">QVariant</db:link> containing a copy of <db:code role="parameter">value</db:code>. Behaves exactly like <db:link xlink:href="qvariant.xml#setValue">setValue</db:link>() otherwise.</db:para>
<db:para>Example:</db:para>
<db:programlisting language="cpp">MyCustomStruct s;
return QVariant::fromValue(s);
</db:programlisting>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qvariant.xml#setValue">setValue</db:link>()</db:member>
<db:member><db:link xlink:href="qvariant.xml#value">value</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="fromValue-1">
<db:title>[static, since 6.6] QVariant QVariant::fromValue(T &amp;&amp;<db:emphasis>value</db:emphasis>)</db:title>
<db:para>This is an overloaded function.</db:para>
<db:para>This function was introduced in Qt 6.6.</db:para>
</db:section>
<db:section xml:id="isNull">
<db:title>bool QVariant::isNull() const</db:title>
<db:para>Returns true if this is a null variant, false otherwise.</db:para>
<db:para>A variant is considered null if it contains no initialized value or a null pointer.</db:para>
<db:note>
<db:para>This behavior has been changed from Qt 5, where isNull() would also return true if the variant contained an object of a builtin type with an isNull() method that returned true for that object.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qvariant.xml#convert">convert</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="isValid">
<db:title>bool QVariant::isValid() const</db:title>
<db:para>Returns true if the storage type of this variant is not <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::UnknownType</db:link>; otherwise returns false.</db:para>
</db:section>
<db:section xml:id="metaType">
<db:title>[since 6.0] QMetaType QVariant::metaType() const</db:title>
<db:para>Returns the <db:link xlink:href="qmetatype.xml">QMetaType</db:link> of the value stored in the variant.</db:para>
<db:para>This function was introduced in Qt 6.0.</db:para>
</db:section>
<db:section xml:id="setValue">
<db:title>void QVariant::setValue(QVariant &amp;&amp;<db:emphasis>value</db:emphasis>)</db:title>
<db:para>Moves <db:code role="parameter">value</db:code> over this <db:link xlink:href="qvariant.xml">QVariant</db:link>. It is equivalent to simply move assigning <db:code role="parameter">value</db:code> to this <db:link xlink:href="qvariant.xml">QVariant</db:link>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qvariant.xml#value">value</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setValue-1">
<db:title>void QVariant::setValue(T &amp;&amp;<db:emphasis>value</db:emphasis>)</db:title>
<db:para>Stores a copy of <db:code role="parameter">value</db:code>. If T is a type that <db:link xlink:href="qvariant.xml">QVariant</db:link> doesn't support, <db:link xlink:href="qmetatype.xml">QMetaType</db:link> is used to store the value. A compile error will occur if <db:link xlink:href="qmetatype.xml">QMetaType</db:link> doesn't handle the type.</db:para>
<db:para>Example:</db:para>
<db:programlisting language="cpp">QVariant v;

v.setValue(5);
int i = v.toInt();         // i is now 5
QString s = v.toString();  // s is now &quot;5&quot;

MyCustomStruct c;
v.setValue(c);

...

MyCustomStruct c2 = v.value&lt;MyCustomStruct&gt;();
</db:programlisting>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qvariant.xml#value">value</db:link>()</db:member>
<db:member><db:link xlink:href="qvariant.xml#fromValue">fromValue</db:link>()</db:member>
<db:member><db:link xlink:href="qvariant.xml#canConvert">canConvert</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setValue-2">
<db:title>void QVariant::setValue(const QVariant &amp;<db:emphasis>value</db:emphasis>)</db:title>
<db:para>Copies <db:code role="parameter">value</db:code> over this <db:link xlink:href="qvariant.xml">QVariant</db:link>. It is equivalent to simply assigning <db:code role="parameter">value</db:code> to this <db:link xlink:href="qvariant.xml">QVariant</db:link>.</db:para>
</db:section>
<db:section xml:id="swap">
<db:title>[noexcept] void QVariant::swap(QVariant &amp;<db:emphasis>other</db:emphasis>)</db:title>
<db:para>Swaps this variant with <db:code role="parameter">other</db:code>. This operation is very fast and never fails.</db:para>
</db:section>
<db:section xml:id="toBitArray">
<db:title>QBitArray QVariant::toBitArray() const</db:title>
<db:para>Returns the variant as a <db:link xlink:href="qbitarray.xml">QBitArray</db:link> if the variant has <db:link xlink:href="qvariant.xml#userType">userType</db:link>() <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QBitArray</db:link>; otherwise returns an empty bit array.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qvariant.xml#canConvert">canConvert</db:link>()</db:member>
<db:member><db:link xlink:href="qvariant.xml#convert">convert</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="toBool">
<db:title>bool QVariant::toBool() const</db:title>
<db:para>Returns the variant as a bool if the variant has <db:link xlink:href="qvariant.xml#userType">userType</db:link>() Bool.</db:para>
<db:para>Returns true if the variant has <db:link xlink:href="qvariant.xml#userType">userType</db:link>() <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::Bool</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QChar</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::Double</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::Int</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::LongLong</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::UInt</db:link>, or <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::ULongLong</db:link> and the value is non-zero, or if the variant has type <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QString</db:link> or <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QByteArray</db:link> and its lower-case content is not one of the following: empty, &quot;0&quot; or &quot;false&quot;; otherwise returns false.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qvariant.xml#canConvert">canConvert</db:link>()</db:member>
<db:member><db:link xlink:href="qvariant.xml#convert">convert</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="toByteArray">
<db:title>QByteArray QVariant::toByteArray() const</db:title>
<db:para>Returns the variant as a <db:link xlink:href="qbytearray.xml">QByteArray</db:link> if the variant has <db:link xlink:href="qvariant.xml#userType">userType</db:link>() <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QByteArray</db:link> or <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QString</db:link> (converted using <db:link xlink:href="qstring.xml#fromUtf8">QString::fromUtf8</db:link>()); otherwise returns an empty byte array.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qvariant.xml#canConvert">canConvert</db:link>()</db:member>
<db:member><db:link xlink:href="qvariant.xml#convert">convert</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="toChar">
<db:title>QChar QVariant::toChar() const</db:title>
<db:para>Returns the variant as a <db:link xlink:href="qchar.xml">QChar</db:link> if the variant has <db:link xlink:href="qvariant.xml#userType">userType</db:link>() <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QChar</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::Int</db:link>, or <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::UInt</db:link>; otherwise returns an invalid <db:link xlink:href="qchar.xml">QChar</db:link>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qvariant.xml#canConvert">canConvert</db:link>()</db:member>
<db:member><db:link xlink:href="qvariant.xml#convert">convert</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="toDate">
<db:title>QDate QVariant::toDate() const</db:title>
<db:para>Returns the variant as a <db:link xlink:href="qdate.xml">QDate</db:link> if the variant has <db:link xlink:href="qvariant.xml#userType">userType</db:link>() <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QDate</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QDateTime</db:link>, or <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QString</db:link>; otherwise returns an invalid date.</db:para>
<db:para>If the type() is <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QString</db:link>, an invalid date will be returned if the string cannot be parsed as a <db:link xlink:href="qt.xml#DateFormat-enum">Qt::ISODate</db:link> format date.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qvariant.xml#canConvert">canConvert</db:link>()</db:member>
<db:member><db:link xlink:href="qvariant.xml#convert">convert</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="toDateTime">
<db:title>QDateTime QVariant::toDateTime() const</db:title>
<db:para>Returns the variant as a <db:link xlink:href="qdatetime.xml">QDateTime</db:link> if the variant has <db:link xlink:href="qvariant.xml#userType">userType</db:link>() <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QDateTime</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QDate</db:link>, or <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QString</db:link>; otherwise returns an invalid date/time.</db:para>
<db:para>If the type() is <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QString</db:link>, an invalid date/time will be returned if the string cannot be parsed as a <db:link xlink:href="qt.xml#DateFormat-enum">Qt::ISODate</db:link> format date/time.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qvariant.xml#canConvert">canConvert</db:link>()</db:member>
<db:member><db:link xlink:href="qvariant.xml#convert">convert</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="toDouble">
<db:title>double QVariant::toDouble(bool *<db:emphasis>ok</db:emphasis> = nullptr) const</db:title>
<db:para>Returns the variant as a double if the variant has <db:link xlink:href="qvariant.xml#userType">userType</db:link>() <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::Double</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::Float</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::Bool</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QByteArray</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::Int</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::LongLong</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QString</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::UInt</db:link>, or <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::ULongLong</db:link>; otherwise returns 0.0.</db:para>
<db:para>If <db:code role="parameter">ok</db:code> is non-null: *<db:code role="parameter">ok</db:code> is set to true if the value could be converted to a double; otherwise *<db:code role="parameter">ok</db:code> is set to false.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qvariant.xml#canConvert">canConvert</db:link>()</db:member>
<db:member><db:link xlink:href="qvariant.xml#convert">convert</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="toEasingCurve">
<db:title>QEasingCurve QVariant::toEasingCurve() const</db:title>
<db:para>Returns the variant as a <db:link xlink:href="qeasingcurve.xml">QEasingCurve</db:link> if the variant has <db:link xlink:href="qvariant.xml#userType">userType</db:link>() <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QEasingCurve</db:link>; otherwise returns a default easing curve.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qvariant.xml#canConvert">canConvert</db:link>()</db:member>
<db:member><db:link xlink:href="qvariant.xml#convert">convert</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="toFloat">
<db:title>float QVariant::toFloat(bool *<db:emphasis>ok</db:emphasis> = nullptr) const</db:title>
<db:para>Returns the variant as a float if the variant has <db:link xlink:href="qvariant.xml#userType">userType</db:link>() <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::Double</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::Float</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::Bool</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QByteArray</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::Int</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::LongLong</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QString</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::UInt</db:link>, or <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::ULongLong</db:link>; otherwise returns 0.0.</db:para>
<db:para>If <db:code role="parameter">ok</db:code> is non-null: *<db:code role="parameter">ok</db:code> is set to true if the value could be converted to a double; otherwise *<db:code role="parameter">ok</db:code> is set to false.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qvariant.xml#canConvert">canConvert</db:link>()</db:member>
<db:member><db:link xlink:href="qvariant.xml#convert">convert</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="toHash">
<db:title>QHash&lt;QString, QVariant&gt; QVariant::toHash() const</db:title>
<db:para>Returns the variant as a <db:link xlink:href="qhash.xml#the-hashing-function">QHash</db:link>&lt;<db:link xlink:href="qstring.xml">QString</db:link>, <db:link xlink:href="qvariant.xml">QVariant</db:link>&gt; if the variant has type() <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QVariantHash</db:link>; otherwise returns an empty map.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qvariant.xml#canConvert">canConvert</db:link>()</db:member>
<db:member><db:link xlink:href="qvariant.xml#convert">convert</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="toInt">
<db:title>int QVariant::toInt(bool *<db:emphasis>ok</db:emphasis> = nullptr) const</db:title>
<db:para>Returns the variant as an int if the variant has <db:link xlink:href="qvariant.xml#userType">userType</db:link>() <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::Int</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::Bool</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QByteArray</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QChar</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::Double</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::LongLong</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QString</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::UInt</db:link>, or <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::ULongLong</db:link>; otherwise returns 0.</db:para>
<db:para>If <db:code role="parameter">ok</db:code> is non-null: *<db:code role="parameter">ok</db:code> is set to true if the value could be converted to an int; otherwise *<db:code role="parameter">ok</db:code> is set to false.</db:para>
<db:para><db:emphasis role="bold">Warning:</db:emphasis> If the value is convertible to a <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::LongLong</db:link> but is too large to be represented in an int, the resulting arithmetic overflow will not be reflected in <db:code role="parameter">ok</db:code>. A simple workaround is to use <db:link xlink:href="qstring.xml#toInt">QString::toInt</db:link>().</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qvariant.xml#canConvert">canConvert</db:link>()</db:member>
<db:member><db:link xlink:href="qvariant.xml#convert">convert</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="toJsonArray">
<db:title>QJsonArray QVariant::toJsonArray() const</db:title>
<db:para>Returns the variant as a <db:link xlink:href="qjsonarray.xml">QJsonArray</db:link> if the variant has <db:link xlink:href="qvariant.xml#userType">userType</db:link>() <db:link xlink:href="qjsonarray.xml">QJsonArray</db:link>; otherwise returns a default constructed <db:link xlink:href="qjsonarray.xml">QJsonArray</db:link>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qvariant.xml#canConvert">canConvert</db:link>()</db:member>
<db:member><db:link xlink:href="qvariant.xml#convert">convert</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="toJsonDocument">
<db:title>QJsonDocument QVariant::toJsonDocument() const</db:title>
<db:para>Returns the variant as a <db:link xlink:href="qjsondocument.xml">QJsonDocument</db:link> if the variant has <db:link xlink:href="qvariant.xml#userType">userType</db:link>() <db:link xlink:href="qjsondocument.xml">QJsonDocument</db:link>; otherwise returns a default constructed <db:link xlink:href="qjsondocument.xml">QJsonDocument</db:link>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qvariant.xml#canConvert">canConvert</db:link>()</db:member>
<db:member><db:link xlink:href="qvariant.xml#convert">convert</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="toJsonObject">
<db:title>QJsonObject QVariant::toJsonObject() const</db:title>
<db:para>Returns the variant as a <db:link xlink:href="qjsonobject.xml">QJsonObject</db:link> if the variant has <db:link xlink:href="qvariant.xml#userType">userType</db:link>() <db:link xlink:href="qjsonobject.xml">QJsonObject</db:link>; otherwise returns a default constructed <db:link xlink:href="qjsonobject.xml">QJsonObject</db:link>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qvariant.xml#canConvert">canConvert</db:link>()</db:member>
<db:member><db:link xlink:href="qvariant.xml#convert">convert</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="toJsonValue">
<db:title>QJsonValue QVariant::toJsonValue() const</db:title>
<db:para>Returns the variant as a <db:link xlink:href="qjsonvalue.xml">QJsonValue</db:link> if the variant has <db:link xlink:href="qvariant.xml#userType">userType</db:link>() <db:link xlink:href="qjsonvalue.xml">QJsonValue</db:link>; otherwise returns a default constructed <db:link xlink:href="qjsonvalue.xml">QJsonValue</db:link>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qvariant.xml#canConvert">canConvert</db:link>()</db:member>
<db:member><db:link xlink:href="qvariant.xml#convert">convert</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="toLine">
<db:title>QLine QVariant::toLine() const</db:title>
<db:para>Returns the variant as a <db:link xlink:href="qline.xml">QLine</db:link> if the variant has <db:link xlink:href="qvariant.xml#userType">userType</db:link>() <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QLine</db:link>; otherwise returns an invalid <db:link xlink:href="qline.xml">QLine</db:link>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qvariant.xml#canConvert">canConvert</db:link>()</db:member>
<db:member><db:link xlink:href="qvariant.xml#convert">convert</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="toLineF">
<db:title>QLineF QVariant::toLineF() const</db:title>
<db:para>Returns the variant as a <db:link xlink:href="qlinef.xml">QLineF</db:link> if the variant has <db:link xlink:href="qvariant.xml#userType">userType</db:link>() <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QLineF</db:link>; otherwise returns an invalid <db:link xlink:href="qlinef.xml">QLineF</db:link>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qvariant.xml#canConvert">canConvert</db:link>()</db:member>
<db:member><db:link xlink:href="qvariant.xml#convert">convert</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="toList">
<db:title>QList&lt;QVariant&gt; QVariant::toList() const</db:title>
<db:para>Returns the variant as a <db:link xlink:href="qvariant.xml#QVariantList-typedef">QVariantList</db:link> if the variant has <db:link xlink:href="qvariant.xml#userType">userType</db:link>() <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QVariantList</db:link>. If it doesn't, <db:link xlink:href="qvariant.xml">QVariant</db:link> will attempt to convert the type to a list and then return it. This will succeed for any type that has registered a converter to <db:link xlink:href="qvariant.xml#QVariantList-typedef">QVariantList</db:link> or which was declared as a sequential container using <db:link xlink:href="qmetatype.xml#Q_DECLARE_SEQUENTIAL_CONTAINER_METATYPE">Q_DECLARE_SEQUENTIAL_CONTAINER_METATYPE</db:link>. If none of those conditions are true, this function will return an empty list.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qvariant.xml#canConvert">canConvert</db:link>()</db:member>
<db:member><db:link xlink:href="qvariant.xml#convert">convert</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="toLocale">
<db:title>QLocale QVariant::toLocale() const</db:title>
<db:para>Returns the variant as a <db:link xlink:href="qlocale.xml">QLocale</db:link> if the variant has <db:link xlink:href="qvariant.xml#userType">userType</db:link>() <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QLocale</db:link>; otherwise returns an invalid <db:link xlink:href="qlocale.xml">QLocale</db:link>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qvariant.xml#canConvert">canConvert</db:link>()</db:member>
<db:member><db:link xlink:href="qvariant.xml#convert">convert</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="toLongLong">
<db:title>qlonglong QVariant::toLongLong(bool *<db:emphasis>ok</db:emphasis> = nullptr) const</db:title>
<db:para>Returns the variant as a long long int if the variant has <db:link xlink:href="qvariant.xml#userType">userType</db:link>() <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::LongLong</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::Bool</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QByteArray</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QChar</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::Double</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::Int</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QString</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::UInt</db:link>, or <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::ULongLong</db:link>; otherwise returns 0.</db:para>
<db:para>If <db:code role="parameter">ok</db:code> is non-null: *ok is set to true if the value could be converted to an int; otherwise *ok is set to false.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qvariant.xml#canConvert">canConvert</db:link>()</db:member>
<db:member><db:link xlink:href="qvariant.xml#convert">convert</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="toMap">
<db:title>QMap&lt;QString, QVariant&gt; QVariant::toMap() const</db:title>
<db:para>Returns the variant as a <db:link xlink:href="qvariant.xml#QVariantMap-typedef">QVariantMap</db:link> if the variant has type() <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QVariantMap</db:link>. If it doesn't, <db:link xlink:href="qvariant.xml">QVariant</db:link> will attempt to convert the type to a map and then return it. This will succeed for any type that has registered a converter to <db:link xlink:href="qvariant.xml#QVariantMap-typedef">QVariantMap</db:link> or which was declared as a associative container using <db:link xlink:href="qmetatype.xml#Q_DECLARE_ASSOCIATIVE_CONTAINER_METATYPE">Q_DECLARE_ASSOCIATIVE_CONTAINER_METATYPE</db:link>. If none of those conditions are true, this function will return an empty map.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qvariant.xml#canConvert">canConvert</db:link>()</db:member>
<db:member><db:link xlink:href="qvariant.xml#convert">convert</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="toModelIndex">
<db:title>QModelIndex QVariant::toModelIndex() const</db:title>
<db:para>Returns the variant as a <db:link xlink:href="qmodelindex.xml">QModelIndex</db:link> if the variant has <db:link xlink:href="qvariant.xml#userType">userType</db:link>() <db:link xlink:href="qmodelindex.xml">QModelIndex</db:link>; otherwise returns a default constructed <db:link xlink:href="qmodelindex.xml">QModelIndex</db:link>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qvariant.xml#canConvert">canConvert</db:link>()</db:member>
<db:member><db:link xlink:href="qvariant.xml#convert">convert</db:link>()</db:member>
<db:member><db:link xlink:href="qvariant.xml#toPersistentModelIndex">toPersistentModelIndex</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="toPersistentModelIndex">
<db:title>QPersistentModelIndex QVariant::toPersistentModelIndex() const</db:title>
<db:para>Returns the variant as a <db:link xlink:href="qpersistentmodelindex.xml">QPersistentModelIndex</db:link> if the variant has <db:link xlink:href="qvariant.xml#userType">userType</db:link>() <db:link xlink:href="qpersistentmodelindex.xml">QPersistentModelIndex</db:link>; otherwise returns a default constructed <db:link xlink:href="qpersistentmodelindex.xml">QPersistentModelIndex</db:link>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qvariant.xml#canConvert">canConvert</db:link>()</db:member>
<db:member><db:link xlink:href="qvariant.xml#convert">convert</db:link>()</db:member>
<db:member><db:link xlink:href="qvariant.xml#toModelIndex">toModelIndex</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="toPoint">
<db:title>QPoint QVariant::toPoint() const</db:title>
<db:para>Returns the variant as a <db:link xlink:href="qpoint.xml">QPoint</db:link> if the variant has <db:link xlink:href="qvariant.xml#userType">userType</db:link>() <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QPoint</db:link> or <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QPointF</db:link>; otherwise returns a null <db:link xlink:href="qpoint.xml">QPoint</db:link>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qvariant.xml#canConvert">canConvert</db:link>()</db:member>
<db:member><db:link xlink:href="qvariant.xml#convert">convert</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="toPointF">
<db:title>QPointF QVariant::toPointF() const</db:title>
<db:para>Returns the variant as a <db:link xlink:href="qpointf.xml">QPointF</db:link> if the variant has <db:link xlink:href="qvariant.xml#userType">userType</db:link>() <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QPoint</db:link> or <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QPointF</db:link>; otherwise returns a null <db:link xlink:href="qpointf.xml">QPointF</db:link>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qvariant.xml#canConvert">canConvert</db:link>()</db:member>
<db:member><db:link xlink:href="qvariant.xml#convert">convert</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="toReal">
<db:title>qreal QVariant::toReal(bool *<db:emphasis>ok</db:emphasis> = nullptr) const</db:title>
<db:para>Returns the variant as a qreal if the variant has <db:link xlink:href="qvariant.xml#userType">userType</db:link>() <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::Double</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::Float</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::Bool</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QByteArray</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::Int</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::LongLong</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QString</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::UInt</db:link>, or <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::ULongLong</db:link>; otherwise returns 0.0.</db:para>
<db:para>If <db:code role="parameter">ok</db:code> is non-null: *<db:code role="parameter">ok</db:code> is set to true if the value could be converted to a double; otherwise *<db:code role="parameter">ok</db:code> is set to false.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qvariant.xml#canConvert">canConvert</db:link>()</db:member>
<db:member><db:link xlink:href="qvariant.xml#convert">convert</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="toRect">
<db:title>QRect QVariant::toRect() const</db:title>
<db:para>Returns the variant as a <db:link xlink:href="qrect.xml">QRect</db:link> if the variant has <db:link xlink:href="qvariant.xml#userType">userType</db:link>() <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QRect</db:link>; otherwise returns an invalid <db:link xlink:href="qrect.xml">QRect</db:link>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qvariant.xml#canConvert">canConvert</db:link>()</db:member>
<db:member><db:link xlink:href="qvariant.xml#convert">convert</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="toRectF">
<db:title>QRectF QVariant::toRectF() const</db:title>
<db:para>Returns the variant as a <db:link xlink:href="qrectf.xml">QRectF</db:link> if the variant has <db:link xlink:href="qvariant.xml#userType">userType</db:link>() <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QRect</db:link> or <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QRectF</db:link>; otherwise returns an invalid <db:link xlink:href="qrectf.xml">QRectF</db:link>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qvariant.xml#canConvert">canConvert</db:link>()</db:member>
<db:member><db:link xlink:href="qvariant.xml#convert">convert</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="toRegularExpression">
<db:title>QRegularExpression QVariant::toRegularExpression() const</db:title>
<db:para>Returns the variant as a <db:link xlink:href="qregularexpression.xml">QRegularExpression</db:link> if the variant has <db:link xlink:href="qvariant.xml#userType">userType</db:link>() <db:link xlink:href="qregularexpression.xml">QRegularExpression</db:link>; otherwise returns an empty <db:link xlink:href="qregularexpression.xml">QRegularExpression</db:link>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qvariant.xml#canConvert">canConvert</db:link>()</db:member>
<db:member><db:link xlink:href="qvariant.xml#convert">convert</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="toSize">
<db:title>QSize QVariant::toSize() const</db:title>
<db:para>Returns the variant as a <db:link xlink:href="qsize.xml">QSize</db:link> if the variant has <db:link xlink:href="qvariant.xml#userType">userType</db:link>() <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QSize</db:link>; otherwise returns an invalid <db:link xlink:href="qsize.xml">QSize</db:link>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qvariant.xml#canConvert">canConvert</db:link>()</db:member>
<db:member><db:link xlink:href="qvariant.xml#convert">convert</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="toSizeF">
<db:title>QSizeF QVariant::toSizeF() const</db:title>
<db:para>Returns the variant as a <db:link xlink:href="qsizef.xml">QSizeF</db:link> if the variant has <db:link xlink:href="qvariant.xml#userType">userType</db:link>() <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QSizeF</db:link>; otherwise returns an invalid <db:link xlink:href="qsizef.xml">QSizeF</db:link>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qvariant.xml#canConvert">canConvert</db:link>()</db:member>
<db:member><db:link xlink:href="qvariant.xml#convert">convert</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="toString">
<db:title>QString QVariant::toString() const</db:title>
<db:para>Returns the variant as a <db:link xlink:href="qstring.xml">QString</db:link> if the variant has a <db:link xlink:href="qvariant.xml#userType">userType</db:link>() including, but not limited to:</db:para>
<db:para><db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QString</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::Bool</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QByteArray</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QChar</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QDate</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QDateTime</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::Double</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::Int</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::LongLong</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QStringList</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QTime</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::UInt</db:link>, or <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::ULongLong</db:link>.</db:para>
<db:para>Calling QVariant::toString() on an unsupported variant returns an empty string.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qvariant.xml#canConvert">canConvert</db:link>()</db:member>
<db:member><db:link xlink:href="qvariant.xml#convert">convert</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="toStringList">
<db:title>QStringList QVariant::toStringList() const</db:title>
<db:para>Returns the variant as a <db:link xlink:href="qstringlist.xml">QStringList</db:link> if the variant has <db:link xlink:href="qvariant.xml#userType">userType</db:link>() <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QStringList</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QString</db:link>, or <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QVariantList</db:link> of a type that can be converted to <db:link xlink:href="qstring.xml">QString</db:link>; otherwise returns an empty list.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qvariant.xml#canConvert">canConvert</db:link>()</db:member>
<db:member><db:link xlink:href="qvariant.xml#convert">convert</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="toTime">
<db:title>QTime QVariant::toTime() const</db:title>
<db:para>Returns the variant as a <db:link xlink:href="qtime.xml">QTime</db:link> if the variant has <db:link xlink:href="qvariant.xml#userType">userType</db:link>() <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QTime</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QDateTime</db:link>, or <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QString</db:link>; otherwise returns an invalid time.</db:para>
<db:para>If the type() is <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QString</db:link>, an invalid time will be returned if the string cannot be parsed as a <db:link xlink:href="qt.xml#DateFormat-enum">Qt::ISODate</db:link> format time.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qvariant.xml#canConvert">canConvert</db:link>()</db:member>
<db:member><db:link xlink:href="qvariant.xml#convert">convert</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="toUInt">
<db:title>uint QVariant::toUInt(bool *<db:emphasis>ok</db:emphasis> = nullptr) const</db:title>
<db:para>Returns the variant as an unsigned int if the variant has <db:link xlink:href="qvariant.xml#userType">userType</db:link>() <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::UInt</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::Bool</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QByteArray</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QChar</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::Double</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::Int</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::LongLong</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QString</db:link>, or <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::ULongLong</db:link>; otherwise returns 0.</db:para>
<db:para>If <db:code role="parameter">ok</db:code> is non-null: *<db:code role="parameter">ok</db:code> is set to true if the value could be converted to an unsigned int; otherwise *<db:code role="parameter">ok</db:code> is set to false.</db:para>
<db:para><db:emphasis role="bold">Warning:</db:emphasis> If the value is convertible to a <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::ULongLong</db:link> but is too large to be represented in an unsigned int, the resulting arithmetic overflow will not be reflected in <db:code role="parameter">ok</db:code>. A simple workaround is to use <db:link xlink:href="qstring.xml#toUInt">QString::toUInt</db:link>().</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qvariant.xml#canConvert">canConvert</db:link>()</db:member>
<db:member><db:link xlink:href="qvariant.xml#convert">convert</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="toULongLong">
<db:title>qulonglong QVariant::toULongLong(bool *<db:emphasis>ok</db:emphasis> = nullptr) const</db:title>
<db:para>Returns the variant as an unsigned long long int if the variant has type() <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::ULongLong</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::Bool</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QByteArray</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QChar</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::Double</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::Int</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::LongLong</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QString</db:link>, or <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::UInt</db:link>; otherwise returns 0.</db:para>
<db:para>If <db:code role="parameter">ok</db:code> is non-null: *<db:code role="parameter">ok</db:code> is set to true if the value could be converted to an int; otherwise *<db:code role="parameter">ok</db:code> is set to false.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qvariant.xml#canConvert">canConvert</db:link>()</db:member>
<db:member><db:link xlink:href="qvariant.xml#convert">convert</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="toUrl">
<db:title>QUrl QVariant::toUrl() const</db:title>
<db:para>Returns the variant as a <db:link xlink:href="qurl.xml">QUrl</db:link> if the variant has <db:link xlink:href="qvariant.xml#userType">userType</db:link>() <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QUrl</db:link>; otherwise returns an invalid <db:link xlink:href="qurl.xml">QUrl</db:link>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qvariant.xml#canConvert">canConvert</db:link>()</db:member>
<db:member><db:link xlink:href="qvariant.xml#convert">convert</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="toUuid">
<db:title>QUuid QVariant::toUuid() const</db:title>
<db:para>Returns the variant as a <db:link xlink:href="quuid.xml">QUuid</db:link> if the variant has type() <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QUuid</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QByteArray</db:link> or <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QString</db:link>; otherwise returns a default-constructed <db:link xlink:href="quuid.xml">QUuid</db:link>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qvariant.xml#canConvert">canConvert</db:link>()</db:member>
<db:member><db:link xlink:href="qvariant.xml#convert">convert</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="typeName">
<db:title>const char *QVariant::typeName() const</db:title>
<db:para>Returns the name of the type stored in the variant. The returned strings describe the C++ datatype used to store the data: for example, &quot;QFont&quot;, &quot;<db:link xlink:href="qstring.xml">QString</db:link>&quot;, or &quot;<db:link xlink:href="qvariant.xml#QVariantList-typedef">QVariantList</db:link>&quot;. An Invalid variant returns 0.</db:para>
</db:section>
<db:section xml:id="value">
<db:title>T QVariant::value() const &amp;</db:title>
<db:para>Returns the stored value converted to the template type T. Call <db:link xlink:href="qvariant.xml#canConvert">canConvert</db:link>() to find out whether a type can be converted. If the value cannot be converted, a <db:link xlink:href="containers.xml#default-constructed-value">default-constructed value</db:link> will be returned.</db:para>
<db:para>If the type T is supported by <db:link xlink:href="qvariant.xml">QVariant</db:link>, this function behaves exactly as <db:link xlink:href="qvariant.xml#toString">toString</db:link>(), <db:link xlink:href="qvariant.xml#toInt">toInt</db:link>() etc.</db:para>
<db:para>Example:</db:para>
<db:programlisting language="cpp">QVariant v;

MyCustomStruct c;
if (v.canConvert&lt;MyCustomStruct&gt;())
    c = v.value&lt;MyCustomStruct&gt;();

v = 7;
int i = v.value&lt;int&gt;();                        // same as v.toInt()
QString s = v.value&lt;QString&gt;();                // same as v.toString(), s is now &quot;7&quot;
MyCustomStruct c2 = v.value&lt;MyCustomStruct&gt;(); // conversion failed, c2 is empty
</db:programlisting>
<db:para>If the <db:link xlink:href="qvariant.xml">QVariant</db:link> contains a pointer to a type derived from <db:link xlink:href="qobject.xml">QObject</db:link> then T may be any <db:link xlink:href="qobject.xml">QObject</db:link> type. If the pointer stored in the <db:link xlink:href="qvariant.xml">QVariant</db:link> can be <db:link xlink:href="qobject.xml#qobject_cast">qobject_cast</db:link> to T, then that result is returned. Otherwise nullptr is returned. Note that this only works for <db:link xlink:href="qobject.xml">QObject</db:link> subclasses which use the <db:link xlink:href="qobject.xml#Q_OBJECT">Q_OBJECT</db:link> macro.</db:para>
<db:para>If the <db:link xlink:href="qvariant.xml">QVariant</db:link> contains a sequential container and T is <db:link xlink:href="qvariant.xml#QVariantList-typedef">QVariantList</db:link>, the elements of the container will be converted into <db:link xlink:href="qvariant.xml">QVariant</db:link>s and returned as a <db:link xlink:href="qvariant.xml#QVariantList-typedef">QVariantList</db:link>.</db:para>
<db:programlisting language="cpp">QList&lt;int&gt; intList = {7, 11, 42};

QVariant variant = QVariant::fromValue(intList);
if (variant.canConvert&lt;QVariantList&gt;()) {
    QSequentialIterable iterable = variant.value&lt;QSequentialIterable&gt;();
    // Can use foreach:
    foreach (const QVariant &amp;v, iterable) {
        qDebug() &lt;&lt; v;
    }
    // Can use C++11 range-for:
    for (const QVariant &amp;v : iterable) {
        qDebug() &lt;&lt; v;
    }
    // Can use iterators:
    QSequentialIterable::const_iterator it = iterable.begin();
    const QSequentialIterable::const_iterator end = iterable.end();
    for ( ; it != end; ++it) {
        qDebug() &lt;&lt; *it;
    }
}

</db:programlisting>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qvariant.xml#setValue">setValue</db:link>()</db:member>
<db:member><db:link xlink:href="qvariant.xml#fromValue">fromValue</db:link>()</db:member>
<db:member><db:link xlink:href="qvariant.xml#canConvert">canConvert</db:link>()</db:member>
<db:member><db:link xlink:href="qmetatype.xml#Q_DECLARE_SEQUENTIAL_CONTAINER_METATYPE">Q_DECLARE_SEQUENTIAL_CONTAINER_METATYPE</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="view">
<db:title>T QVariant::view()</db:title>
<db:para>Returns a mutable view of template type T on the stored value. Call <db:link xlink:href="qvariant.xml#canView">canView</db:link>() to find out whether such a view is supported. If no such view can be created, returns the stored value converted to the template type T. Call <db:link xlink:href="qvariant.xml#canConvert">canConvert</db:link>() to find out whether a type can be converted. If the value can neither be viewed nor converted, a <db:link xlink:href="containers.xml#default-constructed-value">default-constructed value</db:link> will be returned.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qvariant.xml#canView">canView</db:link>()</db:member>
<db:member><db:link xlink:href="qmetatype.xml#Q_DECLARE_SEQUENTIAL_CONTAINER_METATYPE">Q_DECLARE_SEQUENTIAL_CONTAINER_METATYPE</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="operator-eq">
<db:title>[noexcept] QVariant &amp;QVariant::operator=(QVariant &amp;&amp;<db:emphasis>other</db:emphasis>)</db:title>
<db:para>Move-assigns <db:code role="parameter">other</db:code> to this <db:link xlink:href="qvariant.xml">QVariant</db:link> instance.</db:para>
</db:section>
<db:section xml:id="operator-eq-1">
<db:title>QVariant &amp;QVariant::operator=(const QVariant &amp;<db:emphasis>variant</db:emphasis>)</db:title>
<db:para>Assigns the value of the variant <db:code role="parameter">variant</db:code> to this variant.</db:para>
</db:section>
</db:section>
<db:section xml:id="related-non-members">
<db:title>Related Non-Members</db:title>
<db:section xml:id="get_if">
<db:title>[noexcept, since 6.6] T *get_if(QVariant *<db:emphasis>v</db:emphasis>)</db:title>
<db:bridgehead renderas="sect2" xml:id="get_if-1">[noexcept, since 6.6] const T *get_if(const QVariant *<db:emphasis>v</db:emphasis>)</db:bridgehead>
<db:para>If <db:code role="parameter">v</db:code> contains an object of type T, returns a pointer to the contained object, otherwise returns nullptr.</db:para>
<db:para>The overload taking a mutable <db:code role="parameter">v</db:code> detaches <db:code role="parameter">v</db:code>: When called on a <db:link xlink:href="qvariant.xml#isNull">null</db:link> <db:code role="parameter">v</db:code> with matching type T, <db:code role="parameter">v</db:code> will not be null after the call.</db:para>
<db:para>These functions are provided for compatibility with std::variant.</db:para>
<db:para>This function was introduced in Qt 6.6.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qvariant.xml#data">data</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="get">
<db:title>[since 6.6] T &amp;get(QVariant &amp;<db:emphasis>v</db:emphasis>)</db:title>
<db:bridgehead renderas="sect2" xml:id="get-1">[since 6.6] T &amp;&amp;get(QVariant &amp;&amp;<db:emphasis>v</db:emphasis>)</db:bridgehead>
<db:bridgehead renderas="sect2" xml:id="get-2">[since 6.6] const T &amp;get(const QVariant &amp;<db:emphasis>v</db:emphasis>)</db:bridgehead>
<db:bridgehead renderas="sect2" xml:id="get-3">[since 6.6] const T &amp;&amp;get(const QVariant &amp;&amp;<db:emphasis>v</db:emphasis>)</db:bridgehead>
<db:para>If <db:code role="parameter">v</db:code> contains an object of type T, returns a reference to the contained object, otherwise the call has undefined behavior.</db:para>
<db:para>The overloads taking a mutable <db:code role="parameter">v</db:code> detach <db:code role="parameter">v</db:code>: When called on a <db:link xlink:href="qvariant.xml#isNull">null</db:link> <db:code role="parameter">v</db:code> with matching type T, <db:code role="parameter">v</db:code> will not be null after the call.</db:para>
<db:para>These functions are provided for compatibility with std::variant.</db:para>
<db:para>This function was introduced in Qt 6.6.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qvariant.xml#get_if">get_if</db:link>()</db:member>
<db:member><db:link xlink:href="qvariant.xml#data">data</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="QVariantHash-typedef">
<db:title>[alias] QVariantHash</db:title>
<db:para>Synonym for <db:link xlink:href="qhash.xml#the-hashing-function">QHash</db:link>&lt;<db:link xlink:href="qstring.xml">QString</db:link>, <db:link xlink:href="qvariant.xml">QVariant</db:link>&gt;.</db:para>
</db:section>
<db:section xml:id="QVariantList-typedef">
<db:title>[alias] QVariantList</db:title>
<db:para>Synonym for <db:link xlink:href="qlist.xml">QList</db:link>&lt;<db:link xlink:href="qvariant.xml">QVariant</db:link>&gt;.</db:para>
</db:section>
<db:section xml:id="QVariantMap-typedef">
<db:title>[alias] QVariantMap</db:title>
<db:para>Synonym for <db:link xlink:href="qmap.xml">QMap</db:link>&lt;<db:link xlink:href="qstring.xml">QString</db:link>, <db:link xlink:href="qvariant.xml">QVariant</db:link>&gt;.</db:para>
</db:section>
<db:section xml:id="qvariant_cast">
<db:title>T qvariant_cast(const QVariant &amp;<db:emphasis>value</db:emphasis>)</db:title>
<db:para>Returns the given <db:code role="parameter">value</db:code> converted to the template type T.</db:para>
<db:para>This function is equivalent to <db:link xlink:href="qvariant.xml#value">QVariant::value</db:link>().</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qvariant.xml#value">QVariant::value</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="qvariant_cast-1">
<db:title>[since 6.7] T qvariant_cast(QVariant &amp;&amp;<db:emphasis>value</db:emphasis>)</db:title>
<db:para>This is an overloaded function.</db:para>
<db:para>Returns the given <db:code role="parameter">value</db:code> converted to the template type T.</db:para>
<db:para>This function was introduced in Qt 6.7.</db:para>
</db:section>
<db:section xml:id="operator-not-eq">
<db:title>[noexcept] bool operator!=(const QVariant &amp;<db:emphasis>lhs</db:emphasis>, const QVariant &amp;<db:emphasis>rhs</db:emphasis>)</db:title>
<db:para>Returns false if <db:code role="parameter">lhs</db:code> and <db:code role="parameter">rhs</db:code> are equal; otherwise returns true.</db:para>
<db:para><db:link xlink:href="qvariant.xml">QVariant</db:link> uses the equality operator of the type() contained to check for equality.</db:para>
<db:para>Variants of different types will always compare as not equal with a few exceptions:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para>If both types are numeric types (integers and floatins point numbers) Qt will compare those types using standard C++ type promotion rules.</db:para>
</db:listitem>
<db:listitem>
<db:para>If one type is numeric and the other one a <db:link xlink:href="qstring.xml">QString</db:link>, Qt will try to convert the <db:link xlink:href="qstring.xml">QString</db:link> to a matching numeric type and if successful compare those.</db:para>
</db:listitem>
<db:listitem>
<db:para>If both variants contain pointers to <db:link xlink:href="qobject.xml">QObject</db:link> derived types, <db:link xlink:href="qvariant.xml">QVariant</db:link> will check whether the types are related and point to the same object.</db:para>
</db:listitem>
</db:itemizedlist>
</db:section>
<db:section xml:id="operator-lt-lt-1">
<db:title>QDataStream &amp;operator&lt;&lt;(QDataStream &amp;<db:emphasis>s</db:emphasis>, const QVariant &amp;<db:emphasis>p</db:emphasis>)</db:title>
<db:para>Writes a variant <db:code role="parameter">p</db:code> to the stream <db:code role="parameter">s</db:code>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="datastreamformat.xml">Format of the QDataStream operators</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="operator-eq-eq">
<db:title>[noexcept] bool operator==(const QVariant &amp;<db:emphasis>lhs</db:emphasis>, const QVariant &amp;<db:emphasis>rhs</db:emphasis>)</db:title>
<db:para>Returns true if <db:code role="parameter">lhs</db:code> and <db:code role="parameter">rhs</db:code> are equal; otherwise returns false.</db:para>
<db:para><db:link xlink:href="qvariant.xml">QVariant</db:link> uses the equality operator of the type() contained to check for equality.</db:para>
<db:para>Variants of different types will always compare as not equal with a few exceptions:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para>If both types are numeric types (integers and floatins point numbers) Qt will compare those types using standard C++ type promotion rules.</db:para>
</db:listitem>
<db:listitem>
<db:para>If one type is numeric and the other one a <db:link xlink:href="qstring.xml">QString</db:link>, Qt will try to convert the <db:link xlink:href="qstring.xml">QString</db:link> to a matching numeric type and if successful compare those.</db:para>
</db:listitem>
<db:listitem>
<db:para>If both variants contain pointers to <db:link xlink:href="qobject.xml">QObject</db:link> derived types, <db:link xlink:href="qvariant.xml">QVariant</db:link> will check whether the types are related and point to the same object.</db:para>
</db:listitem>
</db:itemizedlist>
<db:para>The result of the function is not affected by the result of <db:link xlink:href="qvariant.xml#isNull">QVariant::isNull</db:link>, which means that two values can be equal even if one of them is null and another is not.</db:para>
</db:section>
<db:section xml:id="operator-gt-gt">
<db:title>QDataStream &amp;operator&gt;&gt;(QDataStream &amp;<db:emphasis>s</db:emphasis>, QVariant &amp;<db:emphasis>p</db:emphasis>)</db:title>
<db:para>Reads a variant <db:code role="parameter">p</db:code> from the stream <db:code role="parameter">s</db:code>.</db:para>
<db:note>
<db:para>If the stream contains types that aren't the built-in ones (see <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::Type</db:link>), those types must be registered using <db:link xlink:href="qmetatype.xml#qRegisterMetaType">qRegisterMetaType</db:link>() or <db:link xlink:href="qmetatype.xml#registerType">QMetaType::registerType</db:link>() before the variant can be properly loaded. If an unregistered type is found, <db:link xlink:href="qvariant.xml">QVariant</db:link> will set the corrupt flag in the stream, stop processing and print a warning. For example, for <db:link xlink:href="qlist.xml">QList</db:link>&lt;int&gt; it would print the following:</db:para>
</db:note>
<db:blockquote><db:para>QVariant::load: unknown user type with name <db:link xlink:href="qlist.xml">QList</db:link>&lt;int&gt;</db:para>
</db:blockquote>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="datastreamformat.xml">Format of the QDataStream operators</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
</db:section>
<db:section xml:id="obsolete">
<db:title>Obsolete Members for QVariant</db:title>
<db:para><db:emphasis role="bold">The following members of class <db:link xlink:href="qvariant.xml">QVariant</db:link> are deprecated.</db:emphasis> We strongly advise against using them in new code.</db:para>
<db:section xml:id="obsolete-member-type-documentation">
<db:title>Obsolete Member Type Documentation</db:title>
<db:section xml:id="Type-enum">
<db:title>[deprecated] enum QVariant::Type</db:title>
<db:para>This enum is deprecated. We strongly advise against using it in new code.</db:para>
<db:para>Use <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::Type</db:link> instead.</db:para>
<db:para>This enum type defines the types of variable that a <db:link xlink:href="qvariant.xml">QVariant</db:link> can contain.</db:para>
<db:informaltable>
<db:thead>
<db:tr>
<db:th>Constant</db:th>
<db:th>Value</db:th>
<db:th>Description</db:th>
</db:tr>
</db:thead>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qvariant.xml">QVariant</db:link></db:emphasis>::Invalid</db:code></db:para>
</db:td>
<db:td><db:code>QMetaType::UnknownType</db:code></db:td>
<db:td>
<db:para>no type</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qvariant.xml">QVariant</db:link></db:emphasis>::BitArray</db:code></db:para>
</db:td>
<db:td><db:code>QMetaType::QBitArray</db:code></db:td>
<db:td>
<db:para>a <db:link xlink:href="qbitarray.xml">QBitArray</db:link></db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qvariant.xml">QVariant</db:link></db:emphasis>::Bitmap</db:code></db:para>
</db:td>
<db:td><db:code>QMetaType::QBitmap</db:code></db:td>
<db:td>
<db:para>a QBitmap</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qvariant.xml">QVariant</db:link></db:emphasis>::Bool</db:code></db:para>
</db:td>
<db:td><db:code>QMetaType::Bool</db:code></db:td>
<db:td>
<db:para>a bool</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qvariant.xml">QVariant</db:link></db:emphasis>::Brush</db:code></db:para>
</db:td>
<db:td><db:code>QMetaType::QBrush</db:code></db:td>
<db:td>
<db:para>a QBrush</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qvariant.xml">QVariant</db:link></db:emphasis>::ByteArray</db:code></db:para>
</db:td>
<db:td><db:code>QMetaType::QByteArray</db:code></db:td>
<db:td>
<db:para>a <db:link xlink:href="qbytearray.xml">QByteArray</db:link></db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qvariant.xml">QVariant</db:link></db:emphasis>::Char</db:code></db:para>
</db:td>
<db:td><db:code>QMetaType::QChar</db:code></db:td>
<db:td>
<db:para>a <db:link xlink:href="qchar.xml">QChar</db:link></db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qvariant.xml">QVariant</db:link></db:emphasis>::Color</db:code></db:para>
</db:td>
<db:td><db:code>QMetaType::QColor</db:code></db:td>
<db:td>
<db:para>a QColor</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qvariant.xml">QVariant</db:link></db:emphasis>::Cursor</db:code></db:para>
</db:td>
<db:td><db:code>QMetaType::QCursor</db:code></db:td>
<db:td>
<db:para>a QCursor</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qvariant.xml">QVariant</db:link></db:emphasis>::Date</db:code></db:para>
</db:td>
<db:td><db:code>QMetaType::QDate</db:code></db:td>
<db:td>
<db:para>a <db:link xlink:href="qdate.xml">QDate</db:link></db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qvariant.xml">QVariant</db:link></db:emphasis>::DateTime</db:code></db:para>
</db:td>
<db:td><db:code>QMetaType::QDateTime</db:code></db:td>
<db:td>
<db:para>a <db:link xlink:href="qdatetime.xml">QDateTime</db:link></db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qvariant.xml">QVariant</db:link></db:emphasis>::Double</db:code></db:para>
</db:td>
<db:td><db:code>QMetaType::Double</db:code></db:td>
<db:td>
<db:para>a double</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qvariant.xml">QVariant</db:link></db:emphasis>::EasingCurve</db:code></db:para>
</db:td>
<db:td><db:code>QMetaType::QEasingCurve</db:code></db:td>
<db:td>
<db:para>a <db:link xlink:href="qeasingcurve.xml">QEasingCurve</db:link></db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qvariant.xml">QVariant</db:link></db:emphasis>::Uuid</db:code></db:para>
</db:td>
<db:td><db:code>QMetaType::QUuid</db:code></db:td>
<db:td>
<db:para>a <db:link xlink:href="quuid.xml">QUuid</db:link></db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qvariant.xml">QVariant</db:link></db:emphasis>::ModelIndex</db:code></db:para>
</db:td>
<db:td><db:code>QMetaType::QModelIndex</db:code></db:td>
<db:td>
<db:para>a <db:link xlink:href="qmodelindex.xml">QModelIndex</db:link></db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qvariant.xml">QVariant</db:link></db:emphasis>::PersistentModelIndex (since Qt 5.5)</db:code></db:para>
</db:td>
<db:td><db:code>QMetaType::QPersistentModelIndex</db:code></db:td>
<db:td>
<db:para>a <db:link xlink:href="qpersistentmodelindex.xml">QPersistentModelIndex</db:link></db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qvariant.xml">QVariant</db:link></db:emphasis>::Font</db:code></db:para>
</db:td>
<db:td><db:code>QMetaType::QFont</db:code></db:td>
<db:td>
<db:para>a QFont</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qvariant.xml">QVariant</db:link></db:emphasis>::Hash</db:code></db:para>
</db:td>
<db:td><db:code>QMetaType::QVariantHash</db:code></db:td>
<db:td>
<db:para>a <db:link xlink:href="qvariant.xml#QVariantHash-typedef">QVariantHash</db:link></db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qvariant.xml">QVariant</db:link></db:emphasis>::Icon</db:code></db:para>
</db:td>
<db:td><db:code>QMetaType::QIcon</db:code></db:td>
<db:td>
<db:para>a QIcon</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qvariant.xml">QVariant</db:link></db:emphasis>::Image</db:code></db:para>
</db:td>
<db:td><db:code>QMetaType::QImage</db:code></db:td>
<db:td>
<db:para>a QImage</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qvariant.xml">QVariant</db:link></db:emphasis>::Int</db:code></db:para>
</db:td>
<db:td><db:code>QMetaType::Int</db:code></db:td>
<db:td>
<db:para>an int</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qvariant.xml">QVariant</db:link></db:emphasis>::KeySequence</db:code></db:para>
</db:td>
<db:td><db:code>QMetaType::QKeySequence</db:code></db:td>
<db:td>
<db:para>a QKeySequence</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qvariant.xml">QVariant</db:link></db:emphasis>::Line</db:code></db:para>
</db:td>
<db:td><db:code>QMetaType::QLine</db:code></db:td>
<db:td>
<db:para>a <db:link xlink:href="qline.xml">QLine</db:link></db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qvariant.xml">QVariant</db:link></db:emphasis>::LineF</db:code></db:para>
</db:td>
<db:td><db:code>QMetaType::QLineF</db:code></db:td>
<db:td>
<db:para>a <db:link xlink:href="qlinef.xml">QLineF</db:link></db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qvariant.xml">QVariant</db:link></db:emphasis>::List</db:code></db:para>
</db:td>
<db:td><db:code>QMetaType::QVariantList</db:code></db:td>
<db:td>
<db:para>a <db:link xlink:href="qvariant.xml#QVariantList-typedef">QVariantList</db:link></db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qvariant.xml">QVariant</db:link></db:emphasis>::Locale</db:code></db:para>
</db:td>
<db:td><db:code>QMetaType::QLocale</db:code></db:td>
<db:td>
<db:para>a <db:link xlink:href="qlocale.xml">QLocale</db:link></db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qvariant.xml">QVariant</db:link></db:emphasis>::LongLong</db:code></db:para>
</db:td>
<db:td><db:code>QMetaType::LongLong</db:code></db:td>
<db:td>
<db:para>a <db:link xlink:href="qttypes.xml#qlonglong-typedef">qlonglong</db:link></db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qvariant.xml">QVariant</db:link></db:emphasis>::Map</db:code></db:para>
</db:td>
<db:td><db:code>QMetaType::QVariantMap</db:code></db:td>
<db:td>
<db:para>a <db:link xlink:href="qvariant.xml#QVariantMap-typedef">QVariantMap</db:link></db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qvariant.xml">QVariant</db:link></db:emphasis>::Transform</db:code></db:para>
</db:td>
<db:td><db:code>QMetaType::QTransform</db:code></db:td>
<db:td>
<db:para>a QTransform</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qvariant.xml">QVariant</db:link></db:emphasis>::Matrix4x4</db:code></db:para>
</db:td>
<db:td><db:code>QMetaType::QMatrix4x4</db:code></db:td>
<db:td>
<db:para>a QMatrix4x4</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qvariant.xml">QVariant</db:link></db:emphasis>::Palette</db:code></db:para>
</db:td>
<db:td><db:code>QMetaType::QPalette</db:code></db:td>
<db:td>
<db:para>a QPalette</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qvariant.xml">QVariant</db:link></db:emphasis>::Pen</db:code></db:para>
</db:td>
<db:td><db:code>QMetaType::QPen</db:code></db:td>
<db:td>
<db:para>a QPen</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qvariant.xml">QVariant</db:link></db:emphasis>::Pixmap</db:code></db:para>
</db:td>
<db:td><db:code>QMetaType::QPixmap</db:code></db:td>
<db:td>
<db:para>a QPixmap</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qvariant.xml">QVariant</db:link></db:emphasis>::Point</db:code></db:para>
</db:td>
<db:td><db:code>QMetaType::QPoint</db:code></db:td>
<db:td>
<db:para>a <db:link xlink:href="qpoint.xml">QPoint</db:link></db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qvariant.xml">QVariant</db:link></db:emphasis>::PointF</db:code></db:para>
</db:td>
<db:td><db:code>QMetaType::QPointF</db:code></db:td>
<db:td>
<db:para>a <db:link xlink:href="qpointf.xml">QPointF</db:link></db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qvariant.xml">QVariant</db:link></db:emphasis>::Polygon</db:code></db:para>
</db:td>
<db:td><db:code>QMetaType::QPolygon</db:code></db:td>
<db:td>
<db:para>a QPolygon</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qvariant.xml">QVariant</db:link></db:emphasis>::PolygonF</db:code></db:para>
</db:td>
<db:td><db:code>QMetaType::QPolygonF</db:code></db:td>
<db:td>
<db:para>a QPolygonF</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qvariant.xml">QVariant</db:link></db:emphasis>::Quaternion</db:code></db:para>
</db:td>
<db:td><db:code>QMetaType::QQuaternion</db:code></db:td>
<db:td>
<db:para>a QQuaternion</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qvariant.xml">QVariant</db:link></db:emphasis>::Rect</db:code></db:para>
</db:td>
<db:td><db:code>QMetaType::QRect</db:code></db:td>
<db:td>
<db:para>a <db:link xlink:href="qrect.xml">QRect</db:link></db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qvariant.xml">QVariant</db:link></db:emphasis>::RectF</db:code></db:para>
</db:td>
<db:td><db:code>QMetaType::QRectF</db:code></db:td>
<db:td>
<db:para>a <db:link xlink:href="qrectf.xml">QRectF</db:link></db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qvariant.xml">QVariant</db:link></db:emphasis>::RegularExpression</db:code></db:para>
</db:td>
<db:td><db:code>QMetaType::QRegularExpression</db:code></db:td>
<db:td>
<db:para>a <db:link xlink:href="qregularexpression.xml">QRegularExpression</db:link></db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qvariant.xml">QVariant</db:link></db:emphasis>::Region</db:code></db:para>
</db:td>
<db:td><db:code>QMetaType::QRegion</db:code></db:td>
<db:td>
<db:para>a QRegion</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qvariant.xml">QVariant</db:link></db:emphasis>::Size</db:code></db:para>
</db:td>
<db:td><db:code>QMetaType::QSize</db:code></db:td>
<db:td>
<db:para>a <db:link xlink:href="qsize.xml">QSize</db:link></db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qvariant.xml">QVariant</db:link></db:emphasis>::SizeF</db:code></db:para>
</db:td>
<db:td><db:code>QMetaType::QSizeF</db:code></db:td>
<db:td>
<db:para>a <db:link xlink:href="qsizef.xml">QSizeF</db:link></db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qvariant.xml">QVariant</db:link></db:emphasis>::SizePolicy</db:code></db:para>
</db:td>
<db:td><db:code>QMetaType::QSizePolicy</db:code></db:td>
<db:td>
<db:para>a QSizePolicy</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qvariant.xml">QVariant</db:link></db:emphasis>::String</db:code></db:para>
</db:td>
<db:td><db:code>QMetaType::QString</db:code></db:td>
<db:td>
<db:para>a <db:link xlink:href="qstring.xml">QString</db:link></db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qvariant.xml">QVariant</db:link></db:emphasis>::StringList</db:code></db:para>
</db:td>
<db:td><db:code>QMetaType::QStringList</db:code></db:td>
<db:td>
<db:para>a <db:link xlink:href="qstringlist.xml">QStringList</db:link></db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qvariant.xml">QVariant</db:link></db:emphasis>::TextFormat</db:code></db:para>
</db:td>
<db:td><db:code>QMetaType::QTextFormat</db:code></db:td>
<db:td>
<db:para>a QTextFormat</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qvariant.xml">QVariant</db:link></db:emphasis>::TextLength</db:code></db:para>
</db:td>
<db:td><db:code>QMetaType::QTextLength</db:code></db:td>
<db:td>
<db:para>a QTextLength</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qvariant.xml">QVariant</db:link></db:emphasis>::Time</db:code></db:para>
</db:td>
<db:td><db:code>QMetaType::QTime</db:code></db:td>
<db:td>
<db:para>a <db:link xlink:href="qtime.xml">QTime</db:link></db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qvariant.xml">QVariant</db:link></db:emphasis>::UInt</db:code></db:para>
</db:td>
<db:td><db:code>QMetaType::UInt</db:code></db:td>
<db:td>
<db:para>a <db:link xlink:href="qttypes.xml#uint-typedef">uint</db:link></db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qvariant.xml">QVariant</db:link></db:emphasis>::ULongLong</db:code></db:para>
</db:td>
<db:td><db:code>QMetaType::ULongLong</db:code></db:td>
<db:td>
<db:para>a <db:link xlink:href="qttypes.xml#qulonglong-typedef">qulonglong</db:link></db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qvariant.xml">QVariant</db:link></db:emphasis>::Url</db:code></db:para>
</db:td>
<db:td><db:code>QMetaType::QUrl</db:code></db:td>
<db:td>
<db:para>a <db:link xlink:href="qurl.xml">QUrl</db:link></db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qvariant.xml">QVariant</db:link></db:emphasis>::Vector2D</db:code></db:para>
</db:td>
<db:td><db:code>QMetaType::QVector2D</db:code></db:td>
<db:td>
<db:para>a QVector2D</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qvariant.xml">QVariant</db:link></db:emphasis>::Vector3D</db:code></db:para>
</db:td>
<db:td><db:code>QMetaType::QVector3D</db:code></db:td>
<db:td>
<db:para>a QVector3D</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qvariant.xml">QVariant</db:link></db:emphasis>::Vector4D</db:code></db:para>
</db:td>
<db:td><db:code>QMetaType::QVector4D</db:code></db:td>
<db:td>
<db:para>a QVector4D</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qvariant.xml">QVariant</db:link></db:emphasis>::UserType</db:code></db:para>
</db:td>
<db:td><db:code>QMetaType::User</db:code></db:td>
<db:td>
<db:para>Base value for user-defined types.</db:para>
</db:td>
</db:tr>
</db:informaltable>
</db:section>
</db:section>
<db:section xml:id="obsolete-member-function-documentation">
<db:title>Obsolete Member Function Documentation</db:title>
<db:section xml:id="QVariant-15">
<db:title>[explicit, deprecated in 6.0] QVariant::QVariant(QVariant::Type <db:emphasis>type</db:emphasis>)</db:title>
<db:para>This function is deprecated since 6.0. We strongly advise against using it in new code.</db:para>
<db:para>Use the constructor taking a <db:link xlink:href="qmetatype.xml">QMetaType</db:link> instead.</db:para>
<db:para>Constructs an uninitialized variant of type <db:code role="parameter">type</db:code>. This will create a variant in a special null state that if accessed will return a default constructed value of the <db:code role="parameter">type</db:code>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qvariant.xml#isNull">isNull</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="canConvert-2">
<db:title>[deprecated in 6.0] bool QVariant::canConvert(int <db:emphasis>targetTypeId</db:emphasis>) const</db:title>
<db:para>This function is deprecated since 6.0. We strongly advise against using it in new code.</db:para>
<db:para>This is an overloaded function.</db:para>
<db:para>Use canConvert(QMetaType(targetTypeId)) instead.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qmetatype.xml#canConvert">QMetaType::canConvert</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="convert-1">
<db:title>[deprecated in 6.0] bool QVariant::convert(int <db:emphasis>targetTypeId</db:emphasis>)</db:title>
<db:para>This function is deprecated since 6.0. We strongly advise against using it in new code.</db:para>
<db:para>Use convert(QMetaType(targetTypeId)) instead.</db:para>
<db:para>Casts the variant to the requested type, <db:code role="parameter">targetTypeId</db:code>. If the cast cannot be done, the variant is still changed to the requested type, but is left in a cleared null state similar to that constructed by <db:link xlink:href="qvariant.xml">QVariant</db:link>(Type).</db:para>
<db:para>Returns true if the current type of the variant was successfully cast; otherwise returns false.</db:para>
<db:para>A <db:link xlink:href="qvariant.xml">QVariant</db:link> containing a pointer to a type derived from <db:link xlink:href="qobject.xml">QObject</db:link> will also convert and return true for this function if a <db:link xlink:href="qobject.xml#qobject_cast">qobject_cast</db:link> to the type described by <db:code role="parameter">targetTypeId</db:code> would succeed. Note that this only works for <db:link xlink:href="qobject.xml">QObject</db:link> subclasses which use the <db:link xlink:href="qobject.xml#Q_OBJECT">Q_OBJECT</db:link> macro.</db:para>
<db:note>
<db:para>converting QVariants that are null due to not being initialized or having failed a previous conversion will always fail, changing the type, remaining null, and returning false.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qvariant.xml#canConvert">canConvert</db:link>()</db:member>
<db:member><db:link xlink:href="qvariant.xml#clear">clear</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="nameToType">
<db:title>[static, deprecated in 6.0] QVariant::Type QVariant::nameToType(const char *<db:emphasis>name</db:emphasis>)</db:title>
<db:para>This function is deprecated since 6.0. We strongly advise against using it in new code.</db:para>
<db:para>Use QMetaType::fromName(name).id() instead</db:para>
<db:para>Converts the string representation of the storage type given in <db:code role="parameter">name</db:code>, to its enum representation.</db:para>
<db:para>If the string representation cannot be converted to any enum representation, the variant is set to Invalid.</db:para>
</db:section>
<db:section xml:id="type">
<db:title>[deprecated in 6.0] QVariant::Type QVariant::type() const</db:title>
<db:para>This function is deprecated since 6.0. We strongly advise against using it in new code.</db:para>
<db:para>Use <db:link xlink:href="qvariant.xml#typeId">typeId</db:link>() or <db:link xlink:href="qvariant.xml#metaType">metaType</db:link>() instead.</db:para>
<db:para>Returns the storage type of the value stored in the variant. Although this function is declared as returning <db:link xlink:href="qvariant.xml#Type-enum">QVariant::Type</db:link>, the return value should be interpreted as <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::Type</db:link>. In particular, <db:link xlink:href="qvariant.xml#Type-enum">QVariant::UserType</db:link> is returned here only if the value is equal or greater than <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::User</db:link>.</db:para>
<db:para>Note that return values in the ranges <db:link xlink:href="qvariant.xml#Type-enum">QVariant::Char</db:link> through QVariant::RegExp and <db:link xlink:href="qvariant.xml#Type-enum">QVariant::Font</db:link> through <db:link xlink:href="qvariant.xml#Type-enum">QVariant::Transform</db:link> correspond to the values in the ranges <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QChar</db:link> through <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QRegularExpression</db:link> and <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QFont</db:link> through <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QQuaternion</db:link>.</db:para>
<db:para>Pay particular attention when working with char and <db:link xlink:href="qchar.xml">QChar</db:link> variants. Note that there is no <db:link xlink:href="qvariant.xml">QVariant</db:link> constructor specifically for type char, but there is one for <db:link xlink:href="qchar.xml">QChar</db:link>. For a variant of type <db:link xlink:href="qchar.xml">QChar</db:link>, this function returns <db:link xlink:href="qvariant.xml#Type-enum">QVariant::Char</db:link>, which is the same as <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QChar</db:link>, but for a variant of type char, this function returns <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::Char</db:link>, which is <db:emphasis>not</db:emphasis> the same as <db:link xlink:href="qvariant.xml#Type-enum">QVariant::Char</db:link>.</db:para>
<db:para>Also note that the types void*, long, short, unsigned long, unsigned short, unsigned char, float, QObject*, and QWidget* are represented in <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::Type</db:link> but not in <db:link xlink:href="qvariant.xml#Type-enum">QVariant::Type</db:link>, and they can be returned by this function. However, they are considered to be user defined types when tested against <db:link xlink:href="qvariant.xml#Type-enum">QVariant::Type</db:link>.</db:para>
<db:para>To test whether an instance of <db:link xlink:href="qvariant.xml">QVariant</db:link> contains a data type that is compatible with the data type you are interested in, use <db:link xlink:href="qvariant.xml#canConvert">canConvert</db:link>().</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qvariant.xml#userType">userType</db:link>()</db:member>
<db:member><db:link xlink:href="qvariant.xml#metaType">metaType</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="typeToName">
<db:title>[static, deprecated in 6.0] const char *QVariant::typeToName(int <db:emphasis>typeId</db:emphasis>)</db:title>
<db:para>This function is deprecated since 6.0. We strongly advise against using it in new code.</db:para>
<db:para>Use QMetaType(typeId).name() instead.</db:para>
<db:para>Converts the int representation of the storage type, <db:code role="parameter">typeId</db:code>, to its string representation.</db:para>
<db:para>Returns nullptr if the type is <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::UnknownType</db:link> or doesn't exist.</db:para>
</db:section>
</db:section>
<db:section xml:id="obsolete-related-non-members">
<db:title>Obsolete Related Non-Members</db:title>
<db:section xml:id="operator-lt-lt-2">
<db:title>[deprecated in 6.0] QDataStream &amp;operator&lt;&lt;(QDataStream &amp;<db:emphasis>s</db:emphasis>, const QVariant::Type <db:emphasis>p</db:emphasis>)</db:title>
<db:para>This function is deprecated since 6.0. We strongly advise against using it in new code.</db:para>
<db:para>Stream <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::Type</db:link> instead.</db:para>
<db:para>Writes a variant type <db:code role="parameter">p</db:code> to the stream <db:code role="parameter">s</db:code>.</db:para>
</db:section>
<db:section xml:id="operator-gt-gt-1">
<db:title>[deprecated in 6.0] QDataStream &amp;operator&gt;&gt;(QDataStream &amp;<db:emphasis>s</db:emphasis>, QVariant::Type &amp;<db:emphasis>p</db:emphasis>)</db:title>
<db:para>This function is deprecated since 6.0. We strongly advise against using it in new code.</db:para>
<db:para>Stream <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::Type</db:link> instead.</db:para>
<db:para>Reads a variant type <db:code role="parameter">p</db:code> in enum representation from the stream <db:code role="parameter">s</db:code>.</db:para>
</db:section>
</db:section>
</db:section>
</db:article>
