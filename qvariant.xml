<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en">
<db:info>
<db:title>QVariant Class</db:title>
<db:productname>QtCore</db:productname>
<db:edition>Qt 6.7.2 Reference Documentation</db:edition>
<db:titleabbrev>Qt Core Reference Documentation</db:titleabbrev>
<db:abstract>
<db:para>The <db:link xlink:href="qvariant.xml">QVariant</db:link> class acts like a union for the most common Qt data types.</db:para>
</db:abstract>
<db:pubdate>2024-12-27</db:pubdate>
<db:date>2024-12-27</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:variablelist>
<db:varlistentry>
<db:term>Header</db:term>
<db:listitem>
<db:para>QVariant</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>CMake</db:term>
<db:listitem>
<db:para>find_package(Qt6 REQUIRED COMPONENTS Core)</db:para>
<db:para>target_link_libraries(mytarget PRIVATE Qt6::Core)</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>qmake</db:term>
<db:listitem>
<db:para>QT += core</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Group</db:term>
<db:listitem>
<db:para>QVariant is part of <db:simplelist><db:member>objectmodel</db:member><db:member><db:link xlink:href="shared.xml">Implicitly Shared Classes</db:link></db:member></db:simplelist></db:para>
</db:listitem>
</db:varlistentry>
</db:variablelist>
<db:section xml:id="details">
<db:title>Detailed Description</db:title>
<db:para>Because C++ forbids unions from including types that have non-default constructors or destructors, most interesting Qt classes cannot be used in unions. Without <db:link xlink:href="qvariant.xml">QVariant</db:link>, this would be a problem for <db:link xlink:href="qobject.xml#property">QObject::property</db:link>() and for database work, etc.</db:para>
<db:para>A <db:link xlink:href="qvariant.xml">QVariant</db:link> object holds a single value of a single <db:link xlink:href="qvariant.xml#typeId">typeId</db:link>() at a time. (Some types are multi-valued, for example a string list.) You can find out what type, T, the variant holds, convert it to a different type using <db:link xlink:href="qvariant.xml#convert">convert</db:link>(), get its value using one of the toT() functions (e.g., <db:link xlink:href="qvariant.xml#toSize">toSize</db:link>()), and check whether the type can be converted to a particular type using <db:link xlink:href="qvariant.xml#canConvert-2">canConvert</db:link>().</db:para>
<db:para>The methods named toT() (e.g., <db:link xlink:href="qvariant.xml#toInt">toInt</db:link>(), <db:link xlink:href="qvariant.xml#toString">toString</db:link>()) are const. If you ask for the stored type, they return a copy of the stored object. If you ask for a type that can be generated from the stored type, toT() copies and converts and leaves the object itself unchanged. If you ask for a type that cannot be generated from the stored type, the result depends on the type; see the function documentation for details.</db:para>
<db:para>Here is some example code to demonstrate the use of <db:link xlink:href="qvariant.xml">QVariant</db:link>:</db:para>
<db:programlisting language="cpp">QDataStream out(...);
QVariant v(123);                // The variant now contains an int
int x = v.toInt();              // x = 123
out &amp;lt;&amp;lt; v;                       // Writes a type tag and an int to out
v = QVariant(tr(&quot;hello&quot;));      // The variant now contains a QString
int y = v.toInt();              // y = 0 since v cannot be converted to an int
QString s = v.toString();       // s = tr(&quot;hello&quot;)  (see QObject::tr())
out &amp;lt;&amp;lt; v;                       // Writes a type tag and a QString to out
...
QDataStream in(...);            // (opening the previously written stream)
in &amp;gt;&amp;gt; v;                        // Reads an Int variant
int z = v.toInt();              // z = 123
qDebug(&quot;Type is %s&quot;,            // prints &quot;Type is int&quot;
        v.typeName());
v = v.toInt() + 100;            // The variant now holds the value 223
v = QVariant(QStringList());    // The variant now holds a QStringList
</db:programlisting>
<db:para>You can even store <db:link xlink:href="qlist.xml">QList</db:link>&lt;<db:link xlink:href="qvariant.xml">QVariant</db:link>&gt; and <db:link xlink:href="qmap.xml">QMap</db:link>&lt;<db:link xlink:href="qstring.xml">QString</db:link>, <db:link xlink:href="qvariant.xml">QVariant</db:link>&gt; values in a variant, so you can easily construct arbitrarily complex data structures of arbitrary types. This is very powerful and versatile, but may prove less memory and speed efficient than storing specific types in standard data structures.</db:para>
<db:para><db:link xlink:href="qvariant.xml">QVariant</db:link> also supports the notion of null values. A variant is null if the variant contains no initialized value, or contains a null pointer.</db:para>
<db:programlisting language="cpp">QVariant x;                                // x.isNull() == true
QVariant y = QVariant::fromValue(nullptr); // y.isNull() == true
</db:programlisting>
<db:para><db:link xlink:href="qvariant.xml">QVariant</db:link> can be extended to support other types than those mentioned in the <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::Type</db:link> enum. See <db:link xlink:href="custom-types.xml">Creating Custom Qt Types</db:link> for details.</db:para>
<db:section xml:id="a-note-on-gui-types">
<db:title>A Note on GUI Types</db:title>
<db:para>Because <db:link xlink:href="qvariant.xml">QVariant</db:link> is part of the Qt Core module, it cannot provide conversion functions to data types defined in Qt GUI, such as <db:link xlink:href="qcolor.xml">QColor</db:link>, <db:link xlink:href="qimage.xml">QImage</db:link>, and <db:link xlink:href="qpixmap.xml">QPixmap</db:link>. In other words, there is no toColor() function. Instead, you can use the <db:link xlink:href="qvariant.xml#value">QVariant::value</db:link>() or the <db:link xlink:href="qvariant.xml#qvariant_cast">qvariant_cast</db:link>() template function. For example:</db:para>
<db:programlisting language="cpp">QVariant variant;
...
QColor color = variant.value&amp;lt;QColor&amp;gt;();
</db:programlisting>
<db:para>The inverse conversion (e.g., from <db:link xlink:href="qcolor.xml">QColor</db:link> to <db:link xlink:href="qvariant.xml">QVariant</db:link>) is automatic for all data types supported by <db:link xlink:href="qvariant.xml">QVariant</db:link>, including GUI-related types:</db:para>
<db:programlisting language="cpp">QColor color = palette().background().color();
QVariant variant = color;
</db:programlisting>
</db:section>
<db:section xml:id="using-canconvert-and-convert-consecutively">
<db:title>Using canConvert() and convert() Consecutively</db:title>
<db:para>When using <db:link xlink:href="qvariant.xml#canConvert-2">canConvert</db:link>() and <db:link xlink:href="qvariant.xml#convert">convert</db:link>() consecutively, it is possible for <db:link xlink:href="qvariant.xml#canConvert-2">canConvert</db:link>() to return true, but <db:link xlink:href="qvariant.xml#convert">convert</db:link>() to return false. This is typically because <db:link xlink:href="qvariant.xml#canConvert-2">canConvert</db:link>() only reports the general ability of <db:link xlink:href="qvariant.xml">QVariant</db:link> to convert between types given suitable data; it is still possible to supply data which cannot actually be converted.</db:para>
<db:para>For example, canConvert(QMetaType::fromType&lt;int&gt;()) would return true when called on a variant containing a string because, in principle, <db:link xlink:href="qvariant.xml">QVariant</db:link> is able to convert strings of numbers to integers. However, if the string contains non-numeric characters, it cannot be converted to an integer, and any attempt to convert it will fail. Hence, it is important to have both functions return true for a successful conversion.</db:para>
</db:section>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="member-function-documentation">
<db:title>Member Function Documentation</db:title>
<db:section xml:id="typeId">
<db:title>int QVariant::typeId() const</db:title>
<db:bridgehead renderas="sect2" xml:id="userType">int QVariant::userType() const</db:bridgehead>
<db:para>Returns the storage type of the value stored in the variant. This is the same as <db:link xlink:href="qvariant.xml#metaType">metaType</db:link>().id().</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qvariant.xml#metaType">metaType</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="constData">
<db:title>const void *QVariant::constData() const</db:title>
<db:bridgehead renderas="sect2" xml:id="data-1">const void *QVariant::data() const</db:bridgehead>
<db:para>Returns a pointer to the contained object as a generic void* that cannot be written to.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qvariant.xml#get_if">get_if</db:link>()</db:member>
<db:member><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="QVariant">
<db:title>QVariant::QVariant()</db:title>
<db:constructorsynopsis>
<db:methodname>QVariant</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">constructor</db:synopsisinfo>
<db:synopsisinfo role="signature">QVariant()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:constructorsynopsis>
<db:para>Constructs an invalid variant.</db:para>
</db:section>
<db:section xml:id="QVariant-1">
<db:title>[explicit] QVariant::QVariant(QMetaType <db:emphasis>type</db:emphasis>, const void *<db:emphasis>copy</db:emphasis> = nullptr)</db:title>
<db:constructorsynopsis>
<db:methodname>QVariant</db:methodname>
<db:methodparam>
<db:type>QMetaType</db:type>
<db:parameter>type</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const void *</db:type>
<db:parameter>copy</db:parameter>
<db:initializer>nullptr</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">constructor</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">QVariant(QMetaType type, const void *copy)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:constructorsynopsis>
<db:para>Constructs a variant of type <db:code role="parameter">type</db:code>, and initializes it with a copy of *copy if <db:code role="parameter">copy</db:code> is not nullptr (in which case, <db:code role="parameter">copy</db:code> must point to an object of type <db:code role="parameter">type</db:code>).</db:para>
<db:para>Note that you have to pass the address of the object you want stored.</db:para>
<db:para>Usually, you never have to use this constructor, use <db:link xlink:href="qvariant.xml#fromValue">QVariant::fromValue</db:link>() instead to construct variants from the pointer types represented by QMetaType::VoidStar, and QMetaType::QObjectStar.</db:para>
<db:para>If <db:code role="parameter">type</db:code> does not support copy construction and <db:code role="parameter">copy</db:code> is not nullptr, the variant will be invalid. Similarly, if <db:code role="parameter">copy</db:code> is nullptr and <db:code role="parameter">type</db:code> does not support default construction, the variant will be invalid.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qvariant.xml#fromMetaType">QVariant::fromMetaType</db:link></db:member>
<db:member><db:link xlink:href="qvariant.xml#fromValue">QVariant::fromValue</db:link>()</db:member>
<db:member><db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::Type</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="QVariant-36">
<db:title>QVariant::QVariant(QLineF <db:emphasis>val</db:emphasis>)</db:title>
<db:constructorsynopsis>
<db:methodname>QVariant</db:methodname>
<db:methodparam>
<db:type>QLineF</db:type>
<db:parameter>val</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">constructor</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">36</db:synopsisinfo>
<db:synopsisinfo role="signature">QVariant(QLineF val)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:constructorsynopsis>
<db:para>Constructs a new variant with a line value of <db:code role="parameter">val</db:code>.</db:para>
</db:section>
<db:section xml:id="QVariant-37">
<db:title>QVariant::QVariant(QRect <db:emphasis>val</db:emphasis>)</db:title>
<db:constructorsynopsis>
<db:methodname>QVariant</db:methodname>
<db:methodparam>
<db:type>QRect</db:type>
<db:parameter>val</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">constructor</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">37</db:synopsisinfo>
<db:synopsisinfo role="signature">QVariant(QRect val)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:constructorsynopsis>
<db:para>Constructs a new variant with a rect value of <db:code role="parameter">val</db:code>.</db:para>
</db:section>
<db:section xml:id="QVariant-38">
<db:title>QVariant::QVariant(QRectF <db:emphasis>val</db:emphasis>)</db:title>
<db:constructorsynopsis>
<db:methodname>QVariant</db:methodname>
<db:methodparam>
<db:type>QRectF</db:type>
<db:parameter>val</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">constructor</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">38</db:synopsisinfo>
<db:synopsisinfo role="signature">QVariant(QRectF val)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:constructorsynopsis>
<db:para>Constructs a new variant with a rect value of <db:code role="parameter">val</db:code>.</db:para>
</db:section>
<db:section xml:id="QVariant-39">
<db:title>QVariant::QVariant(const QEasingCurve &amp;<db:emphasis>val</db:emphasis>)</db:title>
<db:constructorsynopsis>
<db:methodname>QVariant</db:methodname>
<db:methodparam>
<db:type>const QEasingCurve &amp;</db:type>
<db:parameter>val</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">constructor</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">39</db:synopsisinfo>
<db:synopsisinfo role="signature">QVariant(const QEasingCurve &amp;val)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:constructorsynopsis>
<db:para>Constructs a new variant with an easing curve value, <db:code role="parameter">val</db:code>.</db:para>
</db:section>
<db:section xml:id="QVariant-40">
<db:title>QVariant::QVariant(const QJsonDocument &amp;<db:emphasis>val</db:emphasis>)</db:title>
<db:constructorsynopsis>
<db:methodname>QVariant</db:methodname>
<db:methodparam>
<db:type>const QJsonDocument &amp;</db:type>
<db:parameter>val</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">constructor</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">40</db:synopsisinfo>
<db:synopsisinfo role="signature">QVariant(const QJsonDocument &amp;val)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:constructorsynopsis>
<db:para>Constructs a new variant with a json document value, <db:code role="parameter">val</db:code>.</db:para>
</db:section>
<db:section xml:id="QVariant-41">
<db:title>QVariant::QVariant(const QPersistentModelIndex &amp;<db:emphasis>val</db:emphasis>)</db:title>
<db:constructorsynopsis>
<db:methodname>QVariant</db:methodname>
<db:methodparam>
<db:type>const QPersistentModelIndex &amp;</db:type>
<db:parameter>val</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">constructor</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">41</db:synopsisinfo>
<db:synopsisinfo role="signature">QVariant(const QPersistentModelIndex &amp;val)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:constructorsynopsis>
<db:para>Constructs a new variant with a <db:link xlink:href="qpersistentmodelindex.xml">QPersistentModelIndex</db:link> value, <db:code role="parameter">val</db:code>.</db:para>
</db:section>
<db:section xml:id="QVariant-42">
<db:title>QVariant::QVariant(const char *<db:emphasis>val</db:emphasis>)</db:title>
<db:constructorsynopsis>
<db:methodname>QVariant</db:methodname>
<db:methodparam>
<db:type>const char *</db:type>
<db:parameter>val</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">constructor</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">42</db:synopsisinfo>
<db:synopsisinfo role="signature">QVariant(const char *val)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:constructorsynopsis>
<db:para>Constructs a new variant with a string value of <db:code role="parameter">val</db:code>. The variant creates a deep copy of <db:code role="parameter">val</db:code> into a <db:link xlink:href="qstring.xml">QString</db:link> assuming UTF-8 encoding on the input <db:code role="parameter">val</db:code>.</db:para>
<db:para>Note that <db:code role="parameter">val</db:code> is converted to a <db:link xlink:href="qstring.xml">QString</db:link> for storing in the variant and <db:link xlink:href="qvariant.xml#userType">QVariant::userType</db:link>() will return <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QString</db:link> for the variant.</db:para>
<db:para>You can disable this operator by defining QT_NO_CAST_FROM_ASCII when you compile your applications.</db:para>
</db:section>
<db:section xml:id="QVariant-43">
<db:title>QVariant::QVariant(QLatin1StringView <db:emphasis>val</db:emphasis>)</db:title>
<db:constructorsynopsis>
<db:methodname>QVariant</db:methodname>
<db:methodparam>
<db:type>QLatin1StringView</db:type>
<db:parameter>val</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">constructor</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">43</db:synopsisinfo>
<db:synopsisinfo role="signature">QVariant(QLatin1StringView val)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:constructorsynopsis>
<db:para>Constructs a new variant with a <db:link xlink:href="qstring.xml">QString</db:link> value from the Latin-1 string viewed by <db:code role="parameter">val</db:code>.</db:para>
</db:section>
<db:section xml:id="QVariant-3">
<db:title>[explicit, since 6.6] QVariant::QVariant(<db:emphasis>std::in_place_type_t&lt;T&gt;</db:emphasis>, Args &amp;&amp;... <db:emphasis>args</db:emphasis>)</db:title>
<db:constructorsynopsis>
<db:methodname>QVariant</db:methodname>
<db:methodparam>
<db:type>std::in_place_type_t&lt;T&gt;</db:type>
<db:parameter></db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>Args &amp;&amp;...</db:type>
<db:parameter>args</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">constructor</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">3</db:synopsisinfo>
<db:synopsisinfo role="signature">QVariant(std::in_place_type_t&lt;T&gt;, Args &amp;&amp;... args)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:constructorsynopsis>
<db:para>Constructs a new variant containing a value of type T. The contained value is is initialized with the arguments std::forward&lt;Args&gt;(args)....</db:para>
<db:para>This overload only participates in overload resolution if T can be constructed from <db:code role="parameter">args</db:code>.</db:para>
<db:para>This constructor is provided for STL/std::any compatibility.</db:para>
<db:para>This is an overloaded function.</db:para>
<db:para>This function was introduced in Qt 6.6.</db:para>
</db:section>
<db:section xml:id="QVariant-4">
<db:title>[explicit, since 6.6] QVariant::QVariant(<db:emphasis>std::in_place_type_t&lt;T&gt;</db:emphasis>, std::initializer_list&lt;U&gt; <db:emphasis>il</db:emphasis>, Args &amp;&amp;... <db:emphasis>args</db:emphasis>)</db:title>
<db:constructorsynopsis>
<db:methodname>QVariant</db:methodname>
<db:methodparam>
<db:type>std::in_place_type_t&lt;T&gt;</db:type>
<db:parameter></db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>std::initializer_list&lt;U&gt;</db:type>
<db:parameter>il</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>Args &amp;&amp;...</db:type>
<db:parameter>args</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">constructor</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">4</db:synopsisinfo>
<db:synopsisinfo role="signature">QVariant(std::in_place_type_t&lt;T&gt;, std::initializer_list&lt;U&gt; il, Args &amp;&amp;... args)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:constructorsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>This overload exists to support types with constructors taking an initializer_list. It behaves otherwise equivalent to the non-initializer list in_place_type_t overload.</db:para>
<db:para>This function was introduced in Qt 6.6.</db:para>
</db:section>
<db:section xml:id="QVariant-5">
<db:title>QVariant::QVariant(int <db:emphasis>val</db:emphasis>)</db:title>
<db:constructorsynopsis>
<db:methodname>QVariant</db:methodname>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>val</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">constructor</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">5</db:synopsisinfo>
<db:synopsisinfo role="signature">QVariant(int val)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:constructorsynopsis>
<db:para>Constructs a new variant with an integer value, <db:code role="parameter">val</db:code>.</db:para>
</db:section>
<db:section xml:id="QVariant-6">
<db:title>QVariant::QVariant(uint <db:emphasis>val</db:emphasis>)</db:title>
<db:constructorsynopsis>
<db:methodname>QVariant</db:methodname>
<db:methodparam>
<db:type>uint</db:type>
<db:parameter>val</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">constructor</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">6</db:synopsisinfo>
<db:synopsisinfo role="signature">QVariant(uint val)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:constructorsynopsis>
<db:para>Constructs a new variant with an unsigned integer value, <db:code role="parameter">val</db:code>.</db:para>
</db:section>
<db:section xml:id="QVariant-7">
<db:title>QVariant::QVariant(qlonglong <db:emphasis>val</db:emphasis>)</db:title>
<db:constructorsynopsis>
<db:methodname>QVariant</db:methodname>
<db:methodparam>
<db:type>qlonglong</db:type>
<db:parameter>val</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">constructor</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">7</db:synopsisinfo>
<db:synopsisinfo role="signature">QVariant(qlonglong val)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:constructorsynopsis>
<db:para>Constructs a new variant with a long long integer value, <db:code role="parameter">val</db:code>.</db:para>
</db:section>
<db:section xml:id="QVariant-8">
<db:title>QVariant::QVariant(qulonglong <db:emphasis>val</db:emphasis>)</db:title>
<db:constructorsynopsis>
<db:methodname>QVariant</db:methodname>
<db:methodparam>
<db:type>qulonglong</db:type>
<db:parameter>val</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">constructor</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">8</db:synopsisinfo>
<db:synopsisinfo role="signature">QVariant(qulonglong val)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:constructorsynopsis>
<db:para>Constructs a new variant with an unsigned long long integer value, <db:code role="parameter">val</db:code>.</db:para>
</db:section>
<db:section xml:id="QVariant-9">
<db:title>QVariant::QVariant(bool <db:emphasis>val</db:emphasis>)</db:title>
<db:constructorsynopsis>
<db:methodname>QVariant</db:methodname>
<db:methodparam>
<db:type>bool</db:type>
<db:parameter>val</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">constructor</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">9</db:synopsisinfo>
<db:synopsisinfo role="signature">QVariant(bool val)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:constructorsynopsis>
<db:para>Constructs a new variant with a boolean value, <db:code role="parameter">val</db:code>.</db:para>
</db:section>
<db:section xml:id="QVariant-10">
<db:title>QVariant::QVariant(double <db:emphasis>val</db:emphasis>)</db:title>
<db:constructorsynopsis>
<db:methodname>QVariant</db:methodname>
<db:methodparam>
<db:type>double</db:type>
<db:parameter>val</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">constructor</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">10</db:synopsisinfo>
<db:synopsisinfo role="signature">QVariant(double val)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:constructorsynopsis>
<db:para>Constructs a new variant with a floating point value, <db:code role="parameter">val</db:code>.</db:para>
</db:section>
<db:section xml:id="QVariant-11">
<db:title>QVariant::QVariant(float <db:emphasis>val</db:emphasis>)</db:title>
<db:constructorsynopsis>
<db:methodname>QVariant</db:methodname>
<db:methodparam>
<db:type>float</db:type>
<db:parameter>val</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">constructor</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">11</db:synopsisinfo>
<db:synopsisinfo role="signature">QVariant(float val)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:constructorsynopsis>
<db:para>Constructs a new variant with a floating point value, <db:code role="parameter">val</db:code>.</db:para>
</db:section>
<db:section xml:id="QVariant-12">
<db:title>QVariant::QVariant(QChar <db:emphasis>c</db:emphasis>)</db:title>
<db:constructorsynopsis>
<db:methodname>QVariant</db:methodname>
<db:methodparam>
<db:type>QChar</db:type>
<db:parameter>c</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">constructor</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">12</db:synopsisinfo>
<db:synopsisinfo role="signature">QVariant(QChar c)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:constructorsynopsis>
<db:para>Constructs a new variant with a char value, <db:code role="parameter">c</db:code>.</db:para>
</db:section>
<db:section xml:id="QVariant-13">
<db:title>QVariant::QVariant(QDate <db:emphasis>val</db:emphasis>)</db:title>
<db:constructorsynopsis>
<db:methodname>QVariant</db:methodname>
<db:methodparam>
<db:type>QDate</db:type>
<db:parameter>val</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">constructor</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">13</db:synopsisinfo>
<db:synopsisinfo role="signature">QVariant(QDate val)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:constructorsynopsis>
<db:para>Constructs a new variant with a date value, <db:code role="parameter">val</db:code>.</db:para>
</db:section>
<db:section xml:id="QVariant-14">
<db:title>QVariant::QVariant(QTime <db:emphasis>val</db:emphasis>)</db:title>
<db:constructorsynopsis>
<db:methodname>QVariant</db:methodname>
<db:methodparam>
<db:type>QTime</db:type>
<db:parameter>val</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">constructor</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">14</db:synopsisinfo>
<db:synopsisinfo role="signature">QVariant(QTime val)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:constructorsynopsis>
<db:para>Constructs a new variant with a time value, <db:code role="parameter">val</db:code>.</db:para>
</db:section>
<db:section xml:id="QVariant-15">
<db:title>QVariant::QVariant(const QBitArray &amp;<db:emphasis>val</db:emphasis>)</db:title>
<db:constructorsynopsis>
<db:methodname>QVariant</db:methodname>
<db:methodparam>
<db:type>const QBitArray &amp;</db:type>
<db:parameter>val</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">constructor</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">15</db:synopsisinfo>
<db:synopsisinfo role="signature">QVariant(const QBitArray &amp;val)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:constructorsynopsis>
<db:para>Constructs a new variant with a bitarray value, <db:code role="parameter">val</db:code>.</db:para>
</db:section>
<db:section xml:id="QVariant-16">
<db:title>QVariant::QVariant(const QByteArray &amp;<db:emphasis>val</db:emphasis>)</db:title>
<db:constructorsynopsis>
<db:methodname>QVariant</db:methodname>
<db:methodparam>
<db:type>const QByteArray &amp;</db:type>
<db:parameter>val</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">constructor</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">16</db:synopsisinfo>
<db:synopsisinfo role="signature">QVariant(const QByteArray &amp;val)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:constructorsynopsis>
<db:para>Constructs a new variant with a bytearray value, <db:code role="parameter">val</db:code>.</db:para>
</db:section>
<db:section xml:id="QVariant-17">
<db:title>QVariant::QVariant(const QDateTime &amp;<db:emphasis>val</db:emphasis>)</db:title>
<db:constructorsynopsis>
<db:methodname>QVariant</db:methodname>
<db:methodparam>
<db:type>const QDateTime &amp;</db:type>
<db:parameter>val</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">constructor</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">17</db:synopsisinfo>
<db:synopsisinfo role="signature">QVariant(const QDateTime &amp;val)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:constructorsynopsis>
<db:para>Constructs a new variant with a date/time value, <db:code role="parameter">val</db:code>.</db:para>
</db:section>
<db:section xml:id="QVariant-18">
<db:title>QVariant::QVariant(const QHash&lt;QString, QVariant&gt; &amp;<db:emphasis>val</db:emphasis>)</db:title>
<db:constructorsynopsis>
<db:methodname>QVariant</db:methodname>
<db:methodparam>
<db:type>const QHash&lt;QString, QVariant&gt; &amp;</db:type>
<db:parameter>val</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">constructor</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">18</db:synopsisinfo>
<db:synopsisinfo role="signature">QVariant(const QHash&lt;QString, QVariant&gt; &amp;val)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:constructorsynopsis>
<db:para>Constructs a new variant with a hash of <db:link xlink:href="qvariant.xml">QVariant</db:link>s, <db:code role="parameter">val</db:code>.</db:para>
</db:section>
<db:section xml:id="QVariant-19">
<db:title>QVariant::QVariant(const QJsonArray &amp;<db:emphasis>val</db:emphasis>)</db:title>
<db:constructorsynopsis>
<db:methodname>QVariant</db:methodname>
<db:methodparam>
<db:type>const QJsonArray &amp;</db:type>
<db:parameter>val</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">constructor</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">19</db:synopsisinfo>
<db:synopsisinfo role="signature">QVariant(const QJsonArray &amp;val)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:constructorsynopsis>
<db:para>Constructs a new variant with a json array value, <db:code role="parameter">val</db:code>.</db:para>
</db:section>
<db:section xml:id="QVariant-20">
<db:title>QVariant::QVariant(const QJsonObject &amp;<db:emphasis>val</db:emphasis>)</db:title>
<db:constructorsynopsis>
<db:methodname>QVariant</db:methodname>
<db:methodparam>
<db:type>const QJsonObject &amp;</db:type>
<db:parameter>val</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">constructor</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">20</db:synopsisinfo>
<db:synopsisinfo role="signature">QVariant(const QJsonObject &amp;val)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:constructorsynopsis>
<db:para>Constructs a new variant with a json object value, <db:code role="parameter">val</db:code>.</db:para>
</db:section>
<db:section xml:id="QVariant-21">
<db:title>QVariant::QVariant(const QList&lt;QVariant&gt; &amp;<db:emphasis>val</db:emphasis>)</db:title>
<db:constructorsynopsis>
<db:methodname>QVariant</db:methodname>
<db:methodparam>
<db:type>const QList&lt;QVariant&gt; &amp;</db:type>
<db:parameter>val</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">constructor</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">21</db:synopsisinfo>
<db:synopsisinfo role="signature">QVariant(const QList&lt;QVariant&gt; &amp;val)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:constructorsynopsis>
<db:para>Constructs a new variant with a list value, <db:code role="parameter">val</db:code>.</db:para>
</db:section>
<db:section xml:id="QVariant-22">
<db:title>QVariant::QVariant(const QLocale &amp;<db:emphasis>l</db:emphasis>)</db:title>
<db:constructorsynopsis>
<db:methodname>QVariant</db:methodname>
<db:methodparam>
<db:type>const QLocale &amp;</db:type>
<db:parameter>l</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">constructor</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">22</db:synopsisinfo>
<db:synopsisinfo role="signature">QVariant(const QLocale &amp;l)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:constructorsynopsis>
<db:para>Constructs a new variant with a locale value, <db:code role="parameter">l</db:code>.</db:para>
</db:section>
<db:section xml:id="QVariant-23">
<db:title>QVariant::QVariant(const QMap&lt;QString, QVariant&gt; &amp;<db:emphasis>val</db:emphasis>)</db:title>
<db:constructorsynopsis>
<db:methodname>QVariant</db:methodname>
<db:methodparam>
<db:type>const QMap&lt;QString, QVariant&gt; &amp;</db:type>
<db:parameter>val</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">constructor</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">23</db:synopsisinfo>
<db:synopsisinfo role="signature">QVariant(const QMap&lt;QString, QVariant&gt; &amp;val)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:constructorsynopsis>
<db:para>Constructs a new variant with a map of <db:link xlink:href="qvariant.xml">QVariant</db:link>s, <db:code role="parameter">val</db:code>.</db:para>
</db:section>
<db:section xml:id="QVariant-24">
<db:title>QVariant::QVariant(const QRegularExpression &amp;<db:emphasis>re</db:emphasis>)</db:title>
<db:constructorsynopsis>
<db:methodname>QVariant</db:methodname>
<db:methodparam>
<db:type>const QRegularExpression &amp;</db:type>
<db:parameter>re</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">constructor</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">24</db:synopsisinfo>
<db:synopsisinfo role="signature">QVariant(const QRegularExpression &amp;re)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:constructorsynopsis>
<db:para>Constructs a new variant with the regular expression value <db:code role="parameter">re</db:code>.</db:para>
</db:section>
<db:section xml:id="QVariant-25">
<db:title>QVariant::QVariant(const QString &amp;<db:emphasis>val</db:emphasis>)</db:title>
<db:constructorsynopsis>
<db:methodname>QVariant</db:methodname>
<db:methodparam>
<db:type>const QString &amp;</db:type>
<db:parameter>val</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">constructor</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">25</db:synopsisinfo>
<db:synopsisinfo role="signature">QVariant(const QString &amp;val)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:constructorsynopsis>
<db:para>Constructs a new variant with a string value, <db:code role="parameter">val</db:code>.</db:para>
</db:section>
<db:section xml:id="QVariant-26">
<db:title>QVariant::QVariant(const QStringList &amp;<db:emphasis>val</db:emphasis>)</db:title>
<db:constructorsynopsis>
<db:methodname>QVariant</db:methodname>
<db:methodparam>
<db:type>const QStringList &amp;</db:type>
<db:parameter>val</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">constructor</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">26</db:synopsisinfo>
<db:synopsisinfo role="signature">QVariant(const QStringList &amp;val)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:constructorsynopsis>
<db:para>Constructs a new variant with a string list value, <db:code role="parameter">val</db:code>.</db:para>
</db:section>
<db:section xml:id="QVariant-27">
<db:title>QVariant::QVariant(const QUrl &amp;<db:emphasis>val</db:emphasis>)</db:title>
<db:constructorsynopsis>
<db:methodname>QVariant</db:methodname>
<db:methodparam>
<db:type>const QUrl &amp;</db:type>
<db:parameter>val</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">constructor</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">27</db:synopsisinfo>
<db:synopsisinfo role="signature">QVariant(const QUrl &amp;val)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:constructorsynopsis>
<db:para>Constructs a new variant with a url value of <db:code role="parameter">val</db:code>.</db:para>
</db:section>
<db:section xml:id="QVariant-28">
<db:title>QVariant::QVariant(const QJsonValue &amp;<db:emphasis>val</db:emphasis>)</db:title>
<db:constructorsynopsis>
<db:methodname>QVariant</db:methodname>
<db:methodparam>
<db:type>const QJsonValue &amp;</db:type>
<db:parameter>val</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">constructor</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">28</db:synopsisinfo>
<db:synopsisinfo role="signature">QVariant(const QJsonValue &amp;val)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:constructorsynopsis>
<db:para>Constructs a new variant with a json value, <db:code role="parameter">val</db:code>.</db:para>
</db:section>
<db:section xml:id="QVariant-29">
<db:title>QVariant::QVariant(const QModelIndex &amp;<db:emphasis>val</db:emphasis>)</db:title>
<db:constructorsynopsis>
<db:methodname>QVariant</db:methodname>
<db:methodparam>
<db:type>const QModelIndex &amp;</db:type>
<db:parameter>val</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">constructor</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">29</db:synopsisinfo>
<db:synopsisinfo role="signature">QVariant(const QModelIndex &amp;val)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:constructorsynopsis>
<db:para>Constructs a new variant with a <db:link xlink:href="qmodelindex.xml">QModelIndex</db:link> value, <db:code role="parameter">val</db:code>.</db:para>
</db:section>
<db:section xml:id="QVariant-30">
<db:title>QVariant::QVariant(QUuid <db:emphasis>val</db:emphasis>)</db:title>
<db:constructorsynopsis>
<db:methodname>QVariant</db:methodname>
<db:methodparam>
<db:type>QUuid</db:type>
<db:parameter>val</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">constructor</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">30</db:synopsisinfo>
<db:synopsisinfo role="signature">QVariant(QUuid val)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:constructorsynopsis>
<db:para>Constructs a new variant with an uuid value, <db:code role="parameter">val</db:code>.</db:para>
</db:section>
<db:section xml:id="QVariant-31">
<db:title>QVariant::QVariant(QSize <db:emphasis>val</db:emphasis>)</db:title>
<db:constructorsynopsis>
<db:methodname>QVariant</db:methodname>
<db:methodparam>
<db:type>QSize</db:type>
<db:parameter>val</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">constructor</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">31</db:synopsisinfo>
<db:synopsisinfo role="signature">QVariant(QSize val)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:constructorsynopsis>
<db:para>Constructs a new variant with a size value of <db:code role="parameter">val</db:code>.</db:para>
</db:section>
<db:section xml:id="QVariant-32">
<db:title>QVariant::QVariant(QSizeF <db:emphasis>val</db:emphasis>)</db:title>
<db:constructorsynopsis>
<db:methodname>QVariant</db:methodname>
<db:methodparam>
<db:type>QSizeF</db:type>
<db:parameter>val</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">constructor</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">32</db:synopsisinfo>
<db:synopsisinfo role="signature">QVariant(QSizeF val)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:constructorsynopsis>
<db:para>Constructs a new variant with a size value of <db:code role="parameter">val</db:code>.</db:para>
</db:section>
<db:section xml:id="QVariant-33">
<db:title>QVariant::QVariant(QPoint <db:emphasis>val</db:emphasis>)</db:title>
<db:constructorsynopsis>
<db:methodname>QVariant</db:methodname>
<db:methodparam>
<db:type>QPoint</db:type>
<db:parameter>val</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">constructor</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">33</db:synopsisinfo>
<db:synopsisinfo role="signature">QVariant(QPoint val)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:constructorsynopsis>
<db:para>Constructs a new variant with a point value of <db:code role="parameter">val</db:code>.</db:para>
</db:section>
<db:section xml:id="QVariant-34">
<db:title>QVariant::QVariant(QPointF <db:emphasis>val</db:emphasis>)</db:title>
<db:constructorsynopsis>
<db:methodname>QVariant</db:methodname>
<db:methodparam>
<db:type>QPointF</db:type>
<db:parameter>val</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">constructor</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">34</db:synopsisinfo>
<db:synopsisinfo role="signature">QVariant(QPointF val)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:constructorsynopsis>
<db:para>Constructs a new variant with a point value of <db:code role="parameter">val</db:code>.</db:para>
</db:section>
<db:section xml:id="QVariant-35">
<db:title>QVariant::QVariant(QLine <db:emphasis>val</db:emphasis>)</db:title>
<db:constructorsynopsis>
<db:methodname>QVariant</db:methodname>
<db:methodparam>
<db:type>QLine</db:type>
<db:parameter>val</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">constructor</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">35</db:synopsisinfo>
<db:synopsisinfo role="signature">QVariant(QLine val)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:constructorsynopsis>
<db:para>Constructs a new variant with a line value of <db:code role="parameter">val</db:code>.</db:para>
</db:section>
<db:section xml:id="QVariant-2">
<db:title>QVariant::QVariant(const QVariant &amp;<db:emphasis>p</db:emphasis>)</db:title>
<db:constructorsynopsis>
<db:methodname>QVariant</db:methodname>
<db:methodparam>
<db:type>const QVariant &amp;</db:type>
<db:parameter>p</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">copy-constructor</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">2</db:synopsisinfo>
<db:synopsisinfo role="signature">QVariant(const QVariant &amp;p)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:constructorsynopsis>
<db:para>Constructs a copy of the variant, <db:code role="parameter">p</db:code>, passed as the argument to this constructor.</db:para>
</db:section>
<db:section xml:id="QVariant-45">
<db:title>QVariant::QVariant(QVariant &amp;&amp;<db:emphasis>other</db:emphasis>)</db:title>
<db:constructorsynopsis>
<db:methodname>QVariant</db:methodname>
<db:methodparam>
<db:type>QVariant &amp;&amp;</db:type>
<db:parameter>other</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">move-constructor</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">45</db:synopsisinfo>
<db:synopsisinfo role="signature">QVariant(QVariant &amp;&amp;other)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:constructorsynopsis>
<db:para>Move-constructs a <db:link xlink:href="qvariant.xml">QVariant</db:link> instance, making it point at the same object that <db:code role="parameter">other</db:code> was pointing to.</db:para>
</db:section>
<db:section xml:id="dtor.QVariant">
<db:title>QVariant::~QVariant()</db:title>
<db:destructorsynopsis>
<db:methodname>~QVariant</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">destructor</db:synopsisinfo>
<db:synopsisinfo role="signature">~QVariant()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:destructorsynopsis>
<db:para>Destroys the <db:link xlink:href="qvariant.xml">QVariant</db:link> and the contained object.</db:para>
</db:section>
<db:section xml:id="canConvert">
<db:title>[since 6.0] bool QVariant::canConvert(QMetaType <db:emphasis>type</db:emphasis>) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>bool</db:type>
<db:methodname>canConvert</db:methodname>
<db:methodparam>
<db:type>QMetaType</db:type>
<db:parameter>type</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool canConvert(QMetaType type) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns true if the variant's type can be cast to the requested type, <db:code role="parameter">type</db:code>. Such casting is done automatically when calling the <db:link xlink:href="qvariant.xml#toInt">toInt</db:link>(), <db:link xlink:href="qvariant.xml#toBool">toBool</db:link>(), ... methods.</db:para>
<db:para>This function was introduced in Qt 6.0.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qmetatype.xml#canConvert">QMetaType::canConvert</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="canConvert-2">
<db:title>bool QVariant::canConvert() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>bool</db:type>
<db:methodname>canConvert</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">2</db:synopsisinfo>
<db:synopsisinfo role="signature">bool canConvert() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns true if the variant can be converted to the template type T, otherwise false.</db:para>
<db:para>Example:</db:para>
<db:programlisting language="cpp">QVariant v = 42;

v.canConvert&amp;lt;int&amp;gt;();              // returns true
v.canConvert&amp;lt;QString&amp;gt;();          // returns true

MyCustomStruct s;
v.setValue(s);

v.canConvert&amp;lt;int&amp;gt;();              // returns false
v.canConvert&amp;lt;MyCustomStruct&amp;gt;();   // returns true
</db:programlisting>
<db:para>A <db:link xlink:href="qvariant.xml">QVariant</db:link> containing a pointer to a type derived from <db:link xlink:href="qobject.xml">QObject</db:link> will also return true for this function if a <db:link xlink:href="qobject.xml#qobject_cast-1">qobject_cast</db:link> to the template type T would succeed. Note that this only works for <db:link xlink:href="qobject.xml">QObject</db:link> subclasses which use the <db:link xlink:href="qobject.xml#Q_OBJECT">Q_OBJECT</db:link> macro.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qvariant.xml#convert">convert</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="canView-1">
<db:title>bool QVariant::canView() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>bool</db:type>
<db:methodname>canView</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">bool canView() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns true if a mutable view of the template type T can be created on this variant, otherwise false.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qvariant.xml#value">value</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="clear">
<db:title>void QVariant::clear()</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>clear</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void clear()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Convert this variant to type <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::UnknownType</db:link> and free up any resources used.</db:para>
</db:section>
<db:section xml:id="compare">
<db:title>[static, since 6.0] QPartialOrdering QVariant::compare(const QVariant &amp;<db:emphasis>lhs</db:emphasis>, const QVariant &amp;<db:emphasis>rhs</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:modifier>static</db:modifier>
<db:type>QPartialOrdering</db:type>
<db:methodname>compare</db:methodname>
<db:methodparam>
<db:type>const QVariant &amp;</db:type>
<db:parameter>lhs</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const QVariant &amp;</db:type>
<db:parameter>rhs</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QPartialOrdering compare(const QVariant &amp;lhs, const QVariant &amp;rhs)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Compares the objects at <db:code role="parameter">lhs</db:code> and <db:code role="parameter">rhs</db:code> for ordering.</db:para>
<db:para>Returns <db:link xlink:href="qpartialordering.xml#Unordered-var">QPartialOrdering::Unordered</db:link> if comparison is not supported or the values are unordered. Otherwise, returns <db:link xlink:href="qpartialordering.xml#Less-var">QPartialOrdering::Less</db:link>, <db:link xlink:href="qpartialordering.xml#Equivalent-var">QPartialOrdering::Equivalent</db:link> or <db:link xlink:href="qpartialordering.xml#Greater-var">QPartialOrdering::Greater</db:link> if <db:code role="parameter">lhs</db:code> is less than, equivalent to or greater than <db:code role="parameter">rhs</db:code>, respectively.</db:para>
<db:para>If the variants contain data with a different metatype, the values are considered unordered unless they are both of numeric or pointer types, where regular numeric or pointer comparison rules will be used.</db:para>
<db:note>
<db:para>: If a numeric comparison is done and at least one value is NaN, <db:link xlink:href="qpartialordering.xml#Unordered-var">QPartialOrdering::Unordered</db:link> is returned.</db:para>
</db:note>
<db:para>If both variants contain data of the same metatype, the method will use the <db:link xlink:href="qmetatype.xml#compare">QMetaType::compare</db:link> method to determine the ordering of the two variants, which can also indicate that it can't establish an ordering between the two values.</db:para>
<db:para>This function was introduced in Qt 6.0.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qmetatype.xml#compare">QMetaType::compare</db:link>()</db:member>
<db:member><db:link xlink:href="qmetatype.xml#isOrdered">QMetaType::isOrdered</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="convert">
<db:title>[since 6.0] bool QVariant::convert(QMetaType <db:emphasis>targetType</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>bool</db:type>
<db:methodname>convert</db:methodname>
<db:methodparam>
<db:type>QMetaType</db:type>
<db:parameter>targetType</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool convert(QMetaType targetType)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Casts the variant to the requested type, <db:code role="parameter">targetType</db:code>. If the cast cannot be done, the variant is still changed to the requested type, but is left in a cleared null state similar to that constructed by <db:link xlink:href="qvariant.xml">QVariant</db:link>(Type).</db:para>
<db:para>Returns true if the current type of the variant was successfully cast; otherwise returns false.</db:para>
<db:para>A <db:link xlink:href="qvariant.xml">QVariant</db:link> containing a pointer to a type derived from <db:link xlink:href="qobject.xml">QObject</db:link> will also convert and return true for this function if a <db:link xlink:href="qobject.xml#qobject_cast-1">qobject_cast</db:link> to the type described by <db:code role="parameter">targetType</db:code> would succeed. Note that this only works for <db:link xlink:href="qobject.xml">QObject</db:link> subclasses which use the <db:link xlink:href="qobject.xml#Q_OBJECT">Q_OBJECT</db:link> macro.</db:para>
<db:note>
<db:para>converting QVariants that are null due to not being initialized or having failed a previous conversion will always fail, changing the type, remaining null, and returning false.</db:para>
</db:note>
<db:para>This function was introduced in Qt 6.0.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qvariant.xml#canConvert-2">canConvert</db:link>()</db:member>
<db:member><db:link xlink:href="qvariant.xml#clear">clear</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="data">
<db:title>void *QVariant::data()</db:title>
<db:methodsynopsis>
<db:type>void *</db:type>
<db:methodname>data</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void * data()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns a pointer to the contained object as a generic void* that can be written to.</db:para>
<db:para>This function detaches the <db:link xlink:href="qvariant.xml">QVariant</db:link>. When called on a <db:link xlink:href="qvariant.xml#isNull">null-QVariant</db:link>, the <db:link xlink:href="qvariant.xml">QVariant</db:link> will not be null after the call.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qvariant.xml#get_if">get_if</db:link>()</db:member>
<db:member><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="emplace">
<db:title>[since 6.6] T &amp;QVariant::emplace(Args &amp;&amp;... <db:emphasis>args</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>T &amp;</db:type>
<db:methodname>emplace</db:methodname>
<db:methodparam>
<db:type>Args &amp;&amp;...</db:type>
<db:parameter>args</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">T &amp; emplace(Args &amp;&amp;... args)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Replaces the object currently held in *this with an object of type T, constructed from <db:code role="parameter">args</db:code>.... If *this was non-null, the previously held object is destroyed first. If possible, this method will reuse memory allocated by the <db:link xlink:href="qvariant.xml">QVariant</db:link>. Returns a reference to the newly-created object.</db:para>
<db:para>This function was introduced in Qt 6.6.</db:para>
</db:section>
<db:section xml:id="emplace-1">
<db:title>[since 6.6] T &amp;QVariant::emplace(std::initializer_list&lt;U&gt; <db:emphasis>list</db:emphasis>, Args &amp;&amp;... <db:emphasis>args</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>T &amp;</db:type>
<db:methodname>emplace</db:methodname>
<db:methodparam>
<db:type>std::initializer_list&lt;U&gt;</db:type>
<db:parameter>list</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>Args &amp;&amp;...</db:type>
<db:parameter>args</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">T &amp; emplace(std::initializer_list&lt;U&gt; list, Args &amp;&amp;... args)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>This overload exists to support types with constructors taking an initializer_list. It behaves otherwise equivalent to the non-initializer list overload.</db:para>
<db:para>This function was introduced in Qt 6.6.</db:para>
</db:section>
<db:section xml:id="fromMetaType">
<db:title>[static, since 6.7] QVariant QVariant::fromMetaType(QMetaType <db:emphasis>type</db:emphasis>, const void *<db:emphasis>copy</db:emphasis> = nullptr)</db:title>
<db:methodsynopsis>
<db:modifier>static</db:modifier>
<db:type>QVariant</db:type>
<db:methodname>fromMetaType</db:methodname>
<db:methodparam>
<db:type>QMetaType</db:type>
<db:parameter>type</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const void *</db:type>
<db:parameter>copy</db:parameter>
<db:initializer>nullptr</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QVariant fromMetaType(QMetaType type, const void *copy)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Creates a variant of type <db:code role="parameter">type</db:code>, and initializes it with a copy of *copy if <db:code role="parameter">copy</db:code> is not nullptr (in which case, <db:code role="parameter">copy</db:code> must point to an object of type <db:code role="parameter">type</db:code>).</db:para>
<db:para>Note that you have to pass the address of the object you want stored.</db:para>
<db:para>Usually, you never have to use this constructor, use <db:link xlink:href="qvariant.xml#fromValue">QVariant::fromValue</db:link>() instead to construct variants from the pointer types represented by QMetaType::VoidStar, and QMetaType::QObjectStar.</db:para>
<db:para>If <db:code role="parameter">type</db:code> does not support copy construction and <db:code role="parameter">copy</db:code> is not nullptr, the variant will be invalid. Similarly, if <db:code role="parameter">copy</db:code> is nullptr and <db:code role="parameter">type</db:code> does not support default construction, the variant will be invalid.</db:para>
<db:para>Returns the <db:link xlink:href="qvariant.xml">QVariant</db:link> created as described above.</db:para>
<db:para>This function was introduced in Qt 6.7.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qvariant.xml#fromValue">QVariant::fromValue</db:link>()</db:member>
<db:member><db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::Type</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="fromStdVariant">
<db:title>[static] QVariant QVariant::fromStdVariant(const std::variant&lt;Types...&gt; &amp;<db:emphasis>value</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:modifier>static</db:modifier>
<db:type>QVariant</db:type>
<db:methodname>fromStdVariant</db:methodname>
<db:methodparam>
<db:type>const std::variant&lt;Types...&gt; &amp;</db:type>
<db:parameter>value</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QVariant fromStdVariant(const std::variant&lt;Types...&gt; &amp;value)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns a <db:link xlink:href="qvariant.xml">QVariant</db:link> with the type and value of the active variant of <db:code role="parameter">value</db:code>. If the active type is std::monostate a default <db:link xlink:href="qvariant.xml">QVariant</db:link> is returned.</db:para>
<db:note>
<db:para>With this method you do not need to register the variant as a Qt metatype, since the std::variant is resolved before being stored. The component types should be registered however.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qvariant.xml#fromValue">fromValue</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="fromStdVariant-1">
<db:title>[static, since 6.6] QVariant QVariant::fromStdVariant(std::variant&lt;Types...&gt; &amp;&amp;<db:emphasis>value</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:modifier>static</db:modifier>
<db:type>QVariant</db:type>
<db:methodname>fromStdVariant</db:methodname>
<db:methodparam>
<db:type>std::variant&lt;Types...&gt; &amp;&amp;</db:type>
<db:parameter>value</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">QVariant fromStdVariant(std::variant&lt;Types...&gt; &amp;&amp;value)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>This function was introduced in Qt 6.6.</db:para>
</db:section>
<db:section xml:id="fromValue">
<db:title>[static] QVariant QVariant::fromValue(const T &amp;<db:emphasis>value</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:modifier>static</db:modifier>
<db:type>QVariant</db:type>
<db:methodname>fromValue</db:methodname>
<db:methodparam>
<db:type>const T &amp;</db:type>
<db:parameter>value</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QVariant fromValue(const T &amp;value)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns a <db:link xlink:href="qvariant.xml">QVariant</db:link> containing a copy of <db:code role="parameter">value</db:code>. Behaves exactly like <db:link xlink:href="qvariant.xml#setValue">setValue</db:link>() otherwise.</db:para>
<db:para>Example:</db:para>
<db:programlisting language="cpp">MyCustomStruct s;
return QVariant::fromValue(s);
</db:programlisting>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qvariant.xml#setValue">setValue</db:link>()</db:member>
<db:member><db:link xlink:href="qvariant.xml#value">value</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="fromValue-1">
<db:title>[static, since 6.6] QVariant QVariant::fromValue(T &amp;&amp;<db:emphasis>value</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:modifier>static</db:modifier>
<db:type>QVariant</db:type>
<db:methodname>fromValue</db:methodname>
<db:methodparam>
<db:type>T &amp;&amp;</db:type>
<db:parameter>value</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">QVariant fromValue(T &amp;&amp;value)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>This function was introduced in Qt 6.6.</db:para>
</db:section>
<db:section xml:id="isNull">
<db:title>bool QVariant::isNull() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>bool</db:type>
<db:methodname>isNull</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool isNull() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns true if this is a null variant, false otherwise.</db:para>
<db:para>A variant is considered null if it contains no initialized value or a null pointer.</db:para>
<db:note>
<db:para>This behavior has been changed from Qt 5, where isNull() would also return true if the variant contained an object of a builtin type with an isNull() method that returned true for that object.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qvariant.xml#convert">convert</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="isValid">
<db:title>bool QVariant::isValid() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>bool</db:type>
<db:methodname>isValid</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool isValid() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns true if the storage type of this variant is not <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::UnknownType</db:link>; otherwise returns false.</db:para>
</db:section>
<db:section xml:id="metaType">
<db:title>[since 6.0] QMetaType QVariant::metaType() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QMetaType</db:type>
<db:methodname>metaType</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QMetaType metaType() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the <db:link xlink:href="qmetatype.xml">QMetaType</db:link> of the value stored in the variant.</db:para>
<db:para>This function was introduced in Qt 6.0.</db:para>
</db:section>
<db:section xml:id="setValue">
<db:title>void QVariant::setValue(T &amp;&amp;<db:emphasis>value</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>setValue</db:methodname>
<db:methodparam>
<db:type>T &amp;&amp;</db:type>
<db:parameter>value</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void setValue(T &amp;&amp;value)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Stores a copy of <db:code role="parameter">value</db:code>. If T is a type that <db:link xlink:href="qvariant.xml">QVariant</db:link> doesn't support, <db:link xlink:href="qmetatype.xml">QMetaType</db:link> is used to store the value. A compile error will occur if <db:link xlink:href="qmetatype.xml">QMetaType</db:link> doesn't handle the type.</db:para>
<db:para>Example:</db:para>
<db:programlisting language="cpp">QVariant v;

v.setValue(5);
int i = v.toInt();         // i is now 5
QString s = v.toString();  // s is now &quot;5&quot;

MyCustomStruct c;
v.setValue(c);

...

MyCustomStruct c2 = v.value&amp;lt;MyCustomStruct&amp;gt;();
</db:programlisting>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qvariant.xml#value">value</db:link>()</db:member>
<db:member><db:link xlink:href="qvariant.xml#fromValue">fromValue</db:link>()</db:member>
<db:member><db:link xlink:href="qvariant.xml#canConvert-2">canConvert</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setValue-1">
<db:title>void QVariant::setValue(const QVariant &amp;<db:emphasis>value</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>setValue</db:methodname>
<db:methodparam>
<db:type>const QVariant &amp;</db:type>
<db:parameter>value</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">void setValue(const QVariant &amp;value)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Copies <db:code role="parameter">value</db:code> over this <db:link xlink:href="qvariant.xml">QVariant</db:link>. It is equivalent to simply assigning <db:code role="parameter">value</db:code> to this <db:link xlink:href="qvariant.xml">QVariant</db:link>.</db:para>
</db:section>
<db:section xml:id="setValue-2">
<db:title>void QVariant::setValue(QVariant &amp;&amp;<db:emphasis>value</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>setValue</db:methodname>
<db:methodparam>
<db:type>QVariant &amp;&amp;</db:type>
<db:parameter>value</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">2</db:synopsisinfo>
<db:synopsisinfo role="signature">void setValue(QVariant &amp;&amp;value)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Moves <db:code role="parameter">value</db:code> over this <db:link xlink:href="qvariant.xml">QVariant</db:link>. It is equivalent to simply move assigning <db:code role="parameter">value</db:code> to this <db:link xlink:href="qvariant.xml">QVariant</db:link>.</db:para>
</db:section>
<db:section xml:id="swap">
<db:title>void QVariant::swap(QVariant &amp;<db:emphasis>other</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>swap</db:methodname>
<db:methodparam>
<db:type>QVariant &amp;</db:type>
<db:parameter>other</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void swap(QVariant &amp;other)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Swaps variant <db:code role="parameter">other</db:code> with this variant. This operation is very fast and never fails.</db:para>
</db:section>
<db:section xml:id="toBitArray">
<db:title>QBitArray QVariant::toBitArray() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QBitArray</db:type>
<db:methodname>toBitArray</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QBitArray toBitArray() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the variant as a <db:link xlink:href="qbitarray.xml">QBitArray</db:link> if the variant has <db:link xlink:href="qvariant.xml#userType">userType</db:link>() <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QBitArray</db:link>; otherwise returns an empty bit array.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qvariant.xml#canConvert-2">canConvert</db:link>()</db:member>
<db:member><db:link xlink:href="qvariant.xml#convert">convert</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="toBool">
<db:title>bool QVariant::toBool() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>bool</db:type>
<db:methodname>toBool</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool toBool() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the variant as a bool if the variant has <db:link xlink:href="qvariant.xml#userType">userType</db:link>() Bool.</db:para>
<db:para>Returns true if the variant has <db:link xlink:href="qvariant.xml#userType">userType</db:link>() <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::Bool</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QChar</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::Double</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::Int</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::LongLong</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::UInt</db:link>, or <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::ULongLong</db:link> and the value is non-zero, or if the variant has type <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QString</db:link> or <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QByteArray</db:link> and its lower-case content is not one of the following: empty, &quot;0&quot; or &quot;false&quot;; otherwise returns false.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qvariant.xml#canConvert-2">canConvert</db:link>()</db:member>
<db:member><db:link xlink:href="qvariant.xml#convert">convert</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="toByteArray">
<db:title>QByteArray QVariant::toByteArray() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QByteArray</db:type>
<db:methodname>toByteArray</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QByteArray toByteArray() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the variant as a <db:link xlink:href="qbytearray.xml">QByteArray</db:link> if the variant has <db:link xlink:href="qvariant.xml#userType">userType</db:link>() <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QByteArray</db:link> or <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QString</db:link> (converted using <db:link xlink:href="qstring.xml#fromUtf8">QString::fromUtf8</db:link>()); otherwise returns an empty byte array.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qvariant.xml#canConvert-2">canConvert</db:link>()</db:member>
<db:member><db:link xlink:href="qvariant.xml#convert">convert</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="toChar">
<db:title>QChar QVariant::toChar() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QChar</db:type>
<db:methodname>toChar</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QChar toChar() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the variant as a <db:link xlink:href="qchar.xml">QChar</db:link> if the variant has <db:link xlink:href="qvariant.xml#userType">userType</db:link>() <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QChar</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::Int</db:link>, or <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::UInt</db:link>; otherwise returns an invalid <db:link xlink:href="qchar.xml">QChar</db:link>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qvariant.xml#canConvert-2">canConvert</db:link>()</db:member>
<db:member><db:link xlink:href="qvariant.xml#convert">convert</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="toDate">
<db:title>QDate QVariant::toDate() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QDate</db:type>
<db:methodname>toDate</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QDate toDate() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the variant as a <db:link xlink:href="qdate.xml">QDate</db:link> if the variant has <db:link xlink:href="qvariant.xml#userType">userType</db:link>() <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QDate</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QDateTime</db:link>, or <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QString</db:link>; otherwise returns an invalid date.</db:para>
<db:para>If the type() is <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QString</db:link>, an invalid date will be returned if the string cannot be parsed as a <db:link xlink:href="qt.xml#DateFormat-enum">Qt::ISODate</db:link> format date.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qvariant.xml#canConvert-2">canConvert</db:link>()</db:member>
<db:member><db:link xlink:href="qvariant.xml#convert">convert</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="toDateTime">
<db:title>QDateTime QVariant::toDateTime() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QDateTime</db:type>
<db:methodname>toDateTime</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QDateTime toDateTime() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the variant as a <db:link xlink:href="qdatetime.xml">QDateTime</db:link> if the variant has <db:link xlink:href="qvariant.xml#userType">userType</db:link>() <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QDateTime</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QDate</db:link>, or <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QString</db:link>; otherwise returns an invalid date/time.</db:para>
<db:para>If the type() is <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QString</db:link>, an invalid date/time will be returned if the string cannot be parsed as a <db:link xlink:href="qt.xml#DateFormat-enum">Qt::ISODate</db:link> format date/time.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qvariant.xml#canConvert-2">canConvert</db:link>()</db:member>
<db:member><db:link xlink:href="qvariant.xml#convert">convert</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="toDouble">
<db:title>double QVariant::toDouble(bool *<db:emphasis>ok</db:emphasis> = nullptr) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>double</db:type>
<db:methodname>toDouble</db:methodname>
<db:methodparam>
<db:type>bool *</db:type>
<db:parameter>ok</db:parameter>
<db:initializer>nullptr</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">double toDouble(bool *ok) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the variant as a double if the variant has <db:link xlink:href="qvariant.xml#userType">userType</db:link>() <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::Double</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::Float</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::Bool</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QByteArray</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::Int</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::LongLong</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QString</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::UInt</db:link>, or <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::ULongLong</db:link>; otherwise returns 0.0.</db:para>
<db:para>If <db:code role="parameter">ok</db:code> is non-null: *<db:code role="parameter">ok</db:code> is set to true if the value could be converted to a double; otherwise *<db:code role="parameter">ok</db:code> is set to false.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qvariant.xml#canConvert-2">canConvert</db:link>()</db:member>
<db:member><db:link xlink:href="qvariant.xml#convert">convert</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="toEasingCurve">
<db:title>QEasingCurve QVariant::toEasingCurve() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QEasingCurve</db:type>
<db:methodname>toEasingCurve</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QEasingCurve toEasingCurve() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the variant as a <db:link xlink:href="qeasingcurve.xml">QEasingCurve</db:link> if the variant has <db:link xlink:href="qvariant.xml#userType">userType</db:link>() <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QEasingCurve</db:link>; otherwise returns a default easing curve.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qvariant.xml#canConvert-2">canConvert</db:link>()</db:member>
<db:member><db:link xlink:href="qvariant.xml#convert">convert</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="toFloat">
<db:title>float QVariant::toFloat(bool *<db:emphasis>ok</db:emphasis> = nullptr) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>float</db:type>
<db:methodname>toFloat</db:methodname>
<db:methodparam>
<db:type>bool *</db:type>
<db:parameter>ok</db:parameter>
<db:initializer>nullptr</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">float toFloat(bool *ok) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the variant as a float if the variant has <db:link xlink:href="qvariant.xml#userType">userType</db:link>() <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::Double</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::Float</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::Bool</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QByteArray</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::Int</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::LongLong</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QString</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::UInt</db:link>, or <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::ULongLong</db:link>; otherwise returns 0.0.</db:para>
<db:para>If <db:code role="parameter">ok</db:code> is non-null: *<db:code role="parameter">ok</db:code> is set to true if the value could be converted to a double; otherwise *<db:code role="parameter">ok</db:code> is set to false.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qvariant.xml#canConvert-2">canConvert</db:link>()</db:member>
<db:member><db:link xlink:href="qvariant.xml#convert">convert</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="toHash">
<db:title>QHash&lt;QString, QVariant&gt; QVariant::toHash() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QHash&lt;QString, QVariant&gt;</db:type>
<db:methodname>toHash</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QHash&lt;QString, QVariant&gt; toHash() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the variant as a <db:link xlink:href="qhash.xml#qhash">QHash</db:link>&lt;<db:link xlink:href="qstring.xml">QString</db:link>, <db:link xlink:href="qvariant.xml">QVariant</db:link>&gt; if the variant has type() <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QVariantHash</db:link>; otherwise returns an empty map.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qvariant.xml#canConvert-2">canConvert</db:link>()</db:member>
<db:member><db:link xlink:href="qvariant.xml#convert">convert</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="toInt">
<db:title>int QVariant::toInt(bool *<db:emphasis>ok</db:emphasis> = nullptr) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>int</db:type>
<db:methodname>toInt</db:methodname>
<db:methodparam>
<db:type>bool *</db:type>
<db:parameter>ok</db:parameter>
<db:initializer>nullptr</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">int toInt(bool *ok) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the variant as an int if the variant has <db:link xlink:href="qvariant.xml#userType">userType</db:link>() <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::Int</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::Bool</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QByteArray</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QChar</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::Double</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::LongLong</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QString</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::UInt</db:link>, or <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::ULongLong</db:link>; otherwise returns 0.</db:para>
<db:para>If <db:code role="parameter">ok</db:code> is non-null: *<db:code role="parameter">ok</db:code> is set to true if the value could be converted to an int; otherwise *<db:code role="parameter">ok</db:code> is set to false.</db:para>
<db:para><db:emphasis role="bold">Warning:</db:emphasis> If the value is convertible to a <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::LongLong</db:link> but is too large to be represented in an int, the resulting arithmetic overflow will not be reflected in <db:code role="parameter">ok</db:code>. A simple workaround is to use <db:link xlink:href="qstring.xml#toInt">QString::toInt</db:link>().</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qvariant.xml#canConvert-2">canConvert</db:link>()</db:member>
<db:member><db:link xlink:href="qvariant.xml#convert">convert</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="toJsonArray">
<db:title>QJsonArray QVariant::toJsonArray() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QJsonArray</db:type>
<db:methodname>toJsonArray</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QJsonArray toJsonArray() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the variant as a <db:link xlink:href="qjsonarray.xml">QJsonArray</db:link> if the variant has <db:link xlink:href="qvariant.xml#userType">userType</db:link>() <db:link xlink:href="qjsonarray.xml">QJsonArray</db:link>; otherwise returns a default constructed <db:link xlink:href="qjsonarray.xml">QJsonArray</db:link>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qvariant.xml#canConvert-2">canConvert</db:link>()</db:member>
<db:member><db:link xlink:href="qvariant.xml#convert">convert</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="toJsonDocument">
<db:title>QJsonDocument QVariant::toJsonDocument() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QJsonDocument</db:type>
<db:methodname>toJsonDocument</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QJsonDocument toJsonDocument() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the variant as a <db:link xlink:href="qjsondocument.xml">QJsonDocument</db:link> if the variant has <db:link xlink:href="qvariant.xml#userType">userType</db:link>() <db:link xlink:href="qjsondocument.xml">QJsonDocument</db:link>; otherwise returns a default constructed <db:link xlink:href="qjsondocument.xml">QJsonDocument</db:link>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qvariant.xml#canConvert-2">canConvert</db:link>()</db:member>
<db:member><db:link xlink:href="qvariant.xml#convert">convert</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="toJsonObject">
<db:title>QJsonObject QVariant::toJsonObject() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QJsonObject</db:type>
<db:methodname>toJsonObject</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QJsonObject toJsonObject() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the variant as a <db:link xlink:href="qjsonobject.xml">QJsonObject</db:link> if the variant has <db:link xlink:href="qvariant.xml#userType">userType</db:link>() <db:link xlink:href="qjsonobject.xml">QJsonObject</db:link>; otherwise returns a default constructed <db:link xlink:href="qjsonobject.xml">QJsonObject</db:link>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qvariant.xml#canConvert-2">canConvert</db:link>()</db:member>
<db:member><db:link xlink:href="qvariant.xml#convert">convert</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="toJsonValue">
<db:title>QJsonValue QVariant::toJsonValue() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QJsonValue</db:type>
<db:methodname>toJsonValue</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QJsonValue toJsonValue() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the variant as a <db:link xlink:href="qjsonvalue.xml">QJsonValue</db:link> if the variant has <db:link xlink:href="qvariant.xml#userType">userType</db:link>() <db:link xlink:href="qjsonvalue.xml">QJsonValue</db:link>; otherwise returns a default constructed <db:link xlink:href="qjsonvalue.xml">QJsonValue</db:link>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qvariant.xml#canConvert-2">canConvert</db:link>()</db:member>
<db:member><db:link xlink:href="qvariant.xml#convert">convert</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="toLine">
<db:title>QLine QVariant::toLine() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QLine</db:type>
<db:methodname>toLine</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QLine toLine() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the variant as a <db:link xlink:href="qline.xml">QLine</db:link> if the variant has <db:link xlink:href="qvariant.xml#userType">userType</db:link>() <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QLine</db:link>; otherwise returns an invalid <db:link xlink:href="qline.xml">QLine</db:link>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qvariant.xml#canConvert-2">canConvert</db:link>()</db:member>
<db:member><db:link xlink:href="qvariant.xml#convert">convert</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="toLineF">
<db:title>QLineF QVariant::toLineF() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QLineF</db:type>
<db:methodname>toLineF</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QLineF toLineF() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the variant as a <db:link xlink:href="qlinef.xml">QLineF</db:link> if the variant has <db:link xlink:href="qvariant.xml#userType">userType</db:link>() <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QLineF</db:link>; otherwise returns an invalid <db:link xlink:href="qlinef.xml">QLineF</db:link>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qvariant.xml#canConvert-2">canConvert</db:link>()</db:member>
<db:member><db:link xlink:href="qvariant.xml#convert">convert</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="toList">
<db:title>QList&lt;QVariant&gt; QVariant::toList() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QList&lt;QVariant&gt;</db:type>
<db:methodname>toList</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QList&lt;QVariant&gt; toList() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the variant as a <db:link xlink:href="qvariant.xml#QVariantList-typedef">QVariantList</db:link> if the variant has <db:link xlink:href="qvariant.xml#userType">userType</db:link>() <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QVariantList</db:link>. If it doesn't, <db:link xlink:href="qvariant.xml">QVariant</db:link> will attempt to convert the type to a list and then return it. This will succeed for any type that has registered a converter to <db:link xlink:href="qvariant.xml#QVariantList-typedef">QVariantList</db:link> or which was declared as a sequential container using <db:link xlink:href="qmetatype.xml#Q_DECLARE_SEQUENTIAL_CONTAINER_METATYPE">Q_DECLARE_SEQUENTIAL_CONTAINER_METATYPE</db:link>. If none of those conditions are true, this function will return an empty list.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qvariant.xml#canConvert-2">canConvert</db:link>()</db:member>
<db:member><db:link xlink:href="qvariant.xml#convert">convert</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="toLocale">
<db:title>QLocale QVariant::toLocale() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QLocale</db:type>
<db:methodname>toLocale</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QLocale toLocale() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the variant as a <db:link xlink:href="qlocale.xml">QLocale</db:link> if the variant has <db:link xlink:href="qvariant.xml#userType">userType</db:link>() <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QLocale</db:link>; otherwise returns an invalid <db:link xlink:href="qlocale.xml">QLocale</db:link>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qvariant.xml#canConvert-2">canConvert</db:link>()</db:member>
<db:member><db:link xlink:href="qvariant.xml#convert">convert</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="toLongLong">
<db:title>qlonglong QVariant::toLongLong(bool *<db:emphasis>ok</db:emphasis> = nullptr) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>qlonglong</db:type>
<db:methodname>toLongLong</db:methodname>
<db:methodparam>
<db:type>bool *</db:type>
<db:parameter>ok</db:parameter>
<db:initializer>nullptr</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">qlonglong toLongLong(bool *ok) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the variant as a long long int if the variant has <db:link xlink:href="qvariant.xml#userType">userType</db:link>() <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::LongLong</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::Bool</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QByteArray</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QChar</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::Double</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::Int</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QString</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::UInt</db:link>, or <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::ULongLong</db:link>; otherwise returns 0.</db:para>
<db:para>If <db:code role="parameter">ok</db:code> is non-null: *ok is set to true if the value could be converted to an int; otherwise *ok is set to false.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qvariant.xml#canConvert-2">canConvert</db:link>()</db:member>
<db:member><db:link xlink:href="qvariant.xml#convert">convert</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="toMap">
<db:title>QMap&lt;QString, QVariant&gt; QVariant::toMap() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QMap&lt;QString, QVariant&gt;</db:type>
<db:methodname>toMap</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QMap&lt;QString, QVariant&gt; toMap() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the variant as a <db:link xlink:href="qvariant.xml#QVariantMap-typedef">QVariantMap</db:link> if the variant has type() <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QVariantMap</db:link>. If it doesn't, <db:link xlink:href="qvariant.xml">QVariant</db:link> will attempt to convert the type to a map and then return it. This will succeed for any type that has registered a converter to <db:link xlink:href="qvariant.xml#QVariantMap-typedef">QVariantMap</db:link> or which was declared as a associative container using <db:link xlink:href="qmetatype.xml#Q_DECLARE_ASSOCIATIVE_CONTAINER_METATYPE">Q_DECLARE_ASSOCIATIVE_CONTAINER_METATYPE</db:link>. If none of those conditions are true, this function will return an empty map.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qvariant.xml#canConvert-2">canConvert</db:link>()</db:member>
<db:member><db:link xlink:href="qvariant.xml#convert">convert</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="toModelIndex">
<db:title>QModelIndex QVariant::toModelIndex() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QModelIndex</db:type>
<db:methodname>toModelIndex</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QModelIndex toModelIndex() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the variant as a <db:link xlink:href="qmodelindex.xml">QModelIndex</db:link> if the variant has <db:link xlink:href="qvariant.xml#userType">userType</db:link>() <db:link xlink:href="qmodelindex.xml">QModelIndex</db:link>; otherwise returns a default constructed <db:link xlink:href="qmodelindex.xml">QModelIndex</db:link>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qvariant.xml#canConvert-2">canConvert</db:link>()</db:member>
<db:member><db:link xlink:href="qvariant.xml#convert">convert</db:link>()</db:member>
<db:member><db:link xlink:href="qvariant.xml#toPersistentModelIndex">toPersistentModelIndex</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="toPersistentModelIndex">
<db:title>QPersistentModelIndex QVariant::toPersistentModelIndex() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QPersistentModelIndex</db:type>
<db:methodname>toPersistentModelIndex</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QPersistentModelIndex toPersistentModelIndex() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the variant as a <db:link xlink:href="qpersistentmodelindex.xml">QPersistentModelIndex</db:link> if the variant has <db:link xlink:href="qvariant.xml#userType">userType</db:link>() <db:link xlink:href="qpersistentmodelindex.xml">QPersistentModelIndex</db:link>; otherwise returns a default constructed <db:link xlink:href="qpersistentmodelindex.xml">QPersistentModelIndex</db:link>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qvariant.xml#canConvert-2">canConvert</db:link>()</db:member>
<db:member><db:link xlink:href="qvariant.xml#convert">convert</db:link>()</db:member>
<db:member><db:link xlink:href="qvariant.xml#toModelIndex">toModelIndex</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="toPoint">
<db:title>QPoint QVariant::toPoint() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QPoint</db:type>
<db:methodname>toPoint</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QPoint toPoint() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the variant as a <db:link xlink:href="qpoint.xml">QPoint</db:link> if the variant has <db:link xlink:href="qvariant.xml#userType">userType</db:link>() <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QPoint</db:link> or <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QPointF</db:link>; otherwise returns a null <db:link xlink:href="qpoint.xml">QPoint</db:link>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qvariant.xml#canConvert-2">canConvert</db:link>()</db:member>
<db:member><db:link xlink:href="qvariant.xml#convert">convert</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="toPointF">
<db:title>QPointF QVariant::toPointF() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QPointF</db:type>
<db:methodname>toPointF</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QPointF toPointF() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the variant as a <db:link xlink:href="qpointf.xml">QPointF</db:link> if the variant has <db:link xlink:href="qvariant.xml#userType">userType</db:link>() <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QPoint</db:link> or <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QPointF</db:link>; otherwise returns a null <db:link xlink:href="qpointf.xml">QPointF</db:link>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qvariant.xml#canConvert-2">canConvert</db:link>()</db:member>
<db:member><db:link xlink:href="qvariant.xml#convert">convert</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="toReal">
<db:title>qreal QVariant::toReal(bool *<db:emphasis>ok</db:emphasis> = nullptr) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>qreal</db:type>
<db:methodname>toReal</db:methodname>
<db:methodparam>
<db:type>bool *</db:type>
<db:parameter>ok</db:parameter>
<db:initializer>nullptr</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">qreal toReal(bool *ok) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the variant as a qreal if the variant has <db:link xlink:href="qvariant.xml#userType">userType</db:link>() <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::Double</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::Float</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::Bool</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QByteArray</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::Int</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::LongLong</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QString</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::UInt</db:link>, or <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::ULongLong</db:link>; otherwise returns 0.0.</db:para>
<db:para>If <db:code role="parameter">ok</db:code> is non-null: *<db:code role="parameter">ok</db:code> is set to true if the value could be converted to a double; otherwise *<db:code role="parameter">ok</db:code> is set to false.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qvariant.xml#canConvert-2">canConvert</db:link>()</db:member>
<db:member><db:link xlink:href="qvariant.xml#convert">convert</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="toRect">
<db:title>QRect QVariant::toRect() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QRect</db:type>
<db:methodname>toRect</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QRect toRect() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the variant as a <db:link xlink:href="qrect.xml">QRect</db:link> if the variant has <db:link xlink:href="qvariant.xml#userType">userType</db:link>() <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QRect</db:link>; otherwise returns an invalid <db:link xlink:href="qrect.xml">QRect</db:link>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qvariant.xml#canConvert-2">canConvert</db:link>()</db:member>
<db:member><db:link xlink:href="qvariant.xml#convert">convert</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="toRectF">
<db:title>QRectF QVariant::toRectF() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QRectF</db:type>
<db:methodname>toRectF</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QRectF toRectF() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the variant as a <db:link xlink:href="qrectf.xml">QRectF</db:link> if the variant has <db:link xlink:href="qvariant.xml#userType">userType</db:link>() <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QRect</db:link> or <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QRectF</db:link>; otherwise returns an invalid <db:link xlink:href="qrectf.xml">QRectF</db:link>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qvariant.xml#canConvert-2">canConvert</db:link>()</db:member>
<db:member><db:link xlink:href="qvariant.xml#convert">convert</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="toRegularExpression">
<db:title>QRegularExpression QVariant::toRegularExpression() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QRegularExpression</db:type>
<db:methodname>toRegularExpression</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QRegularExpression toRegularExpression() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the variant as a <db:link xlink:href="qregularexpression.xml">QRegularExpression</db:link> if the variant has <db:link xlink:href="qvariant.xml#userType">userType</db:link>() <db:link xlink:href="qregularexpression.xml">QRegularExpression</db:link>; otherwise returns an empty <db:link xlink:href="qregularexpression.xml">QRegularExpression</db:link>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qvariant.xml#canConvert-2">canConvert</db:link>()</db:member>
<db:member><db:link xlink:href="qvariant.xml#convert">convert</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="toSize">
<db:title>QSize QVariant::toSize() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QSize</db:type>
<db:methodname>toSize</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QSize toSize() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the variant as a <db:link xlink:href="qsize.xml">QSize</db:link> if the variant has <db:link xlink:href="qvariant.xml#userType">userType</db:link>() <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QSize</db:link>; otherwise returns an invalid <db:link xlink:href="qsize.xml">QSize</db:link>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qvariant.xml#canConvert-2">canConvert</db:link>()</db:member>
<db:member><db:link xlink:href="qvariant.xml#convert">convert</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="toSizeF">
<db:title>QSizeF QVariant::toSizeF() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QSizeF</db:type>
<db:methodname>toSizeF</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QSizeF toSizeF() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the variant as a <db:link xlink:href="qsizef.xml">QSizeF</db:link> if the variant has <db:link xlink:href="qvariant.xml#userType">userType</db:link>() <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QSizeF</db:link>; otherwise returns an invalid <db:link xlink:href="qsizef.xml">QSizeF</db:link>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qvariant.xml#canConvert-2">canConvert</db:link>()</db:member>
<db:member><db:link xlink:href="qvariant.xml#convert">convert</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="toString">
<db:title>QString QVariant::toString() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QString</db:type>
<db:methodname>toString</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QString toString() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the variant as a <db:link xlink:href="qstring.xml">QString</db:link> if the variant has a <db:link xlink:href="qvariant.xml#userType">userType</db:link>() including, but not limited to:</db:para>
<db:para><db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QString</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::Bool</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QByteArray</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QChar</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QDate</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QDateTime</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::Double</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::Int</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::LongLong</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QStringList</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QTime</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::UInt</db:link>, or <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::ULongLong</db:link>.</db:para>
<db:para>Calling QVariant::toString() on an unsupported variant returns an empty string.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qvariant.xml#canConvert-2">canConvert</db:link>()</db:member>
<db:member><db:link xlink:href="qvariant.xml#convert">convert</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="toStringList">
<db:title>QStringList QVariant::toStringList() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QStringList</db:type>
<db:methodname>toStringList</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QStringList toStringList() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the variant as a <db:link xlink:href="qstringlist.xml">QStringList</db:link> if the variant has <db:link xlink:href="qvariant.xml#userType">userType</db:link>() <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QStringList</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QString</db:link>, or <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QVariantList</db:link> of a type that can be converted to <db:link xlink:href="qstring.xml">QString</db:link>; otherwise returns an empty list.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qvariant.xml#canConvert-2">canConvert</db:link>()</db:member>
<db:member><db:link xlink:href="qvariant.xml#convert">convert</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="toTime">
<db:title>QTime QVariant::toTime() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QTime</db:type>
<db:methodname>toTime</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QTime toTime() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the variant as a <db:link xlink:href="qtime.xml">QTime</db:link> if the variant has <db:link xlink:href="qvariant.xml#userType">userType</db:link>() <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QTime</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QDateTime</db:link>, or <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QString</db:link>; otherwise returns an invalid time.</db:para>
<db:para>If the type() is <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QString</db:link>, an invalid time will be returned if the string cannot be parsed as a <db:link xlink:href="qt.xml#DateFormat-enum">Qt::ISODate</db:link> format time.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qvariant.xml#canConvert-2">canConvert</db:link>()</db:member>
<db:member><db:link xlink:href="qvariant.xml#convert">convert</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="toUInt">
<db:title>uint QVariant::toUInt(bool *<db:emphasis>ok</db:emphasis> = nullptr) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>uint</db:type>
<db:methodname>toUInt</db:methodname>
<db:methodparam>
<db:type>bool *</db:type>
<db:parameter>ok</db:parameter>
<db:initializer>nullptr</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">uint toUInt(bool *ok) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the variant as an unsigned int if the variant has <db:link xlink:href="qvariant.xml#userType">userType</db:link>() <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::UInt</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::Bool</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QByteArray</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QChar</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::Double</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::Int</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::LongLong</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QString</db:link>, or <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::ULongLong</db:link>; otherwise returns 0.</db:para>
<db:para>If <db:code role="parameter">ok</db:code> is non-null: *<db:code role="parameter">ok</db:code> is set to true if the value could be converted to an unsigned int; otherwise *<db:code role="parameter">ok</db:code> is set to false.</db:para>
<db:para><db:emphasis role="bold">Warning:</db:emphasis> If the value is convertible to a <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::ULongLong</db:link> but is too large to be represented in an unsigned int, the resulting arithmetic overflow will not be reflected in <db:code role="parameter">ok</db:code>. A simple workaround is to use <db:link xlink:href="qstring.xml#toUInt">QString::toUInt</db:link>().</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qvariant.xml#canConvert-2">canConvert</db:link>()</db:member>
<db:member><db:link xlink:href="qvariant.xml#convert">convert</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="toULongLong">
<db:title>qulonglong QVariant::toULongLong(bool *<db:emphasis>ok</db:emphasis> = nullptr) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>qulonglong</db:type>
<db:methodname>toULongLong</db:methodname>
<db:methodparam>
<db:type>bool *</db:type>
<db:parameter>ok</db:parameter>
<db:initializer>nullptr</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">qulonglong toULongLong(bool *ok) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the variant as an unsigned long long int if the variant has type() <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::ULongLong</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::Bool</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QByteArray</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QChar</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::Double</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::Int</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::LongLong</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QString</db:link>, or <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::UInt</db:link>; otherwise returns 0.</db:para>
<db:para>If <db:code role="parameter">ok</db:code> is non-null: *<db:code role="parameter">ok</db:code> is set to true if the value could be converted to an int; otherwise *<db:code role="parameter">ok</db:code> is set to false.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qvariant.xml#canConvert-2">canConvert</db:link>()</db:member>
<db:member><db:link xlink:href="qvariant.xml#convert">convert</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="toUrl">
<db:title>QUrl QVariant::toUrl() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QUrl</db:type>
<db:methodname>toUrl</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QUrl toUrl() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the variant as a <db:link xlink:href="qurl.xml">QUrl</db:link> if the variant has <db:link xlink:href="qvariant.xml#userType">userType</db:link>() <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QUrl</db:link>; otherwise returns an invalid <db:link xlink:href="qurl.xml">QUrl</db:link>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qvariant.xml#canConvert-2">canConvert</db:link>()</db:member>
<db:member><db:link xlink:href="qvariant.xml#convert">convert</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="toUuid">
<db:title>QUuid QVariant::toUuid() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QUuid</db:type>
<db:methodname>toUuid</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QUuid toUuid() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the variant as a <db:link xlink:href="quuid.xml">QUuid</db:link> if the variant has type() <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QUuid</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QByteArray</db:link> or <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QString</db:link>; otherwise returns a default-constructed <db:link xlink:href="quuid.xml">QUuid</db:link>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qvariant.xml#canConvert-2">canConvert</db:link>()</db:member>
<db:member><db:link xlink:href="qvariant.xml#convert">convert</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="typeName">
<db:title>const char *QVariant::typeName() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>const char *</db:type>
<db:methodname>typeName</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">const char * typeName() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the name of the type stored in the variant. The returned strings describe the C++ datatype used to store the data: for example, &quot;<db:link xlink:href="qfont.xml">QFont</db:link>&quot;, &quot;<db:link xlink:href="qstring.xml">QString</db:link>&quot;, or &quot;<db:link xlink:href="qvariant.xml#QVariantList-typedef">QVariantList</db:link>&quot;. An Invalid variant returns 0.</db:para>
</db:section>
<db:section xml:id="value">
<db:title>T QVariant::value() const &amp;</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>T</db:type>
<db:methodname>value</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="refness">1</db:synopsisinfo>
<db:synopsisinfo role="signature">T value() const &amp;</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the stored value converted to the template type T. Call <db:link xlink:href="qvariant.xml#canConvert-2">canConvert</db:link>() to find out whether a type can be converted. If the value cannot be converted, a <db:link xlink:href="containers.xml#default-constructed-value">default-constructed value</db:link> will be returned.</db:para>
<db:para>If the type T is supported by <db:link xlink:href="qvariant.xml">QVariant</db:link>, this function behaves exactly as <db:link xlink:href="qvariant.xml#toString">toString</db:link>(), <db:link xlink:href="qvariant.xml#toInt">toInt</db:link>() etc.</db:para>
<db:para>Example:</db:para>
<db:programlisting language="cpp">QVariant v;

MyCustomStruct c;
if (v.canConvert&amp;lt;MyCustomStruct&amp;gt;())
    c = v.value&amp;lt;MyCustomStruct&amp;gt;();

v = 7;
int i = v.value&amp;lt;int&amp;gt;();                        // same as v.toInt()
QString s = v.value&amp;lt;QString&amp;gt;();                // same as v.toString(), s is now &quot;7&quot;
MyCustomStruct c2 = v.value&amp;lt;MyCustomStruct&amp;gt;(); // conversion failed, c2 is empty
</db:programlisting>
<db:para>If the <db:link xlink:href="qvariant.xml">QVariant</db:link> contains a pointer to a type derived from <db:link xlink:href="qobject.xml">QObject</db:link> then T may be any <db:link xlink:href="qobject.xml">QObject</db:link> type. If the pointer stored in the <db:link xlink:href="qvariant.xml">QVariant</db:link> can be <db:link xlink:href="qobject.xml#qobject_cast-1">qobject_cast</db:link> to T, then that result is returned. Otherwise nullptr is returned. Note that this only works for <db:link xlink:href="qobject.xml">QObject</db:link> subclasses which use the <db:link xlink:href="qobject.xml#Q_OBJECT">Q_OBJECT</db:link> macro.</db:para>
<db:para>If the <db:link xlink:href="qvariant.xml">QVariant</db:link> contains a sequential container and T is <db:link xlink:href="qvariant.xml#QVariantList-typedef">QVariantList</db:link>, the elements of the container will be converted into <db:link xlink:href="qvariant.xml">QVariant</db:link>s and returned as a <db:link xlink:href="qvariant.xml#QVariantList-typedef">QVariantList</db:link>.</db:para>
<db:programlisting language="cpp">QList&amp;lt;int&amp;gt; intList = {7, 11, 42};

QVariant variant = QVariant::fromValue(intList);
if (variant.canConvert&amp;lt;QVariantList&amp;gt;()) {
    QSequentialIterable iterable = variant.value&amp;lt;QSequentialIterable&amp;gt;();
    // Can use foreach:
    foreach (const QVariant &amp;amp;v, iterable) {
        qDebug() &amp;lt;&amp;lt; v;
    }
    // Can use C++11 range-for:
    for (const QVariant &amp;amp;v : iterable) {
        qDebug() &amp;lt;&amp;lt; v;
    }
    // Can use iterators:
    QSequentialIterable::const_iterator it = iterable.begin();
    const QSequentialIterable::const_iterator end = iterable.end();
    for ( ; it != end; ++it) {
        qDebug() &amp;lt;&amp;lt; *it;
    }
}

</db:programlisting>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qvariant.xml#setValue">setValue</db:link>()</db:member>
<db:member><db:link xlink:href="qvariant.xml#fromValue">fromValue</db:link>()</db:member>
<db:member><db:link xlink:href="qvariant.xml#canConvert-2">canConvert</db:link>()</db:member>
<db:member><db:link xlink:href="qmetatype.xml#Q_DECLARE_SEQUENTIAL_CONTAINER_METATYPE">Q_DECLARE_SEQUENTIAL_CONTAINER_METATYPE</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="view">
<db:title>T QVariant::view()</db:title>
<db:methodsynopsis>
<db:type>T</db:type>
<db:methodname>view</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">T view()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns a mutable view of template type T on the stored value. Call <db:link xlink:href="qvariant.xml#canView-1">canView</db:link>() to find out whether such a view is supported. If no such view can be created, returns the stored value converted to the template type T. Call <db:link xlink:href="qvariant.xml#canConvert-2">canConvert</db:link>() to find out whether a type can be converted. If the value can neither be viewed nor converted, a <db:link xlink:href="containers.xml#default-constructed-value">default-constructed value</db:link> will be returned.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qvariant.xml#canView-1">canView</db:link>()</db:member>
<db:member><db:link xlink:href="qmetatype.xml#Q_DECLARE_SEQUENTIAL_CONTAINER_METATYPE">Q_DECLARE_SEQUENTIAL_CONTAINER_METATYPE</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="operator-eq">
<db:title>QVariant &amp;QVariant::operator=(const QVariant &amp;<db:emphasis>variant</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>QVariant &amp;</db:type>
<db:methodname>operator=</db:methodname>
<db:methodparam>
<db:type>const QVariant &amp;</db:type>
<db:parameter>variant</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">copy-assign</db:synopsisinfo>
<db:synopsisinfo role="signature">QVariant &amp; operator=(const QVariant &amp;variant)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Assigns the value of the variant <db:code role="parameter">variant</db:code> to this variant.</db:para>
</db:section>
<db:section xml:id="operator-eq-1">
<db:title>QVariant &amp;QVariant::operator=(QVariant &amp;&amp;<db:emphasis>other</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>QVariant &amp;</db:type>
<db:methodname>operator=</db:methodname>
<db:methodparam>
<db:type>QVariant &amp;&amp;</db:type>
<db:parameter>other</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">move-assign</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">QVariant &amp; operator=(QVariant &amp;&amp;other)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Move-assigns <db:code role="parameter">other</db:code> to this <db:link xlink:href="qvariant.xml">QVariant</db:link> instance.</db:para>
</db:section>
</db:section>
<db:section xml:id="related-non-members">
<db:title>Related Non-Members</db:title>
<db:section xml:id="get_if">
<db:title>[since 6.6] T *get_if(QVariant *<db:emphasis>v</db:emphasis>)</db:title>
<db:bridgehead renderas="sect2" xml:id="get_if-1">[since 6.6] const T *get_if(const QVariant *<db:emphasis>v</db:emphasis>)</db:bridgehead>
<db:para>If <db:code role="parameter">v</db:code> contains an object of type T, returns a pointer to the contained object, otherwise returns nullptr.</db:para>
<db:para>The overload taking a mutable <db:code role="parameter">v</db:code> detaches <db:code role="parameter">v</db:code>: When called on a <db:link xlink:href="qvariant.xml#isNull">null</db:link> <db:code role="parameter">v</db:code> with matching type T, <db:code role="parameter">v</db:code> will not be null after the call.</db:para>
<db:para>These functions are provided for compatibility with std::variant.</db:para>
<db:para>This function was introduced in Qt 6.6.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qvariant.xml#data">data</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="get">
<db:title>[constexpr, since 6.6] T &amp;get(QVariant &amp;<db:emphasis>v</db:emphasis>)</db:title>
<db:bridgehead renderas="sect2" xml:id="get-2">[constexpr, since 6.6] T &amp;&amp;get(QVariant &amp;&amp;<db:emphasis>v</db:emphasis>)</db:bridgehead>
<db:bridgehead renderas="sect2" xml:id="get-1">[constexpr, since 6.6] const T &amp;get(const QVariant &amp;<db:emphasis>v</db:emphasis>)</db:bridgehead>
<db:bridgehead renderas="sect2" xml:id="get-3">[constexpr, since 6.6] const T &amp;&amp;get(const QVariant &amp;&amp;<db:emphasis>v</db:emphasis>)</db:bridgehead>
<db:para>If <db:code role="parameter">v</db:code> contains an object of type T, returns a reference to the contained object, otherwise the call has undefined behavior.</db:para>
<db:para>The overloads taking a mutable <db:code role="parameter">v</db:code> detach <db:code role="parameter">v</db:code>: When called on a <db:link xlink:href="qvariant.xml#isNull">null</db:link> <db:code role="parameter">v</db:code> with matching type T, <db:code role="parameter">v</db:code> will not be null after the call.</db:para>
<db:para>These functions are provided for compatibility with std::variant.</db:para>
<db:para>This function was introduced in Qt 6.6.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qvariant.xml#get_if">get_if</db:link>()</db:member>
<db:member><db:link xlink:href="qvariant.xml#data">data</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="QVariantHash-typedef">
<db:title>[alias] QVariantHash</db:title>
<db:typedefsynopsis>
<db:typedefname>QVariantHash</db:typedefname>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:typedefsynopsis>
<db:para>Synonym for <db:link xlink:href="qhash.xml#qhash">QHash</db:link>&lt;<db:link xlink:href="qstring.xml">QString</db:link>, <db:link xlink:href="qvariant.xml">QVariant</db:link>&gt;.</db:para>
</db:section>
<db:section xml:id="QVariantList-typedef">
<db:title>[alias] QVariantList</db:title>
<db:typedefsynopsis>
<db:typedefname>QVariantList</db:typedefname>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:typedefsynopsis>
<db:para>Synonym for <db:link xlink:href="qlist.xml">QList</db:link>&lt;<db:link xlink:href="qvariant.xml">QVariant</db:link>&gt;.</db:para>
</db:section>
<db:section xml:id="QVariantMap-typedef">
<db:title>[alias] QVariantMap</db:title>
<db:typedefsynopsis>
<db:typedefname>QVariantMap</db:typedefname>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:typedefsynopsis>
<db:para>Synonym for <db:link xlink:href="qmap.xml">QMap</db:link>&lt;<db:link xlink:href="qstring.xml">QString</db:link>, <db:link xlink:href="qvariant.xml">QVariant</db:link>&gt;.</db:para>
</db:section>
<db:section xml:id="qvariant_cast">
<db:title>T qvariant_cast(const QVariant &amp;<db:emphasis>value</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>T</db:type>
<db:methodname>qvariant_cast</db:methodname>
<db:methodparam>
<db:type>const QVariant &amp;</db:type>
<db:parameter>value</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">T qvariant_cast(const QVariant &amp;value)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the given <db:code role="parameter">value</db:code> converted to the template type T.</db:para>
<db:para>This function is equivalent to <db:link xlink:href="qvariant.xml#value">QVariant::value</db:link>().</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qvariant.xml#value">QVariant::value</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="qvariant_cast-1">
<db:title>[since 6.7] T qvariant_cast(QVariant &amp;&amp;<db:emphasis>value</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>T</db:type>
<db:methodname>qvariant_cast</db:methodname>
<db:methodparam>
<db:type>QVariant &amp;&amp;</db:type>
<db:parameter>value</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">T qvariant_cast(QVariant &amp;&amp;value)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>Returns the given <db:code role="parameter">value</db:code> converted to the template type T.</db:para>
<db:para>This function was introduced in Qt 6.7.</db:para>
</db:section>
<db:section xml:id="operator-not-eq">
<db:title>bool operator!=(const QVariant &amp;<db:emphasis>v1</db:emphasis>, const QVariant &amp;<db:emphasis>v2</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>bool</db:type>
<db:methodname>operator!=</db:methodname>
<db:methodparam>
<db:type>const QVariant &amp;</db:type>
<db:parameter>v1</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const QVariant &amp;</db:type>
<db:parameter>v2</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool operator!=(const QVariant &amp;v1, const QVariant &amp;v2)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns false if <db:code role="parameter">v1</db:code> and <db:code role="parameter">v2</db:code> are equal; otherwise returns true.</db:para>
<db:para><db:link xlink:href="qvariant.xml">QVariant</db:link> uses the equality operator of the type() contained to check for equality.</db:para>
<db:para>Variants of different types will always compare as not equal with a few exceptions:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para>If both types are numeric types (integers and floatins point numbers) Qt will compare those types using standard C++ type promotion rules.</db:para>
</db:listitem>
<db:listitem>
<db:para>If one type is numeric and the other one a <db:link xlink:href="qstring.xml">QString</db:link>, Qt will try to convert the <db:link xlink:href="qstring.xml">QString</db:link> to a matching numeric type and if successful compare those.</db:para>
</db:listitem>
<db:listitem>
<db:para>If both variants contain pointers to <db:link xlink:href="qobject.xml">QObject</db:link> derived types, <db:link xlink:href="qvariant.xml">QVariant</db:link> will check whether the types are related and point to the same object.</db:para>
</db:listitem>
</db:itemizedlist>
</db:section>
<db:section xml:id="operator-lt-lt-1">
<db:title>QDataStream &amp;operator&lt;&lt;(QDataStream &amp;<db:emphasis>s</db:emphasis>, const QVariant &amp;<db:emphasis>p</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>QDataStream &amp;</db:type>
<db:methodname>operator&lt;&lt;</db:methodname>
<db:methodparam>
<db:type>QDataStream &amp;</db:type>
<db:parameter>s</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const QVariant &amp;</db:type>
<db:parameter>p</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">QDataStream &amp; operator&lt;&lt;(QDataStream &amp;s, const QVariant &amp;p)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Writes a variant <db:code role="parameter">p</db:code> to the stream <db:code role="parameter">s</db:code>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="datastreamformat.xml">Format of the QDataStream operators</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="operator-eq-eq">
<db:title>bool operator==(const QVariant &amp;<db:emphasis>v1</db:emphasis>, const QVariant &amp;<db:emphasis>v2</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>bool</db:type>
<db:methodname>operator==</db:methodname>
<db:methodparam>
<db:type>const QVariant &amp;</db:type>
<db:parameter>v1</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const QVariant &amp;</db:type>
<db:parameter>v2</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool operator==(const QVariant &amp;v1, const QVariant &amp;v2)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns true if <db:code role="parameter">v1</db:code> and <db:code role="parameter">v2</db:code> are equal; otherwise returns false.</db:para>
<db:para><db:link xlink:href="qvariant.xml">QVariant</db:link> uses the equality operator of the type() contained to check for equality.</db:para>
<db:para>Variants of different types will always compare as not equal with a few exceptions:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para>If both types are numeric types (integers and floatins point numbers) Qt will compare those types using standard C++ type promotion rules.</db:para>
</db:listitem>
<db:listitem>
<db:para>If one type is numeric and the other one a <db:link xlink:href="qstring.xml">QString</db:link>, Qt will try to convert the <db:link xlink:href="qstring.xml">QString</db:link> to a matching numeric type and if successful compare those.</db:para>
</db:listitem>
<db:listitem>
<db:para>If both variants contain pointers to <db:link xlink:href="qobject.xml">QObject</db:link> derived types, <db:link xlink:href="qvariant.xml">QVariant</db:link> will check whether the types are related and point to the same object.</db:para>
</db:listitem>
</db:itemizedlist>
<db:para>The result of the function is not affected by the result of <db:link xlink:href="qvariant.xml#isNull">QVariant::isNull</db:link>, which means that two values can be equal even if one of them is null and another is not.</db:para>
</db:section>
<db:section xml:id="operator-gt-gt">
<db:title>QDataStream &amp;operator&gt;&gt;(QDataStream &amp;<db:emphasis>s</db:emphasis>, QVariant &amp;<db:emphasis>p</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>QDataStream &amp;</db:type>
<db:methodname>operator&gt;&gt;</db:methodname>
<db:methodparam>
<db:type>QDataStream &amp;</db:type>
<db:parameter>s</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>QVariant &amp;</db:type>
<db:parameter>p</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QDataStream &amp; operator&gt;&gt;(QDataStream &amp;s, QVariant &amp;p)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Reads a variant <db:code role="parameter">p</db:code> from the stream <db:code role="parameter">s</db:code>.</db:para>
<db:note>
<db:para>If the stream contains types that aren't the built-in ones (see <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::Type</db:link>), those types must be registered using <db:link xlink:href="qmetatype.xml#qRegisterMetaType-3">qRegisterMetaType</db:link>() or <db:link xlink:href="qmetatype.xml#registerType">QMetaType::registerType</db:link>() before the variant can be properly loaded. If an unregistered type is found, <db:link xlink:href="qvariant.xml">QVariant</db:link> will set the corrupt flag in the stream, stop processing and print a warning. For example, for <db:link xlink:href="qlist.xml">QList</db:link>&lt;int&gt; it would print the following:</db:para>
</db:note>
<db:blockquote><db:para>QVariant::load: unknown user type with name <db:link xlink:href="qlist.xml">QList</db:link>&lt;int&gt;</db:para>
</db:blockquote>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="datastreamformat.xml">Format of the QDataStream operators</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
</db:section>
<db:section xml:id="obsolete">
<db:title>Obsolete Members for QVariant</db:title>
<db:para><db:emphasis role="bold">The following members of class <db:link xlink:href="qvariant.xml">QVariant</db:link> are deprecated.</db:emphasis> We strongly advise against using them in new code.</db:para>
<db:section xml:id="obsolete-member-type-documentation">
<db:title>Obsolete Member Type Documentation</db:title>
<db:section xml:id="Type-enum">
<db:title>enum QVariant::Type</db:title>
<db:enumsynopsis>
<db:enumname>Type</db:enumname>
<db:enumitem>
<db:enumidentifier>Invalid</db:enumidentifier>
<db:enumvalue>QMetaType::UnknownType</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>Bool</db:enumidentifier>
<db:enumvalue>QMetaType::Bool</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>Int</db:enumidentifier>
<db:enumvalue>QMetaType::Int</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>UInt</db:enumidentifier>
<db:enumvalue>QMetaType::UInt</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>LongLong</db:enumidentifier>
<db:enumvalue>QMetaType::LongLong</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>ULongLong</db:enumidentifier>
<db:enumvalue>QMetaType::ULongLong</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>Double</db:enumidentifier>
<db:enumvalue>QMetaType::Double</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>Char</db:enumidentifier>
<db:enumvalue>QMetaType::QChar</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>Map</db:enumidentifier>
<db:enumvalue>QMetaType::QVariantMap</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>List</db:enumidentifier>
<db:enumvalue>QMetaType::QVariantList</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>String</db:enumidentifier>
<db:enumvalue>QMetaType::QString</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>StringList</db:enumidentifier>
<db:enumvalue>QMetaType::QStringList</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>ByteArray</db:enumidentifier>
<db:enumvalue>QMetaType::QByteArray</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>BitArray</db:enumidentifier>
<db:enumvalue>QMetaType::QBitArray</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>Date</db:enumidentifier>
<db:enumvalue>QMetaType::QDate</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>Time</db:enumidentifier>
<db:enumvalue>QMetaType::QTime</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>DateTime</db:enumidentifier>
<db:enumvalue>QMetaType::QDateTime</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>Url</db:enumidentifier>
<db:enumvalue>QMetaType::QUrl</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>Locale</db:enumidentifier>
<db:enumvalue>QMetaType::QLocale</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>Rect</db:enumidentifier>
<db:enumvalue>QMetaType::QRect</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>RectF</db:enumidentifier>
<db:enumvalue>QMetaType::QRectF</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>Size</db:enumidentifier>
<db:enumvalue>QMetaType::QSize</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>SizeF</db:enumidentifier>
<db:enumvalue>QMetaType::QSizeF</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>Line</db:enumidentifier>
<db:enumvalue>QMetaType::QLine</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>LineF</db:enumidentifier>
<db:enumvalue>QMetaType::QLineF</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>Point</db:enumidentifier>
<db:enumvalue>QMetaType::QPoint</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>PointF</db:enumidentifier>
<db:enumvalue>QMetaType::QPointF</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>RegularExpression</db:enumidentifier>
<db:enumvalue>QMetaType::QRegularExpression</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>Hash</db:enumidentifier>
<db:enumvalue>QMetaType::QVariantHash</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>EasingCurve</db:enumidentifier>
<db:enumvalue>QMetaType::QEasingCurve</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>Uuid</db:enumidentifier>
<db:enumvalue>QMetaType::QUuid</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>ModelIndex</db:enumidentifier>
<db:enumvalue>QMetaType::QModelIndex</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>PersistentModelIndex</db:enumidentifier>
<db:enumvalue>QMetaType::QPersistentModelIndex</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>LastCoreType</db:enumidentifier>
<db:enumvalue>51</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>Font</db:enumidentifier>
<db:enumvalue>QMetaType::QFont</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>Pixmap</db:enumidentifier>
<db:enumvalue>QMetaType::QPixmap</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>Brush</db:enumidentifier>
<db:enumvalue>QMetaType::QBrush</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>Color</db:enumidentifier>
<db:enumvalue>QMetaType::QColor</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>Palette</db:enumidentifier>
<db:enumvalue>QMetaType::QPalette</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>Image</db:enumidentifier>
<db:enumvalue>QMetaType::QImage</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>Polygon</db:enumidentifier>
<db:enumvalue>QMetaType::QPolygon</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>Region</db:enumidentifier>
<db:enumvalue>QMetaType::QRegion</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>Bitmap</db:enumidentifier>
<db:enumvalue>QMetaType::QBitmap</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>Cursor</db:enumidentifier>
<db:enumvalue>QMetaType::QCursor</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>KeySequence</db:enumidentifier>
<db:enumvalue>QMetaType::QKeySequence</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>Pen</db:enumidentifier>
<db:enumvalue>QMetaType::QPen</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>TextLength</db:enumidentifier>
<db:enumvalue>QMetaType::QTextLength</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>TextFormat</db:enumidentifier>
<db:enumvalue>QMetaType::QTextFormat</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>Transform</db:enumidentifier>
<db:enumvalue>QMetaType::QTransform</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>Matrix4x4</db:enumidentifier>
<db:enumvalue>QMetaType::QMatrix4x4</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>Vector2D</db:enumidentifier>
<db:enumvalue>QMetaType::QVector2D</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>Vector3D</db:enumidentifier>
<db:enumvalue>QMetaType::QVector3D</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>Vector4D</db:enumidentifier>
<db:enumvalue>QMetaType::QVector4D</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>Quaternion</db:enumidentifier>
<db:enumvalue>QMetaType::QQuaternion</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>PolygonF</db:enumidentifier>
<db:enumvalue>QMetaType::QPolygonF</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>Icon</db:enumidentifier>
<db:enumvalue>QMetaType::QIcon</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>LastGuiType</db:enumidentifier>
<db:enumvalue>4102</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>SizePolicy</db:enumidentifier>
<db:enumvalue>QMetaType::QSizePolicy</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>UserType</db:enumidentifier>
<db:enumvalue>QMetaType::User</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>LastType</db:enumidentifier>
<db:enumvalue>0xffffffff</db:enumvalue>
</db:enumitem>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">deprecated</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:enumsynopsis>
<db:para>This enum is deprecated. We strongly advise against using it in new code.</db:para>
<db:para>Use <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::Type</db:link> instead.</db:para>
<db:para>This enum type defines the types of variable that a <db:link xlink:href="qvariant.xml">QVariant</db:link> can contain.</db:para>
<db:informaltable>
<db:thead>
<db:tr>
<db:th>Constant</db:th>
<db:th>Value</db:th>
<db:th>Description</db:th>
</db:tr>
</db:thead>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qvariant.xml">QVariant</db:link></db:emphasis>::Invalid</db:code></db:para>
</db:td>
<db:td><db:code>QMetaType::UnknownType</db:code></db:td>
<db:td>
<db:para>no type</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qvariant.xml">QVariant</db:link></db:emphasis>::BitArray</db:code></db:para>
</db:td>
<db:td><db:code>QMetaType::QBitArray</db:code></db:td>
<db:td>
<db:para>a <db:link xlink:href="qbitarray.xml">QBitArray</db:link></db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qvariant.xml">QVariant</db:link></db:emphasis>::Bitmap</db:code></db:para>
</db:td>
<db:td><db:code>QMetaType::QBitmap</db:code></db:td>
<db:td>
<db:para>a <db:link xlink:href="qbitmap.xml">QBitmap</db:link></db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qvariant.xml">QVariant</db:link></db:emphasis>::Bool</db:code></db:para>
</db:td>
<db:td><db:code>QMetaType::Bool</db:code></db:td>
<db:td>
<db:para>a bool</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qvariant.xml">QVariant</db:link></db:emphasis>::Brush</db:code></db:para>
</db:td>
<db:td><db:code>QMetaType::QBrush</db:code></db:td>
<db:td>
<db:para>a <db:link xlink:href="qbrush.xml">QBrush</db:link></db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qvariant.xml">QVariant</db:link></db:emphasis>::ByteArray</db:code></db:para>
</db:td>
<db:td><db:code>QMetaType::QByteArray</db:code></db:td>
<db:td>
<db:para>a <db:link xlink:href="qbytearray.xml">QByteArray</db:link></db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qvariant.xml">QVariant</db:link></db:emphasis>::Char</db:code></db:para>
</db:td>
<db:td><db:code>QMetaType::QChar</db:code></db:td>
<db:td>
<db:para>a <db:link xlink:href="qchar.xml">QChar</db:link></db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qvariant.xml">QVariant</db:link></db:emphasis>::Color</db:code></db:para>
</db:td>
<db:td><db:code>QMetaType::QColor</db:code></db:td>
<db:td>
<db:para>a <db:link xlink:href="qcolor.xml">QColor</db:link></db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qvariant.xml">QVariant</db:link></db:emphasis>::Cursor</db:code></db:para>
</db:td>
<db:td><db:code>QMetaType::QCursor</db:code></db:td>
<db:td>
<db:para>a <db:link xlink:href="qcursor.xml">QCursor</db:link></db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qvariant.xml">QVariant</db:link></db:emphasis>::Date</db:code></db:para>
</db:td>
<db:td><db:code>QMetaType::QDate</db:code></db:td>
<db:td>
<db:para>a <db:link xlink:href="qdate.xml">QDate</db:link></db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qvariant.xml">QVariant</db:link></db:emphasis>::DateTime</db:code></db:para>
</db:td>
<db:td><db:code>QMetaType::QDateTime</db:code></db:td>
<db:td>
<db:para>a <db:link xlink:href="qdatetime.xml">QDateTime</db:link></db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qvariant.xml">QVariant</db:link></db:emphasis>::Double</db:code></db:para>
</db:td>
<db:td><db:code>QMetaType::Double</db:code></db:td>
<db:td>
<db:para>a double</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qvariant.xml">QVariant</db:link></db:emphasis>::EasingCurve</db:code></db:para>
</db:td>
<db:td><db:code>QMetaType::QEasingCurve</db:code></db:td>
<db:td>
<db:para>a <db:link xlink:href="qeasingcurve.xml">QEasingCurve</db:link></db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qvariant.xml">QVariant</db:link></db:emphasis>::Uuid</db:code></db:para>
</db:td>
<db:td><db:code>QMetaType::QUuid</db:code></db:td>
<db:td>
<db:para>a <db:link xlink:href="quuid.xml">QUuid</db:link></db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qvariant.xml">QVariant</db:link></db:emphasis>::ModelIndex</db:code></db:para>
</db:td>
<db:td><db:code>QMetaType::QModelIndex</db:code></db:td>
<db:td>
<db:para>a <db:link xlink:href="qmodelindex.xml">QModelIndex</db:link></db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qvariant.xml">QVariant</db:link></db:emphasis>::PersistentModelIndex (since Qt 5.5)</db:code></db:para>
</db:td>
<db:td><db:code>QMetaType::QPersistentModelIndex</db:code></db:td>
<db:td>
<db:para>a <db:link xlink:href="qpersistentmodelindex.xml">QPersistentModelIndex</db:link></db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qvariant.xml">QVariant</db:link></db:emphasis>::Font</db:code></db:para>
</db:td>
<db:td><db:code>QMetaType::QFont</db:code></db:td>
<db:td>
<db:para>a <db:link xlink:href="qfont.xml">QFont</db:link></db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qvariant.xml">QVariant</db:link></db:emphasis>::Hash</db:code></db:para>
</db:td>
<db:td><db:code>QMetaType::QVariantHash</db:code></db:td>
<db:td>
<db:para>a <db:link xlink:href="qvariant.xml#QVariantHash-typedef">QVariantHash</db:link></db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qvariant.xml">QVariant</db:link></db:emphasis>::Icon</db:code></db:para>
</db:td>
<db:td><db:code>QMetaType::QIcon</db:code></db:td>
<db:td>
<db:para>a <db:link xlink:href="qicon.xml">QIcon</db:link></db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qvariant.xml">QVariant</db:link></db:emphasis>::Image</db:code></db:para>
</db:td>
<db:td><db:code>QMetaType::QImage</db:code></db:td>
<db:td>
<db:para>a <db:link xlink:href="qimage.xml">QImage</db:link></db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qvariant.xml">QVariant</db:link></db:emphasis>::Int</db:code></db:para>
</db:td>
<db:td><db:code>QMetaType::Int</db:code></db:td>
<db:td>
<db:para>an int</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qvariant.xml">QVariant</db:link></db:emphasis>::KeySequence</db:code></db:para>
</db:td>
<db:td><db:code>QMetaType::QKeySequence</db:code></db:td>
<db:td>
<db:para>a <db:link xlink:href="qkeysequence.xml">QKeySequence</db:link></db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qvariant.xml">QVariant</db:link></db:emphasis>::Line</db:code></db:para>
</db:td>
<db:td><db:code>QMetaType::QLine</db:code></db:td>
<db:td>
<db:para>a <db:link xlink:href="qline.xml">QLine</db:link></db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qvariant.xml">QVariant</db:link></db:emphasis>::LineF</db:code></db:para>
</db:td>
<db:td><db:code>QMetaType::QLineF</db:code></db:td>
<db:td>
<db:para>a <db:link xlink:href="qlinef.xml">QLineF</db:link></db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qvariant.xml">QVariant</db:link></db:emphasis>::List</db:code></db:para>
</db:td>
<db:td><db:code>QMetaType::QVariantList</db:code></db:td>
<db:td>
<db:para>a <db:link xlink:href="qvariant.xml#QVariantList-typedef">QVariantList</db:link></db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qvariant.xml">QVariant</db:link></db:emphasis>::Locale</db:code></db:para>
</db:td>
<db:td><db:code>QMetaType::QLocale</db:code></db:td>
<db:td>
<db:para>a <db:link xlink:href="qlocale.xml">QLocale</db:link></db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qvariant.xml">QVariant</db:link></db:emphasis>::LongLong</db:code></db:para>
</db:td>
<db:td><db:code>QMetaType::LongLong</db:code></db:td>
<db:td>
<db:para>a <db:link xlink:href="qttypes.xml#qlonglong-typedef">qlonglong</db:link></db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qvariant.xml">QVariant</db:link></db:emphasis>::Map</db:code></db:para>
</db:td>
<db:td><db:code>QMetaType::QVariantMap</db:code></db:td>
<db:td>
<db:para>a <db:link xlink:href="qvariant.xml#QVariantMap-typedef">QVariantMap</db:link></db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qvariant.xml">QVariant</db:link></db:emphasis>::Transform</db:code></db:para>
</db:td>
<db:td><db:code>QMetaType::QTransform</db:code></db:td>
<db:td>
<db:para>a <db:link xlink:href="qtransform.xml">QTransform</db:link></db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qvariant.xml">QVariant</db:link></db:emphasis>::Matrix4x4</db:code></db:para>
</db:td>
<db:td><db:code>QMetaType::QMatrix4x4</db:code></db:td>
<db:td>
<db:para>a <db:link xlink:href="qmatrix4x4.xml">QMatrix4x4</db:link></db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qvariant.xml">QVariant</db:link></db:emphasis>::Palette</db:code></db:para>
</db:td>
<db:td><db:code>QMetaType::QPalette</db:code></db:td>
<db:td>
<db:para>a <db:link xlink:href="qpalette.xml">QPalette</db:link></db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qvariant.xml">QVariant</db:link></db:emphasis>::Pen</db:code></db:para>
</db:td>
<db:td><db:code>QMetaType::QPen</db:code></db:td>
<db:td>
<db:para>a <db:link xlink:href="qpen.xml">QPen</db:link></db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qvariant.xml">QVariant</db:link></db:emphasis>::Pixmap</db:code></db:para>
</db:td>
<db:td><db:code>QMetaType::QPixmap</db:code></db:td>
<db:td>
<db:para>a <db:link xlink:href="qpixmap.xml">QPixmap</db:link></db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qvariant.xml">QVariant</db:link></db:emphasis>::Point</db:code></db:para>
</db:td>
<db:td><db:code>QMetaType::QPoint</db:code></db:td>
<db:td>
<db:para>a <db:link xlink:href="qpoint.xml">QPoint</db:link></db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qvariant.xml">QVariant</db:link></db:emphasis>::PointF</db:code></db:para>
</db:td>
<db:td><db:code>QMetaType::QPointF</db:code></db:td>
<db:td>
<db:para>a <db:link xlink:href="qpointf.xml">QPointF</db:link></db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qvariant.xml">QVariant</db:link></db:emphasis>::Polygon</db:code></db:para>
</db:td>
<db:td><db:code>QMetaType::QPolygon</db:code></db:td>
<db:td>
<db:para>a <db:link xlink:href="qpolygon.xml">QPolygon</db:link></db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qvariant.xml">QVariant</db:link></db:emphasis>::PolygonF</db:code></db:para>
</db:td>
<db:td><db:code>QMetaType::QPolygonF</db:code></db:td>
<db:td>
<db:para>a <db:link xlink:href="qpolygonf.xml">QPolygonF</db:link></db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qvariant.xml">QVariant</db:link></db:emphasis>::Quaternion</db:code></db:para>
</db:td>
<db:td><db:code>QMetaType::QQuaternion</db:code></db:td>
<db:td>
<db:para>a <db:link xlink:href="qquaternion.xml">QQuaternion</db:link></db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qvariant.xml">QVariant</db:link></db:emphasis>::Rect</db:code></db:para>
</db:td>
<db:td><db:code>QMetaType::QRect</db:code></db:td>
<db:td>
<db:para>a <db:link xlink:href="qrect.xml">QRect</db:link></db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qvariant.xml">QVariant</db:link></db:emphasis>::RectF</db:code></db:para>
</db:td>
<db:td><db:code>QMetaType::QRectF</db:code></db:td>
<db:td>
<db:para>a <db:link xlink:href="qrectf.xml">QRectF</db:link></db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qvariant.xml">QVariant</db:link></db:emphasis>::RegularExpression</db:code></db:para>
</db:td>
<db:td><db:code>QMetaType::QRegularExpression</db:code></db:td>
<db:td>
<db:para>a <db:link xlink:href="qregularexpression.xml">QRegularExpression</db:link></db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qvariant.xml">QVariant</db:link></db:emphasis>::Region</db:code></db:para>
</db:td>
<db:td><db:code>QMetaType::QRegion</db:code></db:td>
<db:td>
<db:para>a <db:link xlink:href="qregion.xml">QRegion</db:link></db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qvariant.xml">QVariant</db:link></db:emphasis>::Size</db:code></db:para>
</db:td>
<db:td><db:code>QMetaType::QSize</db:code></db:td>
<db:td>
<db:para>a <db:link xlink:href="qsize.xml">QSize</db:link></db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qvariant.xml">QVariant</db:link></db:emphasis>::SizeF</db:code></db:para>
</db:td>
<db:td><db:code>QMetaType::QSizeF</db:code></db:td>
<db:td>
<db:para>a <db:link xlink:href="qsizef.xml">QSizeF</db:link></db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qvariant.xml">QVariant</db:link></db:emphasis>::SizePolicy</db:code></db:para>
</db:td>
<db:td><db:code>QMetaType::QSizePolicy</db:code></db:td>
<db:td>
<db:para>a <db:link xlink:href="qsizepolicy.xml">QSizePolicy</db:link></db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qvariant.xml">QVariant</db:link></db:emphasis>::String</db:code></db:para>
</db:td>
<db:td><db:code>QMetaType::QString</db:code></db:td>
<db:td>
<db:para>a <db:link xlink:href="qstring.xml">QString</db:link></db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qvariant.xml">QVariant</db:link></db:emphasis>::StringList</db:code></db:para>
</db:td>
<db:td><db:code>QMetaType::QStringList</db:code></db:td>
<db:td>
<db:para>a <db:link xlink:href="qstringlist.xml">QStringList</db:link></db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qvariant.xml">QVariant</db:link></db:emphasis>::TextFormat</db:code></db:para>
</db:td>
<db:td><db:code>QMetaType::QTextFormat</db:code></db:td>
<db:td>
<db:para>a <db:link xlink:href="qtextformat.xml">QTextFormat</db:link></db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qvariant.xml">QVariant</db:link></db:emphasis>::TextLength</db:code></db:para>
</db:td>
<db:td><db:code>QMetaType::QTextLength</db:code></db:td>
<db:td>
<db:para>a <db:link xlink:href="qtextlength.xml">QTextLength</db:link></db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qvariant.xml">QVariant</db:link></db:emphasis>::Time</db:code></db:para>
</db:td>
<db:td><db:code>QMetaType::QTime</db:code></db:td>
<db:td>
<db:para>a <db:link xlink:href="qtime.xml">QTime</db:link></db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qvariant.xml">QVariant</db:link></db:emphasis>::UInt</db:code></db:para>
</db:td>
<db:td><db:code>QMetaType::UInt</db:code></db:td>
<db:td>
<db:para>a <db:link xlink:href="qttypes.xml#uint-typedef">uint</db:link></db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qvariant.xml">QVariant</db:link></db:emphasis>::ULongLong</db:code></db:para>
</db:td>
<db:td><db:code>QMetaType::ULongLong</db:code></db:td>
<db:td>
<db:para>a <db:link xlink:href="qttypes.xml#qulonglong-typedef">qulonglong</db:link></db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qvariant.xml">QVariant</db:link></db:emphasis>::Url</db:code></db:para>
</db:td>
<db:td><db:code>QMetaType::QUrl</db:code></db:td>
<db:td>
<db:para>a <db:link xlink:href="qurl.xml">QUrl</db:link></db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qvariant.xml">QVariant</db:link></db:emphasis>::Vector2D</db:code></db:para>
</db:td>
<db:td><db:code>QMetaType::QVector2D</db:code></db:td>
<db:td>
<db:para>a <db:link xlink:href="qvector2d.xml">QVector2D</db:link></db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qvariant.xml">QVariant</db:link></db:emphasis>::Vector3D</db:code></db:para>
</db:td>
<db:td><db:code>QMetaType::QVector3D</db:code></db:td>
<db:td>
<db:para>a <db:link xlink:href="qvector3d.xml">QVector3D</db:link></db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qvariant.xml">QVariant</db:link></db:emphasis>::Vector4D</db:code></db:para>
</db:td>
<db:td><db:code>QMetaType::QVector4D</db:code></db:td>
<db:td>
<db:para>a <db:link xlink:href="qvector4d.xml">QVector4D</db:link></db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qvariant.xml">QVariant</db:link></db:emphasis>::UserType</db:code></db:para>
</db:td>
<db:td><db:code>QMetaType::User</db:code></db:td>
<db:td>
<db:para>Base value for user-defined types.</db:para>
</db:td>
</db:tr>
</db:informaltable>
</db:section>
</db:section>
<db:section xml:id="obsolete-member-function-documentation">
<db:title>Obsolete Member Function Documentation</db:title>
<db:section xml:id="QVariant-46">
<db:title>[explicit] QVariant::QVariant(QVariant::Type <db:emphasis>type</db:emphasis>)</db:title>
<db:constructorsynopsis>
<db:methodname>QVariant</db:methodname>
<db:methodparam>
<db:type>QVariant::Type</db:type>
<db:parameter>type</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">constructor</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">46</db:synopsisinfo>
<db:synopsisinfo role="signature">QVariant(QVariant::Type type)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">deprecated</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:constructorsynopsis>
<db:para>This function is deprecated since 6.0. We strongly advise against using it in new code.</db:para>
<db:para>Use the constructor taking a <db:link xlink:href="qmetatype.xml">QMetaType</db:link> instead.</db:para>
<db:para>Constructs an uninitialized variant of type <db:code role="parameter">type</db:code>. This will create a variant in a special null state that if accessed will return a default constructed value of the <db:code role="parameter">type</db:code>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qvariant.xml#isNull">isNull</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="canConvert-1">
<db:title>bool QVariant::canConvert(int <db:emphasis>targetTypeId</db:emphasis>) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>bool</db:type>
<db:methodname>canConvert</db:methodname>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>targetTypeId</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">bool canConvert(int targetTypeId) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">deprecated</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This function is deprecated since 6.0. We strongly advise against using it in new code.</db:para>
<db:para>This is an overloaded function.</db:para>
<db:para>Use canConvert(QMetaType(targetTypeId)) instead.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qmetatype.xml#canConvert">QMetaType::canConvert</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="convert-1">
<db:title>bool QVariant::convert(int <db:emphasis>targetTypeId</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>bool</db:type>
<db:methodname>convert</db:methodname>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>targetTypeId</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">bool convert(int targetTypeId)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">deprecated</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This function is deprecated since 6.0. We strongly advise against using it in new code.</db:para>
<db:para>Use convert(QMetaType(targetTypeId)) instead.</db:para>
<db:para>Casts the variant to the requested type, <db:code role="parameter">targetTypeId</db:code>. If the cast cannot be done, the variant is still changed to the requested type, but is left in a cleared null state similar to that constructed by <db:link xlink:href="qvariant.xml">QVariant</db:link>(Type).</db:para>
<db:para>Returns true if the current type of the variant was successfully cast; otherwise returns false.</db:para>
<db:para>A <db:link xlink:href="qvariant.xml">QVariant</db:link> containing a pointer to a type derived from <db:link xlink:href="qobject.xml">QObject</db:link> will also convert and return true for this function if a <db:link xlink:href="qobject.xml#qobject_cast-1">qobject_cast</db:link> to the type described by <db:code role="parameter">targetTypeId</db:code> would succeed. Note that this only works for <db:link xlink:href="qobject.xml">QObject</db:link> subclasses which use the <db:link xlink:href="qobject.xml#Q_OBJECT">Q_OBJECT</db:link> macro.</db:para>
<db:note>
<db:para>converting QVariants that are null due to not being initialized or having failed a previous conversion will always fail, changing the type, remaining null, and returning false.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qvariant.xml#canConvert-2">canConvert</db:link>()</db:member>
<db:member><db:link xlink:href="qvariant.xml#clear">clear</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="nameToType">
<db:title>[static] QVariant::Type QVariant::nameToType(const char *<db:emphasis>name</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:modifier>static</db:modifier>
<db:type>QVariant::Type</db:type>
<db:methodname>nameToType</db:methodname>
<db:methodparam>
<db:type>const char *</db:type>
<db:parameter>name</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QVariant::Type nameToType(const char *name)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">deprecated</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This function is deprecated since 6.0. We strongly advise against using it in new code.</db:para>
<db:para>Use QMetaType::fromName(name).id() instead</db:para>
<db:para>Converts the string representation of the storage type given in <db:code role="parameter">name</db:code>, to its enum representation.</db:para>
<db:para>If the string representation cannot be converted to any enum representation, the variant is set to Invalid.</db:para>
</db:section>
<db:section xml:id="type">
<db:title>QVariant::Type QVariant::type() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QVariant::Type</db:type>
<db:methodname>type</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QVariant::Type type() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">deprecated</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This function is deprecated since 6.0. We strongly advise against using it in new code.</db:para>
<db:para>Use <db:link xlink:href="qvariant.xml#typeId">typeId</db:link>() or <db:link xlink:href="qvariant.xml#metaType">metaType</db:link>() instead.</db:para>
<db:para>Returns the storage type of the value stored in the variant. Although this function is declared as returning <db:link xlink:href="qvariant.xml#Type-enum">QVariant::Type</db:link>, the return value should be interpreted as <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::Type</db:link>. In particular, <db:link xlink:href="qvariant.xml#Type-enum">QVariant::UserType</db:link> is returned here only if the value is equal or greater than <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::User</db:link>.</db:para>
<db:para>Note that return values in the ranges <db:link xlink:href="qvariant.xml#Type-enum">QVariant::Char</db:link> through QVariant::RegExp and <db:link xlink:href="qvariant.xml#Type-enum">QVariant::Font</db:link> through <db:link xlink:href="qvariant.xml#Type-enum">QVariant::Transform</db:link> correspond to the values in the ranges <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QChar</db:link> through <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QRegularExpression</db:link> and <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QFont</db:link> through <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QQuaternion</db:link>.</db:para>
<db:para>Pay particular attention when working with char and <db:link xlink:href="qchar.xml">QChar</db:link> variants. Note that there is no <db:link xlink:href="qvariant.xml">QVariant</db:link> constructor specifically for type char, but there is one for <db:link xlink:href="qchar.xml">QChar</db:link>. For a variant of type <db:link xlink:href="qchar.xml">QChar</db:link>, this function returns <db:link xlink:href="qvariant.xml#Type-enum">QVariant::Char</db:link>, which is the same as <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QChar</db:link>, but for a variant of type char, this function returns <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::Char</db:link>, which is <db:emphasis>not</db:emphasis> the same as <db:link xlink:href="qvariant.xml#Type-enum">QVariant::Char</db:link>.</db:para>
<db:para>Also note that the types void*, long, short, unsigned long, unsigned short, unsigned char, float, QObject*, and QWidget* are represented in <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::Type</db:link> but not in <db:link xlink:href="qvariant.xml#Type-enum">QVariant::Type</db:link>, and they can be returned by this function. However, they are considered to be user defined types when tested against <db:link xlink:href="qvariant.xml#Type-enum">QVariant::Type</db:link>.</db:para>
<db:para>To test whether an instance of <db:link xlink:href="qvariant.xml">QVariant</db:link> contains a data type that is compatible with the data type you are interested in, use <db:link xlink:href="qvariant.xml#canConvert-2">canConvert</db:link>().</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qvariant.xml#userType">userType</db:link>()</db:member>
<db:member><db:link xlink:href="qvariant.xml#metaType">metaType</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="typeToName">
<db:title>[static] const char *QVariant::typeToName(int <db:emphasis>typeId</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:modifier>static</db:modifier>
<db:type>const char *</db:type>
<db:methodname>typeToName</db:methodname>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>typeId</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">const char * typeToName(int typeId)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">deprecated</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This function is deprecated since 6.0. We strongly advise against using it in new code.</db:para>
<db:para>Use QMetaType(typeId).name() instead.</db:para>
<db:para>Converts the int representation of the storage type, <db:code role="parameter">typeId</db:code>, to its string representation.</db:para>
<db:para>Returns nullptr if the type is <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::UnknownType</db:link> or doesn't exist.</db:para>
</db:section>
</db:section>
<db:section xml:id="obsolete-related-non-members">
<db:title>Obsolete Related Non-Members</db:title>
<db:section xml:id="operator-lt-lt-2">
<db:title>QDataStream &amp;operator&lt;&lt;(QDataStream &amp;<db:emphasis>s</db:emphasis>, const QVariant::Type <db:emphasis>p</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>QDataStream &amp;</db:type>
<db:methodname>operator&lt;&lt;</db:methodname>
<db:methodparam>
<db:type>QDataStream &amp;</db:type>
<db:parameter>s</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const QVariant::Type</db:type>
<db:parameter>p</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">2</db:synopsisinfo>
<db:synopsisinfo role="signature">QDataStream &amp; operator&lt;&lt;(QDataStream &amp;s, const QVariant::Type p)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">deprecated</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This function is deprecated since 6.0. We strongly advise against using it in new code.</db:para>
<db:para>Stream <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::Type</db:link> instead.</db:para>
<db:para>Writes a variant type <db:code role="parameter">p</db:code> to the stream <db:code role="parameter">s</db:code>.</db:para>
</db:section>
<db:section xml:id="operator-gt-gt-1">
<db:title>QDataStream &amp;operator&gt;&gt;(QDataStream &amp;<db:emphasis>s</db:emphasis>, QVariant::Type &amp;<db:emphasis>p</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>QDataStream &amp;</db:type>
<db:methodname>operator&gt;&gt;</db:methodname>
<db:methodparam>
<db:type>QDataStream &amp;</db:type>
<db:parameter>s</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>QVariant::Type &amp;</db:type>
<db:parameter>p</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">QDataStream &amp; operator&gt;&gt;(QDataStream &amp;s, QVariant::Type &amp;p)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">deprecated</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This function is deprecated since 6.0. We strongly advise against using it in new code.</db:para>
<db:para>Stream <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::Type</db:link> instead.</db:para>
<db:para>Reads a variant type <db:code role="parameter">p</db:code> in enum representation from the stream <db:code role="parameter">s</db:code>.</db:para>
</db:section>
</db:section>
</db:section>
</db:article>
