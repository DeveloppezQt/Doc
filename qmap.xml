<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en">
<db:info>
<db:title>QMap Class</db:title>
<db:subtitle>template &lt;typename Key, typename T&gt; class QMap</db:subtitle>
<db:productname>QtCore</db:productname>
<db:edition>Qt 6.8.3 Reference Documentation</db:edition>
<db:titleabbrev>Qt Core Reference Documentation</db:titleabbrev>
<db:abstract>
<db:para>The <db:link xlink:href="qmap.xml">QMap</db:link> class is a template class that provides an associative array.</db:para>
<db:note>
<db:para>All functions in this class are reentrant.</db:para>
</db:note>
</db:abstract>
<db:pubdate>2025-06-29</db:pubdate>
<db:date>2025-06-29</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:variablelist>
<db:varlistentry>
<db:term>Header</db:term>
<db:listitem>
<db:para>QMap</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>CMake</db:term>
<db:listitem>
<db:para>find_package(Qt6 REQUIRED COMPONENTS Core)</db:para>
<db:para>target_link_libraries(mytarget PRIVATE Qt6::Core)</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>qmake</db:term>
<db:listitem>
<db:para>QT += core</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Group</db:term>
<db:listitem>
<db:para>QMap is part of <db:simplelist><db:member>tools</db:member><db:member><db:link xlink:href="shared.xml">Implicitly Shared Classes</db:link></db:member></db:simplelist>
</db:para>
</db:listitem>
</db:varlistentry>
</db:variablelist>
<db:section xml:id="details">
<db:title>Detailed Description</db:title>
<db:para><db:link xlink:href="qmap.xml">QMap</db:link>&lt;Key, T&gt; is one of Qt's generic <db:link xlink:href="containers.xml">container classes</db:link>. It stores (key, value) pairs and provides fast lookup by key.</db:para>
<db:para><db:link xlink:href="qmap.xml">QMap</db:link> and <db:link xlink:href="qhash.xml#the-hashing-function">QHash</db:link> provide very similar functionality. The differences are:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:link xlink:href="qhash.xml#the-hashing-function">QHash</db:link> provides average faster lookups than <db:link xlink:href="qmap.xml">QMap</db:link>. (See <db:link xlink:href="containers.xml#algorithmic-complexity">Algorithmic Complexity</db:link> for details.)</db:para>
</db:listitem>
<db:listitem>
<db:para>When iterating over a <db:link xlink:href="qhash.xml#the-hashing-function">QHash</db:link>, the items are arbitrarily ordered. With <db:link xlink:href="qmap.xml">QMap</db:link>, the items are always sorted by key.</db:para>
</db:listitem>
<db:listitem>
<db:para>The key type of a <db:link xlink:href="qhash.xml#the-hashing-function">QHash</db:link> must provide operator==() and a global <db:link xlink:href="qhash.xml#the-hashing-function">qHash</db:link>(Key) function. The key type of a <db:link xlink:href="qmap.xml">QMap</db:link> must provide operator&lt;() specifying a total order. Since Qt 5.8.1 it is also safe to use a pointer type as key, even if the underlying operator&lt;() does not provide a total order.</db:para>
</db:listitem>
</db:itemizedlist>
<db:para>Here's an example <db:link xlink:href="qmap.xml">QMap</db:link> with <db:link xlink:href="qstring.xml">QString</db:link> keys and int values:</db:para>
<db:programlisting language="cpp">QMap&lt;QString, int&gt; map;
</db:programlisting>
<db:para>To insert a (key, value) pair into the map, you can use operator[]():</db:para>
<db:programlisting language="cpp">map[&quot;one&quot;] = 1;
map[&quot;three&quot;] = 3;
map[&quot;seven&quot;] = 7;
</db:programlisting>
<db:para>This inserts the following three (key, value) pairs into the <db:link xlink:href="qmap.xml">QMap</db:link>: (&quot;one&quot;, 1), (&quot;three&quot;, 3), and (&quot;seven&quot;, 7). Another way to insert items into the map is to use <db:link xlink:href="qmap.xml#insert">insert</db:link>():</db:para>
<db:programlisting language="cpp">map.insert(&quot;twelve&quot;, 12);
</db:programlisting>
<db:para>To look up a value, use operator[]() or <db:link xlink:href="qmap.xml#value">value</db:link>():</db:para>
<db:programlisting language="cpp">int num1 = map[&quot;thirteen&quot;];
int num2 = map.value(&quot;thirteen&quot;);
</db:programlisting>
<db:para>If there is no item with the specified key in the map, these functions return a <db:link xlink:href="containers.xml#default-constructed-value">default-constructed value</db:link>.</db:para>
<db:para>If you want to check whether the map contains a certain key, use <db:link xlink:href="qmap.xml#contains">contains</db:link>():</db:para>
<db:programlisting language="cpp">int timeout = 30;
if (map.contains(&quot;TIMEOUT&quot;))
    timeout = map.value(&quot;TIMEOUT&quot;);
</db:programlisting>
<db:para>There is also a <db:link xlink:href="qmap.xml#value">value</db:link>() overload that uses its second argument as a default value if there is no item with the specified key:</db:para>
<db:programlisting language="cpp">int timeout = map.value(&quot;TIMEOUT&quot;, 30);
</db:programlisting>
<db:para>In general, we recommend that you use <db:link xlink:href="qmap.xml#contains">contains</db:link>() and <db:link xlink:href="qmap.xml#value">value</db:link>() rather than operator[]() for looking up a key in a map. The reason is that operator[]() silently inserts an item into the map if no item exists with the same key (unless the map is const). For example, the following code snippet will create 1000 items in memory:</db:para>
<db:programlisting language="cpp">// WRONG
QMap&lt;int, QWidget *&gt; map;
...
for (int i = 0; i &lt; 1000; ++i) {
    if (map[i] == okButton)
        cout &lt;&lt; &quot;Found button at index &quot; &lt;&lt; i &lt;&lt; endl;
}
</db:programlisting>
<db:para>To avoid this problem, replace map[i] with map.value(i) in the code above.</db:para>
<db:para>If you want to navigate through all the (key, value) pairs stored in a <db:link xlink:href="qmap.xml">QMap</db:link>, you can use an iterator. <db:link xlink:href="qmap.xml">QMap</db:link> provides both <db:link xlink:href="java-style-iterators.xml#java-style-iterators">Java-style iterators</db:link> (<db:link xlink:href="qmapiterator.xml">QMapIterator</db:link> and <db:link xlink:href="qmutablemapiterator.xml">QMutableMapIterator</db:link>) and <db:link xlink:href="containers.xml#stl-style-iterators">STL-style iterators</db:link> (<db:link xlink:href="qmap-const-iterator.xml">QMap::const_iterator</db:link> and <db:link xlink:href="qmap-iterator.xml">QMap::iterator</db:link>). Here's how to iterate over a <db:link xlink:href="qmap.xml">QMap</db:link>&lt;<db:link xlink:href="qstring.xml">QString</db:link>, int&gt; using a Java-style iterator:</db:para>
<db:programlisting language="cpp">QMapIterator&lt;QString, int&gt; i(map);
while (i.hasNext()) {
    i.next();
    cout &lt;&lt; qPrintable(i.key()) &lt;&lt; &quot;: &quot; &lt;&lt; i.value() &lt;&lt; endl;
}
</db:programlisting>
<db:para>Here's the same code, but using an STL-style iterator this time:</db:para>
<db:programlisting language="cpp">for (auto i = map.cbegin(), end = map.cend(); i != end; ++i)
    cout &lt;&lt; qPrintable(i.key()) &lt;&lt; &quot;: &quot; &lt;&lt; i.value() &lt;&lt; endl;
</db:programlisting>
<db:para>The items are traversed in ascending key order.</db:para>
<db:para>A <db:link xlink:href="qmap.xml">QMap</db:link> allows only one value per key. If you call <db:link xlink:href="qmap.xml#insert">insert</db:link>() with a key that already exists in the <db:link xlink:href="qmap.xml">QMap</db:link>, the previous value will be erased. For example:</db:para>
<db:programlisting language="cpp">map.insert(&quot;plenty&quot;, 100);
map.insert(&quot;plenty&quot;, 2000);
// map.value(&quot;plenty&quot;) == 2000
</db:programlisting>
<db:para>However, you can store multiple values per key by using <db:link xlink:href="qmultimap.xml">QMultiMap</db:link>.</db:para>
<db:para>If you only need to extract the values from a map (not the keys), you can also use range-based for:</db:para>
<db:programlisting language="cpp">QMap&lt;QString, int&gt; map;
...
for (int value : std::as_const(map))
    cout &lt;&lt; value &lt;&lt; endl;
</db:programlisting>
<db:para>Items can be removed from the map in several ways. One way is to call <db:link xlink:href="qmap.xml#remove">remove</db:link>(); this will remove any item with the given key. Another way is to use <db:link xlink:href="qmutablemapiterator.xml#remove">QMutableMapIterator::remove</db:link>(). In addition, you can clear the entire map using <db:link xlink:href="qmap.xml#clear">clear</db:link>().</db:para>
<db:para><db:link xlink:href="qmap.xml">QMap</db:link>'s key and value data types must be <db:link xlink:href="containers.xml#assignable-data-types">assignable data types</db:link>. This covers most data types you are likely to encounter, but the compiler won't let you, for example, store a QWidget as a value; instead, store a QWidget *. In addition, <db:link xlink:href="qmap.xml">QMap</db:link>'s key type must provide operator&lt;(). <db:link xlink:href="qmap.xml">QMap</db:link> uses it to keep its items sorted, and assumes that two keys x and y are equivalent if neither x &lt; y nor y &lt; x is true.</db:para>
<db:para>Example:</db:para>
<db:programlisting language="cpp">#ifndef EMPLOYEE_H
#define EMPLOYEE_H

class Employee
{
public:
    Employee() {}
    Employee(const QString &amp;name, QDate dateOfBirth);
    ...

private:
    QString myName;
    QDate myDateOfBirth;
};

inline bool operator&lt;(const Employee &amp;e1, const Employee &amp;e2)
{
    if (e1.name() != e2.name())
        return e1.name() &lt; e2.name();
    return e1.dateOfBirth() &lt; e2.dateOfBirth();
}

#endif // EMPLOYEE_H
</db:programlisting>
<db:para>In the example, we start by comparing the employees' names. If they're equal, we compare their dates of birth to break the tie.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qmapiterator.xml">QMapIterator</db:link></db:member>
<db:member><db:link xlink:href="qmutablemapiterator.xml">QMutableMapIterator</db:link></db:member>
<db:member><db:link xlink:href="qhash.xml#the-hashing-function">QHash</db:link></db:member>
<db:member><db:link xlink:href="qset.xml">QSet</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="member-type-documentation">
<db:title>Member Type Documentation</db:title>
<db:section xml:id="ConstIterator-typedef">
<db:title>QMap::ConstIterator</db:title>
<db:para>Qt-style synonym for <db:link xlink:href="qmap-const-iterator.xml">QMap::const_iterator</db:link>.</db:para>
</db:section>
<db:section xml:id="Iterator-typedef">
<db:title>QMap::Iterator</db:title>
<db:para>Qt-style synonym for <db:link xlink:href="qmap-iterator.xml">QMap::iterator</db:link>.</db:para>
</db:section>
<db:section xml:id="const_key_value_iterator-typedef">
<db:title>QMap::const_key_value_iterator</db:title>
<db:para>The QMap::const_key_value_iterator typedef provides an STL-style iterator for <db:link xlink:href="qmap.xml">QMap</db:link>.</db:para>
<db:para>QMap::const_key_value_iterator is essentially the same as <db:link xlink:href="qmap-const-iterator.xml">QMap::const_iterator</db:link> with the difference that operator*() returns a key/value pair instead of a value.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qkeyvalueiterator.xml">QKeyValueIterator</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="difference_type-typedef">
<db:title>[alias] QMap::difference_type</db:title>
<db:para>Typedef for ptrdiff_t. Provided for STL compatibility.</db:para>
</db:section>
<db:section xml:id="key_type-typedef">
<db:title>[alias] QMap::key_type</db:title>
<db:para>Typedef for Key. Provided for STL compatibility.</db:para>
</db:section>
<db:section xml:id="key_value_iterator-typedef">
<db:title>QMap::key_value_iterator</db:title>
<db:para>The QMap::key_value_iterator typedef provides an STL-style iterator for <db:link xlink:href="qmap.xml">QMap</db:link>.</db:para>
<db:para>QMap::key_value_iterator is essentially the same as <db:link xlink:href="qmap-iterator.xml">QMap::iterator</db:link> with the difference that operator*() returns a key/value pair instead of a value.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qkeyvalueiterator.xml">QKeyValueIterator</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="mapped_type-typedef">
<db:title>[alias] QMap::mapped_type</db:title>
<db:para>Typedef for T. Provided for STL compatibility.</db:para>
</db:section>
<db:section xml:id="size_type-typedef">
<db:title>[alias] QMap::size_type</db:title>
<db:para>Typedef for int. Provided for STL compatibility.</db:para>
</db:section>
</db:section>
<db:section xml:id="member-function-documentation">
<db:title>Member Function Documentation</db:title>
<db:section xml:id="asKeyValueRange-1">
<db:title>[since 6.4] auto QMap::asKeyValueRange() &amp;</db:title>
<db:bridgehead renderas="sect2" xml:id="asKeyValueRange">[since 6.4] auto QMap::asKeyValueRange() &amp;&amp;</db:bridgehead>
<db:bridgehead renderas="sect2" xml:id="asKeyValueRange-3">[since 6.4] auto QMap::asKeyValueRange() const &amp;</db:bridgehead>
<db:bridgehead renderas="sect2" xml:id="asKeyValueRange-2">[since 6.4] auto QMap::asKeyValueRange() const &amp;&amp;</db:bridgehead>
<db:para>Returns a range object that allows iteration over this map as key/value pairs. For instance, this range object can be used in a range-based for loop, in combination with a structured binding declaration:</db:para>
<db:programlisting language="cpp">QMap&lt;QString, int&gt; map;
map.insert(&quot;January&quot;, 1);
map.insert(&quot;February&quot;, 2);
// ...
map.insert(&quot;December&quot;, 12);

for (auto [key, value] : map.asKeyValueRange()) {
    cout &lt;&lt; qPrintable(key) &lt;&lt; &quot;: &quot; &lt;&lt; value &lt;&lt; endl;
    --value; // convert to JS month indexing
}
</db:programlisting>
<db:para>Note that both the key and the value obtained this way are references to the ones in the map. Specifically, mutating the value will modify the map itself.</db:para>
<db:para>This function was introduced in Qt 6.4.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qkeyvalueiterator.xml">QKeyValueIterator</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="QMap">
<db:title>QMap::QMap()</db:title>
<db:para>Constructs an empty map.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qmap.xml#clear">clear</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="QMap-3">
<db:title>[explicit] QMap::QMap(const std::map&lt;Key, T&gt; &amp;<db:emphasis>other</db:emphasis>)</db:title>
<db:para>Constructs a copy of <db:code role="parameter">other</db:code>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qmap.xml#toStdMap">toStdMap</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="QMap-4">
<db:title>QMap::QMap(std::initializer_list&lt;std::pair&lt;Key, T&gt;&gt; <db:emphasis>list</db:emphasis>)</db:title>
<db:para>Constructs a map with a copy of each of the elements in the initializer list <db:code role="parameter">list</db:code>.</db:para>
</db:section>
<db:section xml:id="QMap-5">
<db:title>[explicit] QMap::QMap(std::map&lt;Key, T&gt; &amp;&amp;<db:emphasis>other</db:emphasis>)</db:title>
<db:para>Constructs a map by moving from <db:code role="parameter">other</db:code>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qmap.xml#toStdMap">toStdMap</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="QMap-2">
<db:title>[default] QMap::QMap(const QMap&lt;Key, T&gt; &amp;<db:emphasis>other</db:emphasis>)</db:title>
<db:para>Constructs a copy of <db:code role="parameter">other</db:code>.</db:para>
<db:para>This operation occurs in <db:link xlink:href="containers.xml#constant-time">constant time</db:link>, because <db:link xlink:href="qmap.xml">QMap</db:link> is <db:link xlink:href="implicit-sharing.xml">implicitly shared</db:link>. This makes returning a <db:link xlink:href="qmap.xml">QMap</db:link> from a function very fast. If a shared instance is modified, it will be copied (copy-on-write), and this takes <db:link xlink:href="containers.xml#linear-time">linear time</db:link>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qmap.xml#operator-eq">operator=</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="QMap-1">
<db:title>[default] QMap::QMap(QMap&lt;Key, T&gt; &amp;&amp;<db:emphasis>other</db:emphasis>)</db:title>
<db:para>Move-constructs a <db:link xlink:href="qmap.xml">QMap</db:link> instance.</db:para>
</db:section>
<db:section xml:id="dtor.QMap">
<db:title>[default] QMap::~QMap()</db:title>
<db:para>Destroys the map. References to the values in the map, and all iterators over this map, become invalid.</db:para>
</db:section>
<db:section xml:id="begin">
<db:title>QMap&lt;Key, T&gt;::iterator QMap::begin()</db:title>
<db:para>Returns an <db:link xlink:href="containers.xml#stl-style-iterators">STL-style iterator</db:link> pointing to the first item in the map.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qmap.xml#constBegin">constBegin</db:link>()</db:member>
<db:member><db:link xlink:href="qmap.xml#end">end</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="begin-1">
<db:title>QMap&lt;Key, T&gt;::const_iterator QMap::begin() const</db:title>
<db:para>This is an overloaded function.</db:para>
</db:section>
<db:section xml:id="cbegin">
<db:title>QMap&lt;Key, T&gt;::const_iterator QMap::cbegin() const</db:title>
<db:para>Returns a const <db:link xlink:href="containers.xml#stl-style-iterators">STL-style iterator</db:link> pointing to the first item in the map.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qmap.xml#begin">begin</db:link>()</db:member>
<db:member><db:link xlink:href="qmap.xml#cend">cend</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="cend">
<db:title>QMap&lt;Key, T&gt;::const_iterator QMap::cend() const</db:title>
<db:para>Returns a const <db:link xlink:href="containers.xml#stl-style-iterators">STL-style iterator</db:link> pointing to the imaginary item after the last item in the map.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qmap.xml#cbegin">cbegin</db:link>()</db:member>
<db:member><db:link xlink:href="qmap.xml#end">end</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="clear">
<db:title>void QMap::clear()</db:title>
<db:para>Removes all items from the map.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qmap.xml#remove">remove</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="constBegin">
<db:title>QMap&lt;Key, T&gt;::const_iterator QMap::constBegin() const</db:title>
<db:para>Returns a const <db:link xlink:href="containers.xml#stl-style-iterators">STL-style iterator</db:link> pointing to the first item in the map.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qmap.xml#begin">begin</db:link>()</db:member>
<db:member><db:link xlink:href="qmap.xml#constEnd">constEnd</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="constEnd">
<db:title>QMap&lt;Key, T&gt;::const_iterator QMap::constEnd() const</db:title>
<db:para>Returns a const <db:link xlink:href="containers.xml#stl-style-iterators">STL-style iterator</db:link> pointing to the imaginary item after the last item in the map.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qmap.xml#constBegin">constBegin</db:link>()</db:member>
<db:member><db:link xlink:href="qmap.xml#end">end</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="constFind">
<db:title>QMap&lt;Key, T&gt;::const_iterator QMap::constFind(const Key &amp;<db:emphasis>key</db:emphasis>) const</db:title>
<db:para>Returns an const iterator pointing to the item with key <db:code role="parameter">key</db:code> in the map.</db:para>
<db:para>If the map contains no item with key <db:code role="parameter">key</db:code>, the function returns <db:link xlink:href="qmap.xml#constEnd">constEnd</db:link>().</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qmap.xml#find">find</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="constKeyValueBegin">
<db:title>QMap&lt;Key, T&gt;::const_key_value_iterator QMap::constKeyValueBegin() const</db:title>
<db:para>Returns a const <db:link xlink:href="containers.xml#stl-style-iterators">STL-style iterator</db:link> pointing to the first entry in the map.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qmap.xml#keyValueBegin">keyValueBegin</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="constKeyValueEnd">
<db:title>QMap&lt;Key, T&gt;::const_key_value_iterator QMap::constKeyValueEnd() const</db:title>
<db:para>Returns a const <db:link xlink:href="containers.xml#stl-style-iterators">STL-style iterator</db:link> pointing to the imaginary entry after the last entry in the map.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qmap.xml#constKeyValueBegin">constKeyValueBegin</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="contains">
<db:title>bool QMap::contains(const Key &amp;<db:emphasis>key</db:emphasis>) const</db:title>
<db:para>Returns true if the map contains an item with key <db:code role="parameter">key</db:code>; otherwise returns false.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qmap.xml#count-1">count</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="count">
<db:title>QMap&lt;Key, T&gt;::size_type QMap::count(const Key &amp;<db:emphasis>key</db:emphasis>) const</db:title>
<db:para>Returns the number of items associated with key <db:code role="parameter">key</db:code>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qmap.xml#contains">contains</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="count-1">
<db:title>QMap&lt;Key, T&gt;::size_type QMap::count() const</db:title>
<db:para>This is an overloaded function.</db:para>
<db:para>Same as <db:link xlink:href="qmap.xml#size">size</db:link>().</db:para>
</db:section>
<db:section xml:id="empty">
<db:title>bool QMap::empty() const</db:title>
<db:para>This function is provided for STL compatibility. It is equivalent to <db:link xlink:href="qmap.xml#isEmpty">isEmpty</db:link>(), returning true if the map is empty; otherwise returning false.</db:para>
</db:section>
<db:section xml:id="end">
<db:title>QMap&lt;Key, T&gt;::iterator QMap::end()</db:title>
<db:para>Returns an <db:link xlink:href="containers.xml#stl-style-iterators">STL-style iterator</db:link> pointing to the imaginary item after the last item in the map.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qmap.xml#begin">begin</db:link>()</db:member>
<db:member><db:link xlink:href="qmap.xml#constEnd">constEnd</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="end-1">
<db:title>QMap&lt;Key, T&gt;::const_iterator QMap::end() const</db:title>
<db:para>This is an overloaded function.</db:para>
</db:section>
<db:section xml:id="equal_range">
<db:title>std::pair&lt;QMap&lt;Key, T&gt;::iterator, QMap&lt;Key, T&gt;::iterator&gt; QMap::equal_range(const Key &amp;<db:emphasis>key</db:emphasis>)</db:title>
<db:para>Returns a pair of iterators delimiting the range of values [first, second), that are stored under <db:code role="parameter">key</db:code>.</db:para>
</db:section>
<db:section xml:id="equal_range-1">
<db:title>std::pair&lt;QMap&lt;Key, T&gt;::const_iterator, QMap&lt;Key, T&gt;::const_iterator&gt; QMap::equal_range(const Key &amp;<db:emphasis>key</db:emphasis>) const</db:title>
<db:para>This is an overloaded function.</db:para>
</db:section>
<db:section xml:id="erase">
<db:title>QMap&lt;Key, T&gt;::iterator QMap::erase(QMap&lt;Key, T&gt;::const_iterator <db:emphasis>pos</db:emphasis>)</db:title>
<db:para>Removes the (key, value) pair pointed to by the iterator <db:code role="parameter">pos</db:code> from the map, and returns an iterator to the next item in the map.</db:para>
<db:note>
<db:para>The iterator <db:code role="parameter">pos</db:code> <db:emphasis>must</db:emphasis> be valid and dereferenceable.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qmap.xml#remove">remove</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="erase-1">
<db:title>[since 6.0] QMap&lt;Key, T&gt;::iterator QMap::erase(QMap&lt;Key, T&gt;::const_iterator <db:emphasis>first</db:emphasis>, QMap&lt;Key, T&gt;::const_iterator <db:emphasis>last</db:emphasis>)</db:title>
<db:para>Removes the (key, value) pairs pointed to by the iterator range [<db:code role="parameter">first</db:code>, <db:code role="parameter">last</db:code>) from the map. Returns an iterator to the item in the map following the last removed element.</db:para>
<db:note>
<db:para>The range [first, last) <db:emphasis>must</db:emphasis> be a valid range in *this.</db:para>
</db:note>
<db:para>This function was introduced in Qt 6.0.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qmap.xml#remove">remove</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="find">
<db:title>QMap&lt;Key, T&gt;::iterator QMap::find(const Key &amp;<db:emphasis>key</db:emphasis>)</db:title>
<db:para>Returns an iterator pointing to the item with key <db:code role="parameter">key</db:code> in the map.</db:para>
<db:para>If the map contains no item with key <db:code role="parameter">key</db:code>, the function returns <db:link xlink:href="qmap.xml#end">end</db:link>().</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qmap.xml#constFind">constFind</db:link>()</db:member>
<db:member><db:link xlink:href="qmap.xml#value">value</db:link>()</db:member>
<db:member><db:link xlink:href="qmap.xml#values">values</db:link>()</db:member>
<db:member><db:link xlink:href="qmap.xml#lowerBound">lowerBound</db:link>()</db:member>
<db:member><db:link xlink:href="qmap.xml#upperBound">upperBound</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="find-1">
<db:title>QMap&lt;Key, T&gt;::const_iterator QMap::find(const Key &amp;<db:emphasis>key</db:emphasis>) const</db:title>
<db:para>This is an overloaded function.</db:para>
</db:section>
<db:section xml:id="first">
<db:title>T &amp;QMap::first()</db:title>
<db:para>Returns a reference to the first value in the map, that is the value mapped to the smallest key. This function assumes that the map is not empty.</db:para>
<db:para>When unshared (or const version is called), this executes in <db:link xlink:href="containers.xml#constant-time">constant time</db:link>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qmap.xml#last">last</db:link>()</db:member>
<db:member><db:link xlink:href="qmap.xml#firstKey">firstKey</db:link>()</db:member>
<db:member><db:link xlink:href="qmap.xml#isEmpty">isEmpty</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="first-1">
<db:title>const T &amp;QMap::first() const</db:title>
<db:para>This is an overloaded function.</db:para>
</db:section>
<db:section xml:id="firstKey">
<db:title>const Key &amp;QMap::firstKey() const</db:title>
<db:para>Returns a reference to the smallest key in the map. This function assumes that the map is not empty.</db:para>
<db:para>This executes in <db:link xlink:href="containers.xml#constant-time">constant time</db:link>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qmap.xml#lastKey">lastKey</db:link>()</db:member>
<db:member><db:link xlink:href="qmap.xml#first">first</db:link>()</db:member>
<db:member><db:link xlink:href="qmap.xml#keyBegin">keyBegin</db:link>()</db:member>
<db:member><db:link xlink:href="qmap.xml#isEmpty">isEmpty</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="insert">
<db:title>void QMap::insert(QMap&lt;Key, T&gt; &amp;&amp;<db:emphasis>map</db:emphasis>)</db:title>
<db:para>Moves all the items from <db:code role="parameter">map</db:code> into this map.</db:para>
<db:para>If a key is common to both maps, its value will be replaced with the value stored in <db:code role="parameter">map</db:code>.</db:para>
<db:para>If <db:code role="parameter">map</db:code> is shared, then the items will be copied instead.</db:para>
</db:section>
<db:section xml:id="insert-1">
<db:title>void QMap::insert(const QMap&lt;Key, T&gt; &amp;<db:emphasis>map</db:emphasis>)</db:title>
<db:para>Inserts all the items in <db:code role="parameter">map</db:code> into this map.</db:para>
<db:para>If a key is common to both maps, its value will be replaced with the value stored in <db:code role="parameter">map</db:code>.</db:para>
</db:section>
<db:section xml:id="insert-2">
<db:title>QMap&lt;Key, T&gt;::iterator QMap::insert(const Key &amp;<db:emphasis>key</db:emphasis>, const T &amp;<db:emphasis>value</db:emphasis>)</db:title>
<db:para>Inserts a new item with the key <db:code role="parameter">key</db:code> and a value of <db:code role="parameter">value</db:code>.</db:para>
<db:para>If there is already an item with the key <db:code role="parameter">key</db:code>, that item's value is replaced with <db:code role="parameter">value</db:code>.</db:para>
<db:para>Returns an iterator pointing to the new/updated element.</db:para>
</db:section>
<db:section xml:id="insert-3">
<db:title>QMap&lt;Key, T&gt;::iterator QMap::insert(QMap&lt;Key, T&gt;::const_iterator <db:emphasis>pos</db:emphasis>, const Key &amp;<db:emphasis>key</db:emphasis>, const T &amp;<db:emphasis>value</db:emphasis>)</db:title>
<db:para>This is an overloaded function.</db:para>
<db:para>Inserts a new item with the key <db:code role="parameter">key</db:code> and value <db:code role="parameter">value</db:code> and with hint <db:code role="parameter">pos</db:code> suggesting where to do the insert.</db:para>
<db:para>If <db:link xlink:href="qmap.xml#constBegin">constBegin</db:link>() is used as hint it indicates that the <db:code role="parameter">key</db:code> is less than any key in the map while <db:link xlink:href="qmap.xml#constEnd">constEnd</db:link>() suggests that the <db:code role="parameter">key</db:code> is (strictly) larger than any key in the map. Otherwise the hint should meet the condition (<db:code role="parameter">pos</db:code> - 1).<db:link xlink:href="qmap.xml#key">key</db:link>() &lt; <db:code role="parameter">key</db:code> &lt;= pos.<db:link xlink:href="qmap.xml#key">key</db:link>(). If the hint <db:code role="parameter">pos</db:code> is wrong it is ignored and a regular insert is done.</db:para>
<db:para>If there is already an item with the key <db:code role="parameter">key</db:code>, that item's value is replaced with <db:code role="parameter">value</db:code>.</db:para>
<db:para>If the hint is correct and the map is unshared, the insert executes in amortized <db:link xlink:href="containers.xml#constant-time">constant time</db:link>.</db:para>
<db:para>When creating a map from sorted data inserting the largest key first with <db:link xlink:href="qmap.xml#constBegin">constBegin</db:link>() is faster than inserting in sorted order with <db:link xlink:href="qmap.xml#constEnd">constEnd</db:link>(), since <db:link xlink:href="qmap.xml#constEnd">constEnd</db:link>() - 1 (which is needed to check if the hint is valid) needs <db:link xlink:href="containers.xml#logarithmic-time">logarithmic time</db:link>.</db:para>
<db:para><db:emphasis role="bold">Note:</db:emphasis> Be careful with the hint. Providing an iterator from an older shared instance might crash but there is also a risk that it will silently corrupt both the map and the <db:code role="parameter">pos</db:code> map.</db:para>
<db:para>Returns an iterator pointing to the new/updated element.</db:para>
</db:section>
<db:section xml:id="isEmpty">
<db:title>bool QMap::isEmpty() const</db:title>
<db:para>Returns true if the map contains no items; otherwise returns false.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qmap.xml#size">size</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="key">
<db:title>Key QMap::key(const T &amp;<db:emphasis>value</db:emphasis>, const Key &amp;<db:emphasis>defaultKey</db:emphasis> = Key()) const</db:title>
<db:para>This is an overloaded function.</db:para>
<db:para>Returns the first key with value <db:code role="parameter">value</db:code>, or <db:code role="parameter">defaultKey</db:code> if the map contains no item with value <db:code role="parameter">value</db:code>. If no <db:code role="parameter">defaultKey</db:code> is provided the function returns a <db:link xlink:href="containers.xml#default-constructed-value">default-constructed key</db:link>.</db:para>
<db:para>This function can be slow (<db:link xlink:href="containers.xml#linear-time">linear time</db:link>), because <db:link xlink:href="qmap.xml">QMap</db:link>'s internal data structure is optimized for fast lookup by key, not by value.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qmap.xml#value">value</db:link>()</db:member>
<db:member><db:link xlink:href="qmap.xml#keys">keys</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="keyBegin">
<db:title>QMap&lt;Key, T&gt;::key_iterator QMap::keyBegin() const</db:title>
<db:para>Returns a const <db:link xlink:href="containers.xml#stl-style-iterators">STL-style iterator</db:link> pointing to the first key in the map.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qmap.xml#keyEnd">keyEnd</db:link>()</db:member>
<db:member><db:link xlink:href="qmap.xml#firstKey">firstKey</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="keyEnd">
<db:title>QMap&lt;Key, T&gt;::key_iterator QMap::keyEnd() const</db:title>
<db:para>Returns a const <db:link xlink:href="containers.xml#stl-style-iterators">STL-style iterator</db:link> pointing to the imaginary item after the last key in the map.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qmap.xml#keyBegin">keyBegin</db:link>()</db:member>
<db:member><db:link xlink:href="qmap.xml#lastKey">lastKey</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="keyValueBegin">
<db:title>QMap&lt;Key, T&gt;::key_value_iterator QMap::keyValueBegin()</db:title>
<db:para>Returns an <db:link xlink:href="containers.xml#stl-style-iterators">STL-style iterator</db:link> pointing to the first entry in the map.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qmap.xml#keyValueEnd">keyValueEnd</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="keyValueBegin-1">
<db:title>QMap&lt;Key, T&gt;::const_key_value_iterator QMap::keyValueBegin() const</db:title>
<db:para>Returns a const <db:link xlink:href="containers.xml#stl-style-iterators">STL-style iterator</db:link> pointing to the first entry in the map.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qmap.xml#keyValueEnd">keyValueEnd</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="keyValueEnd">
<db:title>QMap&lt;Key, T&gt;::key_value_iterator QMap::keyValueEnd()</db:title>
<db:para>Returns an <db:link xlink:href="containers.xml#stl-style-iterators">STL-style iterator</db:link> pointing to the imaginary entry after the last entry in the map.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qmap.xml#keyValueBegin">keyValueBegin</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="keyValueEnd-1">
<db:title>QMap&lt;Key, T&gt;::const_key_value_iterator QMap::keyValueEnd() const</db:title>
<db:para>Returns a const <db:link xlink:href="containers.xml#stl-style-iterators">STL-style iterator</db:link> pointing to the imaginary entry after the last entry in the map.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qmap.xml#keyValueBegin">keyValueBegin</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="keys">
<db:title>QList&lt;Key&gt; QMap::keys() const</db:title>
<db:para>Returns a list containing all the keys in the map in ascending order.</db:para>
<db:para>The order is guaranteed to be the same as that used by <db:link xlink:href="qmap.xml#values">values</db:link>().</db:para>
<db:para>This function creates a new list, in <db:link xlink:href="containers.xml#linear-time">linear time</db:link>. The time and memory use that entails can be avoided by iterating from <db:link xlink:href="qmap.xml#keyBegin">keyBegin</db:link>() to <db:link xlink:href="qmap.xml#keyEnd">keyEnd</db:link>().</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qmap.xml#values">values</db:link>()</db:member>
<db:member><db:link xlink:href="qmap.xml#key">key</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="keys-1">
<db:title>QList&lt;Key&gt; QMap::keys(const T &amp;<db:emphasis>value</db:emphasis>) const</db:title>
<db:para>This is an overloaded function.</db:para>
<db:para>Returns a list containing all the keys associated with value <db:code role="parameter">value</db:code> in ascending order.</db:para>
<db:para>This function can be slow (<db:link xlink:href="containers.xml#linear-time">linear time</db:link>), because <db:link xlink:href="qmap.xml">QMap</db:link>'s internal data structure is optimized for fast lookup by key, not by value.</db:para>
</db:section>
<db:section xml:id="last">
<db:title>T &amp;QMap::last()</db:title>
<db:para>Returns a reference to the last value in the map, that is the value mapped to the largest key. This function assumes that the map is not empty.</db:para>
<db:para>When unshared (or const version is called), this executes in <db:link xlink:href="containers.xml#logarithmic-time">logarithmic time</db:link>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qmap.xml#first">first</db:link>()</db:member>
<db:member><db:link xlink:href="qmap.xml#lastKey">lastKey</db:link>()</db:member>
<db:member><db:link xlink:href="qmap.xml#isEmpty">isEmpty</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="last-1">
<db:title>const T &amp;QMap::last() const</db:title>
<db:para>This is an overloaded function.</db:para>
</db:section>
<db:section xml:id="lastKey">
<db:title>const Key &amp;QMap::lastKey() const</db:title>
<db:para>Returns a reference to the largest key in the map. This function assumes that the map is not empty.</db:para>
<db:para>This executes in <db:link xlink:href="containers.xml#logarithmic-time">logarithmic time</db:link>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qmap.xml#firstKey">firstKey</db:link>()</db:member>
<db:member><db:link xlink:href="qmap.xml#last">last</db:link>()</db:member>
<db:member><db:link xlink:href="qmap.xml#keyEnd">keyEnd</db:link>()</db:member>
<db:member><db:link xlink:href="qmap.xml#isEmpty">isEmpty</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="lowerBound">
<db:title>QMap&lt;Key, T&gt;::iterator QMap::lowerBound(const Key &amp;<db:emphasis>key</db:emphasis>)</db:title>
<db:para>Returns an iterator pointing to the first item with key <db:code role="parameter">key</db:code> in the map. If the map contains no item with key <db:code role="parameter">key</db:code>, the function returns an iterator to the nearest item with a greater key.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qmap.xml#upperBound">upperBound</db:link>()</db:member>
<db:member><db:link xlink:href="qmap.xml#find">find</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="lowerBound-1">
<db:title>QMap&lt;Key, T&gt;::const_iterator QMap::lowerBound(const Key &amp;<db:emphasis>key</db:emphasis>) const</db:title>
<db:para>This is an overloaded function.</db:para>
</db:section>
<db:section xml:id="remove">
<db:title>QMap&lt;Key, T&gt;::size_type QMap::remove(const Key &amp;<db:emphasis>key</db:emphasis>)</db:title>
<db:para>Removes all the items that have the key <db:code role="parameter">key</db:code> from the map. Returns the number of items removed which will be 1 if the key exists in the map, and 0 otherwise.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qmap.xml#clear">clear</db:link>()</db:member>
<db:member><db:link xlink:href="qmap.xml#take">take</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="removeIf">
<db:title>[since 6.1] QMap&lt;Key, T&gt;::size_type QMap::removeIf(Predicate <db:emphasis>pred</db:emphasis>)</db:title>
<db:para>Removes all elements for which the predicate <db:code role="parameter">pred</db:code> returns true from the map.</db:para>
<db:para>The function supports predicates which take either an argument of type QMap&lt;Key, T&gt;::iterator, or an argument of type std::pair&lt;const Key &amp;, T &amp;&gt;.</db:para>
<db:para>Returns the number of elements removed, if any.</db:para>
<db:para>This function was introduced in Qt 6.1.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qmap.xml#clear">clear</db:link>()</db:member>
<db:member><db:link xlink:href="qmap.xml#take">take</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="size">
<db:title>QMap&lt;Key, T&gt;::size_type QMap::size() const</db:title>
<db:para>Returns the number of (key, value) pairs in the map.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qmap.xml#isEmpty">isEmpty</db:link>()</db:member>
<db:member><db:link xlink:href="qmap.xml#count-1">count</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="swap">
<db:title>[noexcept] void QMap::swap(QMap&lt;Key, T&gt; &amp;<db:emphasis>other</db:emphasis>)</db:title>
<db:para>Swaps this map with <db:code role="parameter">other</db:code>. This operation is very fast and never fails.</db:para>
</db:section>
<db:section xml:id="take">
<db:title>T QMap::take(const Key &amp;<db:emphasis>key</db:emphasis>)</db:title>
<db:para>Removes the item with the key <db:code role="parameter">key</db:code> from the map and returns the value associated with it.</db:para>
<db:para>If the item does not exist in the map, the function simply returns a <db:link xlink:href="containers.xml#default-constructed-value">default-constructed value</db:link>.</db:para>
<db:para>If you don't use the return value, <db:link xlink:href="qmap.xml#remove">remove</db:link>() is more efficient.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qmap.xml#remove">remove</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="toStdMap">
<db:title>std::map&lt;Key, T&gt; QMap::toStdMap() const &amp;</db:title>
<db:para>Returns an STL map equivalent to this <db:link xlink:href="qmap.xml">QMap</db:link>.</db:para>
</db:section>
<db:section xml:id="toStdMap-1">
<db:title>[since 6.0] std::map&lt;Key, T&gt; QMap::toStdMap() &amp;&amp;</db:title>
<db:para>This is an overloaded function.</db:para>
<db:note>
<db:para>Calling this function will leave this <db:link xlink:href="qmap.xml">QMap</db:link> in the partially-formed state, in which the only valid operations are destruction or assignment of a new value.</db:para>
</db:note>
<db:para>This function was introduced in Qt 6.0.</db:para>
</db:section>
<db:section xml:id="upperBound">
<db:title>QMap&lt;Key, T&gt;::iterator QMap::upperBound(const Key &amp;<db:emphasis>key</db:emphasis>)</db:title>
<db:para>Returns an iterator pointing to the item that immediately follows the last item with key <db:code role="parameter">key</db:code> in the map. If the map contains no item with key <db:code role="parameter">key</db:code>, the function returns an iterator to the nearest item with a greater key.</db:para>
<db:para>Example:</db:para>
<db:programlisting language="cpp">QMap&lt;int, QString&gt; map;
map.insert(1, &quot;one&quot;);
map.insert(5, &quot;five&quot;);
map.insert(10, &quot;ten&quot;);

map.upperBound(0);      // returns iterator to (1, &quot;one&quot;)
map.upperBound(1);      // returns iterator to (5, &quot;five&quot;)
map.upperBound(2);      // returns iterator to (5, &quot;five&quot;)
map.upperBound(10);     // returns end()
map.upperBound(999);    // returns end()
</db:programlisting>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qmap.xml#lowerBound">lowerBound</db:link>()</db:member>
<db:member><db:link xlink:href="qmap.xml#find">find</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="upperBound-1">
<db:title>QMap&lt;Key, T&gt;::const_iterator QMap::upperBound(const Key &amp;<db:emphasis>key</db:emphasis>) const</db:title>
<db:para>This is an overloaded function.</db:para>
</db:section>
<db:section xml:id="value">
<db:title>T QMap::value(const Key &amp;<db:emphasis>key</db:emphasis>, const T &amp;<db:emphasis>defaultValue</db:emphasis> = T()) const</db:title>
<db:para>Returns the value associated with the key <db:code role="parameter">key</db:code>.</db:para>
<db:para>If the map contains no item with key <db:code role="parameter">key</db:code>, the function returns <db:code role="parameter">defaultValue</db:code>. If no <db:code role="parameter">defaultValue</db:code> is specified, the function returns a <db:link xlink:href="containers.xml#default-constructed-value">default-constructed value</db:link>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qmap.xml#key">key</db:link>()</db:member>
<db:member><db:link xlink:href="qmap.xml#values">values</db:link>()</db:member>
<db:member><db:link xlink:href="qmap.xml#contains">contains</db:link>()</db:member>
<db:member><db:link xlink:href="qmap.xml#operator-5b-5d">operator[]</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="values">
<db:title>QList&lt;T&gt; QMap::values() const</db:title>
<db:para>Returns a list containing all the values in the map, in ascending order of their keys.</db:para>
<db:para>This function creates a new list, in <db:link xlink:href="containers.xml#linear-time">linear time</db:link>. The time and memory use that entails can be avoided by iterating from <db:link xlink:href="qmap.xml#keyValueBegin">keyValueBegin</db:link>() to <db:link xlink:href="qmap.xml#keyValueEnd">keyValueEnd</db:link>().</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qmap.xml#keys">keys</db:link>()</db:member>
<db:member><db:link xlink:href="qmap.xml#value">value</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="operator-eq">
<db:title>[default] QMap&lt;Key, T&gt; &amp;QMap::operator=(QMap&lt;Key, T&gt; &amp;&amp;<db:emphasis>other</db:emphasis>)</db:title>
<db:para>Move-assigns <db:code role="parameter">other</db:code> to this <db:link xlink:href="qmap.xml">QMap</db:link> instance.</db:para>
</db:section>
<db:section xml:id="operator-eq-1">
<db:title>[default] QMap&lt;Key, T&gt; &amp;QMap::operator=(const QMap&lt;Key, T&gt; &amp;<db:emphasis>other</db:emphasis>)</db:title>
<db:para>Assigns <db:code role="parameter">other</db:code> to this map and returns a reference to this map.</db:para>
</db:section>
<db:section xml:id="operator-5b-5d">
<db:title>T &amp;QMap::operator[](const Key &amp;<db:emphasis>key</db:emphasis>)</db:title>
<db:para>Returns the value associated with the key <db:code role="parameter">key</db:code> as a modifiable reference.</db:para>
<db:para>If the map contains no item with key <db:code role="parameter">key</db:code>, the function inserts a <db:link xlink:href="containers.xml#default-constructed-value">default-constructed value</db:link> into the map with key <db:code role="parameter">key</db:code>, and returns a reference to it.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qmap.xml#insert">insert</db:link>()</db:member>
<db:member><db:link xlink:href="qmap.xml#value">value</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="operator-5b-5d-1">
<db:title>T QMap::operator[](const Key &amp;<db:emphasis>key</db:emphasis>) const</db:title>
<db:para>This is an overloaded function.</db:para>
<db:para>Same as <db:link xlink:href="qmap.xml#value">value</db:link>().</db:para>
</db:section>
</db:section>
<db:section xml:id="related-non-members">
<db:title>Related Non-Members</db:title>
<db:section xml:id="erase_if-3">
<db:title>[since 6.1] qsizetype erase_if(QMap&lt;Key, T&gt; &amp;<db:emphasis>map</db:emphasis>, Predicate <db:emphasis>pred</db:emphasis>)</db:title>
<db:para>Removes all elements for which the predicate <db:code role="parameter">pred</db:code> returns true from the map <db:code role="parameter">map</db:code>.</db:para>
<db:para>The function supports predicates which take either an argument of type QMap&lt;Key, T&gt;::iterator, or an argument of type std::pair&lt;const Key &amp;, T &amp;&gt;.</db:para>
<db:para>Returns the number of elements removed, if any.</db:para>
<db:para>This function was introduced in Qt 6.1.</db:para>
</db:section>
<db:section xml:id="qHash">
<db:title>[since 6.8] size_t qHash(const QMap&lt;Key, T&gt; &amp;<db:emphasis>key</db:emphasis>, size_t <db:emphasis>seed</db:emphasis> = 0)</db:title>
<db:para>Returns the hash value for <db:code role="parameter">key</db:code>, using <db:code role="parameter">seed</db:code> to seed the calculation.</db:para>
<db:para>Types Key and T must be supported by qHash().</db:para>
<db:para>This function was introduced in Qt 6.8.</db:para>
</db:section>
<db:section xml:id="operator-not-eq">
<db:title>bool operator!=(const QMap&lt;Key, T&gt; &amp;<db:emphasis>lhs</db:emphasis>, const QMap&lt;Key, T&gt; &amp;<db:emphasis>rhs</db:emphasis>)</db:title>
<db:para>Returns true if <db:code role="parameter">lhs</db:code> is not equal to <db:code role="parameter">rhs</db:code>; otherwise returns false.</db:para>
<db:para>Two maps are considered equal if they contain the same (key, value) pairs.</db:para>
<db:para>This function requires the key and the value types to implement operator==().</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qmap.xml#operator-eq-eq">operator==</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="operator-lt-lt-12">
<db:title>QDataStream &amp;operator&lt;&lt;(QDataStream &amp;<db:emphasis>out</db:emphasis>, const QMap&lt;Key, T&gt; &amp;<db:emphasis>map</db:emphasis>)</db:title>
<db:para>Writes the map <db:code role="parameter">map</db:code> to stream <db:code role="parameter">out</db:code>.</db:para>
<db:para>This function requires the key and value types to implement operator&lt;&lt;().</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="datastreamformat.xml">Format of the QDataStream operators</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="operator-eq-eq">
<db:title>bool operator==(const QMap&lt;Key, T&gt; &amp;<db:emphasis>lhs</db:emphasis>, const QMap&lt;Key, T&gt; &amp;<db:emphasis>rhs</db:emphasis>)</db:title>
<db:para>Returns true if <db:code role="parameter">lhs</db:code> is equal to <db:code role="parameter">rhs</db:code>; otherwise returns false.</db:para>
<db:para>Two maps are considered equal if they contain the same (key, value) pairs.</db:para>
<db:para>This function requires the key and the value types to implement operator==().</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qmap.xml#operator-not-eq">operator!=</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="operator-gt-gt-11">
<db:title>QDataStream &amp;operator&gt;&gt;(QDataStream &amp;<db:emphasis>in</db:emphasis>, QMap&lt;Key, T&gt; &amp;<db:emphasis>map</db:emphasis>)</db:title>
<db:para>Reads a map from stream <db:code role="parameter">in</db:code> into <db:code role="parameter">map</db:code>.</db:para>
<db:para>This function requires the key and value types to implement operator&gt;&gt;().</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="datastreamformat.xml">Format of the QDataStream operators</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
</db:section>
</db:article>
