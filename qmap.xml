<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en">
<db:info>
<db:title>QMap Class</db:title>
<db:subtitle>template &lt;typename Key, typename T&gt; class QMap</db:subtitle>
<db:productname>QtCore</db:productname>
<db:edition>Qt 5.7.1 Reference Documentation</db:edition>
<db:titleabbrev>Qt Core Reference Documentation</db:titleabbrev>
<db:abstract>
<db:para>The <db:link xlink:href="qmap.xml">QMap</db:link> class is a template class that provides a red-black-tree-based dictionary.</db:para>
<db:note>
<db:para>All functions in this class are <db:link xlink:href="threads-reentrancy.xml">reentrant</db:link>.</db:para>
</db:note>
</db:abstract>
<db:pubdate>2025-06-29</db:pubdate>
<db:date>2025-06-29</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:variablelist>
<db:varlistentry>
<db:term>Header</db:term>
<db:listitem>
<db:para>QMap</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>qmake</db:term>
<db:listitem>
<db:para>QT += core</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Inherited By</db:term>
<db:listitem>
<db:para><db:link xlink:href="qmultimap.xml" xlink:role="class">QMultiMap</db:link></db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Group</db:term>
<db:listitem>
<db:para>QMap is part of <db:simplelist><db:member>tools</db:member><db:member><db:link xlink:href="shared.xml">Implicitly Shared Classes</db:link></db:member></db:simplelist>
</db:para>
</db:listitem>
</db:varlistentry>
</db:variablelist>
<db:section xml:id="details">
<db:title>Detailed Description</db:title>
<db:para><db:link xlink:href="qmap.xml">QMap</db:link>&lt;Key, T&gt; is one of Qt's generic <db:link xlink:href="containers.xml">container classes</db:link>. It stores (key, value) pairs and provides fast lookup of the value associated with a key.</db:para>
<db:para><db:link xlink:href="qmap.xml">QMap</db:link> and <db:link xlink:href="qhash.xml#the-qhash-hashing-function">QHash</db:link> provide very similar functionality. The differences are:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:link xlink:href="qhash.xml#the-qhash-hashing-function">QHash</db:link> provides average faster lookups than <db:link xlink:href="qmap.xml">QMap</db:link>. (See <db:link xlink:href="containers.xml#algorithmic-complexity">Algorithmic Complexity</db:link> for details.)</db:para>
</db:listitem>
<db:listitem>
<db:para>When iterating over a <db:link xlink:href="qhash.xml#the-qhash-hashing-function">QHash</db:link>, the items are arbitrarily ordered. With <db:link xlink:href="qmap.xml">QMap</db:link>, the items are always sorted by key.</db:para>
</db:listitem>
<db:listitem>
<db:para>The key type of a <db:link xlink:href="qhash.xml#the-qhash-hashing-function">QHash</db:link> must provide operator==() and a global <db:link xlink:href="qhash.xml#the-qhash-hashing-function">qHash</db:link>(Key) function. The key type of a <db:link xlink:href="qmap.xml">QMap</db:link> must provide operator&lt;() specifying a total order.</db:para>
</db:listitem>
</db:itemizedlist>
<db:para>Here's an example <db:link xlink:href="qmap.xml">QMap</db:link> with <db:link xlink:href="qstring.xml">QString</db:link> keys and <db:code>int</db:code> values:</db:para>
<db:programlisting language="cpp">QMap&lt;QString, int&gt; map;
</db:programlisting>
<db:para>To insert a (key, value) pair into the map, you can use operator[]():</db:para>
<db:programlisting language="cpp">map[&quot;one&quot;] = 1;
map[&quot;three&quot;] = 3;
map[&quot;seven&quot;] = 7;
</db:programlisting>
<db:para>This inserts the following three (key, value) pairs into the <db:link xlink:href="qmap.xml">QMap</db:link>: (&quot;one&quot;, 1), (&quot;three&quot;, 3), and (&quot;seven&quot;, 7). Another way to insert items into the map is to use insert():</db:para>
<db:programlisting language="cpp">map.insert(&quot;twelve&quot;, 12);
</db:programlisting>
<db:para>To look up a value, use operator[]() or value():</db:para>
<db:programlisting language="cpp">int num1 = map[&quot;thirteen&quot;];
int num2 = map.value(&quot;thirteen&quot;);
</db:programlisting>
<db:para>If there is no item with the specified key in the map, these functions return a <db:link xlink:href="containers.xml#default-constructed-value">default-constructed value</db:link>.</db:para>
<db:para>If you want to check whether the map contains a certain key, use <db:link xlink:href="qml-geoshape.xml#contains">contains()</db:link>:</db:para>
<db:programlisting language="cpp">int timeout = 30;
if (map.contains(&quot;TIMEOUT&quot;))
    timeout = map.value(&quot;TIMEOUT&quot;);
</db:programlisting>
<db:para>There is also a value() overload that uses its second argument as a default value if there is no item with the specified key:</db:para>
<db:programlisting language="cpp">int timeout = map.value(&quot;TIMEOUT&quot;, 30);
</db:programlisting>
<db:para>In general, we recommend that you use <db:link xlink:href="qml-geoshape.xml#contains">contains()</db:link> and value() rather than operator[]() for looking up a key in a map. The reason is that operator[]() silently inserts an item into the map if no item exists with the same key (unless the map is const). For example, the following code snippet will create 1000 items in memory:</db:para>
<db:programlisting language="cpp">// WRONG
QMap&lt;int, QWidget *&gt; map;
...
for (int i = 0; i &lt; 1000; ++i) {
    if (map[i] == okButton)
        cout &lt;&lt; &quot;Found button at index &quot; &lt;&lt; i &lt;&lt; endl;
}
</db:programlisting>
<db:para>To avoid this problem, replace <db:code>map[i]</db:code> with <db:code>map.value(i)</db:code> in the code above.</db:para>
<db:para>If you want to navigate through all the (key, value) pairs stored in a <db:link xlink:href="qmap.xml">QMap</db:link>, you can use an iterator. <db:link xlink:href="qmap.xml">QMap</db:link> provides both <db:link xlink:href="containers.xml#java-style-iterators">Java-style iterators</db:link> (<db:link xlink:href="qmapiterator.xml">QMapIterator</db:link> and <db:link xlink:href="qmutablemapiterator.xml">QMutableMapIterator</db:link>) and <db:link xlink:href="containers.xml#stl-style-iterators">STL-style iterators</db:link> (<db:link xlink:href="qmap-const-iterator.xml">QMap::const_iterator</db:link> and <db:link xlink:href="qmap-iterator.xml">QMap::iterator</db:link>). Here's how to iterate over a <db:link xlink:href="qmap.xml">QMap</db:link>&lt;<db:link xlink:href="qstring.xml">QString</db:link>, int&gt; using a Java-style iterator:</db:para>
<db:programlisting language="cpp">QMapIterator&lt;QString, int&gt; i(map);
while (i.hasNext()) {
    i.next();
    cout &lt;&lt; i.key() &lt;&lt; &quot;: &quot; &lt;&lt; i.value() &lt;&lt; endl;
}
</db:programlisting>
<db:para>Here's the same code, but using an STL-style iterator this time:</db:para>
<db:programlisting language="cpp">QMap&lt;QString, int&gt;::const_iterator i = map.constBegin();
while (i != map.constEnd()) {
    cout &lt;&lt; i.key() &lt;&lt; &quot;: &quot; &lt;&lt; i.value() &lt;&lt; endl;
    ++i;
}
</db:programlisting>
<db:para>The items are traversed in ascending key order.</db:para>
<db:para>Normally, a <db:link xlink:href="qmap.xml">QMap</db:link> allows only one value per key. If you call insert() with a key that already exists in the <db:link xlink:href="qmap.xml">QMap</db:link>, the previous value will be erased. For example:</db:para>
<db:programlisting language="cpp">map.insert(&quot;plenty&quot;, 100);
map.insert(&quot;plenty&quot;, 2000);
// map.value(&quot;plenty&quot;) == 2000
</db:programlisting>
<db:para>However, you can store multiple values per key by using insertMulti() instead of insert() (or using the convenience subclass <db:link xlink:href="qmultimap.xml">QMultiMap</db:link>). If you want to retrieve all the values for a single key, you can use values(const Key &amp;key), which returns a <db:link xlink:href="qlist.xml">QList</db:link>&lt;T&gt;:</db:para>
<db:programlisting language="cpp">QList&lt;int&gt; values = map.values(&quot;plenty&quot;);
for (int i = 0; i &lt; values.size(); ++i)
    cout &lt;&lt; values.at(i) &lt;&lt; endl;
</db:programlisting>
<db:para>The items that share the same key are available from most recently to least recently inserted. Another approach is to call find() to get the STL-style iterator for the first item with a key and iterate from there:</db:para>
<db:programlisting language="cpp">QMap&lt;QString, int&gt;::iterator i = map.find(&quot;plenty&quot;);
while (i != map.end() &amp;&amp; i.key() == &quot;plenty&quot;) {
    cout &lt;&lt; i.value() &lt;&lt; endl;
    ++i;
}
</db:programlisting>
<db:para>If you only need to extract the values from a map (not the keys), you can also use <db:link xlink:href="containers.xml#the-foreach-keyword">foreach</db:link>:</db:para>
<db:programlisting language="cpp">QMap&lt;QString, int&gt; map;
...
foreach (int value, map)
    cout &lt;&lt; value &lt;&lt; endl;
</db:programlisting>
<db:para>Items can be removed from the map in several ways. One way is to call remove(); this will remove any item with the given key. Another way is to use QMutableMapIterator::remove(). In addition, you can clear the entire map using clear().</db:para>
<db:para><db:link xlink:href="qmap.xml">QMap</db:link>'s key and value data types must be <db:link xlink:href="containers.xml#assignable-data-types">assignable data types</db:link>. This covers most data types you are likely to encounter, but the compiler won't let you, for example, store a <db:link xlink:href="qwidget.xml">QWidget</db:link> as a value; instead, store a <db:link xlink:href="qwidget.xml">QWidget</db:link> *. In addition, <db:link xlink:href="qmap.xml">QMap</db:link>'s key type must provide operator&lt;(). <db:link xlink:href="qmap.xml">QMap</db:link> uses it to keep its items sorted, and assumes that two keys <db:code>x</db:code> and <db:code>y</db:code> are equal if neither <db:code>x &lt; y</db:code> nor <db:code>y &lt; x</db:code> is true.</db:para>
<db:para>Example:</db:para>
<db:programlisting language="cpp">#ifndef EMPLOYEE_H
#define EMPLOYEE_H

class Employee
{
public:
    Employee() {}
    Employee(const QString &amp;name, const QDate &amp;dateOfBirth);
    ...

private:
    QString myName;
    QDate myDateOfBirth;
};

inline bool operator&lt;(const Employee &amp;e1, const Employee &amp;e2)
{
    if (e1.name() != e2.name())
        return e1.name() &lt; e2.name();
    return e1.dateOfBirth() &lt; e2.dateOfBirth();
}

#endif // EMPLOYEE_H
</db:programlisting>
<db:para>In the example, we start by comparing the employees' names. If they're equal, we compare their dates of birth to break the tie.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qmapiterator.xml">QMapIterator</db:link></db:member>
<db:member><db:link xlink:href="qmutablemapiterator.xml">QMutableMapIterator</db:link></db:member>
<db:member><db:link xlink:href="qhash.xml#the-qhash-hashing-function">QHash</db:link></db:member>
<db:member><db:link xlink:href="qset.xml">QSet</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="member-type-documentation">
<db:title>Member Type Documentation</db:title>
<db:section xml:id="ConstIterator-typedef">
<db:title>QMap::ConstIterator</db:title>
<db:para>Qt-style synonym for <db:link xlink:href="qmap-const-iterator.xml">QMap::const_iterator</db:link>.</db:para>
</db:section>
<db:section xml:id="Iterator-typedef">
<db:title>QMap::Iterator</db:title>
<db:para>Qt-style synonym for <db:link xlink:href="qmap-iterator.xml">QMap::iterator</db:link>.</db:para>
</db:section>
<db:section xml:id="difference_type-typedef">
<db:title>QMap::difference_type</db:title>
<db:para>Typedef for ptrdiff_t. Provided for STL compatibility.</db:para>
</db:section>
<db:section xml:id="key_type-typedef">
<db:title>QMap::key_type</db:title>
<db:para>Typedef for Key. Provided for STL compatibility.</db:para>
</db:section>
<db:section xml:id="mapped_type-typedef">
<db:title>QMap::mapped_type</db:title>
<db:para>Typedef for T. Provided for STL compatibility.</db:para>
</db:section>
<db:section xml:id="size_type-typedef">
<db:title>QMap::size_type</db:title>
<db:para>Typedef for int. Provided for STL compatibility.</db:para>
</db:section>
</db:section>
</db:article>
