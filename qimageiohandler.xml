<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en">
<db:info>
<db:title>QImageIOHandler Class</db:title>
<db:productname>QtGui</db:productname>
<db:edition>Qt 6.0.4 Reference Documentation</db:edition>
<db:titleabbrev>Qt GUI Reference Documentation</db:titleabbrev>
<db:abstract>
<db:para>The <db:link xlink:href="qimageiohandler.xml">QImageIOHandler</db:link> class defines the common image I/O interface for all image formats in Qt.</db:para>
<db:note>
<db:para>All functions in this class are <db:link xlink:href="threads-reentrancy.xml">reentrant</db:link>.</db:para>
</db:note>
</db:abstract>
<db:pubdate>2024-12-27</db:pubdate>
<db:date>2024-12-27</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:variablelist>
<db:varlistentry>
<db:term>Header</db:term>
<db:listitem>
<db:para>QImageIOHandler</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>CMake</db:term>
<db:listitem>
<db:para>find_package(Qt6 REQUIRED COMPONENTS Gui)</db:para>
<db:para>target_link_libraries(mytarget PRIVATE Qt6::Gui)</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>qmake</db:term>
<db:listitem>
<db:para>QT += gui</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Inherited By</db:term>
<db:listitem>
<db:para/>
</db:listitem>
</db:varlistentry>
</db:variablelist>
<db:section xml:id="details">
<db:title>Detailed Description</db:title>
<db:para>Qt uses <db:link xlink:href="qimageiohandler.xml">QImageIOHandler</db:link> for reading and writing images through <db:link xlink:href="qimagereader.xml">QImageReader</db:link> and <db:link xlink:href="qimagewriter.xml">QImageWriter</db:link>. You can also derive from this class to write your own image format handler using Qt's plugin mechanism.</db:para>
<db:para>Call <db:link xlink:href="qimageiohandler.xml#setDevice">setDevice</db:link>() to assign a device to the handler, and <db:link xlink:href="qimageiohandler.xml#setFormat">setFormat</db:link>() to assign a format to it. One <db:link xlink:href="qimageiohandler.xml">QImageIOHandler</db:link> may support more than one image format. <db:link xlink:href="qimageiohandler.xml#canRead">canRead</db:link>() returns <db:code>true</db:code> if an image can be read from the device, and <db:link xlink:href="qimageiohandler.xml#read">read</db:link>() and <db:link xlink:href="qimageiohandler.xml#write">write</db:link>() return true if reading or writing an image was completed successfully.</db:para>
<db:para><db:link xlink:href="qimageiohandler.xml">QImageIOHandler</db:link> also has support for animations formats, through the functions <db:link xlink:href="qimageiohandler.xml#loopCount">loopCount</db:link>(), <db:link xlink:href="qimageiohandler.xml#imageCount">imageCount</db:link>(), <db:link xlink:href="qimageiohandler.xml#nextImageDelay">nextImageDelay</db:link>() and <db:link xlink:href="qimageiohandler.xml#currentImageNumber">currentImageNumber</db:link>().</db:para>
<db:para>In order to determine what options an image handler supports, Qt will call <db:link xlink:href="qimageiohandler.xml#supportsOption">supportsOption</db:link>() and <db:link xlink:href="qimageiohandler.xml#setOption">setOption</db:link>(). Make sure to reimplement these functions if you can provide support for any of the options in the <db:link xlink:href="qimageiohandler.xml#ImageOption-enum">ImageOption</db:link> enum.</db:para>
<db:para>To write your own image handler, you must at least reimplement <db:link xlink:href="qimageiohandler.xml#canRead">canRead</db:link>() and <db:link xlink:href="qimageiohandler.xml#read">read</db:link>(). Then create a <db:link xlink:href="qimageioplugin.xml">QImageIOPlugin</db:link> that can create the handler. Finally, install your plugin, and <db:link xlink:href="qimagereader.xml">QImageReader</db:link> and <db:link xlink:href="qimagewriter.xml">QImageWriter</db:link> will then automatically load the plugin, and start using it.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qimageioplugin.xml">QImageIOPlugin</db:link></db:member>
<db:member><db:link xlink:href="qimagereader.xml">QImageReader</db:link></db:member>
<db:member><db:link xlink:href="qimagewriter.xml">QImageWriter</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="member-type-documentation">
<db:title>Member Type Documentation</db:title>
<db:section xml:id="ImageOption-enum">
<db:title>enum QImageIOHandler::ImageOption</db:title>
<db:enumsynopsis>
<db:enumname>ImageOption</db:enumname>
<db:enumitem>
<db:enumidentifier>Size</db:enumidentifier>
<db:enumvalue>0</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>ClipRect</db:enumidentifier>
<db:enumvalue>1</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>Description</db:enumidentifier>
<db:enumvalue>2</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>ScaledClipRect</db:enumidentifier>
<db:enumvalue>3</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>ScaledSize</db:enumidentifier>
<db:enumvalue>4</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>CompressionRatio</db:enumidentifier>
<db:enumvalue>5</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>Gamma</db:enumidentifier>
<db:enumvalue>6</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>Quality</db:enumidentifier>
<db:enumvalue>7</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>Name</db:enumidentifier>
<db:enumvalue>8</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>SubType</db:enumidentifier>
<db:enumvalue>9</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>IncrementalReading</db:enumidentifier>
<db:enumvalue>10</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>Endianness</db:enumidentifier>
<db:enumvalue>11</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>Animation</db:enumidentifier>
<db:enumvalue>12</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>BackgroundColor</db:enumidentifier>
<db:enumvalue>13</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>ImageFormat</db:enumidentifier>
<db:enumvalue>14</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>SupportedSubTypes</db:enumidentifier>
<db:enumvalue>15</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>OptimizedWrite</db:enumidentifier>
<db:enumvalue>16</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>ProgressiveScanWrite</db:enumidentifier>
<db:enumvalue>17</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>ImageTransformation</db:enumidentifier>
<db:enumvalue>18</db:enumvalue>
</db:enumitem>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:enumsynopsis>
<db:para>This enum describes the different options supported by <db:link xlink:href="qimageiohandler.xml">QImageIOHandler</db:link>. Some options are used to query an image for properties, and others are used to toggle the way in which an image should be written.</db:para>
<db:informaltable>
<db:thead>
<db:tr>
<db:th>Constant</db:th>
<db:th>Value</db:th>
<db:th>Description</db:th>
</db:tr>
</db:thead>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qimageiohandler.xml">QImageIOHandler</db:link></db:emphasis>::Size</db:code></db:para>
</db:td>
<db:td><db:code>0</db:code></db:td>
<db:td>
<db:para>The original size of an image. A handler that supports this option is expected to read the size of the image from the image metadata, and return this size from <db:link xlink:href="qimageiohandler.xml#option">option</db:link>() as a <db:link xlink:href="qsize.xml">QSize</db:link>.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qimageiohandler.xml">QImageIOHandler</db:link></db:emphasis>::ClipRect</db:code></db:para>
</db:td>
<db:td><db:code>1</db:code></db:td>
<db:td>
<db:para>The clip rect, or ROI (Region Of Interest). A handler that supports this option is expected to only read the provided <db:link xlink:href="qrect.xml">QRect</db:link> area from the original image in <db:link xlink:href="qimageiohandler.xml#read">read</db:link>(), before any other transformation is applied.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qimageiohandler.xml">QImageIOHandler</db:link></db:emphasis>::ScaledSize</db:code></db:para>
</db:td>
<db:td><db:code>4</db:code></db:td>
<db:td>
<db:para>The scaled size of the image. A handler that supports this option is expected to scale the image to the provided size (a <db:link xlink:href="qsize.xml">QSize</db:link>), after applying any clip rect transformation (ClipRect). If the handler does not support this option, <db:link xlink:href="qimagereader.xml">QImageReader</db:link> will perform the scaling after the image has been read.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qimageiohandler.xml">QImageIOHandler</db:link></db:emphasis>::ScaledClipRect</db:code></db:para>
</db:td>
<db:td><db:code>3</db:code></db:td>
<db:td>
<db:para>The scaled clip rect (or ROI, Region Of Interest) of the image. A handler that supports this option is expected to apply the provided clip rect (a <db:link xlink:href="qrect.xml">QRect</db:link>), after applying any scaling (ScaleSize) or regular clipping (ClipRect). If the handler does not support this option, <db:link xlink:href="qimagereader.xml">QImageReader</db:link> will apply the scaled clip rect after the image has been read.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qimageiohandler.xml">QImageIOHandler</db:link></db:emphasis>::Description</db:code></db:para>
</db:td>
<db:td><db:code>2</db:code></db:td>
<db:td>
<db:para>The image description. Some image formats, such as GIF and PNG, allow embedding of text or comments into the image data (e.g., for storing copyright information). It's common that the text is stored in key-value pairs, but some formats store all text in one continuous block. <db:link xlink:href="qimageiohandler.xml">QImageIOHandler</db:link> returns the text as one <db:link xlink:href="qstring.xml">QString</db:link>, where keys and values are separated by a ':', and keys-value pairs are separated by two newlines (\n\n). For example, &quot;Title: Sunset\n\nAuthor: Jim Smith\nSarah Jones\n\n&quot;. Formats that store text in a single block can use &quot;Description&quot; as the key.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qimageiohandler.xml">QImageIOHandler</db:link></db:emphasis>::CompressionRatio</db:code></db:para>
</db:td>
<db:td><db:code>5</db:code></db:td>
<db:td>
<db:para>The compression ratio of the image data. A handler that supports this option is expected to set its compression rate depending on the value of this option (an int) when writing.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qimageiohandler.xml">QImageIOHandler</db:link></db:emphasis>::Gamma</db:code></db:para>
</db:td>
<db:td><db:code>6</db:code></db:td>
<db:td>
<db:para>The gamma level of the image. A handler that supports this option is expected to set the image gamma level depending on the value of this option (a float) when writing.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qimageiohandler.xml">QImageIOHandler</db:link></db:emphasis>::Quality</db:code></db:para>
</db:td>
<db:td><db:code>7</db:code></db:td>
<db:td>
<db:para>The quality level of the image. A handler that supports this option is expected to set the image quality level depending on the value of this option (an int) when writing.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qimageiohandler.xml">QImageIOHandler</db:link></db:emphasis>::Name</db:code></db:para>
</db:td>
<db:td><db:code>8</db:code></db:td>
<db:td>
<db:para>The name of the image. A handler that supports this option is expected to read the name from the image metadata and return this as a <db:link xlink:href="qstring.xml">QString</db:link>, or when writing an image it is expected to store the name in the image metadata.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qimageiohandler.xml">QImageIOHandler</db:link></db:emphasis>::SubType</db:code></db:para>
</db:td>
<db:td><db:code>9</db:code></db:td>
<db:td>
<db:para>The subtype of the image. A handler that supports this option can use the subtype value to help when reading and writing images. For example, a PPM handler may have a subtype value of &quot;ppm&quot; or &quot;ppmraw&quot;.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qimageiohandler.xml">QImageIOHandler</db:link></db:emphasis>::IncrementalReading</db:code></db:para>
</db:td>
<db:td><db:code>10</db:code></db:td>
<db:td>
<db:para>A handler that supports this option is expected to read the image in several passes, as if it was an animation. <db:link xlink:href="qimagereader.xml">QImageReader</db:link> will treat the image as an animation.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qimageiohandler.xml">QImageIOHandler</db:link></db:emphasis>::Endianness</db:code></db:para>
</db:td>
<db:td><db:code>11</db:code></db:td>
<db:td>
<db:para>The endianness of the image. Certain image formats can be stored as BigEndian or LittleEndian. A handler that supports Endianness uses the value of this option to determine how the image should be stored.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qimageiohandler.xml">QImageIOHandler</db:link></db:emphasis>::Animation</db:code></db:para>
</db:td>
<db:td><db:code>12</db:code></db:td>
<db:td>
<db:para>Image formats that support animation return true for this value in <db:link xlink:href="qimageiohandler.xml#supportsOption">supportsOption</db:link>(); otherwise, false is returned.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qimageiohandler.xml">QImageIOHandler</db:link></db:emphasis>::BackgroundColor</db:code></db:para>
</db:td>
<db:td><db:code>13</db:code></db:td>
<db:td>
<db:para>Certain image formats allow the background color to be specified. A handler that supports BackgroundColor initializes the background color to this option (a <db:link xlink:href="qcolor.xml">QColor</db:link>) when reading an image.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qimageiohandler.xml">QImageIOHandler</db:link></db:emphasis>::ImageFormat</db:code></db:para>
</db:td>
<db:td><db:code>14</db:code></db:td>
<db:td>
<db:para>The image's data format returned by the handler. This can be any of the formats listed in <db:link xlink:href="qimage.xml#Format-enum">QImage::Format</db:link>.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qimageiohandler.xml">QImageIOHandler</db:link></db:emphasis>::SupportedSubTypes</db:code></db:para>
</db:td>
<db:td><db:code>15</db:code></db:td>
<db:td>
<db:para>Image formats that support different saving variants should return a list of supported variant names (<db:link xlink:href="qlist.xml">QList</db:link>&lt;<db:link xlink:href="qbytearray.xml">QByteArray</db:link>&gt;) in this option.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qimageiohandler.xml">QImageIOHandler</db:link></db:emphasis>::OptimizedWrite</db:code></db:para>
</db:td>
<db:td><db:code>16</db:code></db:td>
<db:td>
<db:para>. A handler which supports this option is expected to turn on optimization flags when writing.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qimageiohandler.xml">QImageIOHandler</db:link></db:emphasis>::ProgressiveScanWrite</db:code></db:para>
</db:td>
<db:td><db:code>17</db:code></db:td>
<db:td>
<db:para>. A handler which supports this option is expected to write the image as a progressive scan image.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qimageiohandler.xml">QImageIOHandler</db:link></db:emphasis>::ImageTransformation</db:code></db:para>
</db:td>
<db:td><db:code>18</db:code></db:td>
<db:td>
<db:para>. A handler which supports this option can read the transformation metadata of an image. A handler that supports this option should not apply the transformation itself.</db:para>
</db:td>
</db:tr>
</db:informaltable>
</db:section>
<db:section xml:id="Transformation-enum">
<db:title>[since 5.5] enum QImageIOHandler::Transformation</db:title>
<db:bridgehead renderas="sect2">flags QImageIOHandler::Transformations</db:bridgehead>
<db:enumsynopsis>
<db:enumname>Transformation</db:enumname>
<db:enumitem>
<db:enumidentifier>TransformationNone</db:enumidentifier>
<db:enumvalue>0</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>TransformationMirror</db:enumidentifier>
<db:enumvalue>1</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>TransformationFlip</db:enumidentifier>
<db:enumvalue>2</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>TransformationRotate180</db:enumidentifier>
<db:enumvalue>TransformationMirror | TransformationFlip</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>TransformationRotate90</db:enumidentifier>
<db:enumvalue>4</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>TransformationMirrorAndRotate90</db:enumidentifier>
<db:enumvalue>TransformationMirror | TransformationRotate90</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>TransformationFlipAndRotate90</db:enumidentifier>
<db:enumvalue>TransformationFlip | TransformationRotate90</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>TransformationRotate270</db:enumidentifier>
<db:enumvalue>TransformationRotate180 | TransformationRotate90</db:enumvalue>
</db:enumitem>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:enumsynopsis>
<db:typedefsynopsis>
<db:typedefname>QImageIOHandler::Transformations</db:typedefname>
</db:typedefsynopsis>
<db:para>This enum describes the different transformations or orientations supported by some image formats, usually through EXIF.</db:para>
<db:informaltable>
<db:thead>
<db:tr>
<db:th>Constant</db:th>
<db:th>Value</db:th>
<db:th>Description</db:th>
</db:tr>
</db:thead>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qimageiohandler.xml">QImageIOHandler</db:link></db:emphasis>::TransformationNone</db:code></db:para>
</db:td>
<db:td><db:code>0</db:code></db:td>
<db:td>
<db:para>No transformation should be applied.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qimageiohandler.xml">QImageIOHandler</db:link></db:emphasis>::TransformationMirror</db:code></db:para>
</db:td>
<db:td><db:code>1</db:code></db:td>
<db:td>
<db:para>Mirror the image horizontally.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qimageiohandler.xml">QImageIOHandler</db:link></db:emphasis>::TransformationFlip</db:code></db:para>
</db:td>
<db:td><db:code>2</db:code></db:td>
<db:td>
<db:para>Mirror the image vertically.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qimageiohandler.xml">QImageIOHandler</db:link></db:emphasis>::TransformationRotate180</db:code></db:para>
</db:td>
<db:td><db:code>TransformationMirror | TransformationFlip</db:code></db:td>
<db:td>
<db:para>Rotate the image 180 degrees. This is the same as mirroring it both horizontally and vertically.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qimageiohandler.xml">QImageIOHandler</db:link></db:emphasis>::TransformationRotate90</db:code></db:para>
</db:td>
<db:td><db:code>4</db:code></db:td>
<db:td>
<db:para>Rotate the image 90 degrees.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qimageiohandler.xml">QImageIOHandler</db:link></db:emphasis>::TransformationMirrorAndRotate90</db:code></db:para>
</db:td>
<db:td><db:code>TransformationMirror | TransformationRotate90</db:code></db:td>
<db:td>
<db:para>Mirror the image horizontally and then rotate it 90 degrees.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qimageiohandler.xml">QImageIOHandler</db:link></db:emphasis>::TransformationFlipAndRotate90</db:code></db:para>
</db:td>
<db:td><db:code>TransformationFlip | TransformationRotate90</db:code></db:td>
<db:td>
<db:para>Mirror the image vertically and then rotate it 90 degrees.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qimageiohandler.xml">QImageIOHandler</db:link></db:emphasis>::TransformationRotate270</db:code></db:para>
</db:td>
<db:td><db:code>TransformationRotate180 | TransformationRotate90</db:code></db:td>
<db:td>
<db:para>Rotate the image 270 degrees. This is the same as mirroring it both horizontally, vertically and then rotating it 90 degrees.</db:para>
</db:td>
</db:tr>
</db:informaltable>
<db:para>This enum was introduced or modified in Qt 5.5.</db:para>
<db:para>The <db:code>Transformations</db:code> type is a typedef for <db:code><db:link xlink:href="qflags.xml">QFlags</db:link>&lt;Transformation&gt;. </db:code>It stores an OR combination of <db:code>Transformation</db:code> values.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qimagereader.xml#transformation">QImageReader::transformation</db:link>()</db:member>
<db:member><db:link xlink:href="qimagereader.xml#setAutoTransform">QImageReader::setAutoTransform</db:link>()</db:member>
<db:member><db:link xlink:href="qimagewriter.xml#setTransformation">QImageWriter::setTransformation</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
</db:section>
<db:section xml:id="member-function-documentation">
<db:title>Member Function Documentation</db:title>
<db:section xml:id="QImageIOHandler">
<db:title>QImageIOHandler::QImageIOHandler()</db:title>
<db:constructorsynopsis>
<db:methodname>QImageIOHandler</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">constructor</db:synopsisinfo>
<db:synopsisinfo role="signature">QImageIOHandler()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:constructorsynopsis>
<db:para>Constructs a <db:link xlink:href="qimageiohandler.xml">QImageIOHandler</db:link> object.</db:para>
</db:section>
<db:section xml:id="dtor.QImageIOHandler">
<db:title>[virtual] QImageIOHandler::~QImageIOHandler()</db:title>
<db:destructorsynopsis>
<db:modifier>virtual</db:modifier>
<db:methodname>~QImageIOHandler</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">destructor</db:synopsisinfo>
<db:synopsisinfo role="signature">~QImageIOHandler()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:destructorsynopsis>
<db:para>Destructs the <db:link xlink:href="qimageiohandler.xml">QImageIOHandler</db:link> object.</db:para>
</db:section>
<db:section xml:id="allocateImage">
<db:title>[static, since 6.0] bool QImageIOHandler::allocateImage(QSize <db:emphasis>size</db:emphasis>, QImage::Format <db:emphasis>format</db:emphasis>, QImage *<db:emphasis>image</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:modifier>static</db:modifier>
<db:type>bool</db:type>
<db:methodname>allocateImage</db:methodname>
<db:methodparam>
<db:type>QSize</db:type>
<db:parameter>size</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>QImage::Format</db:type>
<db:parameter>format</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>QImage *</db:type>
<db:parameter>image</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool allocateImage(QSize size, QImage::Format format, QImage *image)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is a convenience method for the reading function in subclasses. Image format handlers must reject loading an image if the required allocation would exceeed the current allocation limit. This function checks the parameters and limit, and does the allocation if it is valid and required. Upon successful return, <db:code role="parameter">image</db:code> will be a valid, detached <db:link xlink:href="qimage.xml">QImage</db:link> of the given <db:code role="parameter">size</db:code> and <db:code role="parameter">format</db:code>.</db:para>
<db:para>This function was introduced in Qt 6.0.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qimagereader.xml#allocationLimit">QImageReader::allocationLimit</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="canRead">
<db:title>[pure virtual] bool QImageIOHandler::canRead() const</db:title>
<db:methodsynopsis>
<db:modifier>virtual</db:modifier>
<db:modifier>const</db:modifier>
<db:type>bool</db:type>
<db:methodname>canRead</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool canRead() const = 0</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns <db:code>true</db:code> if an image can be read from the device (i.e., the image format is supported, the device can be read from and the initial header information suggests that the image can be read); otherwise returns <db:code>false</db:code>.</db:para>
<db:para>When reimplementing canRead(), make sure that the I/O device (<db:link xlink:href="qimageiohandler.xml#device">device</db:link>()) is left in its original state (e.g., by using peek() rather than <db:link xlink:href="qimageiohandler.xml#read">read</db:link>()).</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qimageiohandler.xml#read">read</db:link>()</db:member>
<db:member><db:link xlink:href="qiodevice.xml#peek">QIODevice::peek</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="currentImageNumber">
<db:title>[virtual] int QImageIOHandler::currentImageNumber() const</db:title>
<db:methodsynopsis>
<db:modifier>virtual</db:modifier>
<db:modifier>const</db:modifier>
<db:type>int</db:type>
<db:methodname>currentImageNumber</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">int currentImageNumber() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>For image formats that support animation, this function returns the sequence number of the current image in the animation. If this function is called before any image is <db:link xlink:href="qimageiohandler.xml#read">read</db:link>(), -1 is returned. The number of the first image in the sequence is 0.</db:para>
<db:para>If the image format does not support animation, 0 is returned.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qimageiohandler.xml#read">read</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="currentImageRect">
<db:title>[virtual] QRect QImageIOHandler::currentImageRect() const</db:title>
<db:methodsynopsis>
<db:modifier>virtual</db:modifier>
<db:modifier>const</db:modifier>
<db:type>QRect</db:type>
<db:methodname>currentImageRect</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QRect currentImageRect() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the rect of the current image. If no rect is defined for the image, and empty QRect() is returned.</db:para>
<db:para>This function is useful for animations, where only parts of the frame may be updated at a time.</db:para>
</db:section>
<db:section xml:id="device">
<db:title>QIODevice *QImageIOHandler::device() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QIODevice *</db:type>
<db:methodname>device</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QIODevice * device() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the device currently assigned to the <db:link xlink:href="qimageiohandler.xml">QImageIOHandler</db:link>. If not device has been assigned, <db:code>nullptr</db:code> is returned.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qimageiohandler.xml#setDevice">setDevice</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="format">
<db:title>QByteArray QImageIOHandler::format() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QByteArray</db:type>
<db:methodname>format</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QByteArray format() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the format that is currently assigned to <db:link xlink:href="qimageiohandler.xml">QImageIOHandler</db:link>. If no format has been assigned, an empty string is returned.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qimageiohandler.xml#setFormat">setFormat</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="imageCount">
<db:title>[virtual] int QImageIOHandler::imageCount() const</db:title>
<db:methodsynopsis>
<db:modifier>virtual</db:modifier>
<db:modifier>const</db:modifier>
<db:type>int</db:type>
<db:methodname>imageCount</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">int imageCount() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>For image formats that support animation, this function returns the number of images in the animation. If the image format does not support animation, or if it is unable to determine the number of images, 0 is returned.</db:para>
<db:para>The default implementation returns 1 if <db:link xlink:href="qimageiohandler.xml#canRead">canRead</db:link>() returns <db:code>true</db:code>; otherwise 0 is returned.</db:para>
</db:section>
<db:section xml:id="jumpToImage">
<db:title>[virtual] bool QImageIOHandler::jumpToImage(int <db:emphasis>imageNumber</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:modifier>virtual</db:modifier>
<db:type>bool</db:type>
<db:methodname>jumpToImage</db:methodname>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>imageNumber</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool jumpToImage(int imageNumber)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>For image formats that support animation, this function jumps to the image whose sequence number is <db:code role="parameter">imageNumber</db:code>. The next call to <db:link xlink:href="qimageiohandler.xml#read">read</db:link>() will attempt to read this image.</db:para>
<db:para>The default implementation does nothing, and returns <db:code>false</db:code>.</db:para>
</db:section>
<db:section xml:id="jumpToNextImage">
<db:title>[virtual] bool QImageIOHandler::jumpToNextImage()</db:title>
<db:methodsynopsis>
<db:modifier>virtual</db:modifier>
<db:type>bool</db:type>
<db:methodname>jumpToNextImage</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool jumpToNextImage()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>For image formats that support animation, this function jumps to the next image.</db:para>
<db:para>The default implementation does nothing, and returns <db:code>false</db:code>.</db:para>
</db:section>
<db:section xml:id="loopCount">
<db:title>[virtual] int QImageIOHandler::loopCount() const</db:title>
<db:methodsynopsis>
<db:modifier>virtual</db:modifier>
<db:modifier>const</db:modifier>
<db:type>int</db:type>
<db:methodname>loopCount</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">int loopCount() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>For image formats that support animation, this function returns the number of times the animation should loop. If the image format does not support animation, 0 is returned.</db:para>
</db:section>
<db:section xml:id="nextImageDelay">
<db:title>[virtual] int QImageIOHandler::nextImageDelay() const</db:title>
<db:methodsynopsis>
<db:modifier>virtual</db:modifier>
<db:modifier>const</db:modifier>
<db:type>int</db:type>
<db:methodname>nextImageDelay</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">int nextImageDelay() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>For image formats that support animation, this function returns the number of milliseconds to wait until reading the next image. If the image format does not support animation, 0 is returned.</db:para>
</db:section>
<db:section xml:id="option">
<db:title>[virtual] QVariant QImageIOHandler::option(QImageIOHandler::ImageOption <db:emphasis>option</db:emphasis>) const</db:title>
<db:methodsynopsis>
<db:modifier>virtual</db:modifier>
<db:modifier>const</db:modifier>
<db:type>QVariant</db:type>
<db:methodname>option</db:methodname>
<db:methodparam>
<db:type>QImageIOHandler::ImageOption</db:type>
<db:parameter>option</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QVariant option(QImageIOHandler::ImageOption option) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the value assigned to <db:code role="parameter">option</db:code> as a <db:link xlink:href="qvariant.xml">QVariant</db:link>. The type of the value depends on the option. For example, option(Size) returns a <db:link xlink:href="qsize.xml">QSize</db:link> variant.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qimageiohandler.xml#setOption">setOption</db:link>()</db:member>
<db:member><db:link xlink:href="qimageiohandler.xml#supportsOption">supportsOption</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="read">
<db:title>[pure virtual] bool QImageIOHandler::read(QImage *<db:emphasis>image</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:modifier>virtual</db:modifier>
<db:type>bool</db:type>
<db:methodname>read</db:methodname>
<db:methodparam>
<db:type>QImage *</db:type>
<db:parameter>image</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool read(QImage *image) = 0</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Read an image from the device, and stores it in <db:code role="parameter">image</db:code>. Returns <db:code>true</db:code> if the image is successfully read; otherwise returns false.</db:para>
<db:para>For image formats that support incremental loading, and for animation formats, the image handler can assume that <db:code role="parameter">image</db:code> points to the previous frame.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qimageiohandler.xml#canRead">canRead</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setDevice">
<db:title>void QImageIOHandler::setDevice(QIODevice *<db:emphasis>device</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>setDevice</db:methodname>
<db:methodparam>
<db:type>QIODevice *</db:type>
<db:parameter>device</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void setDevice(QIODevice *device)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Sets the device of the <db:link xlink:href="qimageiohandler.xml">QImageIOHandler</db:link> to <db:code role="parameter">device</db:code>. The image handler will use this device when reading and writing images.</db:para>
<db:para>The device can only be set once and must be set before calling <db:link xlink:href="qimageiohandler.xml#canRead">canRead</db:link>(), <db:link xlink:href="qimageiohandler.xml#read">read</db:link>(), <db:link xlink:href="qimageiohandler.xml#write">write</db:link>(), etc. If you need to read multiple files, construct multiple instances of the appropriate <db:link xlink:href="qimageiohandler.xml">QImageIOHandler</db:link> subclass.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qimageiohandler.xml#device">device</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setFormat">
<db:title>void QImageIOHandler::setFormat(const QByteArray &amp;<db:emphasis>format</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>setFormat</db:methodname>
<db:methodparam>
<db:type>const QByteArray &amp;</db:type>
<db:parameter>format</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void setFormat(const QByteArray &amp;format)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Sets the format of the <db:link xlink:href="qimageiohandler.xml">QImageIOHandler</db:link> to <db:code role="parameter">format</db:code>. The format is most useful for handlers that support multiple image formats.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qimageiohandler.xml#format">format</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setFormat-1">
<db:title>void QImageIOHandler::setFormat(const QByteArray &amp;<db:emphasis>format</db:emphasis>) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:void/>
<db:methodname>setFormat</db:methodname>
<db:methodparam>
<db:type>const QByteArray &amp;</db:type>
<db:parameter>format</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">void setFormat(const QByteArray &amp;format) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Sets the format of the <db:link xlink:href="qimageiohandler.xml">QImageIOHandler</db:link> to <db:code role="parameter">format</db:code>. The format is most useful for handlers that support multiple image formats.</db:para>
<db:para>This function is declared const so that it can be called from <db:link xlink:href="qimageiohandler.xml#canRead">canRead</db:link>().</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qimageiohandler.xml#format">format</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setOption">
<db:title>[virtual] void QImageIOHandler::setOption(QImageIOHandler::ImageOption <db:emphasis>option</db:emphasis>, const QVariant &amp;<db:emphasis>value</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:modifier>virtual</db:modifier>
<db:void/>
<db:methodname>setOption</db:methodname>
<db:methodparam>
<db:type>QImageIOHandler::ImageOption</db:type>
<db:parameter>option</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const QVariant &amp;</db:type>
<db:parameter>value</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void setOption(QImageIOHandler::ImageOption option, const QVariant &amp;value)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Sets the option <db:code role="parameter">option</db:code> with the value <db:code role="parameter">value</db:code>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qimageiohandler.xml#option">option</db:link>()</db:member>
<db:member><db:link xlink:href="qimageiohandler.xml#ImageOption-enum">ImageOption</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="supportsOption">
<db:title>[virtual] bool QImageIOHandler::supportsOption(QImageIOHandler::ImageOption <db:emphasis>option</db:emphasis>) const</db:title>
<db:methodsynopsis>
<db:modifier>virtual</db:modifier>
<db:modifier>const</db:modifier>
<db:type>bool</db:type>
<db:methodname>supportsOption</db:methodname>
<db:methodparam>
<db:type>QImageIOHandler::ImageOption</db:type>
<db:parameter>option</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool supportsOption(QImageIOHandler::ImageOption option) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns <db:code>true</db:code> if the <db:link xlink:href="qimageiohandler.xml">QImageIOHandler</db:link> supports the option <db:code role="parameter">option</db:code>; otherwise returns <db:code>false</db:code>. For example, if the <db:link xlink:href="qimageiohandler.xml">QImageIOHandler</db:link> supports the <db:link xlink:href="qimageiohandler.xml#ImageOption-enum">Size</db:link> option, supportsOption(Size) must return true.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qimageiohandler.xml#setOption">setOption</db:link>()</db:member>
<db:member><db:link xlink:href="qimageiohandler.xml#option">option</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="write">
<db:title>[virtual] bool QImageIOHandler::write(const QImage &amp;<db:emphasis>image</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:modifier>virtual</db:modifier>
<db:type>bool</db:type>
<db:methodname>write</db:methodname>
<db:methodparam>
<db:type>const QImage &amp;</db:type>
<db:parameter>image</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool write(const QImage &amp;image)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Writes the image <db:code role="parameter">image</db:code> to the assigned device. Returns <db:code>true</db:code> on success; otherwise returns <db:code>false</db:code>.</db:para>
<db:para>The default implementation does nothing, and simply returns <db:code>false</db:code>.</db:para>
</db:section>
</db:section>
</db:article>
