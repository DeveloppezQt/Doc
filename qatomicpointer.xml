<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en">
<db:info>
<db:title>QAtomicPointer Class</db:title>
<db:subtitle>template &lt;typename T&gt; class QAtomicPointer</db:subtitle>
<db:productname>QtCore</db:productname>
<db:edition>Qt 5.7.1 Reference Documentation</db:edition>
<db:titleabbrev>Qt Core Reference Documentation</db:titleabbrev>
<db:abstract>
<db:para>The <db:link xlink:href="qatomicpointer.xml">QAtomicPointer</db:link> class is a template class that provides platform-independent atomic operations on pointers.</db:para>
<db:para>This class was introduced in Qt 4.4.</db:para>
</db:abstract>
<db:pubdate>2025-06-29</db:pubdate>
<db:date>2025-06-29</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:variablelist>
<db:varlistentry>
<db:term>Header</db:term>
<db:listitem>
<db:para>QAtomicPointer</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Since</db:term>
<db:listitem>
<db:para>Qt 4.4</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>qmake</db:term>
<db:listitem>
<db:para>QT += core</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Inherits</db:term>
<db:listitem>
<db:para><db:link xlink:href="qbasicatomicpointer.xml" xlink:role="class">QBasicAtomicPointer</db:link></db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Group</db:term>
<db:listitem>
<db:para>QAtomicPointer is part of <db:simplelist><db:member>thread</db:member></db:simplelist>
</db:para>
</db:listitem>
</db:varlistentry>
</db:variablelist>
<db:section xml:id="details">
<db:title>Detailed Description</db:title>
<db:para>For atomic operations on integers, see the <db:link xlink:href="qatomicinteger.xml">QAtomicInteger</db:link> class.</db:para>
<db:para>An <db:emphasis>atomic</db:emphasis> operation is a complex operation that completes without interruption. The <db:link xlink:href="qatomicpointer.xml">QAtomicPointer</db:link> class provides atomic test-and-set, fetch-and-store, and fetch-and-add for pointers.</db:para>
<db:section xml:id="the-atomic-api">
<db:title>The Atomic API</db:title>
<db:section xml:id="memory-ordering">
<db:title>Memory ordering</db:title>
<db:para><db:link xlink:href="qatomicpointer.xml">QAtomicPointer</db:link> provides several implementations of the atomic test-and-set, fetch-and-store, and fetch-and-add functions. Each implementation defines a memory ordering semantic that describes how memory accesses surrounding the atomic instruction are executed by the processor. Since many modern architectures allow out-of-order execution and memory ordering, using the correct semantic is necessary to ensure that your application functions properly on all processors.</db:para>
<db:itemizedlist>
<db:listitem>
<db:para>Relaxed - memory ordering is unspecified, leaving the compiler and processor to freely reorder memory accesses.</db:para>
</db:listitem>
<db:listitem>
<db:para>Acquire - memory access following the atomic operation (in program order) may not be re-ordered before the atomic operation.</db:para>
</db:listitem>
<db:listitem>
<db:para>Release - memory access before the atomic operation (in program order) may not be re-ordered after the atomic operation.</db:para>
</db:listitem>
<db:listitem>
<db:para>Ordered - the same Acquire and Release semantics combined.</db:para>
</db:listitem>
</db:itemizedlist>
</db:section>
<db:section xml:id="test-and-set">
<db:title>Test-and-set</db:title>
<db:para>If the current value of the <db:link xlink:href="qatomicpointer.xml">QAtomicPointer</db:link> is an expected value, the test-and-set functions assign a new value to the <db:link xlink:href="qatomicpointer.xml">QAtomicPointer</db:link> and return true. If values are <db:code role="parameter">not</db:code> the same, these functions do nothing and return false. This operation equates to the following code:</db:para>
<db:programlisting language="cpp">if (currentValue == expectedValue) {
    currentValue = newValue;
    return true;
}
return false;
</db:programlisting>
<db:para>There are 4 test-and-set functions: testAndSetRelaxed(), testAndSetAcquire(), testAndSetRelease(), and testAndSetOrdered(). See above for an explanation of the different memory ordering semantics.</db:para>
</db:section>
<db:section xml:id="fetch-and-store">
<db:title>Fetch-and-store</db:title>
<db:para>The atomic fetch-and-store functions read the current value of the <db:link xlink:href="qatomicpointer.xml">QAtomicPointer</db:link> and then assign a new value, returning the original value. This operation equates to the following code:</db:para>
<db:programlisting language="cpp">T *originalValue = currentValue;
currentValue = newValue;
return originalValue;
</db:programlisting>
<db:para>There are 4 fetch-and-store functions: fetchAndStoreRelaxed(), fetchAndStoreAcquire(), fetchAndStoreRelease(), and fetchAndStoreOrdered(). See above for an explanation of the different memory ordering semantics.</db:para>
</db:section>
<db:section xml:id="fetch-and-add">
<db:title>Fetch-and-add</db:title>
<db:para>The atomic fetch-and-add functions read the current value of the <db:link xlink:href="qatomicpointer.xml">QAtomicPointer</db:link> and then add the given value to the current value, returning the original value. This operation equates to the following code:</db:para>
<db:programlisting language="cpp">T *originalValue = currentValue;
currentValue += valueToAdd;
return originalValue;
</db:programlisting>
<db:para>There are 4 fetch-and-add functions: fetchAndAddRelaxed(), fetchAndAddAcquire(), fetchAndAddRelease(), and fetchAndAddOrdered(). See above for an explanation of the different memory ordering semantics.</db:para>
</db:section>
</db:section>
<db:section xml:id="feature-tests-for-the-atomic-api">
<db:title>Feature Tests for the Atomic API</db:title>
<db:para>Providing a platform-independent atomic API that works on all processors is challenging. The API provided by <db:link xlink:href="qatomicpointer.xml">QAtomicPointer</db:link> is guaranteed to work atomically on all processors. However, since not all processors implement support for every operation provided by <db:link xlink:href="qatomicpointer.xml">QAtomicPointer</db:link>, it is necessary to expose information about the processor.</db:para>
<db:para>You can check at compile time which features are supported on your hardware using various macros. These will tell you if your hardware always, sometimes, or does not support a particular operation. The macros have the form Q_ATOMIC_POINTER_<db:emphasis>OPERATION</db:emphasis>_IS_<db:emphasis>HOW</db:emphasis>_NATIVE. <db:emphasis>OPERATION</db:emphasis> is one of <db:link xlink:href="qatomicpointer.xml#test-and-set">TEST_AND_SET</db:link>, <db:link xlink:href="qatomicpointer.xml#fetch-and-store">FETCH_AND_STORE</db:link>, or <db:link xlink:href="qatomicpointer.xml#fetch-and-add">FETCH_AND_ADD</db:link>, and <db:emphasis>HOW</db:emphasis> is one of ALWAYS, SOMETIMES, or NOT. There will always be exactly one defined macro per operation. For example, if <db:link xlink:href="qatomicpointer.xml#Q_ATOMIC_POINTER_TEST_AND_SET_IS_ALWAYS_NATIVE">Q_ATOMIC_POINTER_TEST_AND_SET_IS_ALWAYS_NATIVE</db:link> is defined, neither <db:link xlink:href="qatomicpointer.xml#Q_ATOMIC_POINTER_TEST_AND_SET_IS_SOMETIMES_NATIVE">Q_ATOMIC_POINTER_TEST_AND_SET_IS_SOMETIMES_NATIVE</db:link> nor <db:link xlink:href="qatomicpointer.xml#Q_ATOMIC_POINTER_TEST_AND_SET_IS_NOT_NATIVE">Q_ATOMIC_POINTER_TEST_AND_SET_IS_NOT_NATIVE</db:link> will be defined.</db:para>
<db:para>An operation that completes in constant time is said to be wait-free. Such operations are not implemented using locks or loops of any kind. For atomic operations that are always supported, and that are wait-free, Qt defines the Q_ATOMIC_POINTER_<db:emphasis>OPERATION</db:emphasis>_IS_WAIT_FREE in addition to the Q_ATOMIC_POINTER_<db:emphasis>OPERATION</db:emphasis>_IS_ALWAYS_NATIVE.</db:para>
<db:para>In cases where an atomic operation is only supported in newer generations of the processor, <db:link xlink:href="qatomicpointer.xml">QAtomicPointer</db:link> also provides a way to check at runtime what your hardware supports with the isTestAndSetNative(), isFetchAndStoreNative(), and isFetchAndAddNative() functions. Wait-free implementations can be detected using the isTestAndSetWaitFree(), isFetchAndStoreWaitFree(), and isFetchAndAddWaitFree() functions.</db:para>
<db:para>Below is a complete list of all feature macros for <db:link xlink:href="qatomicpointer.xml">QAtomicPointer</db:link>:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:link xlink:href="qatomicpointer.xml#Q_ATOMIC_POINTER_TEST_AND_SET_IS_ALWAYS_NATIVE">Q_ATOMIC_POINTER_TEST_AND_SET_IS_ALWAYS_NATIVE</db:link></db:para>
</db:listitem>
<db:listitem>
<db:para><db:link xlink:href="qatomicpointer.xml#Q_ATOMIC_POINTER_TEST_AND_SET_IS_SOMETIMES_NATIVE">Q_ATOMIC_POINTER_TEST_AND_SET_IS_SOMETIMES_NATIVE</db:link></db:para>
</db:listitem>
<db:listitem>
<db:para><db:link xlink:href="qatomicpointer.xml#Q_ATOMIC_POINTER_TEST_AND_SET_IS_NOT_NATIVE">Q_ATOMIC_POINTER_TEST_AND_SET_IS_NOT_NATIVE</db:link></db:para>
</db:listitem>
<db:listitem>
<db:para><db:link xlink:href="qatomicpointer.xml#Q_ATOMIC_POINTER_TEST_AND_SET_IS_WAIT_FREE">Q_ATOMIC_POINTER_TEST_AND_SET_IS_WAIT_FREE</db:link></db:para>
</db:listitem>
<db:listitem>
<db:para><db:link xlink:href="qatomicpointer.xml#Q_ATOMIC_POINTER_FETCH_AND_STORE_IS_ALWAYS_NATIVE">Q_ATOMIC_POINTER_FETCH_AND_STORE_IS_ALWAYS_NATIVE</db:link></db:para>
</db:listitem>
<db:listitem>
<db:para><db:link xlink:href="qatomicpointer.xml#Q_ATOMIC_POINTER_FETCH_AND_STORE_IS_SOMETIMES_NATIVE">Q_ATOMIC_POINTER_FETCH_AND_STORE_IS_SOMETIMES_NATIVE</db:link></db:para>
</db:listitem>
<db:listitem>
<db:para><db:link xlink:href="qatomicpointer.xml#Q_ATOMIC_POINTER_FETCH_AND_STORE_IS_NOT_NATIVE">Q_ATOMIC_POINTER_FETCH_AND_STORE_IS_NOT_NATIVE</db:link></db:para>
</db:listitem>
<db:listitem>
<db:para><db:link xlink:href="qatomicpointer.xml#Q_ATOMIC_POINTER_FETCH_AND_STORE_IS_WAIT_FREE">Q_ATOMIC_POINTER_FETCH_AND_STORE_IS_WAIT_FREE</db:link></db:para>
</db:listitem>
<db:listitem>
<db:para><db:link xlink:href="qatomicpointer.xml#Q_ATOMIC_POINTER_FETCH_AND_ADD_IS_ALWAYS_NATIVE">Q_ATOMIC_POINTER_FETCH_AND_ADD_IS_ALWAYS_NATIVE</db:link></db:para>
</db:listitem>
<db:listitem>
<db:para><db:link xlink:href="qatomicpointer.xml#Q_ATOMIC_POINTER_FETCH_AND_ADD_IS_SOMETIMES_NATIVE">Q_ATOMIC_POINTER_FETCH_AND_ADD_IS_SOMETIMES_NATIVE</db:link></db:para>
</db:listitem>
<db:listitem>
<db:para><db:link xlink:href="qatomicpointer.xml#Q_ATOMIC_POINTER_FETCH_AND_ADD_IS_NOT_NATIVE">Q_ATOMIC_POINTER_FETCH_AND_ADD_IS_NOT_NATIVE</db:link></db:para>
</db:listitem>
<db:listitem>
<db:para><db:link xlink:href="qatomicpointer.xml#Q_ATOMIC_POINTER_FETCH_AND_ADD_IS_WAIT_FREE">Q_ATOMIC_POINTER_FETCH_AND_ADD_IS_WAIT_FREE</db:link></db:para>
</db:listitem>
</db:itemizedlist>
</db:section>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qatomicinteger.xml">QAtomicInteger</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="macro-documentation">
<db:title>Macro Documentation</db:title>
<db:section xml:id="Q_ATOMIC_POINTER_FETCH_AND_ADD_IS_ALWAYS_NATIVE">
<db:title>Q_ATOMIC_POINTER_FETCH_AND_ADD_IS_ALWAYS_NATIVE</db:title>
<db:para>This macro is defined if and only if your processor supports atomic fetch-and-add on pointers.</db:para>
</db:section>
<db:section xml:id="Q_ATOMIC_POINTER_FETCH_AND_ADD_IS_NOT_NATIVE">
<db:title>Q_ATOMIC_POINTER_FETCH_AND_ADD_IS_NOT_NATIVE</db:title>
<db:para>This macro is defined when the hardware does not support atomic fetch-and-add on pointers.</db:para>
</db:section>
<db:section xml:id="Q_ATOMIC_POINTER_FETCH_AND_ADD_IS_SOMETIMES_NATIVE">
<db:title>Q_ATOMIC_POINTER_FETCH_AND_ADD_IS_SOMETIMES_NATIVE</db:title>
<db:para>This macro is defined when only certain generations of the processor support atomic fetch-and-add on pointers. Use the QAtomicPointer::isFetchAndAddNative() function to check what your processor supports.</db:para>
</db:section>
<db:section xml:id="Q_ATOMIC_POINTER_FETCH_AND_ADD_IS_WAIT_FREE">
<db:title>Q_ATOMIC_POINTER_FETCH_AND_ADD_IS_WAIT_FREE</db:title>
<db:para>This macro is defined together with <db:link xlink:href="qatomicpointer.xml#Q_ATOMIC_POINTER_FETCH_AND_ADD_IS_ALWAYS_NATIVE">Q_ATOMIC_POINTER_FETCH_AND_ADD_IS_ALWAYS_NATIVE</db:link> to indicate that the atomic fetch-and-add on pointers is wait-free.</db:para>
</db:section>
<db:section xml:id="Q_ATOMIC_POINTER_FETCH_AND_STORE_IS_ALWAYS_NATIVE">
<db:title>Q_ATOMIC_POINTER_FETCH_AND_STORE_IS_ALWAYS_NATIVE</db:title>
<db:para>This macro is defined if and only if your processor supports atomic fetch-and-store on pointers.</db:para>
</db:section>
<db:section xml:id="Q_ATOMIC_POINTER_FETCH_AND_STORE_IS_NOT_NATIVE">
<db:title>Q_ATOMIC_POINTER_FETCH_AND_STORE_IS_NOT_NATIVE</db:title>
<db:para>This macro is defined when the hardware does not support atomic fetch-and-store on pointers.</db:para>
</db:section>
<db:section xml:id="Q_ATOMIC_POINTER_FETCH_AND_STORE_IS_SOMETIMES_NATIVE">
<db:title>Q_ATOMIC_POINTER_FETCH_AND_STORE_IS_SOMETIMES_NATIVE</db:title>
<db:para>This macro is defined when only certain generations of the processor support atomic fetch-and-store on pointers. Use the QAtomicPointer::isFetchAndStoreNative() function to check what your processor supports.</db:para>
</db:section>
<db:section xml:id="Q_ATOMIC_POINTER_FETCH_AND_STORE_IS_WAIT_FREE">
<db:title>Q_ATOMIC_POINTER_FETCH_AND_STORE_IS_WAIT_FREE</db:title>
<db:para>This macro is defined together with <db:link xlink:href="qatomicpointer.xml#Q_ATOMIC_POINTER_FETCH_AND_STORE_IS_ALWAYS_NATIVE">Q_ATOMIC_POINTER_FETCH_AND_STORE_IS_ALWAYS_NATIVE</db:link> to indicate that the atomic fetch-and-store on pointers is wait-free.</db:para>
</db:section>
<db:section xml:id="Q_ATOMIC_POINTER_TEST_AND_SET_IS_ALWAYS_NATIVE">
<db:title>Q_ATOMIC_POINTER_TEST_AND_SET_IS_ALWAYS_NATIVE</db:title>
<db:para>This macro is defined if and only if your processor supports atomic test-and-set on pointers.</db:para>
</db:section>
<db:section xml:id="Q_ATOMIC_POINTER_TEST_AND_SET_IS_NOT_NATIVE">
<db:title>Q_ATOMIC_POINTER_TEST_AND_SET_IS_NOT_NATIVE</db:title>
<db:para>This macro is defined when the hardware does not support atomic test-and-set on pointers.</db:para>
</db:section>
<db:section xml:id="Q_ATOMIC_POINTER_TEST_AND_SET_IS_SOMETIMES_NATIVE">
<db:title>Q_ATOMIC_POINTER_TEST_AND_SET_IS_SOMETIMES_NATIVE</db:title>
<db:para>This macro is defined when only certain generations of the processor support atomic test-and-set on pointers. Use the QAtomicPointer::isTestAndSetNative() function to check what your processor supports.</db:para>
</db:section>
<db:section xml:id="Q_ATOMIC_POINTER_TEST_AND_SET_IS_WAIT_FREE">
<db:title>Q_ATOMIC_POINTER_TEST_AND_SET_IS_WAIT_FREE</db:title>
<db:para>This macro is defined together with <db:link xlink:href="qatomicpointer.xml#Q_ATOMIC_POINTER_TEST_AND_SET_IS_ALWAYS_NATIVE">Q_ATOMIC_POINTER_TEST_AND_SET_IS_ALWAYS_NATIVE</db:link> to indicate that the atomic test-and-set on pointers is wait-free.</db:para>
</db:section>
</db:section>
</db:article>
