<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en">
<db:info>
<db:title>QAtomicPointer Class</db:title>
<db:subtitle>template &lt;typename T&gt; class QAtomicPointer</db:subtitle>
<db:productname>QtCore</db:productname>
<db:edition>Qt 6.5.3 Reference Documentation</db:edition>
<db:titleabbrev>Qt Core Reference Documentation</db:titleabbrev>
<db:abstract>
<db:para>The <db:link xlink:href="qatomicpointer.xml">QAtomicPointer</db:link> class is a template class that provides platform-independent atomic operations on pointers.</db:para>
</db:abstract>
<db:pubdate>2024-02-14</db:pubdate>
<db:date>2024-02-14</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:variablelist>
<db:varlistentry>
<db:term>Header</db:term>
<db:listitem>
<db:para>QAtomicPointer</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>CMake</db:term>
<db:listitem>
<db:para>find_package(Qt6 REQUIRED COMPONENTS Core)</db:para>
<db:para>target_link_libraries(mytarget PRIVATE Qt6::Core)</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>qmake</db:term>
<db:listitem>
<db:para>QT += core</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Group</db:term>
<db:listitem>
<db:para>QAtomicPointer is part of <db:simplelist><db:member>thread</db:member></db:simplelist></db:para>
</db:listitem>
</db:varlistentry>
</db:variablelist>
<db:section xml:id="details">
<db:title>Detailed Description</db:title>
<db:para>For atomic operations on integers, see the <db:link xlink:href="qatomicinteger.xml">QAtomicInteger</db:link> class.</db:para>
<db:para>An <db:emphasis>atomic</db:emphasis> operation is a complex operation that completes without interruption. The <db:link xlink:href="qatomicpointer.xml">QAtomicPointer</db:link> class provides atomic test-and-set, fetch-and-store, and fetch-and-add for pointers.</db:para>
<db:section xml:id="the-atomic-api">
<db:title>The Atomic API</db:title>
<db:section xml:id="memory-ordering">
<db:title>Memory ordering</db:title>
<db:para><db:link xlink:href="qatomicpointer.xml">QAtomicPointer</db:link> provides several implementations of the atomic test-and-set, fetch-and-store, and fetch-and-add functions. Each implementation defines a memory ordering semantic that describes how memory accesses surrounding the atomic instruction are executed by the processor. Since many modern architectures allow out-of-order execution and memory ordering, using the correct semantic is necessary to ensure that your application functions properly on all processors.</db:para>
<db:itemizedlist>
<db:listitem>
<db:para>Relaxed - memory ordering is unspecified, leaving the compiler and processor to freely reorder memory accesses.</db:para>
</db:listitem>
<db:listitem>
<db:para>Acquire - memory access following the atomic operation (in program order) may not be re-ordered before the atomic operation.</db:para>
</db:listitem>
<db:listitem>
<db:para>Release - memory access before the atomic operation (in program order) may not be re-ordered after the atomic operation.</db:para>
</db:listitem>
<db:listitem>
<db:para>Ordered - the same Acquire and Release semantics combined.</db:para>
</db:listitem>
</db:itemizedlist>
</db:section>
<db:section xml:id="test-and-set">
<db:title>Test-and-set</db:title>
<db:para>If the current value of the <db:link xlink:href="qatomicpointer.xml">QAtomicPointer</db:link> is an expected value, the test-and-set functions assign a new value to the <db:link xlink:href="qatomicpointer.xml">QAtomicPointer</db:link> and return true. If values are <db:code role="parameter">not</db:code> the same, these functions do nothing and return false. This operation equates to the following code:</db:para>
<db:programlisting language="cpp">if (currentValue == expectedValue) {
    currentValue = newValue;
    return true;
}
return false;
</db:programlisting>
<db:para>There are 4 test-and-set functions: <db:link xlink:href="qatomicpointer.xml#testAndSetRelaxed">testAndSetRelaxed</db:link>(), <db:link xlink:href="qatomicpointer.xml#testAndSetAcquire">testAndSetAcquire</db:link>(), <db:link xlink:href="qatomicpointer.xml#testAndSetRelease">testAndSetRelease</db:link>(), and <db:link xlink:href="qatomicpointer.xml#testAndSetOrdered">testAndSetOrdered</db:link>(). See above for an explanation of the different memory ordering semantics.</db:para>
</db:section>
<db:section xml:id="fetch-and-store">
<db:title>Fetch-and-store</db:title>
<db:para>The atomic fetch-and-store functions read the current value of the <db:link xlink:href="qatomicpointer.xml">QAtomicPointer</db:link> and then assign a new value, returning the original value. This operation equates to the following code:</db:para>
<db:programlisting language="cpp">T *originalValue = currentValue;
currentValue = newValue;
return originalValue;
</db:programlisting>
<db:para>There are 4 fetch-and-store functions: <db:link xlink:href="qatomicpointer.xml#fetchAndStoreRelaxed">fetchAndStoreRelaxed</db:link>(), <db:link xlink:href="qatomicpointer.xml#fetchAndStoreAcquire">fetchAndStoreAcquire</db:link>(), <db:link xlink:href="qatomicpointer.xml#fetchAndStoreRelease">fetchAndStoreRelease</db:link>(), and <db:link xlink:href="qatomicpointer.xml#fetchAndStoreOrdered">fetchAndStoreOrdered</db:link>(). See above for an explanation of the different memory ordering semantics.</db:para>
</db:section>
<db:section xml:id="fetch-and-add">
<db:title>Fetch-and-add</db:title>
<db:para>The atomic fetch-and-add functions read the current value of the <db:link xlink:href="qatomicpointer.xml">QAtomicPointer</db:link> and then add the given value to the current value, returning the original value. This operation equates to the following code:</db:para>
<db:programlisting language="cpp">T *originalValue = currentValue;
currentValue += valueToAdd;
return originalValue;
</db:programlisting>
<db:para>There are 4 fetch-and-add functions: <db:link xlink:href="qatomicpointer.xml#fetchAndAddRelaxed">fetchAndAddRelaxed</db:link>(), <db:link xlink:href="qatomicpointer.xml#fetchAndAddAcquire">fetchAndAddAcquire</db:link>(), <db:link xlink:href="qatomicpointer.xml#fetchAndAddRelease">fetchAndAddRelease</db:link>(), and <db:link xlink:href="qatomicpointer.xml#fetchAndAddOrdered">fetchAndAddOrdered</db:link>(). See above for an explanation of the different memory ordering semantics.</db:para>
</db:section>
</db:section>
<db:section xml:id="feature-tests-for-the-atomic-api">
<db:title>Feature Tests for the Atomic API</db:title>
<db:para>Providing a platform-independent atomic API that works on all processors is challenging. The API provided by <db:link xlink:href="qatomicpointer.xml">QAtomicPointer</db:link> is guaranteed to work atomically on all processors. However, since not all processors implement support for every operation provided by <db:link xlink:href="qatomicpointer.xml">QAtomicPointer</db:link>, it is necessary to expose information about the processor.</db:para>
<db:para>You can check at compile time which features are supported on your hardware using various macros. These will tell you if your hardware always, sometimes, or does not support a particular operation. The macros have the form Q_ATOMIC_POINTER_<db:emphasis>OPERATION</db:emphasis>_IS_<db:emphasis>HOW</db:emphasis>_NATIVE. <db:emphasis>OPERATION</db:emphasis> is one of <db:link xlink:href="qatomicpointer.xml#test-and-set">TEST_AND_SET</db:link>, <db:link xlink:href="qatomicpointer.xml#fetch-and-store">FETCH_AND_STORE</db:link>, or <db:link xlink:href="qatomicpointer.xml#fetch-and-add">FETCH_AND_ADD</db:link>, and <db:emphasis>HOW</db:emphasis> is one of ALWAYS, SOMETIMES, or NOT. There will always be exactly one defined macro per operation. For example, if <db:link xlink:href="qatomicpointer.xml#Q_ATOMIC_POINTER_TEST_AND_SET_IS_ALWAYS_NATIVE">Q_ATOMIC_POINTER_TEST_AND_SET_IS_ALWAYS_NATIVE</db:link> is defined, neither <db:link xlink:href="qatomicpointer.xml#Q_ATOMIC_POINTER_TEST_AND_SET_IS_SOMETIMES_NATIVE">Q_ATOMIC_POINTER_TEST_AND_SET_IS_SOMETIMES_NATIVE</db:link> nor <db:link xlink:href="qatomicpointer.xml#Q_ATOMIC_POINTER_TEST_AND_SET_IS_NOT_NATIVE">Q_ATOMIC_POINTER_TEST_AND_SET_IS_NOT_NATIVE</db:link> will be defined.</db:para>
<db:para>An operation that completes in constant time is said to be wait-free. Such operations are not implemented using locks or loops of any kind. For atomic operations that are always supported, and that are wait-free, Qt defines the Q_ATOMIC_POINTER_<db:emphasis>OPERATION</db:emphasis>_IS_WAIT_FREE in addition to the Q_ATOMIC_POINTER_<db:emphasis>OPERATION</db:emphasis>_IS_ALWAYS_NATIVE.</db:para>
<db:para>In cases where an atomic operation is only supported in newer generations of the processor, <db:link xlink:href="qatomicpointer.xml">QAtomicPointer</db:link> also provides a way to check at runtime what your hardware supports with the <db:link xlink:href="qatomicpointer.xml#isTestAndSetNative">isTestAndSetNative</db:link>(), <db:link xlink:href="qatomicpointer.xml#isFetchAndStoreNative">isFetchAndStoreNative</db:link>(), and <db:link xlink:href="qatomicpointer.xml#isFetchAndAddNative">isFetchAndAddNative</db:link>() functions. Wait-free implementations can be detected using the <db:link xlink:href="qatomicpointer.xml#isTestAndSetWaitFree">isTestAndSetWaitFree</db:link>(), <db:link xlink:href="qatomicpointer.xml#isFetchAndStoreWaitFree">isFetchAndStoreWaitFree</db:link>(), and <db:link xlink:href="qatomicpointer.xml#isFetchAndAddWaitFree">isFetchAndAddWaitFree</db:link>() functions.</db:para>
<db:para>Below is a complete list of all feature macros for <db:link xlink:href="qatomicpointer.xml">QAtomicPointer</db:link>:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:link xlink:href="qatomicpointer.xml#Q_ATOMIC_POINTER_TEST_AND_SET_IS_ALWAYS_NATIVE">Q_ATOMIC_POINTER_TEST_AND_SET_IS_ALWAYS_NATIVE</db:link></db:para>
</db:listitem>
<db:listitem>
<db:para><db:link xlink:href="qatomicpointer.xml#Q_ATOMIC_POINTER_TEST_AND_SET_IS_SOMETIMES_NATIVE">Q_ATOMIC_POINTER_TEST_AND_SET_IS_SOMETIMES_NATIVE</db:link></db:para>
</db:listitem>
<db:listitem>
<db:para><db:link xlink:href="qatomicpointer.xml#Q_ATOMIC_POINTER_TEST_AND_SET_IS_NOT_NATIVE">Q_ATOMIC_POINTER_TEST_AND_SET_IS_NOT_NATIVE</db:link></db:para>
</db:listitem>
<db:listitem>
<db:para><db:link xlink:href="qatomicpointer.xml#Q_ATOMIC_POINTER_TEST_AND_SET_IS_WAIT_FREE">Q_ATOMIC_POINTER_TEST_AND_SET_IS_WAIT_FREE</db:link></db:para>
</db:listitem>
<db:listitem>
<db:para><db:link xlink:href="qatomicpointer.xml#Q_ATOMIC_POINTER_FETCH_AND_STORE_IS_ALWAYS_NATIVE">Q_ATOMIC_POINTER_FETCH_AND_STORE_IS_ALWAYS_NATIVE</db:link></db:para>
</db:listitem>
<db:listitem>
<db:para><db:link xlink:href="qatomicpointer.xml#Q_ATOMIC_POINTER_FETCH_AND_STORE_IS_SOMETIMES_NATIVE">Q_ATOMIC_POINTER_FETCH_AND_STORE_IS_SOMETIMES_NATIVE</db:link></db:para>
</db:listitem>
<db:listitem>
<db:para><db:link xlink:href="qatomicpointer.xml#Q_ATOMIC_POINTER_FETCH_AND_STORE_IS_NOT_NATIVE">Q_ATOMIC_POINTER_FETCH_AND_STORE_IS_NOT_NATIVE</db:link></db:para>
</db:listitem>
<db:listitem>
<db:para><db:link xlink:href="qatomicpointer.xml#Q_ATOMIC_POINTER_FETCH_AND_STORE_IS_WAIT_FREE">Q_ATOMIC_POINTER_FETCH_AND_STORE_IS_WAIT_FREE</db:link></db:para>
</db:listitem>
<db:listitem>
<db:para><db:link xlink:href="qatomicpointer.xml#Q_ATOMIC_POINTER_FETCH_AND_ADD_IS_ALWAYS_NATIVE">Q_ATOMIC_POINTER_FETCH_AND_ADD_IS_ALWAYS_NATIVE</db:link></db:para>
</db:listitem>
<db:listitem>
<db:para><db:link xlink:href="qatomicpointer.xml#Q_ATOMIC_POINTER_FETCH_AND_ADD_IS_SOMETIMES_NATIVE">Q_ATOMIC_POINTER_FETCH_AND_ADD_IS_SOMETIMES_NATIVE</db:link></db:para>
</db:listitem>
<db:listitem>
<db:para><db:link xlink:href="qatomicpointer.xml#Q_ATOMIC_POINTER_FETCH_AND_ADD_IS_NOT_NATIVE">Q_ATOMIC_POINTER_FETCH_AND_ADD_IS_NOT_NATIVE</db:link></db:para>
</db:listitem>
<db:listitem>
<db:para><db:link xlink:href="qatomicpointer.xml#Q_ATOMIC_POINTER_FETCH_AND_ADD_IS_WAIT_FREE">Q_ATOMIC_POINTER_FETCH_AND_ADD_IS_WAIT_FREE</db:link></db:para>
</db:listitem>
</db:itemizedlist>
</db:section>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qatomicinteger.xml">QAtomicInteger</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="member-function-documentation">
<db:title>Member Function Documentation</db:title>
<db:section xml:id="QAtomicPointer">
<db:title>[constexpr] QAtomicPointer::QAtomicPointer(T *<db:emphasis>value</db:emphasis> = nullptr)</db:title>
<db:constructorsynopsis>
<db:methodname>QAtomicPointer</db:methodname>
<db:methodparam>
<db:type>T *</db:type>
<db:parameter>value</db:parameter>
<db:initializer>nullptr</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">constructor</db:synopsisinfo>
<db:synopsisinfo role="signature">QAtomicPointer(T *value)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:constructorsynopsis>
<db:para>Constructs a <db:link xlink:href="qatomicpointer.xml">QAtomicPointer</db:link> with the given <db:code role="parameter">value</db:code>.</db:para>
</db:section>
<db:section xml:id="QAtomicPointer-1">
<db:title>QAtomicPointer::QAtomicPointer(const QAtomicPointer&lt;T&gt; &amp;<db:emphasis>other</db:emphasis>)</db:title>
<db:constructorsynopsis>
<db:methodname>QAtomicPointer</db:methodname>
<db:methodparam>
<db:type>const QAtomicPointer&lt;T&gt; &amp;</db:type>
<db:parameter>other</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">constructor</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">QAtomicPointer(const QAtomicPointer&lt;T&gt; &amp;other)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:constructorsynopsis>
<db:para>Constructs a copy of <db:code role="parameter">other</db:code>.</db:para>
</db:section>
<db:section xml:id="fetchAndAddAcquire">
<db:title>T *QAtomicPointer::fetchAndAddAcquire(qptrdiff <db:emphasis>valueToAdd</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>T *</db:type>
<db:methodname>fetchAndAddAcquire</db:methodname>
<db:methodparam>
<db:type>qptrdiff</db:type>
<db:parameter>valueToAdd</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">T * fetchAndAddAcquire(qptrdiff valueToAdd)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Atomic fetch-and-add.</db:para>
<db:para>Reads the current value of this <db:link xlink:href="qatomicpointer.xml">QAtomicPointer</db:link> and then adds <db:code role="parameter">valueToAdd</db:code> to the current value, returning the original value.</db:para>
<db:para>This function uses <db:emphasis>acquire</db:emphasis> <db:link xlink:href="qatomicpointer.xml#memory-ordering">memory ordering</db:link> semantics, which ensures that memory access following the atomic operation (in program order) may not be re-ordered before the atomic operation.</db:para>
</db:section>
<db:section xml:id="fetchAndAddOrdered">
<db:title>T *QAtomicPointer::fetchAndAddOrdered(qptrdiff <db:emphasis>valueToAdd</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>T *</db:type>
<db:methodname>fetchAndAddOrdered</db:methodname>
<db:methodparam>
<db:type>qptrdiff</db:type>
<db:parameter>valueToAdd</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">T * fetchAndAddOrdered(qptrdiff valueToAdd)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Atomic fetch-and-add.</db:para>
<db:para>Reads the current value of this <db:link xlink:href="qatomicpointer.xml">QAtomicPointer</db:link> and then adds <db:code role="parameter">valueToAdd</db:code> to the current value, returning the original value.</db:para>
<db:para>This function uses <db:emphasis>ordered</db:emphasis> <db:link xlink:href="qatomicpointer.xml#memory-ordering">memory ordering</db:link> semantics, which ensures that memory access before and after the atomic operation (in program order) may not be re-ordered.</db:para>
</db:section>
<db:section xml:id="fetchAndAddRelaxed">
<db:title>T *QAtomicPointer::fetchAndAddRelaxed(qptrdiff <db:emphasis>valueToAdd</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>T *</db:type>
<db:methodname>fetchAndAddRelaxed</db:methodname>
<db:methodparam>
<db:type>qptrdiff</db:type>
<db:parameter>valueToAdd</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">T * fetchAndAddRelaxed(qptrdiff valueToAdd)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Atomic fetch-and-add.</db:para>
<db:para>Reads the current value of this <db:link xlink:href="qatomicpointer.xml">QAtomicPointer</db:link> and then adds <db:code role="parameter">valueToAdd</db:code> to the current value, returning the original value.</db:para>
<db:para>This function uses <db:emphasis>relaxed</db:emphasis> <db:link xlink:href="qatomicpointer.xml#memory-ordering">memory ordering</db:link> semantics, leaving the compiler and processor to freely reorder memory accesses.</db:para>
</db:section>
<db:section xml:id="fetchAndAddRelease">
<db:title>T *QAtomicPointer::fetchAndAddRelease(qptrdiff <db:emphasis>valueToAdd</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>T *</db:type>
<db:methodname>fetchAndAddRelease</db:methodname>
<db:methodparam>
<db:type>qptrdiff</db:type>
<db:parameter>valueToAdd</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">T * fetchAndAddRelease(qptrdiff valueToAdd)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Atomic fetch-and-add.</db:para>
<db:para>Reads the current value of this <db:link xlink:href="qatomicpointer.xml">QAtomicPointer</db:link> and then adds <db:code role="parameter">valueToAdd</db:code> to the current value, returning the original value.</db:para>
<db:para>This function uses <db:emphasis>release</db:emphasis> <db:link xlink:href="qatomicpointer.xml#memory-ordering">memory ordering</db:link> semantics, which ensures that memory access before the atomic operation (in program order) may not be re-ordered after the atomic operation.</db:para>
</db:section>
<db:section xml:id="fetchAndStoreAcquire">
<db:title>T *QAtomicPointer::fetchAndStoreAcquire(T *<db:emphasis>newValue</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>T *</db:type>
<db:methodname>fetchAndStoreAcquire</db:methodname>
<db:methodparam>
<db:type>T *</db:type>
<db:parameter>newValue</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">T * fetchAndStoreAcquire(T *newValue)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Atomic fetch-and-store.</db:para>
<db:para>Reads the current value of this <db:link xlink:href="qatomicpointer.xml">QAtomicPointer</db:link> and then assigns it the <db:code role="parameter">newValue</db:code>, returning the original value.</db:para>
<db:para>This function uses <db:emphasis>acquire</db:emphasis> <db:link xlink:href="qatomicpointer.xml#memory-ordering">memory ordering</db:link> semantics, which ensures that memory access following the atomic operation (in program order) may not be re-ordered before the atomic operation.</db:para>
</db:section>
<db:section xml:id="fetchAndStoreOrdered">
<db:title>T *QAtomicPointer::fetchAndStoreOrdered(T *<db:emphasis>newValue</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>T *</db:type>
<db:methodname>fetchAndStoreOrdered</db:methodname>
<db:methodparam>
<db:type>T *</db:type>
<db:parameter>newValue</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">T * fetchAndStoreOrdered(T *newValue)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Atomic fetch-and-store.</db:para>
<db:para>Reads the current value of this <db:link xlink:href="qatomicpointer.xml">QAtomicPointer</db:link> and then assigns it the <db:code role="parameter">newValue</db:code>, returning the original value.</db:para>
<db:para>This function uses <db:emphasis>ordered</db:emphasis> <db:link xlink:href="qatomicpointer.xml#memory-ordering">memory ordering</db:link> semantics, which ensures that memory access before and after the atomic operation (in program order) may not be re-ordered.</db:para>
</db:section>
<db:section xml:id="fetchAndStoreRelaxed">
<db:title>T *QAtomicPointer::fetchAndStoreRelaxed(T *<db:emphasis>newValue</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>T *</db:type>
<db:methodname>fetchAndStoreRelaxed</db:methodname>
<db:methodparam>
<db:type>T *</db:type>
<db:parameter>newValue</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">T * fetchAndStoreRelaxed(T *newValue)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Atomic fetch-and-store.</db:para>
<db:para>Reads the current value of this <db:link xlink:href="qatomicpointer.xml">QAtomicPointer</db:link> and then assigns it the <db:code role="parameter">newValue</db:code>, returning the original value.</db:para>
<db:para>This function uses <db:emphasis>relaxed</db:emphasis> <db:link xlink:href="qatomicpointer.xml#memory-ordering">memory ordering</db:link> semantics, leaving the compiler and processor to freely reorder memory accesses.</db:para>
</db:section>
<db:section xml:id="fetchAndStoreRelease">
<db:title>T *QAtomicPointer::fetchAndStoreRelease(T *<db:emphasis>newValue</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>T *</db:type>
<db:methodname>fetchAndStoreRelease</db:methodname>
<db:methodparam>
<db:type>T *</db:type>
<db:parameter>newValue</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">T * fetchAndStoreRelease(T *newValue)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Atomic fetch-and-store.</db:para>
<db:para>Reads the current value of this <db:link xlink:href="qatomicpointer.xml">QAtomicPointer</db:link> and then assigns it the <db:code role="parameter">newValue</db:code>, returning the original value.</db:para>
<db:para>This function uses <db:emphasis>release</db:emphasis> <db:link xlink:href="qatomicpointer.xml#memory-ordering">memory ordering</db:link> semantics, which ensures that memory access before the atomic operation (in program order) may not be re-ordered after the atomic operation.</db:para>
</db:section>
<db:section xml:id="isFetchAndAddNative">
<db:title>[static constexpr] bool QAtomicPointer::isFetchAndAddNative()</db:title>
<db:methodsynopsis>
<db:modifier>static</db:modifier>
<db:type>bool</db:type>
<db:methodname>isFetchAndAddNative</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool isFetchAndAddNative()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns <db:code>true</db:code> if fetch-and-add is implemented using atomic processor instructions, false otherwise.</db:para>
</db:section>
<db:section xml:id="isFetchAndAddWaitFree">
<db:title>[static constexpr] bool QAtomicPointer::isFetchAndAddWaitFree()</db:title>
<db:methodsynopsis>
<db:modifier>static</db:modifier>
<db:type>bool</db:type>
<db:methodname>isFetchAndAddWaitFree</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool isFetchAndAddWaitFree()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns <db:code>true</db:code> if atomic fetch-and-add is wait-free, false otherwise.</db:para>
</db:section>
<db:section xml:id="isFetchAndStoreNative">
<db:title>[static constexpr] bool QAtomicPointer::isFetchAndStoreNative()</db:title>
<db:methodsynopsis>
<db:modifier>static</db:modifier>
<db:type>bool</db:type>
<db:methodname>isFetchAndStoreNative</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool isFetchAndStoreNative()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns <db:code>true</db:code> if fetch-and-store is implemented using atomic processor instructions, false otherwise.</db:para>
</db:section>
<db:section xml:id="isFetchAndStoreWaitFree">
<db:title>[static constexpr] bool QAtomicPointer::isFetchAndStoreWaitFree()</db:title>
<db:methodsynopsis>
<db:modifier>static</db:modifier>
<db:type>bool</db:type>
<db:methodname>isFetchAndStoreWaitFree</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool isFetchAndStoreWaitFree()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns <db:code>true</db:code> if atomic fetch-and-store is wait-free, false otherwise.</db:para>
</db:section>
<db:section xml:id="isTestAndSetNative">
<db:title>[static constexpr] bool QAtomicPointer::isTestAndSetNative()</db:title>
<db:methodsynopsis>
<db:modifier>static</db:modifier>
<db:type>bool</db:type>
<db:methodname>isTestAndSetNative</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool isTestAndSetNative()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns <db:code>true</db:code> if test-and-set is implemented using atomic processor instructions, false otherwise.</db:para>
</db:section>
<db:section xml:id="isTestAndSetWaitFree">
<db:title>[static constexpr] bool QAtomicPointer::isTestAndSetWaitFree()</db:title>
<db:methodsynopsis>
<db:modifier>static</db:modifier>
<db:type>bool</db:type>
<db:methodname>isTestAndSetWaitFree</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool isTestAndSetWaitFree()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns <db:code>true</db:code> if atomic test-and-set is wait-free, false otherwise.</db:para>
</db:section>
<db:section xml:id="loadAcquire">
<db:title>T *QAtomicPointer::loadAcquire() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>T *</db:type>
<db:methodname>loadAcquire</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">T * loadAcquire() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Atomically loads the value of this <db:link xlink:href="qatomicpointer.xml">QAtomicPointer</db:link> using the &quot;Acquire&quot; memory ordering. The value is not modified in any way, but note that there's no guarantee that it remains so.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qatomicpointer.xml#storeRelease">storeRelease</db:link>()</db:member>
<db:member><db:link xlink:href="qatomicpointer.xml#loadRelaxed">loadRelaxed</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="loadRelaxed">
<db:title>T *QAtomicPointer::loadRelaxed() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>T *</db:type>
<db:methodname>loadRelaxed</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">T * loadRelaxed() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Atomically loads the value of this <db:link xlink:href="qatomicpointer.xml">QAtomicPointer</db:link> using relaxed memory ordering. The value is not modified in any way, but note that there's no guarantee that it remains so.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qatomicpointer.xml#storeRelaxed">storeRelaxed</db:link>()</db:member>
<db:member><db:link xlink:href="qatomicpointer.xml#loadAcquire">loadAcquire</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="storeRelaxed">
<db:title>void QAtomicPointer::storeRelaxed(T *<db:emphasis>newValue</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>storeRelaxed</db:methodname>
<db:methodparam>
<db:type>T *</db:type>
<db:parameter>newValue</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void storeRelaxed(T *newValue)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Atomically stores the <db:code role="parameter">newValue</db:code> value into this atomic type, using relaxed memory ordering.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qatomicpointer.xml#storeRelease">storeRelease</db:link>()</db:member>
<db:member><db:link xlink:href="qatomicpointer.xml#loadRelaxed">loadRelaxed</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="storeRelease">
<db:title>void QAtomicPointer::storeRelease(T *<db:emphasis>newValue</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>storeRelease</db:methodname>
<db:methodparam>
<db:type>T *</db:type>
<db:parameter>newValue</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void storeRelease(T *newValue)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Atomically stores the <db:code role="parameter">newValue</db:code> value into this atomic type, using the &quot;Release&quot; memory ordering.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qatomicpointer.xml#storeRelaxed">storeRelaxed</db:link>()</db:member>
<db:member><db:link xlink:href="qatomicpointer.xml#loadRelaxed">loadRelaxed</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="testAndSetAcquire">
<db:title>bool QAtomicPointer::testAndSetAcquire(T *<db:emphasis>expectedValue</db:emphasis>, T *<db:emphasis>newValue</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>bool</db:type>
<db:methodname>testAndSetAcquire</db:methodname>
<db:methodparam>
<db:type>T *</db:type>
<db:parameter>expectedValue</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>T *</db:type>
<db:parameter>newValue</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool testAndSetAcquire(T *expectedValue, T *newValue)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Atomic test-and-set.</db:para>
<db:para>If the current value of this <db:link xlink:href="qatomicpointer.xml">QAtomicPointer</db:link> is the <db:code role="parameter">expectedValue</db:code>, the test-and-set functions assign the <db:code role="parameter">newValue</db:code> to this <db:link xlink:href="qatomicpointer.xml">QAtomicPointer</db:link> and return true. If the values are <db:emphasis>not</db:emphasis> the same, this function does nothing and returns <db:code>false</db:code>.</db:para>
<db:para>This function uses <db:emphasis>acquire</db:emphasis> <db:link xlink:href="qatomicpointer.xml#memory-ordering">memory ordering</db:link> semantics, which ensures that memory access following the atomic operation (in program order) may not be re-ordered before the atomic operation.</db:para>
</db:section>
<db:section xml:id="testAndSetOrdered">
<db:title>bool QAtomicPointer::testAndSetOrdered(T *<db:emphasis>expectedValue</db:emphasis>, T *<db:emphasis>newValue</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>bool</db:type>
<db:methodname>testAndSetOrdered</db:methodname>
<db:methodparam>
<db:type>T *</db:type>
<db:parameter>expectedValue</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>T *</db:type>
<db:parameter>newValue</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool testAndSetOrdered(T *expectedValue, T *newValue)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Atomic test-and-set.</db:para>
<db:para>If the current value of this <db:link xlink:href="qatomicpointer.xml">QAtomicPointer</db:link> is the <db:code role="parameter">expectedValue</db:code>, the test-and-set functions assign the <db:code role="parameter">newValue</db:code> to this <db:link xlink:href="qatomicpointer.xml">QAtomicPointer</db:link> and return true. If the values are <db:emphasis>not</db:emphasis> the same, this function does nothing and returns <db:code>false</db:code>.</db:para>
<db:para>This function uses <db:emphasis>ordered</db:emphasis> <db:link xlink:href="qatomicpointer.xml#memory-ordering">memory ordering</db:link> semantics, which ensures that memory access before and after the atomic operation (in program order) may not be re-ordered.</db:para>
</db:section>
<db:section xml:id="testAndSetRelaxed">
<db:title>bool QAtomicPointer::testAndSetRelaxed(T *<db:emphasis>expectedValue</db:emphasis>, T *<db:emphasis>newValue</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>bool</db:type>
<db:methodname>testAndSetRelaxed</db:methodname>
<db:methodparam>
<db:type>T *</db:type>
<db:parameter>expectedValue</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>T *</db:type>
<db:parameter>newValue</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool testAndSetRelaxed(T *expectedValue, T *newValue)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Atomic test-and-set.</db:para>
<db:para>If the current value of this <db:link xlink:href="qatomicpointer.xml">QAtomicPointer</db:link> is the <db:code role="parameter">expectedValue</db:code>, the test-and-set functions assign the <db:code role="parameter">newValue</db:code> to this <db:link xlink:href="qatomicpointer.xml">QAtomicPointer</db:link> and return true. If the values are <db:emphasis>not</db:emphasis> the same, this function does nothing and returns <db:code>false</db:code>.</db:para>
<db:para>This function uses <db:emphasis>relaxed</db:emphasis> <db:link xlink:href="qatomicpointer.xml#memory-ordering">memory ordering</db:link> semantics, leaving the compiler and processor to freely reorder memory accesses.</db:para>
</db:section>
<db:section xml:id="testAndSetRelease">
<db:title>bool QAtomicPointer::testAndSetRelease(T *<db:emphasis>expectedValue</db:emphasis>, T *<db:emphasis>newValue</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>bool</db:type>
<db:methodname>testAndSetRelease</db:methodname>
<db:methodparam>
<db:type>T *</db:type>
<db:parameter>expectedValue</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>T *</db:type>
<db:parameter>newValue</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool testAndSetRelease(T *expectedValue, T *newValue)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Atomic test-and-set.</db:para>
<db:para>If the current value of this <db:link xlink:href="qatomicpointer.xml">QAtomicPointer</db:link> is the <db:code role="parameter">expectedValue</db:code>, the test-and-set functions assign the <db:code role="parameter">newValue</db:code> to this <db:link xlink:href="qatomicpointer.xml">QAtomicPointer</db:link> and return true. If the values are <db:emphasis>not</db:emphasis> the same, this function does nothing and returns <db:code>false</db:code>.</db:para>
<db:para>This function uses <db:emphasis>release</db:emphasis> <db:link xlink:href="qatomicpointer.xml#memory-ordering">memory ordering</db:link> semantics, which ensures that memory access before the atomic operation (in program order) may not be re-ordered after the atomic operation.</db:para>
</db:section>
<db:section xml:id="operator-eq">
<db:title>QAtomicPointer&lt;T&gt; &amp;QAtomicPointer::operator=(const QAtomicPointer&lt;T&gt; &amp;<db:emphasis>other</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>QAtomicPointer&lt;T&gt; &amp;</db:type>
<db:methodname>operator=</db:methodname>
<db:methodparam>
<db:type>const QAtomicPointer&lt;T&gt; &amp;</db:type>
<db:parameter>other</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">copy-assign</db:synopsisinfo>
<db:synopsisinfo role="signature">QAtomicPointer&lt;T&gt; &amp; operator=(const QAtomicPointer&lt;T&gt; &amp;other)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Assigns <db:code role="parameter">other</db:code> to this <db:link xlink:href="qatomicpointer.xml">QAtomicPointer</db:link> and returns a reference to this <db:link xlink:href="qatomicpointer.xml">QAtomicPointer</db:link>.</db:para>
</db:section>
</db:section>
<db:section xml:id="macro-documentation">
<db:title>Macro Documentation</db:title>
<db:section xml:id="Q_ATOMIC_POINTER_FETCH_AND_ADD_IS_ALWAYS_NATIVE">
<db:title>Q_ATOMIC_POINTER_FETCH_AND_ADD_IS_ALWAYS_NATIVE</db:title>
<db:methodsynopsis>
<db:methodname>Q_ATOMIC_POINTER_FETCH_AND_ADD_IS_ALWAYS_NATIVE</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">macrowithoutparams</db:synopsisinfo>
<db:synopsisinfo role="signature">Q_ATOMIC_POINTER_FETCH_AND_ADD_IS_ALWAYS_NATIVE</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This macro is defined if and only if your processor supports atomic fetch-and-add on pointers.</db:para>
</db:section>
<db:section xml:id="Q_ATOMIC_POINTER_FETCH_AND_ADD_IS_NOT_NATIVE">
<db:title>Q_ATOMIC_POINTER_FETCH_AND_ADD_IS_NOT_NATIVE</db:title>
<db:methodsynopsis>
<db:methodname>Q_ATOMIC_POINTER_FETCH_AND_ADD_IS_NOT_NATIVE</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">macrowithoutparams</db:synopsisinfo>
<db:synopsisinfo role="signature">Q_ATOMIC_POINTER_FETCH_AND_ADD_IS_NOT_NATIVE</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This macro is defined when the hardware does not support atomic fetch-and-add on pointers.</db:para>
</db:section>
<db:section xml:id="Q_ATOMIC_POINTER_FETCH_AND_ADD_IS_SOMETIMES_NATIVE">
<db:title>Q_ATOMIC_POINTER_FETCH_AND_ADD_IS_SOMETIMES_NATIVE</db:title>
<db:methodsynopsis>
<db:methodname>Q_ATOMIC_POINTER_FETCH_AND_ADD_IS_SOMETIMES_NATIVE</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">macrowithoutparams</db:synopsisinfo>
<db:synopsisinfo role="signature">Q_ATOMIC_POINTER_FETCH_AND_ADD_IS_SOMETIMES_NATIVE</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This macro is defined when only certain generations of the processor support atomic fetch-and-add on pointers. Use the <db:link xlink:href="qatomicpointer.xml#isFetchAndAddNative">QAtomicPointer::isFetchAndAddNative</db:link>() function to check what your processor supports.</db:para>
</db:section>
<db:section xml:id="Q_ATOMIC_POINTER_FETCH_AND_ADD_IS_WAIT_FREE">
<db:title>Q_ATOMIC_POINTER_FETCH_AND_ADD_IS_WAIT_FREE</db:title>
<db:methodsynopsis>
<db:methodname>Q_ATOMIC_POINTER_FETCH_AND_ADD_IS_WAIT_FREE</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">macrowithoutparams</db:synopsisinfo>
<db:synopsisinfo role="signature">Q_ATOMIC_POINTER_FETCH_AND_ADD_IS_WAIT_FREE</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This macro is defined together with <db:link xlink:href="qatomicpointer.xml#Q_ATOMIC_POINTER_FETCH_AND_ADD_IS_ALWAYS_NATIVE">Q_ATOMIC_POINTER_FETCH_AND_ADD_IS_ALWAYS_NATIVE</db:link> to indicate that the atomic fetch-and-add on pointers is wait-free.</db:para>
</db:section>
<db:section xml:id="Q_ATOMIC_POINTER_FETCH_AND_STORE_IS_ALWAYS_NATIVE">
<db:title>Q_ATOMIC_POINTER_FETCH_AND_STORE_IS_ALWAYS_NATIVE</db:title>
<db:methodsynopsis>
<db:methodname>Q_ATOMIC_POINTER_FETCH_AND_STORE_IS_ALWAYS_NATIVE</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">macrowithoutparams</db:synopsisinfo>
<db:synopsisinfo role="signature">Q_ATOMIC_POINTER_FETCH_AND_STORE_IS_ALWAYS_NATIVE</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This macro is defined if and only if your processor supports atomic fetch-and-store on pointers.</db:para>
</db:section>
<db:section xml:id="Q_ATOMIC_POINTER_FETCH_AND_STORE_IS_NOT_NATIVE">
<db:title>Q_ATOMIC_POINTER_FETCH_AND_STORE_IS_NOT_NATIVE</db:title>
<db:methodsynopsis>
<db:methodname>Q_ATOMIC_POINTER_FETCH_AND_STORE_IS_NOT_NATIVE</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">macrowithoutparams</db:synopsisinfo>
<db:synopsisinfo role="signature">Q_ATOMIC_POINTER_FETCH_AND_STORE_IS_NOT_NATIVE</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This macro is defined when the hardware does not support atomic fetch-and-store on pointers.</db:para>
</db:section>
<db:section xml:id="Q_ATOMIC_POINTER_FETCH_AND_STORE_IS_SOMETIMES_NATIVE">
<db:title>Q_ATOMIC_POINTER_FETCH_AND_STORE_IS_SOMETIMES_NATIVE</db:title>
<db:methodsynopsis>
<db:methodname>Q_ATOMIC_POINTER_FETCH_AND_STORE_IS_SOMETIMES_NATIVE</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">macrowithoutparams</db:synopsisinfo>
<db:synopsisinfo role="signature">Q_ATOMIC_POINTER_FETCH_AND_STORE_IS_SOMETIMES_NATIVE</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This macro is defined when only certain generations of the processor support atomic fetch-and-store on pointers. Use the <db:link xlink:href="qatomicpointer.xml#isFetchAndStoreNative">QAtomicPointer::isFetchAndStoreNative</db:link>() function to check what your processor supports.</db:para>
</db:section>
<db:section xml:id="Q_ATOMIC_POINTER_FETCH_AND_STORE_IS_WAIT_FREE">
<db:title>Q_ATOMIC_POINTER_FETCH_AND_STORE_IS_WAIT_FREE</db:title>
<db:methodsynopsis>
<db:methodname>Q_ATOMIC_POINTER_FETCH_AND_STORE_IS_WAIT_FREE</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">macrowithoutparams</db:synopsisinfo>
<db:synopsisinfo role="signature">Q_ATOMIC_POINTER_FETCH_AND_STORE_IS_WAIT_FREE</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This macro is defined together with <db:link xlink:href="qatomicpointer.xml#Q_ATOMIC_POINTER_FETCH_AND_STORE_IS_ALWAYS_NATIVE">Q_ATOMIC_POINTER_FETCH_AND_STORE_IS_ALWAYS_NATIVE</db:link> to indicate that the atomic fetch-and-store on pointers is wait-free.</db:para>
</db:section>
<db:section xml:id="Q_ATOMIC_POINTER_TEST_AND_SET_IS_ALWAYS_NATIVE">
<db:title>Q_ATOMIC_POINTER_TEST_AND_SET_IS_ALWAYS_NATIVE</db:title>
<db:methodsynopsis>
<db:methodname>Q_ATOMIC_POINTER_TEST_AND_SET_IS_ALWAYS_NATIVE</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">macrowithoutparams</db:synopsisinfo>
<db:synopsisinfo role="signature">Q_ATOMIC_POINTER_TEST_AND_SET_IS_ALWAYS_NATIVE</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This macro is defined if and only if your processor supports atomic test-and-set on pointers.</db:para>
</db:section>
<db:section xml:id="Q_ATOMIC_POINTER_TEST_AND_SET_IS_NOT_NATIVE">
<db:title>Q_ATOMIC_POINTER_TEST_AND_SET_IS_NOT_NATIVE</db:title>
<db:methodsynopsis>
<db:methodname>Q_ATOMIC_POINTER_TEST_AND_SET_IS_NOT_NATIVE</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">macrowithoutparams</db:synopsisinfo>
<db:synopsisinfo role="signature">Q_ATOMIC_POINTER_TEST_AND_SET_IS_NOT_NATIVE</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This macro is defined when the hardware does not support atomic test-and-set on pointers.</db:para>
</db:section>
<db:section xml:id="Q_ATOMIC_POINTER_TEST_AND_SET_IS_SOMETIMES_NATIVE">
<db:title>Q_ATOMIC_POINTER_TEST_AND_SET_IS_SOMETIMES_NATIVE</db:title>
<db:methodsynopsis>
<db:methodname>Q_ATOMIC_POINTER_TEST_AND_SET_IS_SOMETIMES_NATIVE</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">macrowithoutparams</db:synopsisinfo>
<db:synopsisinfo role="signature">Q_ATOMIC_POINTER_TEST_AND_SET_IS_SOMETIMES_NATIVE</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This macro is defined when only certain generations of the processor support atomic test-and-set on pointers. Use the <db:link xlink:href="qatomicpointer.xml#isTestAndSetNative">QAtomicPointer::isTestAndSetNative</db:link>() function to check what your processor supports.</db:para>
</db:section>
<db:section xml:id="Q_ATOMIC_POINTER_TEST_AND_SET_IS_WAIT_FREE">
<db:title>Q_ATOMIC_POINTER_TEST_AND_SET_IS_WAIT_FREE</db:title>
<db:methodsynopsis>
<db:methodname>Q_ATOMIC_POINTER_TEST_AND_SET_IS_WAIT_FREE</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">macrowithoutparams</db:synopsisinfo>
<db:synopsisinfo role="signature">Q_ATOMIC_POINTER_TEST_AND_SET_IS_WAIT_FREE</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This macro is defined together with <db:link xlink:href="qatomicpointer.xml#Q_ATOMIC_POINTER_TEST_AND_SET_IS_ALWAYS_NATIVE">Q_ATOMIC_POINTER_TEST_AND_SET_IS_ALWAYS_NATIVE</db:link> to indicate that the atomic test-and-set on pointers is wait-free.</db:para>
</db:section>
</db:section>
</db:article>
