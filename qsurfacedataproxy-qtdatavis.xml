<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en">
<db:info>
<db:title>QSurfaceDataProxy Class</db:title>
<db:productname>QtDataVis3D</db:productname>
<db:edition>Qt Data Visualization | Commercial or GPLv3</db:edition>
<db:titleabbrev>Qt Data Visualization Reference Documentation</db:titleabbrev>
<db:abstract>
<db:para>The <db:link xlink:href="qsurfacedataproxy-qtdatavis.xml">QSurfaceDataProxy</db:link> class is the data proxy for a 3D surface graph.</db:para>
<db:para>This class was introduced in QtDataVisualization 1.0.</db:para>
</db:abstract>
<db:pubdate>2025-06-29</db:pubdate>
<db:date>2025-06-29</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:variablelist>
<db:varlistentry>
<db:term>Header</db:term>
<db:listitem>
<db:para>QSurfaceDataProxy</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Since</db:term>
<db:listitem>
<db:para>QtDataVisualization 1.0</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>CMake</db:term>
<db:listitem>
<db:para>find_package(Qt6 REQUIRED COMPONENTS DataVisualization)</db:para>
<db:para>target_link_libraries(mytarget PRIVATE Qt6::DataVisualization)</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>qmake</db:term>
<db:listitem>
<db:para>QT += datavisualization</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>In QML</db:term>
<db:listitem>
<db:para><db:link xlink:href="qml-qtdatavisualization-surfacedataproxy.xml" xlink:role="">SurfaceDataProxy</db:link></db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Inherits</db:term>
<db:listitem>
<db:para><db:link xlink:href="qabstractdataproxy-qtdatavis.xml" xlink:role="class">QAbstractDataProxy</db:link></db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Inherited By</db:term>
<db:listitem>
<db:para><db:link xlink:href="qheightmapsurfacedataproxy-qtdatavis.xml" xlink:role="class">QHeightMapSurfaceDataProxy</db:link> and <db:link xlink:href="qitemmodelsurfacedataproxy-qtdatavis.xml" xlink:role="class">QItemModelSurfaceDataProxy</db:link></db:para>
</db:listitem>
</db:varlistentry>
</db:variablelist>
<db:section xml:id="details">
<db:title>Detailed Description</db:title>
<db:para>A surface data proxy handles surface related data in rows. For this it provides two auxiliary typedefs: QtDataVisualization::QSurfaceDataArray and QtDataVisualization::QSurfaceDataRow. <db:code>QSurfaceDataArray</db:code> is a <db:link xlink:href="qlist.xml">QList</db:link> that controls the rows. <db:code>QSurfaceDataRow</db:code> is a <db:link xlink:href="qlist.xml">QList</db:link> that contains <db:link xlink:href="qsurfacedataitem-qtdatavis.xml">QSurfaceDataItem</db:link> objects. For more information about how to feed the data to the proxy, see the sample code in the <db:link xlink:href="q3dsurface-qtdatavis.xml">Q3DSurface</db:link> documentation.</db:para>
<db:para>All rows must have the same number of items.</db:para>
<db:para><db:link xlink:href="qsurfacedataproxy-qtdatavis.xml">QSurfaceDataProxy</db:link> takes ownership of all <db:code>QSurfaceDataRow</db:code> objects passed to it, whether directly or in a <db:code>QSurfaceDataArray</db:code> container. To use surface data row pointers to directly modify data after adding the array to the proxy, the appropriate signal must be emitted to update the graph.</db:para>
<db:para>To make a sensible surface, the x-value of each successive item in all rows must be either ascending or descending throughout the row. Similarly, the z-value of each successive item in all columns must be either ascending or descending throughout the column.</db:para>
<db:note>
<db:para>Currently only surfaces with straight rows and columns are fully supported. Any row with items that do not have the exact same z-value or any column with items that do not have the exact same x-value may get clipped incorrectly if the whole surface does not completely fit within the visible x-axis or z-axis ranges.</db:para>
</db:note>
<db:note>
<db:para>Surfaces with less than two rows or columns are not considered valid surfaces and will not be rendered.</db:para>
</db:note>
<db:note>
<db:para>On some environments, surfaces with a lot of visible vertices may not render, because they exceed the per-draw vertex count supported by the graphics driver. This is mostly an issue on 32-bit and OpenGL ES2 platforms.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtdatavisualization-data-handling.xml">Qt Data Visualization Data Handling</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="property-documentation">
<db:title>Property Documentation</db:title>
<db:section xml:id="columnCount-prop">
<db:title>[read-only] columnCount : const int</db:title>
<db:para>This property holds the number of columns in the data array.</db:para>
<db:para>
<db:emphasis role="bold">Access functions:
</db:emphasis>
</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:type>int</db:type> <db:emphasis role="bold">columnCount</db:emphasis>() const</db:para>
</db:listitem>
</db:itemizedlist>
<db:para>
<db:emphasis role="bold">Notifier signal:
</db:emphasis>
</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:type>void</db:type> <db:emphasis role="bold">columnCountChanged</db:emphasis>(<db:type>int</db:type> <db:emphasis>count</db:emphasis>)</db:para>
</db:listitem>
</db:itemizedlist>
</db:section>
<db:section xml:id="rowCount-prop">
<db:title>[read-only] rowCount : const int</db:title>
<db:para>This property holds the number of rows in the data array.</db:para>
<db:para>
<db:emphasis role="bold">Access functions:
</db:emphasis>
</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:type>int</db:type> <db:emphasis role="bold">rowCount</db:emphasis>() const</db:para>
</db:listitem>
</db:itemizedlist>
<db:para>
<db:emphasis role="bold">Notifier signal:
</db:emphasis>
</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:type>void</db:type> <db:emphasis role="bold">rowCountChanged</db:emphasis>(<db:type>int</db:type> <db:emphasis>count</db:emphasis>)</db:para>
</db:listitem>
</db:itemizedlist>
</db:section>
<db:section xml:id="series-prop">
<db:title>[read-only] series : QSurface3DSeries* const</db:title>
<db:para>This property holds the series this proxy is attached to.</db:para>
<db:para>
<db:emphasis role="bold">Access functions:
</db:emphasis>
</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:type><db:link xlink:href="qsurface3dseries-qtdatavis.xml">QSurface3DSeries</db:link></db:type> *<db:emphasis role="bold">series</db:emphasis>() const</db:para>
</db:listitem>
</db:itemizedlist>
<db:para>
<db:emphasis role="bold">Notifier signal:
</db:emphasis>
</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:type>void</db:type> <db:emphasis role="bold">seriesChanged</db:emphasis>(<db:type><db:link xlink:href="qsurface3dseries-qtdatavis.xml">QSurface3DSeries</db:link></db:type> *<db:emphasis>series</db:emphasis>)</db:para>
</db:listitem>
</db:itemizedlist>
</db:section>
</db:section>
<db:section xml:id="member-function-documentation">
<db:title>Member Function Documentation</db:title>
<db:section xml:id="QSurfaceDataProxy">
<db:title>[explicit] QSurfaceDataProxy::QSurfaceDataProxy(QObject *<db:emphasis>parent</db:emphasis> = nullptr)</db:title>
<db:para>Constructs <db:link xlink:href="qsurfacedataproxy-qtdatavis.xml">QSurfaceDataProxy</db:link> with the given <db:code role="parameter">parent</db:code>.</db:para>
</db:section>
<db:section xml:id="dtor.QSurfaceDataProxy">
<db:title>[virtual noexcept] QSurfaceDataProxy::~QSurfaceDataProxy()</db:title>
<db:para>Deletes the surface data proxy.</db:para>
</db:section>
<db:section xml:id="addRow">
<db:title>int QSurfaceDataProxy::addRow(QSurfaceDataRow *<db:emphasis>row</db:emphasis>)</db:title>
<db:para>Adds the new row <db:code role="parameter">row</db:code> to the end of an array. The new row must have the same number of columns as the rows in the initial array.</db:para>
<db:para>Returns the index of the added row.</db:para>
</db:section>
<db:section xml:id="addRows">
<db:title>int QSurfaceDataProxy::addRows(const QSurfaceDataArray &amp;<db:emphasis>rows</db:emphasis>)</db:title>
<db:para>Adds new <db:code role="parameter">rows</db:code> to the end of an array. The new rows must have the same number of columns as the rows in the initial array.</db:para>
<db:para>Returns the index of the first added row.</db:para>
</db:section>
<db:section xml:id="array">
<db:title>const QSurfaceDataArray *QSurfaceDataProxy::array() const</db:title>
<db:para>Returns the pointer to the data array.</db:para>
</db:section>
<db:section xml:id="arrayReset">
<db:title>void QSurfaceDataProxy::arrayReset()</db:title>
<db:para>This signal is emitted when the data array is reset. If the contents of the whole array are changed without calling <db:link xlink:href="qsurfacedataproxy-qtdatavis.xml#resetArray">resetArray</db:link>(), this signal needs to be emitted to update the graph.</db:para>
</db:section>
<db:section xml:id="insertRow">
<db:title>void QSurfaceDataProxy::insertRow(int <db:emphasis>rowIndex</db:emphasis>, QSurfaceDataRow *<db:emphasis>row</db:emphasis>)</db:title>
<db:para>Inserts the new row <db:code role="parameter">row</db:code> into <db:code role="parameter">rowIndex</db:code>. If <db:code role="parameter">rowIndex</db:code> is equal to the array size, the rows are added to the end of the array. The new row must have the same number of columns as the rows in the initial array.</db:para>
</db:section>
<db:section xml:id="insertRows">
<db:title>void QSurfaceDataProxy::insertRows(int <db:emphasis>rowIndex</db:emphasis>, const QSurfaceDataArray &amp;<db:emphasis>rows</db:emphasis>)</db:title>
<db:para>Inserts new <db:code role="parameter">rows</db:code> into <db:code role="parameter">rowIndex</db:code>. If <db:code role="parameter">rowIndex</db:code> is equal to the array size, the rows are added to the end of the array. The new <db:code role="parameter">rows</db:code> must have the same number of columns as the rows in the initial array.</db:para>
</db:section>
<db:section xml:id="itemAt">
<db:title>const QSurfaceDataItem *QSurfaceDataProxy::itemAt(const QPoint &amp;<db:emphasis>position</db:emphasis>) const</db:title>
<db:para>Returns the pointer to the item at the position <db:code role="parameter">position</db:code>. The x-value of <db:code role="parameter">position</db:code> indicates the row and the y-value indicates the column. The item is guaranteed to be valid only until the next call that modifies data.</db:para>
</db:section>
<db:section xml:id="itemAt-1">
<db:title>const QSurfaceDataItem *QSurfaceDataProxy::itemAt(int <db:emphasis>rowIndex</db:emphasis>, int <db:emphasis>columnIndex</db:emphasis>) const</db:title>
<db:para>Returns the pointer to the item at the position specified by <db:code role="parameter">rowIndex</db:code> and <db:code role="parameter">columnIndex</db:code>. It is guaranteed to be valid only until the next call that modifies data.</db:para>
</db:section>
<db:section xml:id="itemChanged">
<db:title>void QSurfaceDataProxy::itemChanged(int <db:emphasis>rowIndex</db:emphasis>, int <db:emphasis>columnIndex</db:emphasis>)</db:title>
<db:para>This signal is emitted when the item at the position specified by <db:code role="parameter">rowIndex</db:code> and <db:code role="parameter">columnIndex</db:code> changes. If the item is changed in the array without calling <db:link xlink:href="qsurfacedataproxy-qtdatavis.xml#setItem">setItem</db:link>(), this signal needs to be emitted to update the graph.</db:para>
</db:section>
<db:section xml:id="removeRows">
<db:title>void QSurfaceDataProxy::removeRows(int <db:emphasis>rowIndex</db:emphasis>, int <db:emphasis>removeCount</db:emphasis>)</db:title>
<db:para>Removes the number of rows specified by <db:code role="parameter">removeCount</db:code> starting at the position <db:code role="parameter">rowIndex</db:code>. Attempting to remove rows past the end of the array does nothing.</db:para>
</db:section>
<db:section xml:id="resetArray">
<db:title>void QSurfaceDataProxy::resetArray(QSurfaceDataArray *<db:emphasis>newArray</db:emphasis>)</db:title>
<db:para>Takes ownership of the array <db:code role="parameter">newArray</db:code>. Clears the existing array if the new array differs from it. If the arrays are the same, this function just triggers the <db:link xlink:href="qsurfacedataproxy-qtdatavis.xml#arrayReset">arrayReset</db:link>() signal.</db:para>
<db:para>Passing a null array deletes the old array and creates a new empty array. All rows in <db:code role="parameter">newArray</db:code> must be of same length.</db:para>
</db:section>
<db:section xml:id="rowsAdded">
<db:title>void QSurfaceDataProxy::rowsAdded(int <db:emphasis>startIndex</db:emphasis>, int <db:emphasis>count</db:emphasis>)</db:title>
<db:para>This signal is emitted when the number of rows specified by <db:code role="parameter">count</db:code> is added starting at the position <db:code role="parameter">startIndex</db:code>. If rows are added to the array without calling <db:link xlink:href="qsurfacedataproxy-qtdatavis.xml#addRow">addRow</db:link>() or <db:link xlink:href="qsurfacedataproxy-qtdatavis.xml#addRows">addRows</db:link>(), this signal needs to be emitted to update the graph.</db:para>
</db:section>
<db:section xml:id="rowsChanged">
<db:title>void QSurfaceDataProxy::rowsChanged(int <db:emphasis>startIndex</db:emphasis>, int <db:emphasis>count</db:emphasis>)</db:title>
<db:para>This signal is emitted when the number of rows specified by <db:code role="parameter">count</db:code> is changed starting at the position <db:code role="parameter">startIndex</db:code>. If rows are changed in the array without calling <db:link xlink:href="qsurfacedataproxy-qtdatavis.xml#setRow">setRow</db:link>() or <db:link xlink:href="qsurfacedataproxy-qtdatavis.xml#setRows">setRows</db:link>(), this signal needs to be emitted to update the graph.</db:para>
</db:section>
<db:section xml:id="rowsInserted">
<db:title>void QSurfaceDataProxy::rowsInserted(int <db:emphasis>startIndex</db:emphasis>, int <db:emphasis>count</db:emphasis>)</db:title>
<db:para>This signal is emitted when the number of rows specified by <db:code role="parameter">count</db:code> is inserted at the position <db:code role="parameter">startIndex</db:code>.</db:para>
<db:para>If rows are inserted into the array without calling <db:link xlink:href="qsurfacedataproxy-qtdatavis.xml#insertRow">insertRow</db:link>() or <db:link xlink:href="qsurfacedataproxy-qtdatavis.xml#insertRows">insertRows</db:link>(), this signal needs to be emitted to update the graph.</db:para>
</db:section>
<db:section xml:id="rowsRemoved">
<db:title>void QSurfaceDataProxy::rowsRemoved(int <db:emphasis>startIndex</db:emphasis>, int <db:emphasis>count</db:emphasis>)</db:title>
<db:para>This signal is emitted when the number of rows specified by <db:code role="parameter">count</db:code> is removed starting at the position <db:code role="parameter">startIndex</db:code>.</db:para>
<db:para>The index is the current array size if the rows were removed from the end of the array. If rows are removed from the array without calling <db:link xlink:href="qsurfacedataproxy-qtdatavis.xml#removeRows">removeRows</db:link>(), this signal needs to be emitted to update the graph.</db:para>
</db:section>
<db:section xml:id="setItem">
<db:title>void QSurfaceDataProxy::setItem(const QPoint &amp;<db:emphasis>position</db:emphasis>, const QSurfaceDataItem &amp;<db:emphasis>item</db:emphasis>)</db:title>
<db:para>Changes a single item at the position <db:code role="parameter">position</db:code> to the item <db:code role="parameter">item</db:code>. The x-value of <db:code role="parameter">position</db:code> indicates the row and the y-value indicates the column.</db:para>
</db:section>
<db:section xml:id="setItem-1">
<db:title>void QSurfaceDataProxy::setItem(int <db:emphasis>rowIndex</db:emphasis>, int <db:emphasis>columnIndex</db:emphasis>, const QSurfaceDataItem &amp;<db:emphasis>item</db:emphasis>)</db:title>
<db:para>Changes a single item at the position specified by <db:code role="parameter">rowIndex</db:code> and <db:code role="parameter">columnIndex</db:code> to the item <db:code role="parameter">item</db:code>.</db:para>
</db:section>
<db:section xml:id="setRow">
<db:title>void QSurfaceDataProxy::setRow(int <db:emphasis>rowIndex</db:emphasis>, QSurfaceDataRow *<db:emphasis>row</db:emphasis>)</db:title>
<db:para>Changes an existing row by replacing the row at the position <db:code role="parameter">rowIndex</db:code> with the new row specified by <db:code role="parameter">row</db:code>. The new row can be the same as the existing row already stored at the <db:code role="parameter">rowIndex</db:code>. The new row must have the same number of columns as the row it is replacing.</db:para>
</db:section>
<db:section xml:id="setRows">
<db:title>void QSurfaceDataProxy::setRows(int <db:emphasis>rowIndex</db:emphasis>, const QSurfaceDataArray &amp;<db:emphasis>rows</db:emphasis>)</db:title>
<db:para>Changes existing rows by replacing the rows starting at the position <db:code role="parameter">rowIndex</db:code> with the new rows specifies by <db:code role="parameter">rows</db:code>. The rows in the <db:code role="parameter">rows</db:code> array can be the same as the existing rows already stored at the <db:code role="parameter">rowIndex</db:code>. The new rows must have the same number of columns as the rows they are replacing.</db:para>
</db:section>
</db:section>
<db:section xml:id="related-non-members">
<db:title>Related Non-Members</db:title>
<db:section xml:id="QSurfaceDataArray-typedef">
<db:title>QSurfaceDataArray</db:title>
<db:para>A list of pointers to <db:link xlink:href="qsurfacedataproxy-qtdatavis.xml#QSurfaceDataRow-typedef">QSurfaceDataRow</db:link> objects.</db:para>
</db:section>
<db:section xml:id="QSurfaceDataRow-typedef">
<db:title>QSurfaceDataRow</db:title>
<db:para>A list of <db:link xlink:href="qsurfacedataitem-qtdatavis.xml">QSurfaceDataItem</db:link> objects.</db:para>
</db:section>
</db:section>
</db:article>
