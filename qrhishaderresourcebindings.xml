<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en">
<db:info>
<db:title>QRhiShaderResourceBindings Class</db:title>
<db:productname>QtGui</db:productname>
<db:edition>Qt 6.9.1 Reference Documentation</db:edition>
<db:titleabbrev>Qt GUI Reference Documentation</db:titleabbrev>
<db:abstract>
<db:para>Encapsulates resources for making buffer, texture, sampler resources visible to shaders.</db:para>
<db:para>This class was introduced in Qt 6.6.</db:para>
</db:abstract>
<db:pubdate>2025-06-29</db:pubdate>
<db:date>2025-06-29</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:variablelist>
<db:varlistentry>
<db:term>Header</db:term>
<db:listitem>
<db:para>rhi/qrhi.h</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Since</db:term>
<db:listitem>
<db:para>Qt 6.6</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>CMake</db:term>
<db:listitem>
<db:para>find_package(Qt6 REQUIRED COMPONENTS Gui)</db:para>
<db:para>target_link_libraries(mytarget PRIVATE Qt6::GuiPrivate)</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>qmake</db:term>
<db:listitem>
<db:para>QT += gui-private</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Inherits</db:term>
<db:listitem>
<db:para><db:link xlink:href="qrhiresource.xml" xlink:role="class">QRhiResource</db:link></db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Inherited By</db:term>
<db:listitem>
<db:para/>
</db:listitem>
</db:varlistentry>
</db:variablelist>
<db:section xml:id="details">
<db:title>Detailed Description</db:title>
<db:para>A <db:link xlink:href="qrhishaderresourcebindings.xml">QRhiShaderResourceBindings</db:link> is a collection of <db:link xlink:href="qrhishaderresourcebinding.xml">QRhiShaderResourceBinding</db:link> objects, each of which describe a single binding.</db:para>
<db:para>Take a fragment shader with the following interface:</db:para>
<db:programlisting language="cpp" role="bad">layout(std140, binding = 0) uniform buf {
    mat4 mvp;
    int flip;
} ubuf;

layout(binding = 1) uniform sampler2D tex;
</db:programlisting>
<db:para>To make resources visible to the shader, the following <db:link xlink:href="qrhishaderresourcebindings.xml">QRhiShaderResourceBindings</db:link> could be created and then passed to QRhiGraphicsPipeline::setShaderResourceBindings():</db:para>
<db:programlisting language="cpp">QRhiShaderResourceBindings *srb = rhi-&gt;newShaderResourceBindings();
srb-&gt;setBindings({
    QRhiShaderResourceBinding::uniformBuffer(0, QRhiShaderResourceBinding::VertexStage | QRhiShaderResourceBinding::FragmentStage, ubuf),
    QRhiShaderResourceBinding::sampledTexture(1, QRhiShaderResourceBinding::FragmentStage, texture, sampler)
});
srb-&gt;create();
// ...
QRhiGraphicsPipeline *ps = rhi-&gt;newGraphicsPipeline();
// ...
ps-&gt;setShaderResourceBindings(srb);
ps-&gt;create();
// ...
cb-&gt;setGraphicsPipeline(ps);
cb-&gt;setShaderResources(); // binds srb
</db:programlisting>
<db:para>This assumes that <db:code>ubuf</db:code> is a <db:link xlink:href="qrhibuffer.xml">QRhiBuffer</db:link>, <db:code>texture</db:code> is a <db:link xlink:href="qrhitexture.xml">QRhiTexture</db:link>, while <db:code role="parameter">sampler</db:code> is a <db:link xlink:href="qrhisampler.xml">QRhiSampler</db:link>. The example also assumes that the uniform block is present in the vertex shader as well so the same buffer is made visible to the vertex stage too.</db:para>
<db:section xml:id="advanced-usage">
<db:title>Advanced usage</db:title>
<db:para>Building on the above example, let's assume that a pass now needs to use the exact same pipeline and shaders with a different texture. Creating a whole separate <db:link xlink:href="qrhigraphicspipeline.xml">QRhiGraphicsPipeline</db:link> just for this would be an overkill. This is why <db:link xlink:href="qrhicommandbuffer.xml#setShaderResources">QRhiCommandBuffer::setShaderResources</db:link>() allows specifying a <db:code role="parameter">srb</db:code> argument. As long as the layouts (so the number of bindings and the binding points) match between two <db:link xlink:href="qrhishaderresourcebindings.xml">QRhiShaderResourceBindings</db:link>, they can both be used with the same pipeline, assuming the pipeline was created with one of them in the first place. See <db:link xlink:href="qrhishaderresourcebindings.xml#isLayoutCompatible">isLayoutCompatible</db:link>() for more details.</db:para>
<db:programlisting language="cpp">QRhiShaderResourceBindings *srb2 = rhi-&gt;newShaderResourceBindings();
// ...
cb-&gt;setGraphicsPipeline(ps);
cb-&gt;setShaderResources(srb2); // binds srb2
</db:programlisting>
<db:note>
<db:para>This is a RHI API with limited compatibility guarantees, see <db:link xlink:href="qrhi.xml">QRhi</db:link> for details.</db:para>
</db:note>
</db:section>
</db:section>
<db:section xml:id="member-function-documentation">
<db:title>Member Function Documentation</db:title>
<db:section xml:id="isLayoutCompatible">
<db:title>bool QRhiShaderResourceBindings::isLayoutCompatible(const QRhiShaderResourceBindings *<db:emphasis>other</db:emphasis>) const</db:title>
<db:para>Returns <db:code>true</db:code> if the layout is compatible with <db:code role="parameter">other</db:code>. The layout does not include the actual resource (such as, buffer or texture) and related parameters (such as, offset or size). It does include the binding point, pipeline stage, and resource type, however. The number and order of the bindings must also match in order to be compatible.</db:para>
<db:para>When there is a <db:link xlink:href="qrhigraphicspipeline.xml">QRhiGraphicsPipeline</db:link> created with this <db:link xlink:href="qrhishaderresourcebindings.xml">QRhiShaderResourceBindings</db:link>, and the function returns <db:code>true</db:code>, <db:code role="parameter">other</db:code> can then safely be passed to <db:link xlink:href="qrhicommandbuffer.xml#setShaderResources">QRhiCommandBuffer::setShaderResources</db:link>(), and so be used with the pipeline in place of this <db:link xlink:href="qrhishaderresourcebindings.xml">QRhiShaderResourceBindings</db:link>.</db:para>
<db:note>
<db:para>This function must only be called after a successful create(), because it relies on data generated during the baking of the underlying data structures. This way the function can implement a comparison approach that is more efficient than iterating through two binding lists and calling <db:link xlink:href="qrhishaderresourcebinding.xml#isLayoutCompatible">QRhiShaderResourceBinding::isLayoutCompatible</db:link>() on each pair. This becomes relevant especially when this function is called at a high frequency.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="">serializedLayoutDescription()</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="resourceType">
<db:title>[override virtual] QRhiResource::Type QRhiShaderResourceBindings::resourceType() const</db:title>
<db:para>Returns the resource type.</db:para>
</db:section>
</db:section>
</db:article>
