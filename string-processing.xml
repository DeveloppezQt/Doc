<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en">
<db:info>
<db:title>Classes for string data</db:title>
<db:productname>QtCore</db:productname>
<db:edition>Qt 6.9.1 Reference Documentation</db:edition>
<db:titleabbrev>Qt Core Reference Documentation</db:titleabbrev>
<db:abstract>
<db:para>Qt Core Reference Documentation.</db:para></db:abstract>
<db:pubdate>2025-06-29</db:pubdate>
<db:date>2025-06-29</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:anchor xml:id="details"/>
<db:section xml:id="overview">
<db:title>Overview</db:title>
<db:para>This page gives an overview over string classes in Qt, in particular the large amount of string containers and how to use them efficiently in performance-critical code.</db:para>
<db:para>The following instructions for efficient use are aimed at experienced developers working on performance-critical code that contains considerable amounts of string processing. This is, for example, a parser or a text file generator. <db:emphasis>Generally, <db:link xlink:href="qstring.xml">QString</db:link> can be used everywhere and it will perform fine.</db:emphasis> It also provides APIs for handling several encodings (for example <db:link xlink:href="qstring.xml#fromLatin1">QString::fromLatin1</db:link>()). For many applications and especially when string-processing plays an insignificant role for performance, <db:link xlink:href="qstring.xml">QString</db:link> will be a simple and sufficient solution. Some Qt functions return a <db:link xlink:href="qstringview.xml">QStringView</db:link>. It can be converted to a <db:link xlink:href="qstring.xml">QString</db:link> with <db:link xlink:href="qstringview.xml#toString">QStringView::toString</db:link>() if required.</db:para>
<db:section xml:id="impactful-tips">
<db:title>Impactful tips</db:title>
<db:para>The following three rules improve string handling substantially without increasing the complexity too much. Follow these rules to get nearly optimal performance in most cases. The first two rules address encoding of string literals and marking them in source code. The third rule addresses deep copies when using parts of a string.</db:para>
<db:itemizedlist>
<db:listitem>
<db:para>All strings that only contain ASCII characters (for example log messages) can be encoded with Latin-1. Use the <db:link xlink:href="qlatin1char.xml#operator-22-22_L1">string literal</db:link> &quot;foo&quot;_L1. Without this suffix, string literals in source code are assumed to be UTF-8 encoded and processing them will be slower. Generally, try to use the tightest encoding, which is Latin-1 in many cases.</db:para>
</db:listitem>
<db:listitem>
<db:para>User-visible strings are usually translated and thus passed through the <db:link xlink:href="qobject.xml#tr">QObject::tr</db:link>() function. This function takes a string literal (const char array) and returns a <db:link xlink:href="qstring.xml">QString</db:link> with UTF-16 encoding as demanded by all UI elements. If the translation infrastructure is not used, you should use UTF-16 encoding throughout the whole application. Use the string literal u&quot;foo&quot; to create UTF-16 string literals or the Qt specific literal u&quot;foo&quot;_s to directly create a <db:link xlink:href="qstring.xml">QString</db:link>.</db:para>
</db:listitem>
<db:listitem>
<db:para>When processing parts of a <db:link xlink:href="qstring.xml">QString</db:link>, instead of copying each part into its own <db:link xlink:href="qstring.xml">QString</db:link> object, create <db:link xlink:href="qstringview.xml">QStringView</db:link> objects instead. These can be converted back to <db:link xlink:href="qstring.xml">QString</db:link> using <db:link xlink:href="qstringview.xml#toString">QStringView::toString</db:link>(), but avoid doing so as much as possible. If functions return <db:link xlink:href="qstringview.xml">QStringView</db:link>, it is most efficient to keep working with this class, if possible. The API is similar to a constant <db:link xlink:href="qstring.xml">QString</db:link>.</db:para>
</db:listitem>
</db:itemizedlist>
</db:section>
<db:section xml:id="efficient-usage">
<db:title>Efficient usage</db:title>
<db:para>To use string classes efficiently, one should understand the three concepts of:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para>Encoding</db:para>
</db:listitem>
<db:listitem>
<db:para>Owning and non-owning containers</db:para>
</db:listitem>
<db:listitem>
<db:para>Literals</db:para>
</db:listitem>
</db:itemizedlist>
<db:section xml:id="encoding">
<db:title>Encoding</db:title>
<db:para>Encoding-wise Qt supports UTF-16, UTF-8, Latin-1 (ISO 8859-1) and US-ASCII (that is the common subset of Latin-1 and UTF-8) in one form or another.</db:para>
<db:itemizedlist>
<db:listitem>
<db:para>Latin-1 is a character encoding that uses a single byte per character which makes it the most efficient but also limited encoding.</db:para>
</db:listitem>
<db:listitem>
<db:para>UTF-8 is a variable-length character encoding that encodes all characters using one to four bytes. It is backwards compatible to US-ASCII and it is the common encoding for source code and similar files. Qt assumes that source code is encoded in UTF-8.</db:para>
</db:listitem>
<db:listitem>
<db:para>UTF-16 is a variable-length encoding that uses two or four bytes per character. It is the common encoding for user-exposed text in Qt.</db:para>
</db:listitem>
</db:itemizedlist>
<db:para>See the <db:link xlink:href="">information about support for Unicode in Qt</db:link> for more information.</db:para>
<db:para>Other encodings are supported in the form of single functions like <db:link xlink:href="qstring.xml#fromUcs4">QString::fromUcs4</db:link>() or of the <db:link xlink:href="qstringconverter.xml">QStringConverter</db:link> classes. Furthermore, Qt provides an encoding-agnostic container for data, <db:link xlink:href="qbytearray.xml">QByteArray</db:link>, that is well-suited to storing binary data. <db:link xlink:href="qanystringview.xml">QAnyStringView</db:link> keeps track of the encoding of the underlying string and can thus carry a view onto strings with any of the supported encoding standards.</db:para>
<db:para>Converting between encodings is expensive, therefore, avoid if possible. On the other hand, a more compact encoding, particularly for string literals, can reduce binary size, which can increase performance. Where string literals can be expressed in Latin-1, it manages a good compromise between these competing factors, even if it has to be converted to UTF-16 at some point. When a Latin-1 string must be converted to a <db:link xlink:href="qstring.xml">QString</db:link>, it is done relatively efficiently.</db:para>
</db:section>
<db:section xml:id="functionality">
<db:title>Functionality</db:title>
<db:para>String classes can be further distinguished by the functionality they support. One major distinction is whether they own, and thus control, their data or merely reference data held elsewhere. The former are called <db:emphasis>owning</db:emphasis> containers, the latter <db:emphasis>non-owning</db:emphasis> containers or views. A non-owning container type typically just records a pointer to the start of the data and its size, making it lightweight and cheap, but it only remains valid as long as the data remains available. An owning string manages the memory in which it stores its data, ensuring that data remains available throughout the lifetime of the container, but its creation and destruction incur the costs of allocating and releasing memory. Views typically support a subset of the functions of the owning string, lacking the possibility to modify the underlying data.</db:para>
<db:para>As a result, string views are particularly well-suited to representing parts of larger strings, for example in a parser, while owning strings are good for persistent storage, such as members of a class. Where a function returns a string that it has constructed, for example by combining fragments, it has to return an owning string; but where a function returns part of some persistently stored string, a view is usually more suitable.</db:para>
<db:para>Note that owning containers in Qt share their data <db:link xlink:href="implicit-sharing.xml">implicitly</db:link>, meaning that it is also efficient to pass or return large containers by value, although slightly less efficient than passing by reference due to the reference counting. If you want to make use of the implicit data sharing mechanism of Qt classes, you have to pass the string as an owning container or a reference to one. Conversion to a view and back will always create an additional copy of the data.</db:para>
<db:para>Finally, Qt provides classes for single characters, lists of strings and string matchers. These classes are available for most supported encoding standards in Qt, with some exceptions. Higher level functionality is provided by specialized classes, such as <db:link xlink:href="qlocale.xml">QLocale</db:link> or <db:link xlink:href="qtextboundaryfinder.xml">QTextBoundaryFinder</db:link>. These high level classes usually rely on <db:link xlink:href="qstring.xml">QString</db:link> and its UTF-16 encoding. Some classes are templates and work with all available string classes.</db:para>
</db:section>
<db:section xml:id="literals">
<db:title>Literals</db:title>
<db:para>The C++ standard provides <db:link xlink:href="https://en.cppreference.com/w/cpp/language/string_literal">string literals</db:link> to create strings at compile-time. There are string literals defined by the language and literals defined by Qt, so-called <db:link xlink:href="https://en.cppreference.com/w/cpp/language/user_literal">user-defined literals</db:link>. A string literal defined by C++ is enclosed in double quotes and can have a prefix that tells the compiler how to interpret its content. For Qt, the UTF-16 string literal u&quot;foo&quot; is the most important. It creates a string encoded in UTF-16 at compile-time, saving the need to convert from some other encoding at run-time. <db:link xlink:href="qstringview.xml">QStringView</db:link> can be easily and efficiently constructed from one, so they can be passed to functions that accept a <db:link xlink:href="qstringview.xml">QStringView</db:link> argument (or, as a result, a <db:link xlink:href="qanystringview.xml">QAnyStringView</db:link>).</db:para>
<db:para>User-defined literals have the same form as those defined by C++ but add a suffix after the closing quote. The encoding remains determined by the prefix, but the resulting literal is used to construct an object of some user-defined type. Qt thus defines these for some of its own string types: u&quot;foo&quot;_s for <db:link xlink:href="qstring.xml">QString</db:link>, &quot;foo&quot;_L1 for <db:link xlink:href="qlatin1stringview.xml">QLatin1StringView</db:link> and u&quot;foo&quot;_ba for <db:link xlink:href="qbytearray.xml">QByteArray</db:link>. These are provided by using the <db:link xlink:href="qt-literals-stringliterals.xml">StringLiterals Namespace</db:link>. A plain C++ string literal &quot;foo&quot; will be understood as UTF-8 and conversion to <db:link xlink:href="qstring.xml">QString</db:link> and thus UTF-16 will be expensive. When you have string literals in plain ASCII, use &quot;foo&quot;_L1 to interpret it as Latin-1, gaining the various benefits outlined above.</db:para>
</db:section>
</db:section>
</db:section>
<db:section xml:id="basic-string-classes">
<db:title>Basic string classes</db:title>
<db:para>The following table gives an overview over basic string classes for the various standards of text encoding.</db:para>
<db:informaltable style="generic">
<db:thead>
<db:tr>
<db:th>
<db:para>Encoding</db:para>
</db:th>
<db:th>
<db:para>C++ String literal</db:para>
</db:th>
<db:th>
<db:para>Qt user-defined literal</db:para>
</db:th>
<db:th>
<db:para>C++ Character</db:para>
</db:th>
<db:th>
<db:para>Qt Character</db:para>
</db:th>
<db:th>
<db:para>Owning string</db:para>
</db:th>
<db:th>
<db:para>Non-owning string</db:para>
</db:th>
</db:tr>
</db:thead>
<db:tr valign="top">
<db:td>
<db:para>Latin-1</db:para>
</db:td>
<db:td>
<db:para>-</db:para>
</db:td>
<db:td>
<db:para>&quot;&quot;_L1</db:para>
</db:td>
<db:td>
<db:para>-</db:para>
</db:td>
<db:td>
<db:para><db:link xlink:href="qlatin1char.xml">QLatin1Char</db:link></db:para>
</db:td>
<db:td>
<db:para>-</db:para>
</db:td>
<db:td>
<db:para><db:link xlink:href="qlatin1stringview.xml">QLatin1StringView</db:link></db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>UTF-8</db:para>
</db:td>
<db:td>
<db:para>u8&quot;&quot;</db:para>
</db:td>
<db:td>
<db:para>-</db:para>
</db:td>
<db:td>
<db:para>char8_t</db:para>
</db:td>
<db:td>
<db:para>-</db:para>
</db:td>
<db:td>
<db:para>-</db:para>
</db:td>
<db:td>
<db:para><db:link xlink:href="qutf8stringview.xml">QUtf8StringView</db:link></db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>UTF-16</db:para>
</db:td>
<db:td>
<db:para>u&quot;&quot;</db:para>
</db:td>
<db:td>
<db:para>u&quot;&quot;_s</db:para>
</db:td>
<db:td>
<db:para>char16_t</db:para>
</db:td>
<db:td>
<db:para><db:link xlink:href="qchar.xml">QChar</db:link></db:para>
</db:td>
<db:td>
<db:para><db:link xlink:href="qstring.xml">QString</db:link></db:para>
</db:td>
<db:td>
<db:para><db:link xlink:href="qstringview.xml">QStringView</db:link></db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>Binary/None</db:para>
</db:td>
<db:td>
<db:para>-</db:para>
</db:td>
<db:td>
<db:para>&quot;&quot;_ba</db:para>
</db:td>
<db:td>
<db:para>std::byte</db:para>
</db:td>
<db:td>
<db:para>-</db:para>
</db:td>
<db:td>
<db:para><db:link xlink:href="qbytearray.xml">QByteArray</db:link></db:para>
</db:td>
<db:td>
<db:para><db:link xlink:href="qbytearrayview.xml">QByteArrayView</db:link></db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>Flexible</db:para>
</db:td>
<db:td>
<db:para>any</db:para>
</db:td>
<db:td>
<db:para>-</db:para>
</db:td>
<db:td>
<db:para>-</db:para>
</db:td>
<db:td>
<db:para>-</db:para>
</db:td>
<db:td>
<db:para>-</db:para>
</db:td>
<db:td>
<db:para><db:link xlink:href="qanystringview.xml">QAnyStringView</db:link></db:para>
</db:td>
</db:tr>
</db:informaltable>
<db:para>Some of the missing entries can be substituted with built-in and standard library C++ types: An owning Latin-1 or UTF-8 encoded string can be std::string or any 8-bit char array. <db:link xlink:href="qstringview.xml">QStringView</db:link> can also reference any 16-bit character arrays, such as std::u16string or std::wstring on some platforms.</db:para>
<db:para>Qt also provides specialized lists for some of those types, that are <db:link xlink:href="qstringlist.xml">QStringList</db:link> and <db:link xlink:href="qbytearrayview.xml">QByteArrayView</db:link>, as well as matchers, <db:link xlink:href="qlatin1stringmatcher.xml">QLatin1StringMatcher</db:link> and <db:link xlink:href="qbytearraymatcher.xml">QByteArrayMatcher</db:link>. The matchers also have static versions that are created at compile-time, <db:link xlink:href="qstaticlatin1stringmatcher.xml">QStaticLatin1StringMatcher</db:link> and <db:link xlink:href="qstaticbytearraymatcher.xml">QStaticByteArrayMatcher</db:link>.</db:para>
<db:para>Further worth noting:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:link xlink:href="qstring.xml#QStringLiteral">QStringLiteral</db:link> is a macro which is identical to u&quot;foo&quot;_s and available without the <db:link xlink:href="qt-literals-stringliterals.xml">StringLiterals Namespace</db:link>. Preferably you should use the modern string literal.</db:para>
</db:listitem>
<db:listitem>
<db:para><db:link xlink:href="qlatin1string.xml">QLatin1String</db:link> is a synonym for <db:link xlink:href="qlatin1stringview.xml">QLatin1StringView</db:link> and exists for backwards compatibility. It is not an owning string and might be removed in future releases.</db:para>
</db:listitem>
<db:listitem>
<db:para><db:link xlink:href="qanystringview.xml">QAnyStringView</db:link> provides a view for a string with any of the three supported encodings. The encoding is stored alongside the reference to the data. This class is well suited to create interfaces that take a wide spectrum of string types and encodings. In contrast to other classes, no processing is conducted on <db:link xlink:href="qanystringview.xml">QAnyStringView</db:link> directly. Processing is conducted on the underlying <db:link xlink:href="qlatin1stringview.xml">QLatin1StringView</db:link>, <db:link xlink:href="qutf8stringview.xml">QUtf8StringView</db:link> or <db:link xlink:href="qstringview.xml">QStringView</db:link> in the respective encoding. Use <db:link xlink:href="qanystringview.xml#visit">QAnyStringView::visit</db:link>() to do the same in your own functions that take this class as an argument.</db:para>
</db:listitem>
<db:listitem>
<db:para>A <db:link xlink:href="qlatin1stringview.xml">QLatin1StringView</db:link> with non-ASCII characters is not straightforward to construct in a UTF-8 encoded source code file and requires special treatment, see the <db:link xlink:href="qlatin1stringview.xml">QLatin1StringView</db:link> documentation.</db:para>
</db:listitem>
<db:listitem>
<db:para><db:link xlink:href="qstringref.xml">QStringRef</db:link> is a reference to a portion of a <db:link xlink:href="qstring.xml">QString</db:link>, available in the Qt5Compat module for backwards compatibility. It should be replaced by <db:link xlink:href="qstringview.xml">QStringView</db:link>.</db:para>
</db:listitem>
</db:itemizedlist>
</db:section>
<db:section xml:id="high-level-string-related-classes">
<db:title>High-level string-related classes</db:title>
<db:para>More high-level classes that provide additional functionality work mostly with <db:link xlink:href="qstring.xml">QString</db:link> and thus UTF-16. These are:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:link xlink:href="qregularexpression.xml">QRegularExpression</db:link>, <db:link xlink:href="qregularexpressionmatch.xml">QRegularExpressionMatch</db:link> and <db:link xlink:href="qregularexpressionmatchiterator.xml">QRegularExpressionMatchIterator</db:link> to work with pattern matching and regular expressions.</db:para>
</db:listitem>
<db:listitem>
<db:para><db:link xlink:href="qlocale.xml">QLocale</db:link> to convert numbers and data to and from strings in a manner appropriate to the user's language and culture.</db:para>
</db:listitem>
<db:listitem>
<db:para><db:link xlink:href="qcollator.xml">QCollator</db:link> and <db:link xlink:href="qcollatorsortkey.xml">QCollatorSortKey</db:link> to compare strings with respect to the users language, script or territory.</db:para>
</db:listitem>
<db:listitem>
<db:para><db:link xlink:href="qtextboundaryfinder.xml">QTextBoundaryFinder</db:link> to break up text ready for typesetting in accord with Unicode rules.</db:para>
</db:listitem>
<db:listitem>
<db:para>QStringBuilder, an internal class that will substantially improve the performance of string concatenations with the + operator, see the <db:link xlink:href="qstring.xml">QString</db:link> documentation.</db:para>
</db:listitem>
</db:itemizedlist>
<db:para>Some classes are templates or have a flexible API and work with various string classes. These are</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:link xlink:href="qtextstream.xml">QTextStream</db:link> to stream into <db:link xlink:href="qiodevice.xml">QIODevice</db:link>, <db:link xlink:href="qbytearray.xml">QByteArray</db:link> or <db:link xlink:href="qstring.xml">QString</db:link></db:para>
</db:listitem>
<db:listitem>
<db:para><db:link xlink:href="qstringtokenizer.xml">QStringTokenizer</db:link> to split strings</db:para>
</db:listitem>
</db:itemizedlist>
</db:section>
<db:section xml:id="which-string-class-to-use">
<db:title>Which string class to use?</db:title>
<db:para>The general guidance in using string classes is:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para>Avoid copying and memory allocations,</db:para>
</db:listitem>
<db:listitem>
<db:para>Avoid encoding conversions, and</db:para>
</db:listitem>
<db:listitem>
<db:para>Choose the most compact encoding.</db:para>
</db:listitem>
</db:itemizedlist>
<db:para>Qt provides many functionalities to avoid memory allocations. Most Qt containers employ <db:link xlink:href="implicit-sharing.xml">Implicit Sharing</db:link> of their data. For implicit sharing to work, there must be an uninterrupted chain of the same class â€” converting from <db:link xlink:href="qstring.xml">QString</db:link> to <db:link xlink:href="qstringview.xml">QStringView</db:link> and back will result in two <db:link xlink:href="qstring.xml">QStrings</db:link> that do not share their data. Therefore, functions need to pass their data as <db:link xlink:href="qstring.xml">QString</db:link> (both values or references work). Extracting parts of a string is not possible with implicit data sharing. To use parts of a longer string, make use of string views, an explicit form of data sharing.</db:para>
<db:para>Conversions between encodings can be reduced by sticking to a certain encoding. Data received, for example in UTF-8, is best stored and processed in UTF-8 if no conversation to any other encoding is required. Comparisons between strings of the same encoding are fastest and the same is the case for most other operations. If strings of a certain encoding are often compared or converted to any other encoding it might be beneficial to convert and store them once. Some operations provide many overloads (or a <db:link xlink:href="qanystringview.xml">QAnyStringView</db:link> overload) to take various string types and encodings and they should be the second choice to optimize performance, if using the same encoding is not feasible. Explicit encoding conversions before calling a function should be a last resort when no other option is available. Latin-1 is a very simple encoding and operation between Latin-1 and any other encoding are almost as efficient as operations between the same encoding.</db:para>
<db:para>The most efficient encoding (from most to least efficient Latin-1, UTF-8, UTF-16) should be chosen when no other constrains determine the encoding. For error handling and logging <db:link xlink:href="qlatin1stringview.xml">QLatin1StringView</db:link> is usually sufficient. User-visible strings in Qt are always of type <db:link xlink:href="qstring.xml">QString</db:link> and as such UTF-16 encoded. Therefore it is most effective to use <db:link xlink:href="qstring.xml">QStrings</db:link>, <db:link xlink:href="qstringview.xml">QStringViews</db:link> and <db:link xlink:href="qstring.xml#QStringLiteral">QStringLiterals</db:link> throughout the life-time of a user-visible string. The <db:link xlink:href="qobject.xml#tr">QObject::tr</db:link>() function provides the correct encoding and type. <db:link xlink:href="qbytearray.xml">QByteArray</db:link> should be used if encoding does not play a role, for example to store binary data, or if the encoding is unknown.</db:para>
<db:section xml:id="string-class-for-creating-api">
<db:title>String class for creating API</db:title>
<db:mediaobject>
<db:alt>&quot;String class for an optimal API&quot;</db:alt>
<db:imageobject>
<db:imagedata fileref="images/string_class_api.svg"/>
</db:imageobject>
</db:mediaobject>
<db:section xml:id="member-variables">
<db:title>Member variables</db:title>
<db:para>Member variables should be of an owning type in nearly all cases. Views can only be used as member variables if the lifetime of the referenced owning string is guaranteed to exceed the lifetime of the object.</db:para>
</db:section>
<db:section xml:id="function-arguments">
<db:title>Function arguments</db:title>
<db:para>Function arguments should be string views of a suitable encoding in most cases. <db:link xlink:href="qanystringview.xml">QAnyStringView</db:link> can be used as a parameter to support more than one encoding and <db:link xlink:href="qanystringview.xml#visit">QAnyStringView::visit</db:link>() can be used internally to fork off into per-encoding functions. If the function is limited to a single encoding, <db:link xlink:href="qlatin1stringview.xml">QLatin1StringView</db:link>, <db:link xlink:href="qutf8stringview.xml">QUtf8StringView</db:link>, <db:link xlink:href="qstringview.xml">QStringView</db:link> or <db:link xlink:href="qbytearrayview.xml">QByteArrayView</db:link> should be used.</db:para>
<db:para>If the function saves the argument in an owning string (usually a setter function), it is most efficient to use the same owning string as function argument to make use of the implicit data sharing functionality of Qt. The owning string can be passed as a const reference. Overloading functions with multiple owning and non-owning string types can lead to overload ambiguity and should be avoided. Owning string types in Qt can be automatically converted to their non-owning version or to <db:link xlink:href="qanystringview.xml">QAnyStringView</db:link>.</db:para>
</db:section>
<db:section xml:id="return-values">
<db:title>Return values</db:title>
<db:para>Temporary strings have to be returned as an owning string, usually <db:link xlink:href="qstring.xml">QString</db:link>. If the returned string is known at compile-time use u&quot;foo&quot;_s to construct the <db:link xlink:href="qstring.xml">QString</db:link> structure at compile-time. If existing owning strings (for example <db:link xlink:href="qstring.xml">QString</db:link>) are returned from a function in full (for example a getter function), it is most efficient to return them by reference. They can also be returned by value to allow returning a temporary in the future. Qt's use of implicit sharing avoids the performance impact of allocation and copying when returning by value.</db:para>
<db:para>Parts of existing strings can be returned efficiently with a string view of the appropriate encoding, for an example see <db:link xlink:href="qregularexpressionmatch.xml#capturedView">QRegularExpressionMatch::capturedView</db:link>() which returns a <db:link xlink:href="qstringview.xml">QStringView</db:link>.</db:para>
</db:section>
</db:section>
<db:section xml:id="string-class-for-using-api">
<db:title>String class for using API</db:title>
<db:mediaobject>
<db:alt>&quot;String class for calling a function&quot;</db:alt>
<db:imageobject>
<db:imagedata fileref="images/string_class_calling.svg"/>
</db:imageobject>
</db:mediaobject>
<db:para>To use a Qt API efficiently you should try to match the function argument types. If you are limited in your choice, Qt will conduct various conversions: Owning strings are implicitly converted to non-owning strings, non-owning strings can create their owning counter parts, see for example <db:link xlink:href="qstringview.xml#toString">QStringView::toString</db:link>(). Encoding conversions are conducted implicitly in many cases but this should be avoided if possible. To avoid accidental implicit conversion from UTF-8 you can activate the macro <db:link xlink:href="qstring.xml#QT_NO_CAST_FROM_ASCII">QT_NO_CAST_FROM_ASCII</db:link>.</db:para>
<db:para>If you need to assemble a string at runtime before passing it to a function you will need an owning string and thus <db:link xlink:href="qstring.xml">QString</db:link>. If the function argument is <db:link xlink:href="qstringview.xml">QStringView</db:link> or <db:link xlink:href="qanystringview.xml">QAnyStringView</db:link> it will be implicitly converted.</db:para>
<db:para>If the string is known at compile-time, there is room for optimization. If the function accepts a <db:link xlink:href="qstring.xml">QString</db:link>, you should create it with u&quot;foo&quot;_s or the <db:link xlink:href="qstring.xml#QStringLiteral">QStringLiteral</db:link> macro. If the function expects a <db:link xlink:href="qstringview.xml">QStringView</db:link>, it is best constructed with an ordinary UTF-16 string literal u&quot;foo&quot;, if a <db:link xlink:href="qlatin1stringview.xml">QLatin1StringView</db:link> is expected, construct it with &quot;foo&quot;_L1. If you have the choice between both, for example if the function expects <db:link xlink:href="qanystringview.xml">QAnyStringView</db:link>, use the tightest encoding, usually Latin-1.</db:para>
</db:section>
</db:section>
<db:section xml:id="list-of-all-string-related-classes">
<db:title>List of all string related classes</db:title>
<db:section>
<db:title>Contents</db:title>
<db:variablelist role="members">
<db:varlistentry>
<db:term><db:link xlink:href="qanystringview.xml" xlink:role="class">QAnyStringView</db:link></db:term>
<db:listitem>
<db:para>The QAnyStringView class provides a unified view on Latin-1, UTF-8, or UTF-16 strings with a read-only subset of the QString API.</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term><db:link xlink:href="qbytearray.xml" xlink:role="class">QByteArray</db:link></db:term>
<db:listitem>
<db:para>The QByteArray class provides an array of bytes.</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term><db:link xlink:href="qbytearraylist.xml" xlink:role="class">QByteArrayList</db:link></db:term>
<db:listitem>
<db:para>The QByteArrayList class provides a list of byte arrays.</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term><db:link xlink:href="qbytearraymatcher.xml" xlink:role="class">QByteArrayMatcher</db:link></db:term>
<db:listitem>
<db:para>The QByteArrayMatcher class holds a sequence of bytes that can be quickly matched in a byte array.</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term><db:link xlink:href="qbytearrayview.xml" xlink:role="class">QByteArrayView</db:link></db:term>
<db:listitem>
<db:para>The QByteArrayView class provides a view on an array of bytes with a read-only subset of the QByteArray API.</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term><db:link xlink:href="qchar.xml" xlink:role="class">QChar</db:link></db:term>
<db:listitem>
<db:para>The QChar class provides a 16-bit Unicode character.</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term><db:link xlink:href="qcollator.xml" xlink:role="class">QCollator</db:link></db:term>
<db:listitem>
<db:para>The QCollator class compares strings according to a localized collation algorithm.</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term><db:link xlink:href="qcollatorsortkey.xml" xlink:role="class">QCollatorSortKey</db:link></db:term>
<db:listitem>
<db:para>The QCollatorSortKey class can be used to speed up string collation.</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term><db:link xlink:href="qlatin1char.xml" xlink:role="class">QLatin1Char</db:link></db:term>
<db:listitem>
<db:para>The QLatin1Char class provides an 8-bit ASCII/Latin-1 character.</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term><db:link xlink:href="qlatin1stringmatcher.xml" xlink:role="class">QLatin1StringMatcher</db:link></db:term>
<db:listitem>
<db:para>Optimized search for substring in Latin-1 text.</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term><db:link xlink:href="qlatin1stringview.xml" xlink:role="class">QLatin1StringView</db:link></db:term>
<db:listitem>
<db:para>The QLatin1StringView class provides a thin wrapper around a US-ASCII/Latin-1 encoded string literal.</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term><db:link xlink:href="qlocale.xml" xlink:role="class">QLocale</db:link></db:term>
<db:listitem>
<db:para>The QLocale class converts between numbers and their string representations in various languages.</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term><db:link xlink:href="qregularexpression.xml" xlink:role="class">QRegularExpression</db:link></db:term>
<db:listitem>
<db:para>The QRegularExpression class provides pattern matching using regular expressions.</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term><db:link xlink:href="qregularexpressionmatch.xml" xlink:role="class">QRegularExpressionMatch</db:link></db:term>
<db:listitem>
<db:para>The QRegularExpressionMatch class provides the results of a matching a QRegularExpression against a string.</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term><db:link xlink:href="qregularexpressionmatchiterator.xml" xlink:role="class">QRegularExpressionMatchIterator</db:link></db:term>
<db:listitem>
<db:para>The QRegularExpressionMatchIterator class provides an iterator on the results of a global match of a QRegularExpression object against a string.</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term><db:link xlink:href="qstaticbytearraymatcher.xml" xlink:role="class">QStaticByteArrayMatcher</db:link></db:term>
<db:listitem>
<db:para>The QStaticByteArrayMatcher class is a compile-time version of QByteArrayMatcher.</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term><db:link xlink:href="qstaticlatin1stringmatcher.xml" xlink:role="class">QStaticLatin1StringMatcher</db:link></db:term>
<db:listitem>
<db:para>The QStaticLatin1StringMatcher class is a compile-time version of QLatin1StringMatcher.</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term><db:link xlink:href="qstring.xml" xlink:role="class">QString</db:link></db:term>
<db:listitem>
<db:para>The QString class provides a Unicode character string.</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term><db:link xlink:href="qstringconverter.xml" xlink:role="class">QStringConverter</db:link></db:term>
<db:listitem>
<db:para>The QStringConverter class provides a base class for encoding and decoding text.</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term><db:link xlink:href="qstringdecoder.xml" xlink:role="class">QStringDecoder</db:link></db:term>
<db:listitem>
<db:para>The QStringDecoder class provides a state-based decoder for text.</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term><db:link xlink:href="qstringencoder.xml" xlink:role="class">QStringEncoder</db:link></db:term>
<db:listitem>
<db:para>The QStringEncoder class provides a state-based encoder for text.</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term><db:link xlink:href="qstringlist.xml" xlink:role="class">QStringList</db:link></db:term>
<db:listitem>
<db:para>The QStringList class provides a list of strings.</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term><db:link xlink:href="qstringmatcher.xml" xlink:role="class">QStringMatcher</db:link></db:term>
<db:listitem>
<db:para>The QStringMatcher class holds a sequence of characters that can be quickly matched in a Unicode string.</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term><db:link xlink:href="qstringref.xml" xlink:role="class">QStringRef</db:link></db:term>
<db:listitem>
<db:para>The QStringRef class provides a thin wrapper around QString substrings.</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term><db:link xlink:href="qstringtokenizer.xml" xlink:role="class">QStringTokenizer</db:link></db:term>
<db:listitem>
<db:para>The QStringTokenizer class splits strings into tokens along given separators.</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term><db:link xlink:href="qstringview.xml" xlink:role="class">QStringView</db:link></db:term>
<db:listitem>
<db:para>The QStringView class provides a unified view on UTF-16 strings with a read-only subset of the QString API.</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term><db:link xlink:href="qtextboundaryfinder.xml" xlink:role="class">QTextBoundaryFinder</db:link></db:term>
<db:listitem>
<db:para>The QTextBoundaryFinder class provides a way of finding Unicode text boundaries in a string.</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term><db:link xlink:href="qtextstream.xml" xlink:role="class">QTextStream</db:link></db:term>
<db:listitem>
<db:para>The QTextStream class provides a convenient interface for reading and writing text.</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term><db:link xlink:href="qutf8stringview.xml" xlink:role="class">QUtf8StringView</db:link></db:term>
<db:listitem>
<db:para>The QUtf8StringView class provides a unified view on UTF-8 strings with a read-only subset of the QString API.</db:para>
</db:listitem>
</db:varlistentry>
</db:variablelist>
</db:section>
</db:section>
</db:article>
