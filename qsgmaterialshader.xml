<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en">
<db:info>
<db:title>QSGMaterialShader Class</db:title>
<db:productname>QtQuick</db:productname>
<db:edition>Qt 5.12.12 Reference Documentation</db:edition>
<db:titleabbrev>Qt Quick Reference Documentation</db:titleabbrev>
<db:abstract>
<db:para>The <db:link xlink:href="qsgmaterialshader.xml">QSGMaterialShader</db:link> class represents an OpenGL shader program in the renderer.</db:para>
</db:abstract>
<db:pubdate>2024-12-27</db:pubdate>
<db:date>2024-12-27</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:variablelist>
<db:varlistentry>
<db:term>Header</db:term>
<db:listitem>
<db:para>QSGMaterialShader</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>qmake</db:term>
<db:listitem>
<db:para>QT += quick</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Inherited By</db:term>
<db:listitem>
<db:para><db:link xlink:href="qsgsimplematerialshader.xml" xlink:role="class">QSGSimpleMaterialShader</db:link></db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Group</db:term>
<db:listitem>
<db:para>QSGMaterialShader is part of <db:simplelist><db:member><db:link xlink:href="qtquick-scenegraph-materials.xml">Qt Quick Scene Graph Material Classes</db:link></db:member></db:simplelist></db:para>
</db:listitem>
</db:varlistentry>
</db:variablelist>
<db:section xml:id="details">
<db:title>Detailed Description</db:title>
<db:para>The <db:link xlink:href="qsgmaterialshader.xml">QSGMaterialShader</db:link> API is very low-level. A more convenient API, which provides almost all the same features, is available through <db:link xlink:href="qsgsimplematerialshader.xml">QSGSimpleMaterialShader</db:link>.</db:para>
<db:para>The <db:link xlink:href="qsgmaterial.xml">QSGMaterial</db:link> and <db:link xlink:href="qsgmaterialshader.xml">QSGMaterialShader</db:link> form a tight relationship. For one scene graph (including nested graphs), there is one unique <db:link xlink:href="qsgmaterialshader.xml">QSGMaterialShader</db:link> instance which encapsulates the <db:link xlink:href="qopenglshaderprogram.xml">QOpenGLShaderProgram</db:link> the scene graph uses to render that material, such as a shader to flat coloring of geometry. Each <db:link xlink:href="qsggeometrynode.xml">QSGGeometryNode</db:link> can have a unique <db:link xlink:href="qsgmaterial.xml">QSGMaterial</db:link> containing the how the shader should be configured when drawing that node, such as the actual color used to render the geometry.</db:para>
<db:para>An instance of <db:link xlink:href="qsgmaterialshader.xml">QSGMaterialShader</db:link> is never created explicitly by the user, it will be created on demand by the scene graph through <db:link xlink:href="qsgmaterial.xml#createShader">QSGMaterial::createShader</db:link>(). The scene graph will make sure that there is only one instance of each shader implementation through a scene graph.</db:para>
<db:para>The source code returned from <db:link xlink:href="qsgmaterialshader.xml#vertexShader">vertexShader</db:link>() is used to control what the material does with the vertiex data that comes in from the geometry. The source code returned from the <db:link xlink:href="qsgmaterialshader.xml#fragmentShader">fragmentShader</db:link>() is used to control what how the material should fill each individual pixel in the geometry. The vertex and fragment source code is queried once during initialization, changing what is returned from these functions later will not have any effect.</db:para>
<db:para>The <db:link xlink:href="qsgmaterialshader.xml#activate">activate</db:link>() function is called by the scene graph when a shader is is starting to be used. The deactivate function is called by the scene graph when the shader is no longer going to be used. While active, the scene graph may make one or more calls to <db:link xlink:href="qsgmaterialshader.xml#updateState">updateState</db:link>() which will update the state of the shader for each individual geometry to render.</db:para>
<db:para>The <db:link xlink:href="qsgmaterialshader.xml#attributeNames">attributeNames</db:link>() returns the name of the attributes used in the <db:link xlink:href="qsgmaterialshader.xml#vertexShader">vertexShader</db:link>(). These are used in the default implementation of <db:link xlink:href="qsgmaterialshader.xml#activate">activate</db:link>() and <db:link xlink:href="qsgmaterialshader.xml#deactivate">deactivate</db:link>() to decide whice vertex registers are enabled.</db:para>
<db:para>The <db:link xlink:href="qsgmaterialshader.xml#initialize">initialize</db:link>() function is called during program creation to allow subclasses to prepare for use, such as resolve uniform names in the <db:link xlink:href="qsgmaterialshader.xml#vertexShader">vertexShader</db:link>() and <db:link xlink:href="qsgmaterialshader.xml#fragmentShader">fragmentShader</db:link>().</db:para>
<db:para>A minimal example:</db:para>
<db:programlisting language="cpp">class Shader : public QSGMaterialShader
{
public:
    const char *vertexShader() const {
        return
        &quot;attribute highp vec4 vertex;          \n&quot;
        &quot;uniform highp mat4 matrix;            \n&quot;
        &quot;void main() {                         \n&quot;
        &quot;    gl_Position = matrix * vertex;    \n&quot;
        &quot;}&quot;;
    }

    const char *fragmentShader() const {
        return
        &quot;uniform lowp float opacity;                            \n&quot;
        &quot;void main() {                                          \n&quot;
                &quot;    gl_FragColor = vec4(1, 0, 0, 1) * opacity; \n&quot;
        &quot;}&quot;;
    }

    char const *const *attributeNames() const
    {
        static char const *const names[] = { &quot;vertex&quot;, 0 };
        return names;
    }

    void initialize()
    {
        QSGMaterialShader::initialize();
        m_id_matrix = program()-&amp;gt;uniformLocation(&quot;matrix&quot;);
        m_id_opacity = program()-&amp;gt;uniformLocation(&quot;opacity&quot;);
    }

    void updateState(const RenderState &amp;amp;state, QSGMaterial *newMaterial, QSGMaterial *oldMaterial)
    {
        Q_ASSERT(program()-&amp;gt;isLinked());
        if (state.isMatrixDirty())
            program()-&amp;gt;setUniformValue(m_id_matrix, state.combinedMatrix());
        if (state.isOpacityDirty())
            program()-&amp;gt;setUniformValue(m_id_opacity, state.opacity());
    }

private:
    int m_id_matrix;
    int m_id_opacity;
};
</db:programlisting>
<db:note>
<db:para>All classes with QSG prefix should be used solely on the scene graph's rendering thread. See <db:link xlink:href="qtquick-visualcanvas-scenegraph.xml#scene-graph-and-rendering">Scene Graph and Rendering</db:link> for more information.</db:para>
</db:note>
</db:section>
<db:section xml:id="member-function-documentation">
<db:title>Member Function Documentation</db:title>
<db:section xml:id="QSGMaterialShader">
<db:title>QSGMaterialShader::QSGMaterialShader()</db:title>
<db:constructorsynopsis>
<db:methodname>QSGMaterialShader</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">constructor</db:synopsisinfo>
<db:synopsisinfo role="signature">QSGMaterialShader()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:constructorsynopsis>
<db:para>Creates a new <db:link xlink:href="qsgmaterialshader.xml">QSGMaterialShader</db:link>.</db:para>
</db:section>
<db:section xml:id="activate">
<db:title>[virtual] void QSGMaterialShader::activate()</db:title>
<db:methodsynopsis>
<db:modifier>virtual</db:modifier>
<db:void/>
<db:methodname>activate</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void activate()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This function is called by the scene graph to indicate that geometry is about to be rendered using this shader.</db:para>
<db:para>State that is global for all uses of the shader, independent of the geometry that is being drawn, can be setup in this function.</db:para>
</db:section>
<db:section xml:id="attributeNames">
<db:title>[pure virtual] const char *const *QSGMaterialShader::attributeNames() const</db:title>
<db:methodsynopsis>
<db:modifier>virtual</db:modifier>
<db:modifier>const</db:modifier>
<db:type>const char *const *</db:type>
<db:methodname>attributeNames</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">const char *const * attributeNames() const = 0</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns a zero-terminated array describing the names of the attributes used in the vertex shader.</db:para>
<db:para>This function is called when the shader is compiled to specify which attributes exist. The order of the attribute names defines the attribute register position in the vertex shader.</db:para>
</db:section>
<db:section xml:id="compile">
<db:title>[virtual protected] void QSGMaterialShader::compile()</db:title>
<db:methodsynopsis>
<db:modifier>virtual</db:modifier>
<db:void/>
<db:methodname>compile</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void compile()</db:synopsisinfo>
<db:synopsisinfo role="access">protected</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This function is called when the shader is initialized to compile the actual <db:link xlink:href="qopenglshaderprogram.xml">QOpenGLShaderProgram</db:link>. Do not call it explicitly.</db:para>
<db:para>The default implementation will extract the <db:link xlink:href="qsgmaterialshader.xml#vertexShader">vertexShader</db:link>() and <db:link xlink:href="qsgmaterialshader.xml#fragmentShader">fragmentShader</db:link>() and bind the names returned from <db:link xlink:href="qsgmaterialshader.xml#attributeNames">attributeNames</db:link>() to consecutive vertex attribute registers starting at 0.</db:para>
</db:section>
<db:section xml:id="deactivate">
<db:title>[virtual] void QSGMaterialShader::deactivate()</db:title>
<db:methodsynopsis>
<db:modifier>virtual</db:modifier>
<db:void/>
<db:methodname>deactivate</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void deactivate()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This function is called by the scene graph to indicate that geometry will no longer to be rendered using this shader.</db:para>
</db:section>
<db:section xml:id="fragmentShader">
<db:title>[virtual protected] const char *QSGMaterialShader::fragmentShader() const</db:title>
<db:methodsynopsis>
<db:modifier>virtual</db:modifier>
<db:modifier>const</db:modifier>
<db:type>const char *</db:type>
<db:methodname>fragmentShader</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">const char * fragmentShader() const</db:synopsisinfo>
<db:synopsisinfo role="access">protected</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Called when the shader is being initialized to get the fragment shader source code.</db:para>
<db:para>The contents returned from this function should never change.</db:para>
</db:section>
<db:section xml:id="initialize">
<db:title>[virtual protected] void QSGMaterialShader::initialize()</db:title>
<db:methodsynopsis>
<db:modifier>virtual</db:modifier>
<db:void/>
<db:methodname>initialize</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void initialize()</db:synopsisinfo>
<db:synopsisinfo role="access">protected</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Reimplement this function to do one-time initialization when the shader program is compiled. The OpenGL shader program is compiled and linked, but not bound, when this function is called.</db:para>
</db:section>
<db:section xml:id="program">
<db:title>QOpenGLShaderProgram *QSGMaterialShader::program()</db:title>
<db:methodsynopsis>
<db:type>QOpenGLShaderProgram *</db:type>
<db:methodname>program</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QOpenGLShaderProgram * program()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the shader program used by this <db:link xlink:href="qsgmaterialshader.xml">QSGMaterialShader</db:link>.</db:para>
</db:section>
<db:section xml:id="setShaderSourceFile">
<db:title>[protected] void QSGMaterialShader::setShaderSourceFile(QOpenGLShader::ShaderType <db:emphasis>type</db:emphasis>, const QString &amp;<db:emphasis>sourceFile</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>setShaderSourceFile</db:methodname>
<db:methodparam>
<db:type>QOpenGLShader::ShaderType</db:type>
<db:parameter>type</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const QString &amp;</db:type>
<db:parameter>sourceFile</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void setShaderSourceFile(QOpenGLShader::ShaderType type, const QString &amp;sourceFile)</db:synopsisinfo>
<db:synopsisinfo role="access">protected</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Sets the GLSL source file for the shader stage <db:code role="parameter">type</db:code> to <db:code role="parameter">sourceFile</db:code>. The default implementation of the <db:link xlink:href="qsgmaterialshader.xml#vertexShader">vertexShader</db:link>() and <db:link xlink:href="qsgmaterialshader.xml#fragmentShader">fragmentShader</db:link>() functions will load the source files set by this function.</db:para>
<db:para>This function is useful when you have a single source file for a given shader stage. If your shader consists of multiple source files then use <db:link xlink:href="qsgmaterialshader.xml#setShaderSourceFiles">setShaderSourceFiles</db:link>()</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qsgmaterialshader.xml#setShaderSourceFiles">setShaderSourceFiles</db:link>()</db:member>
<db:member><db:link xlink:href="qsgmaterialshader.xml#vertexShader">vertexShader</db:link>()</db:member>
<db:member><db:link xlink:href="qsgmaterialshader.xml#fragmentShader">fragmentShader</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setShaderSourceFiles">
<db:title>[protected] void QSGMaterialShader::setShaderSourceFiles(QOpenGLShader::ShaderType <db:emphasis>type</db:emphasis>, const QStringList &amp;<db:emphasis>sourceFiles</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>setShaderSourceFiles</db:methodname>
<db:methodparam>
<db:type>QOpenGLShader::ShaderType</db:type>
<db:parameter>type</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const QStringList &amp;</db:type>
<db:parameter>sourceFiles</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void setShaderSourceFiles(QOpenGLShader::ShaderType type, const QStringList &amp;sourceFiles)</db:synopsisinfo>
<db:synopsisinfo role="access">protected</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Sets the GLSL source files for the shader stage <db:code role="parameter">type</db:code> to <db:code role="parameter">sourceFiles</db:code>. The default implementation of the <db:link xlink:href="qsgmaterialshader.xml#vertexShader">vertexShader</db:link>() and <db:link xlink:href="qsgmaterialshader.xml#fragmentShader">fragmentShader</db:link>() functions will load the source files set by this function in the order given.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qsgmaterialshader.xml#setShaderSourceFile">setShaderSourceFile</db:link>()</db:member>
<db:member><db:link xlink:href="qsgmaterialshader.xml#vertexShader">vertexShader</db:link>()</db:member>
<db:member><db:link xlink:href="qsgmaterialshader.xml#fragmentShader">fragmentShader</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="updateState">
<db:title>[virtual] void QSGMaterialShader::updateState(const QSGMaterialShader::RenderState &amp;<db:emphasis>state</db:emphasis>, QSGMaterial *<db:emphasis>newMaterial</db:emphasis>, QSGMaterial *<db:emphasis>oldMaterial</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:modifier>virtual</db:modifier>
<db:void/>
<db:methodname>updateState</db:methodname>
<db:methodparam>
<db:type>const QSGMaterialShader::RenderState &amp;</db:type>
<db:parameter>state</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>QSGMaterial *</db:type>
<db:parameter>newMaterial</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>QSGMaterial *</db:type>
<db:parameter>oldMaterial</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void updateState(const QSGMaterialShader::RenderState &amp;state, QSGMaterial *newMaterial, QSGMaterial *oldMaterial)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This function is called by the scene graph before geometry is rendered to make sure the shader is in the right state.</db:para>
<db:para>The current rendering <db:code role="parameter">state</db:code> is passed from the scene graph. If the state indicates that any state is dirty, the updateState implementation must update accordingly for the geometry to render correctly.</db:para>
<db:para>The subclass specific state, such as the color of a flat color material, should be extracted from <db:code role="parameter">newMaterial</db:code> to update the color uniforms accordingly.</db:para>
<db:para>The <db:code role="parameter">oldMaterial</db:code> can be used to minimze state changes when updating material states. The <db:code role="parameter">oldMaterial</db:code> is 0 if this shader was just activated.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qsgmaterialshader.xml#activate">activate</db:link>()</db:member>
<db:member><db:link xlink:href="qsgmaterialshader.xml#deactivate">deactivate</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="vertexShader">
<db:title>[virtual protected] const char *QSGMaterialShader::vertexShader() const</db:title>
<db:methodsynopsis>
<db:modifier>virtual</db:modifier>
<db:modifier>const</db:modifier>
<db:type>const char *</db:type>
<db:methodname>vertexShader</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">const char * vertexShader() const</db:synopsisinfo>
<db:synopsisinfo role="access">protected</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Called when the shader is being initialized to get the vertex shader source code.</db:para>
<db:para>The contents returned from this function should never change.</db:para>
</db:section>
</db:section>
</db:article>
