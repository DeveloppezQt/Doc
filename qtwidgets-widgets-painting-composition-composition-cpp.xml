<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en">
<db:info>
<db:title>Composition Modes</db:title>
<db:productname>QtWidgets</db:productname>
<db:edition>Qt 5.12.12 Reference Documentation</db:edition>
<db:titleabbrev>Qt Widgets Reference Documentation</db:titleabbrev>
<db:abstract>
<db:para>Demonstrates how Composition Modes work in <db:link xlink:href="qpainter.xml">QPainter</db:link>.</db:para>
</db:abstract>
<db:pubdate>2024-12-27</db:pubdate>
<db:date>2024-12-27</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:programlisting language="cpp">/****************************************************************************
**
** Copyright (C) 2016 The Qt Company Ltd.
** Contact: https://www.qt.io/licensing/
**
** This file is part of the demonstration applications of the Qt Toolkit.
**
** $QT_BEGIN_LICENSE:BSD$
** Commercial License Usage
** Licensees holding valid commercial Qt licenses may use this file in
** accordance with the commercial license agreement provided with the
** Software or, alternatively, in accordance with the terms contained in
** a written agreement between you and The Qt Company. For licensing terms
** and conditions see https://www.qt.io/terms-conditions. For further
** information use the contact form at https://www.qt.io/contact-us.
**
** BSD License Usage
** Alternatively, you may use this file under the terms of the BSD license
** as follows:
**
** &quot;Redistribution and use in source and binary forms, with or without
** modification, are permitted provided that the following conditions are
** met:
**   * Redistributions of source code must retain the above copyright
**     notice, this list of conditions and the following disclaimer.
**   * Redistributions in binary form must reproduce the above copyright
**     notice, this list of conditions and the following disclaimer in
**     the documentation and/or other materials provided with the
**     distribution.
**   * Neither the name of The Qt Company Ltd nor the names of its
**     contributors may be used to endorse or promote products derived
**     from this software without specific prior written permission.
**
**
** THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
** &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
** LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
** A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
** OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
** SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
** LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
** DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
** THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
** (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
** OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.&quot;
**
** $QT_END_LICENSE$
**
****************************************************************************/

#include &quot;composition.h&quot;
#include &amp;lt;QBoxLayout&amp;gt;
#include &amp;lt;QRadioButton&amp;gt;
#include &amp;lt;QTimer&amp;gt;
#include &amp;lt;QDateTime&amp;gt;
#include &amp;lt;QSlider&amp;gt;
#include &amp;lt;QMouseEvent&amp;gt;
#include &amp;lt;qmath.h&amp;gt;

#if QT_CONFIG(opengl)
#include &amp;lt;QOpenGLFunctions&amp;gt;
#include &amp;lt;QOpenGLWindow&amp;gt;
#endif

const int animationInterval = 15; // update every 16 ms = ~60FPS

CompositionWidget::CompositionWidget(QWidget *parent)
    : QWidget(parent)
{
    CompositionRenderer *view = new CompositionRenderer(this);

    QGroupBox *mainGroup = new QGroupBox(parent);
    mainGroup-&amp;gt;setTitle(tr(&quot;Composition Modes&quot;));

    QGroupBox *modesGroup = new QGroupBox(mainGroup);
    modesGroup-&amp;gt;setTitle(tr(&quot;Mode&quot;));

    rbClear = new QRadioButton(tr(&quot;Clear&quot;), modesGroup);
    connect(rbClear, SIGNAL(clicked()), view, SLOT(setClearMode()));
    rbSource = new QRadioButton(tr(&quot;Source&quot;), modesGroup);
    connect(rbSource, SIGNAL(clicked()), view, SLOT(setSourceMode()));
    rbDest = new QRadioButton(tr(&quot;Destination&quot;), modesGroup);
    connect(rbDest, SIGNAL(clicked()), view, SLOT(setDestMode()));
    rbSourceOver = new QRadioButton(tr(&quot;Source Over&quot;), modesGroup);
    connect(rbSourceOver, SIGNAL(clicked()), view, SLOT(setSourceOverMode()));
    rbDestOver = new QRadioButton(tr(&quot;Destination Over&quot;), modesGroup);
    connect(rbDestOver, SIGNAL(clicked()), view, SLOT(setDestOverMode()));
    rbSourceIn = new QRadioButton(tr(&quot;Source In&quot;), modesGroup);
    connect(rbSourceIn, SIGNAL(clicked()), view, SLOT(setSourceInMode()));
    rbDestIn = new QRadioButton(tr(&quot;Dest In&quot;), modesGroup);
    connect(rbDestIn, SIGNAL(clicked()), view, SLOT(setDestInMode()));
    rbSourceOut = new QRadioButton(tr(&quot;Source Out&quot;), modesGroup);
    connect(rbSourceOut, SIGNAL(clicked()), view, SLOT(setSourceOutMode()));
    rbDestOut = new QRadioButton(tr(&quot;Dest Out&quot;), modesGroup);
    connect(rbDestOut, SIGNAL(clicked()), view, SLOT(setDestOutMode()));
    rbSourceAtop = new QRadioButton(tr(&quot;Source Atop&quot;), modesGroup);
    connect(rbSourceAtop, SIGNAL(clicked()), view, SLOT(setSourceAtopMode()));
    rbDestAtop = new QRadioButton(tr(&quot;Dest Atop&quot;), modesGroup);
    connect(rbDestAtop, SIGNAL(clicked()), view, SLOT(setDestAtopMode()));
    rbXor = new QRadioButton(tr(&quot;Xor&quot;), modesGroup);
    connect(rbXor, SIGNAL(clicked()), view, SLOT(setXorMode()));

    rbPlus = new QRadioButton(tr(&quot;Plus&quot;), modesGroup);
    connect(rbPlus, SIGNAL(clicked()), view, SLOT(setPlusMode()));
    rbMultiply = new QRadioButton(tr(&quot;Multiply&quot;), modesGroup);
    connect(rbMultiply, SIGNAL(clicked()), view, SLOT(setMultiplyMode()));
    rbScreen = new QRadioButton(tr(&quot;Screen&quot;), modesGroup);
    connect(rbScreen, SIGNAL(clicked()), view, SLOT(setScreenMode()));
    rbOverlay = new QRadioButton(tr(&quot;Overlay&quot;), modesGroup);
    connect(rbOverlay, SIGNAL(clicked()), view, SLOT(setOverlayMode()));
    rbDarken = new QRadioButton(tr(&quot;Darken&quot;), modesGroup);
    connect(rbDarken, SIGNAL(clicked()), view, SLOT(setDarkenMode()));
    rbLighten = new QRadioButton(tr(&quot;Lighten&quot;), modesGroup);
    connect(rbLighten, SIGNAL(clicked()), view, SLOT(setLightenMode()));
    rbColorDodge = new QRadioButton(tr(&quot;Color Dodge&quot;), modesGroup);
    connect(rbColorDodge, SIGNAL(clicked()), view, SLOT(setColorDodgeMode()));
    rbColorBurn = new QRadioButton(tr(&quot;Color Burn&quot;), modesGroup);
    connect(rbColorBurn, SIGNAL(clicked()), view, SLOT(setColorBurnMode()));
    rbHardLight = new QRadioButton(tr(&quot;Hard Light&quot;), modesGroup);
    connect(rbHardLight, SIGNAL(clicked()), view, SLOT(setHardLightMode()));
    rbSoftLight = new QRadioButton(tr(&quot;Soft Light&quot;), modesGroup);
    connect(rbSoftLight, SIGNAL(clicked()), view, SLOT(setSoftLightMode()));
    rbDifference = new QRadioButton(tr(&quot;Difference&quot;), modesGroup);
    connect(rbDifference, SIGNAL(clicked()), view, SLOT(setDifferenceMode()));
    rbExclusion = new QRadioButton(tr(&quot;Exclusion&quot;), modesGroup);
    connect(rbExclusion, SIGNAL(clicked()), view, SLOT(setExclusionMode()));

    QGroupBox *circleColorGroup = new QGroupBox(mainGroup);
    circleColorGroup-&amp;gt;setTitle(tr(&quot;Circle color&quot;));
    QSlider *circleColorSlider = new QSlider(Qt::Horizontal, circleColorGroup);
    circleColorSlider-&amp;gt;setRange(0, 359);
    circleColorSlider-&amp;gt;setSizePolicy(QSizePolicy::Preferred, QSizePolicy::Fixed);
    connect(circleColorSlider, SIGNAL(valueChanged(int)), view, SLOT(setCircleColor(int)));

    QGroupBox *circleAlphaGroup = new QGroupBox(mainGroup);
    circleAlphaGroup-&amp;gt;setTitle(tr(&quot;Circle alpha&quot;));
    QSlider *circleAlphaSlider = new QSlider(Qt::Horizontal, circleAlphaGroup);
    circleAlphaSlider-&amp;gt;setRange(0, 255);
    circleAlphaSlider-&amp;gt;setSizePolicy(QSizePolicy::Preferred, QSizePolicy::Fixed);
    connect(circleAlphaSlider, SIGNAL(valueChanged(int)), view, SLOT(setCircleAlpha(int)));

    QPushButton *showSourceButton = new QPushButton(mainGroup);
    showSourceButton-&amp;gt;setText(tr(&quot;Show Source&quot;));
#if QT_CONFIG(opengl)
    QPushButton *enableOpenGLButton = new QPushButton(mainGroup);
    enableOpenGLButton-&amp;gt;setText(tr(&quot;Use OpenGL&quot;));
    enableOpenGLButton-&amp;gt;setCheckable(true);
    enableOpenGLButton-&amp;gt;setChecked(view-&amp;gt;usesOpenGL());
#endif
    QPushButton *whatsThisButton = new QPushButton(mainGroup);
    whatsThisButton-&amp;gt;setText(tr(&quot;What's This?&quot;));
    whatsThisButton-&amp;gt;setCheckable(true);

    QPushButton *animateButton = new QPushButton(mainGroup);
    animateButton-&amp;gt;setText(tr(&quot;Animated&quot;));
    animateButton-&amp;gt;setCheckable(true);
    animateButton-&amp;gt;setChecked(true);

    QHBoxLayout *viewLayout = new QHBoxLayout(this);
    viewLayout-&amp;gt;addWidget(view);
    viewLayout-&amp;gt;addWidget(mainGroup);

    QVBoxLayout *mainGroupLayout = new QVBoxLayout(mainGroup);
    mainGroupLayout-&amp;gt;addWidget(circleColorGroup);
    mainGroupLayout-&amp;gt;addWidget(circleAlphaGroup);
    mainGroupLayout-&amp;gt;addWidget(modesGroup);
    mainGroupLayout-&amp;gt;addStretch();
    mainGroupLayout-&amp;gt;addWidget(animateButton);
    mainGroupLayout-&amp;gt;addWidget(whatsThisButton);
    mainGroupLayout-&amp;gt;addWidget(showSourceButton);
#if QT_CONFIG(opengl)
    mainGroupLayout-&amp;gt;addWidget(enableOpenGLButton);
#endif

    QGridLayout *modesLayout = new QGridLayout(modesGroup);
    modesLayout-&amp;gt;addWidget(rbClear, 0, 0);
    modesLayout-&amp;gt;addWidget(rbSource, 1, 0);
    modesLayout-&amp;gt;addWidget(rbDest, 2, 0);
    modesLayout-&amp;gt;addWidget(rbSourceOver, 3, 0);
    modesLayout-&amp;gt;addWidget(rbDestOver, 4, 0);
    modesLayout-&amp;gt;addWidget(rbSourceIn, 5, 0);
    modesLayout-&amp;gt;addWidget(rbDestIn, 6, 0);
    modesLayout-&amp;gt;addWidget(rbSourceOut, 7, 0);
    modesLayout-&amp;gt;addWidget(rbDestOut, 8, 0);
    modesLayout-&amp;gt;addWidget(rbSourceAtop, 9, 0);
    modesLayout-&amp;gt;addWidget(rbDestAtop, 10, 0);
    modesLayout-&amp;gt;addWidget(rbXor, 11, 0);

    modesLayout-&amp;gt;addWidget(rbPlus, 0, 1);
    modesLayout-&amp;gt;addWidget(rbMultiply, 1, 1);
    modesLayout-&amp;gt;addWidget(rbScreen, 2, 1);
    modesLayout-&amp;gt;addWidget(rbOverlay, 3, 1);
    modesLayout-&amp;gt;addWidget(rbDarken, 4, 1);
    modesLayout-&amp;gt;addWidget(rbLighten, 5, 1);
    modesLayout-&amp;gt;addWidget(rbColorDodge, 6, 1);
    modesLayout-&amp;gt;addWidget(rbColorBurn, 7, 1);
    modesLayout-&amp;gt;addWidget(rbHardLight, 8, 1);
    modesLayout-&amp;gt;addWidget(rbSoftLight, 9, 1);
    modesLayout-&amp;gt;addWidget(rbDifference, 10, 1);
    modesLayout-&amp;gt;addWidget(rbExclusion, 11, 1);

    QVBoxLayout *circleColorLayout = new QVBoxLayout(circleColorGroup);
    circleColorLayout-&amp;gt;addWidget(circleColorSlider);

    QVBoxLayout *circleAlphaLayout = new QVBoxLayout(circleAlphaGroup);
    circleAlphaLayout-&amp;gt;addWidget(circleAlphaSlider);

    view-&amp;gt;loadDescription(&quot;:res/composition/composition.html&quot;);
    view-&amp;gt;loadSourceFile(&quot;:res/composition/composition.cpp&quot;);

    connect(whatsThisButton, SIGNAL(clicked(bool)), view, SLOT(setDescriptionEnabled(bool)));
    connect(view, SIGNAL(descriptionEnabledChanged(bool)), whatsThisButton, SLOT(setChecked(bool)));
    connect(showSourceButton, SIGNAL(clicked()), view, SLOT(showSource()));
#if QT_CONFIG(opengl)
    connect(enableOpenGLButton, SIGNAL(clicked(bool)), view, SLOT(enableOpenGL(bool)));
#endif
    connect(animateButton, SIGNAL(toggled(bool)), view, SLOT(setAnimationEnabled(bool)));

    circleColorSlider-&amp;gt;setValue(270);
    circleAlphaSlider-&amp;gt;setValue(200);
    rbSourceOut-&amp;gt;animateClick();

    setWindowTitle(tr(&quot;Composition Modes&quot;));
}

void CompositionWidget::nextMode()
{
    /*
      if (!m_animation_enabled)
      return;
      if (rbClear-&amp;gt;isChecked()) rbSource-&amp;gt;animateClick();
      if (rbSource-&amp;gt;isChecked()) rbDest-&amp;gt;animateClick();
      if (rbDest-&amp;gt;isChecked()) rbSourceOver-&amp;gt;animateClick();
      if (rbSourceOver-&amp;gt;isChecked()) rbDestOver-&amp;gt;animateClick();
      if (rbDestOver-&amp;gt;isChecked()) rbSourceIn-&amp;gt;animateClick();
      if (rbSourceIn-&amp;gt;isChecked()) rbDestIn-&amp;gt;animateClick();
      if (rbDestIn-&amp;gt;isChecked()) rbSourceOut-&amp;gt;animateClick();
      if (rbSourceOut-&amp;gt;isChecked()) rbDestOut-&amp;gt;animateClick();
      if (rbDestOut-&amp;gt;isChecked()) rbSourceAtop-&amp;gt;animateClick();
      if (rbSourceAtop-&amp;gt;isChecked()) rbDestAtop-&amp;gt;animateClick();
      if (rbDestAtop-&amp;gt;isChecked()) rbXor-&amp;gt;animateClick();
      if (rbXor-&amp;gt;isChecked()) rbClear-&amp;gt;animateClick();
    */
}

CompositionRenderer::CompositionRenderer(QWidget *parent)
    : ArthurFrame(parent)
{
    m_animation_enabled = true;
    m_animationTimer = startTimer(animationInterval);
    m_image = QImage(&quot;:res/composition/flower.jpg&quot;);
    m_image.setAlphaChannel(QImage(&quot;:res/composition/flower_alpha.jpg&quot;));
    m_circle_alpha = 127;
    m_circle_hue = 255;
    m_current_object = NoObject;
    m_composition_mode = QPainter::CompositionMode_SourceOut;

    m_circle_pos = QPoint(200, 100);

    setSizePolicy(QSizePolicy::Expanding, QSizePolicy::Expanding);
#if QT_CONFIG(opengl)
    m_pbuffer_size = 1024;
#endif
}

QRectF rectangle_around(const QPointF &amp;amp;p, const QSizeF &amp;amp;size = QSize(250, 200))
{
    QRectF rect(p, size);
    rect.translate(-size.width()/2, -size.height()/2);
    return rect;
}

void CompositionRenderer::setAnimationEnabled(bool enabled)
{
    if (m_animation_enabled == enabled)
        return;
    m_animation_enabled = enabled;
    if (enabled) {
        Q_ASSERT(!m_animationTimer);
        m_animationTimer = startTimer(animationInterval);
    } else {
        killTimer(m_animationTimer);
        m_animationTimer = 0;
    }
}

void CompositionRenderer::updateCirclePos()
{
    if (m_current_object != NoObject)
        return;
    QDateTime dt = QDateTime::currentDateTime();
    qreal t = dt.toMSecsSinceEpoch() / 1000.0;

    qreal x = width() / qreal(2) + (qCos(t*8/11) + qSin(-t)) * width() / qreal(4);
    qreal y = height() / qreal(2) + (qSin(t*6/7) + qCos(t * qreal(1.5))) * height() / qreal(4);

    setCirclePos(QLineF(m_circle_pos, QPointF(x, y)).pointAt(0.02));
}

void CompositionRenderer::drawBase(QPainter &amp;amp;p)
{
    p.setPen(Qt::NoPen);

    QLinearGradient rect_gradient(0, 0, 0, height());
    rect_gradient.setColorAt(0, Qt::red);
    rect_gradient.setColorAt(.17, Qt::yellow);
    rect_gradient.setColorAt(.33, Qt::green);
    rect_gradient.setColorAt(.50, Qt::cyan);
    rect_gradient.setColorAt(.66, Qt::blue);
    rect_gradient.setColorAt(.81, Qt::magenta);
    rect_gradient.setColorAt(1, Qt::red);
    p.setBrush(rect_gradient);
    p.drawRect(width() / 2, 0, width() / 2, height());

    QLinearGradient alpha_gradient(0, 0, width(), 0);
    alpha_gradient.setColorAt(0, Qt::white);
    alpha_gradient.setColorAt(0.2, Qt::white);
    alpha_gradient.setColorAt(0.5, Qt::transparent);
    alpha_gradient.setColorAt(0.8, Qt::white);
    alpha_gradient.setColorAt(1, Qt::white);

    p.setCompositionMode(QPainter::CompositionMode_DestinationIn);
    p.setBrush(alpha_gradient);
    p.drawRect(0, 0, width(), height());

    p.setCompositionMode(QPainter::CompositionMode_DestinationOver);

    p.setPen(Qt::NoPen);
    p.setRenderHint(QPainter::SmoothPixmapTransform);
    p.drawImage(rect(), m_image);
}

void CompositionRenderer::drawSource(QPainter &amp;amp;p)
{
    p.setPen(Qt::NoPen);
    p.setRenderHint(QPainter::Antialiasing);
    p.setCompositionMode(m_composition_mode);

    QRectF circle_rect = rectangle_around(m_circle_pos);
    QColor color = QColor::fromHsvF(m_circle_hue / 360.0, 1, 1, m_circle_alpha / 255.0);
    QLinearGradient circle_gradient(circle_rect.topLeft(), circle_rect.bottomRight());
    circle_gradient.setColorAt(0, color.light());
    circle_gradient.setColorAt(0.5, color);
    circle_gradient.setColorAt(1, color.dark());
    p.setBrush(circle_gradient);

    p.drawEllipse(circle_rect);
}

void CompositionRenderer::paint(QPainter *painter)
{
#if QT_CONFIG(opengl)
    if (usesOpenGL() &amp;amp;&amp;amp; glWindow()-&amp;gt;isValid()) {

        if (!m_blitter.isCreated())
            m_blitter.create();

        int new_pbuf_size = m_pbuffer_size;
        while (size().width() &amp;gt; new_pbuf_size || size().height() &amp;gt; new_pbuf_size)
            new_pbuf_size *= 2;

        while (size().width() &amp;lt; new_pbuf_size/2 &amp;amp;&amp;amp; size().height() &amp;lt; new_pbuf_size/2)
            new_pbuf_size /= 2;

        if (!m_fbo || new_pbuf_size != m_pbuffer_size) {
            m_fbo.reset(new QFboPaintDevice(QSize(new_pbuf_size, new_pbuf_size), false, false));
            m_pbuffer_size = new_pbuf_size;
        }

        if (size() != m_previous_size) {
            m_previous_size = size();
            QPainter p(m_fbo.data());
            p.setCompositionMode(QPainter::CompositionMode_Source);
            p.fillRect(QRect(QPoint(0, 0), size()), Qt::transparent);
            p.setCompositionMode(QPainter::CompositionMode_SourceOver);
            drawBase(p);
            p.end();
            m_base_tex = m_fbo-&amp;gt;takeTexture();
        }

        painter-&amp;gt;beginNativePainting();
        {
            QPainter p(m_fbo.data());
            p.beginNativePainting();
            m_blitter.bind();
            const QRect targetRect(QPoint(0, 0), m_fbo-&amp;gt;size());
            const QMatrix4x4 target = QOpenGLTextureBlitter::targetTransform(targetRect, QRect(QPoint(0, 0), m_fbo-&amp;gt;size()));
            m_blitter.blit(m_base_tex, target, QOpenGLTextureBlitter::OriginBottomLeft);
            m_blitter.release();
            p.endNativePainting();
            drawSource(p);
            p.end();
            m_compositing_tex = m_fbo-&amp;gt;takeTexture();
        }
        painter-&amp;gt;endNativePainting();

        painter-&amp;gt;beginNativePainting();
        auto *funcs = QOpenGLContext::currentContext()-&amp;gt;functions();
        funcs-&amp;gt;glEnable(GL_BLEND);
        funcs-&amp;gt;glBlendEquation(GL_FUNC_ADD);
        funcs-&amp;gt;glBlendFunc(GL_ONE, GL_ONE_MINUS_SRC_ALPHA);
        m_blitter.bind();
        const QRect targetRect(QPoint(0, 0), m_fbo-&amp;gt;size());
        const QMatrix4x4 target = QOpenGLTextureBlitter::targetTransform(targetRect, QRect(QPoint(0, 0), size()));
        m_blitter.blit(m_compositing_tex, target, QOpenGLTextureBlitter::OriginBottomLeft);
        m_blitter.release();
        painter-&amp;gt;endNativePainting();
    } else
#endif
    {
        // using a QImage
        if (m_buffer.size() != size()) {
            m_buffer = QImage(size(), QImage::Format_ARGB32_Premultiplied);
            m_base_buffer = QImage(size(), QImage::Format_ARGB32_Premultiplied);

            m_base_buffer.fill(0);

            QPainter p(&amp;amp;m_base_buffer);

            drawBase(p);
        }

        memcpy(m_buffer.bits(), m_base_buffer.bits(), m_buffer.sizeInBytes());

        {
            QPainter p(&amp;amp;m_buffer);
            drawSource(p);
        }

        painter-&amp;gt;drawImage(0, 0, m_buffer);
    }
}

void CompositionRenderer::mousePressEvent(QMouseEvent *e)
{
    setDescriptionEnabled(false);

    QRectF circle = rectangle_around(m_circle_pos);

    if (circle.contains(e-&amp;gt;pos())) {
        m_current_object = Circle;
        m_offset = circle.center() - e-&amp;gt;pos();
    } else {
        m_current_object = NoObject;
    }
    if (m_animation_enabled) {
        killTimer(m_animationTimer);
        m_animationTimer = 0;
    }
}

void CompositionRenderer::mouseMoveEvent(QMouseEvent *e)
{
    if (m_current_object == Circle)
        setCirclePos(e-&amp;gt;pos() + m_offset);
}

void CompositionRenderer::mouseReleaseEvent(QMouseEvent *)
{
    m_current_object = NoObject;

    if (m_animation_enabled) {
        Q_ASSERT(!m_animationTimer);
        m_animationTimer = startTimer(animationInterval);
    }
}

void CompositionRenderer::timerEvent(QTimerEvent *event)
{
    if (event-&amp;gt;timerId() == m_animationTimer)
        updateCirclePos();
}

void CompositionRenderer::setCirclePos(const QPointF &amp;amp;pos)
{
    const QRect oldRect = rectangle_around(m_circle_pos).toAlignedRect();
    m_circle_pos = pos;
    const QRect newRect = rectangle_around(m_circle_pos).toAlignedRect();
#if QT_CONFIG(opengl)
    if (usesOpenGL()) {
        update();
        return;
    }
#endif
    update(oldRect | newRect);
}

</db:programlisting>
</db:article>
