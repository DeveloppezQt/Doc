<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en">
<db:info>
<db:title>Image Gestures Example</db:title>
<db:productname>QtWidgets</db:productname>
<db:edition>Qt 5.12.12 Reference Documentation</db:edition>
<db:titleabbrev>Qt Widgets Reference Documentation</db:titleabbrev>
<db:abstract>
<db:para>Demonstrates the use of simple gestures in a widget.</db:para>
</db:abstract>
<db:pubdate>2024-12-27</db:pubdate>
<db:date>2024-12-27</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:programlisting language="cpp">/****************************************************************************
**
** Copyright (C) 2016 The Qt Company Ltd.
** Contact: https://www.qt.io/licensing/
**
** This file is part of the examples of the Qt Toolkit.
**
** $QT_BEGIN_LICENSE:BSD$
** Commercial License Usage
** Licensees holding valid commercial Qt licenses may use this file in
** accordance with the commercial license agreement provided with the
** Software or, alternatively, in accordance with the terms contained in
** a written agreement between you and The Qt Company. For licensing terms
** and conditions see https://www.qt.io/terms-conditions. For further
** information use the contact form at https://www.qt.io/contact-us.
**
** BSD License Usage
** Alternatively, you may use this file under the terms of the BSD license
** as follows:
**
** &quot;Redistribution and use in source and binary forms, with or without
** modification, are permitted provided that the following conditions are
** met:
**   * Redistributions of source code must retain the above copyright
**     notice, this list of conditions and the following disclaimer.
**   * Redistributions in binary form must reproduce the above copyright
**     notice, this list of conditions and the following disclaimer in
**     the documentation and/or other materials provided with the
**     distribution.
**   * Neither the name of The Qt Company Ltd nor the names of its
**     contributors may be used to endorse or promote products derived
**     from this software without specific prior written permission.
**
**
** THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
** &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
** LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
** A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
** OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
** SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
** LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
** DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
** THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
** (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
** OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.&quot;
**
** $QT_END_LICENSE$
**
****************************************************************************/

#include &quot;imagewidget.h&quot;

#include &amp;lt;QtWidgets&amp;gt;

Q_LOGGING_CATEGORY(lcExample, &quot;qt.examples.imagegestures&quot;)

ImageWidget::ImageWidget(QWidget *parent)
    : QWidget(parent),
    position(0),
    horizontalOffset(0),
    verticalOffset(0),
    rotationAngle(0),
    scaleFactor(1),
    currentStepScaleFactor(1)

{
    setMinimumSize(QSize(100,100));
}

void ImageWidget::grabGestures(const QList&amp;lt;Qt::GestureType&amp;gt; &amp;amp;gestures)
{
    foreach (Qt::GestureType gesture, gestures)
        grabGesture(gesture);
}

bool ImageWidget::event(QEvent *event)
{
    if (event-&amp;gt;type() == QEvent::Gesture)
        return gestureEvent(static_cast&amp;lt;QGestureEvent*&amp;gt;(event));
    return QWidget::event(event);
}

void ImageWidget::paintEvent(QPaintEvent*)
{
    QPainter p(this);

    const qreal iw = currentImage.width();
    const qreal ih = currentImage.height();
    const qreal wh = height();
    const qreal ww = width();

    p.translate(ww/2, wh/2);
    p.translate(horizontalOffset, verticalOffset);
    p.rotate(rotationAngle);
    p.scale(currentStepScaleFactor * scaleFactor, currentStepScaleFactor * scaleFactor);
    p.translate(-iw/2, -ih/2);
    p.drawImage(0, 0, currentImage);
}

void ImageWidget::mouseDoubleClickEvent(QMouseEvent *)
{
    rotationAngle = 0;
    scaleFactor = 1;
    currentStepScaleFactor = 1;
    verticalOffset = 0;
    horizontalOffset = 0;
    update();
    qCDebug(lcExample) &amp;lt;&amp;lt; &quot;reset on mouse double click&quot;;
}

bool ImageWidget::gestureEvent(QGestureEvent *event)
{
    qCDebug(lcExample) &amp;lt;&amp;lt; &quot;gestureEvent():&quot; &amp;lt;&amp;lt; event;
    if (QGesture *swipe = event-&amp;gt;gesture(Qt::SwipeGesture))
        swipeTriggered(static_cast&amp;lt;QSwipeGesture *&amp;gt;(swipe));
    else if (QGesture *pan = event-&amp;gt;gesture(Qt::PanGesture))
        panTriggered(static_cast&amp;lt;QPanGesture *&amp;gt;(pan));
    if (QGesture *pinch = event-&amp;gt;gesture(Qt::PinchGesture))
        pinchTriggered(static_cast&amp;lt;QPinchGesture *&amp;gt;(pinch));
    return true;
}

void ImageWidget::panTriggered(QPanGesture *gesture)
{
#ifndef QT_NO_CURSOR
    switch (gesture-&amp;gt;state()) {
        case Qt::GestureStarted:
        case Qt::GestureUpdated:
            setCursor(Qt::SizeAllCursor);
            break;
        default:
            setCursor(Qt::ArrowCursor);
    }
#endif
    QPointF delta = gesture-&amp;gt;delta();
    qCDebug(lcExample) &amp;lt;&amp;lt; &quot;panTriggered():&quot; &amp;lt;&amp;lt; gesture;
    horizontalOffset += delta.x();
    verticalOffset += delta.y();
    update();
}

void ImageWidget::pinchTriggered(QPinchGesture *gesture)
{
    QPinchGesture::ChangeFlags changeFlags = gesture-&amp;gt;changeFlags();
    if (changeFlags &amp;amp; QPinchGesture::RotationAngleChanged) {
        qreal rotationDelta = gesture-&amp;gt;rotationAngle() - gesture-&amp;gt;lastRotationAngle();
        rotationAngle += rotationDelta;
        qCDebug(lcExample) &amp;lt;&amp;lt; &quot;pinchTriggered(): rotate by&quot; &amp;lt;&amp;lt;
            rotationDelta &amp;lt;&amp;lt; &quot;-&amp;gt;&quot; &amp;lt;&amp;lt; rotationAngle;
    }
    if (changeFlags &amp;amp; QPinchGesture::ScaleFactorChanged) {
        currentStepScaleFactor = gesture-&amp;gt;totalScaleFactor();
        qCDebug(lcExample) &amp;lt;&amp;lt; &quot;pinchTriggered(): zoom by&quot; &amp;lt;&amp;lt;
            gesture-&amp;gt;scaleFactor() &amp;lt;&amp;lt; &quot;-&amp;gt;&quot; &amp;lt;&amp;lt; currentStepScaleFactor;
    }
    if (gesture-&amp;gt;state() == Qt::GestureFinished) {
        scaleFactor *= currentStepScaleFactor;
        currentStepScaleFactor = 1;
    }
    update();
}

void ImageWidget::swipeTriggered(QSwipeGesture *gesture)
{
    if (gesture-&amp;gt;state() == Qt::GestureFinished) {
        if (gesture-&amp;gt;horizontalDirection() == QSwipeGesture::Left
            || gesture-&amp;gt;verticalDirection() == QSwipeGesture::Up) {
            qCDebug(lcExample) &amp;lt;&amp;lt; &quot;swipeTriggered(): swipe to previous&quot;;
            goPrevImage();
        } else {
            qCDebug(lcExample) &amp;lt;&amp;lt; &quot;swipeTriggered(): swipe to next&quot;;
            goNextImage();
        }
        update();
    }
}

void ImageWidget::resizeEvent(QResizeEvent*)
{
    update();
}

void ImageWidget::openDirectory(const QString &amp;amp;path)
{
    this-&amp;gt;path = path;
    QDir dir(path);
    QStringList nameFilters;
    nameFilters &amp;lt;&amp;lt; &quot;*.jpg&quot; &amp;lt;&amp;lt; &quot;*.png&quot;;
    files = dir.entryList(nameFilters, QDir::Files|QDir::Readable, QDir::Name);

    position = 0;
    goToImage(0);
    update();
}

QImage ImageWidget::loadImage(const QString &amp;amp;fileName)
{
    QImageReader reader(fileName);
    reader.setAutoTransform(true);
    qCDebug(lcExample) &amp;lt;&amp;lt; &quot;loading&quot; &amp;lt;&amp;lt; QDir::toNativeSeparators(fileName) &amp;lt;&amp;lt; position &amp;lt;&amp;lt; '/' &amp;lt;&amp;lt; files.size();
    if (!reader.canRead()) {
        qCWarning(lcExample) &amp;lt;&amp;lt; QDir::toNativeSeparators(fileName) &amp;lt;&amp;lt; &quot;: can't load image&quot;;
        return QImage();
    }

    QImage image;
    if (!reader.read(&amp;amp;image)) {
        qCWarning(lcExample) &amp;lt;&amp;lt; QDir::toNativeSeparators(fileName) &amp;lt;&amp;lt; &quot;: corrupted image: &quot; &amp;lt;&amp;lt; reader.errorString();
        return QImage();
    }
    const QSize maximumSize(2000, 2000); // Reduce in case someone has large photo images.
    if (image.size().width() &amp;gt; maximumSize.width() || image.height() &amp;gt; maximumSize.height())
        image = image.scaled(maximumSize, Qt::KeepAspectRatio, Qt::SmoothTransformation);
    return image;
}

void ImageWidget::goNextImage()
{
    if (files.isEmpty())
        return;

    if (position &amp;lt; files.size()-1) {
        ++position;
        prevImage = currentImage;
        currentImage = nextImage;
        if (position+1 &amp;lt; files.size())
            nextImage = loadImage(path + QLatin1Char('/') + files.at(position+1));
        else
            nextImage = QImage();
    }
    update();
}

void ImageWidget::goPrevImage()
{
    if (files.isEmpty())
        return;

    if (position &amp;gt; 0) {
        --position;
        nextImage = currentImage;
        currentImage = prevImage;
        if (position &amp;gt; 0)
            prevImage = loadImage(path + QLatin1Char('/') + files.at(position-1));
        else
            prevImage = QImage();
    }
    update();
}

void ImageWidget::goToImage(int index)
{
    if (files.isEmpty())
        return;

    if (index &amp;lt; 0 || index &amp;gt;= files.size()) {
        qCWarning(lcExample) &amp;lt;&amp;lt; &quot;goToImage: invalid index: &quot; &amp;lt;&amp;lt; index;
        return;
    }

    if (index == position+1) {
        goNextImage();
        return;
    }

    if (position &amp;gt; 0 &amp;amp;&amp;amp; index == position-1) {
        goPrevImage();
        return;
    }

    position = index;

    if (index &amp;gt; 0)
        prevImage = loadImage(path + QLatin1Char('/') + files.at(position-1));
    else
        prevImage = QImage();
    currentImage = loadImage(path + QLatin1Char('/') + files.at(position));
    if (position+1 &amp;lt; files.size())
        nextImage = loadImage(path + QLatin1Char('/') + files.at(position+1));
    else
        nextImage = QImage();
    update();
}

</db:programlisting>
</db:article>
