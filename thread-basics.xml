<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en_US">
<db:info>
<db:title>Threading Basics</db:title>
<db:productname>QtCore</db:productname>
<db:titleabbrev>Qt Core Reference Documentation</db:titleabbrev>
<db:extendedlink xlink:type="extended"><db:link xlink:to="index.html" xlink:type="arc" xlink:arcrole="start" xlink:title="Qt Reference Documentation"/></db:extendedlink>
<db:abstract>
<db:para>An introduction to threads.</db:para>
</db:abstract>
<db:pubdate>2025-06-29</db:pubdate>
<db:date>2025-06-29</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:section xml:id="what-are-threads">
<db:title>What Are Threads?</db:title>
<db:para>Threads are about doing things in parallel, just like processes. So how do threads differ from processes? While you are making calculations on a spreadsheet, there may also be a media player running on the same desktop playing your favorite song. Here is an example of two processes working in parallel: one running the spreadsheet program; one running a media player. Multitasking is a well known term for this. A closer look at the media player reveals that there are again things going on in parallel within one single process. While the media player is sending music to the audio driver, the user interface with all its bells and whistles is being constantly updated. This is what threads are for â€“ concurrency within one single process.</db:para>
<db:para>So how is concurrency implemented? Parallel work on single core CPUs is an illusion which is somewhat similar to the illusion of moving images in cinema. For processes, the illusion is produced by interrupting the processor's work on one process after a very short time. Then the processor moves on to the next process. In order to switch between processes, the current program counter is saved and the next processor's program counter is loaded. This is not sufficient because the same needs to be done with registers and certain architecture and OS specific data.</db:para>
<db:para>Just as one CPU can power two or more processes, it is also possible to let the CPU run on two different code segments of one single process. When a process starts, it always executes one code segment and therefore the process is said to have one thread. However, the program may decide to start a second thread. Then, two different code sequences are processed simultaneously inside one process. Concurrency is achieved on single core CPUs by repeatedly saving program counters and registers then loading the next thread's program counters and registers. No cooperation from the program is required to cycle between the active threads. A thread may be in any state when the switch to the next thread occurs.</db:para>
<db:para>The current trend in CPU design is to have several cores. A typical single-threaded application can make use of only one core. However, a program with multiple threads can be assigned to multiple cores, making things happen in a truly concurrent way. As a result, distributing work to more than one thread can make a program run much faster on multicore CPUs because additional cores can be used.</db:para>
<db:section xml:id="gui-thread-and-worker-thread">
<db:title>GUI Thread and Worker Thread</db:title>
<db:para>As mentioned, each program has one thread when it is started. This thread is called the &quot;main thread&quot; (also known as the &quot;GUI thread&quot; in Qt applications). The Qt GUI must run in this thread. All widgets and several related classes, for example QPixmap, don't work in secondary threads. A secondary thread is commonly referred to as a &quot;worker thread&quot; because it is used to offload processing work from the main thread.</db:para>
</db:section>
<db:section xml:id="simultaneous-access-to-data">
<db:title>Simultaneous Access to Data</db:title>
<db:para>Each thread has its own stack, which means each thread has its own call history and local variables. Unlike processes, threads share the same address space. The following diagram shows how the building blocks of threads are located in memory. Program counter and registers of inactive threads are typically kept in kernel space. There is a shared copy of the code and a separate stack for each thread.</db:para>
<db:mediaobject>
<db:alt>&quot;Thread visualization&quot;</db:alt>
<db:imageobject>
<db:imagedata fileref="images/threadvisual-example.png"/>
</db:imageobject>
</db:mediaobject>
<db:para>If two threads have a pointer to the same object, it is possible that both threads will access that object at the same time and this can potentially destroy the object's integrity. It's easy to imagine the many things that can go wrong when two methods of the same object are executed simultaneously.</db:para>
<db:para>Sometimes it is necessary to access one object from different threads; for example, when objects living in different threads need to communicate. Since threads use the same address space, it is easier and faster for threads to exchange data than it is for processes. Data does not have to be serialized and copied. Passing pointers is possible, but there must be a strict coordination of what thread touches which object. Simultaneous execution of operations on one object must be prevented. There are several ways of achieving this and some of them are described below.</db:para>
<db:para>So what can be done safely? All objects created in a thread can be used safely within that thread provided that other threads don't have references to them and objects don't have implicit coupling with other threads. Such implicit coupling may happen when data is shared between instances as with static members, singletons or global data. Familiarize yourself with the concept of <db:link xlink:href="threads-reentrancy.xml">thread safe and reentrant</db:link> classes and functions.</db:para>
</db:section>
</db:section>
<db:section xml:id="using-threads">
<db:title>Using Threads</db:title>
<db:para>There are basically two use cases for threads:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para>Make processing faster by making use of multicore processors.</db:para>
</db:listitem>
<db:listitem>
<db:para>Keep the GUI thread or other time critical threads responsive by offloading long lasting processing or blocking calls to other threads.</db:para>
</db:listitem>
</db:itemizedlist>
<db:section xml:id="when-to-use-alternatives-to-threads">
<db:title>When to Use Alternatives to Threads</db:title>
<db:para>Developers need to be very careful with threads. It is easy to start other threads, but very hard to ensure that all shared data remains consistent. Problems are often hard to find because they may only show up once in a while or only on specific hardware configurations. Before creating threads to solve certain problems, possible alternatives should be considered.</db:para>
<db:informaltable style="generic">
<db:thead>
<db:tr>
<db:th>
<db:para>Alternative</db:para>
</db:th>
<db:th>
<db:para>Comment</db:para>
</db:th>
</db:tr>
</db:thead>
<db:tr valign="top">
<db:td>
<db:para><db:link xlink:href="qeventloop.xml#processEvents">QEventLoop::processEvents</db:link>()</db:para>
</db:td>
<db:td>
<db:para>Calling <db:link xlink:href="qeventloop.xml#processEvents">QEventLoop::processEvents</db:link>() repeatedly during a time-consuming calculation prevents GUI blocking. However, this solution doesn't scale well because the call to processEvents() may occur too often, or not often enough, depending on hardware.</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para><db:link xlink:href="qtimer.xml">QTimer</db:link></db:para>
</db:td>
<db:td>
<db:para>Background processing can sometimes be done conveniently using a timer to schedule execution of a slot at some point in the future. A timer with an interval of 0 will time out as soon as there are no more events to process.</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para><db:link xlink:href="qsocketnotifier.xml">QSocketNotifier</db:link> QNetworkAccessManager <db:link xlink:href="qiodevice.xml#readyRead">QIODevice::readyRead</db:link>()</db:para>
</db:td>
<db:td>
<db:para>This is an alternative to having one or multiple threads, each with a blocking read on a slow network connection. As long as the calculation in response to a chunk of network data can be executed quickly, this reactive design is better than synchronous waiting in threads. Reactive design is less error prone and energy efficient than threading. In many cases there are also performance benefits.</db:para>
</db:td>
</db:tr>
</db:informaltable>
<db:para>In general, it is recommended to only use safe and tested paths and to avoid introducing ad-hoc threading concepts. The <db:link xlink:href="qtconcurrent-module.xml">QtConcurrent</db:link> module provides an easy interface for distributing work to all of the processor's cores. The threading code is completely hidden in the <db:link xlink:href="qtconcurrent-module.xml">QtConcurrent</db:link> framework, so you don't have to take care of the details. However, <db:link xlink:href="qtconcurrent-module.xml">QtConcurrent</db:link> can't be used when communication with the running thread is needed, and it shouldn't be used to handle blocking operations.</db:para>
</db:section>
<db:section xml:id="which-qt-thread-technology-should-you-use">
<db:title>Which Qt Thread Technology Should You Use?</db:title>
<db:para>Sometimes you want to do more than just running a method in the context of another thread. You may want to have an object which lives in another thread that provides a service to the GUI thread. Maybe you want another thread to stay alive forever to poll hardware ports and send a signal to the GUI thread when something noteworthy has happened. Qt provides different solutions for developing threaded applications. The right solution depends on the purpose of the new thread as well as on the thread's lifetime.</db:para>
<db:informaltable style="generic">
<db:thead>
<db:tr>
<db:th>
<db:para>Lifetime of thread</db:para>
</db:th>
<db:th>
<db:para>Development task</db:para>
</db:th>
<db:th>
<db:para>Solution</db:para>
</db:th>
</db:tr>
</db:thead>
<db:tr valign="top">
<db:td>
<db:para>One call</db:para>
</db:td>
<db:td>
<db:para>Run one method within another thread and quit the thread when the method is finished.</db:para>
</db:td>
<db:td>
<db:para>Qt provides different solutions:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para>Write a function and run it with QtConcurrent::run()</db:para>
</db:listitem>
<db:listitem>
<db:para>Derive a class from <db:link xlink:href="qrunnable.xml">QRunnable</db:link> and run it in the global thread pool with <db:link xlink:href="qthreadpool.xml#globalInstance">QThreadPool::globalInstance</db:link>()-&gt;start()</db:para>
</db:listitem>
<db:listitem>
<db:para>Derive a class from <db:link xlink:href="qthread.xml">QThread</db:link>, reimplement the <db:link xlink:href="qthread.xml#run">QThread::run</db:link>() method and use <db:link xlink:href="qthread.xml#start">QThread::start</db:link>() to run it.</db:para>
</db:listitem>
</db:itemizedlist>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>One call</db:para>
</db:td>
<db:td>
<db:para>Operations are to be performed on all items of a container. Processing should be performed using all available cores. A common example is to produce thumbnails from a list of images.</db:para>
</db:td>
<db:td>
<db:para><db:link xlink:href="qtconcurrent-module.xml">QtConcurrent</db:link> provides the <db:link xlink:href="">map()</db:link> function for applying operations on every container element, <db:link xlink:href="">filter()</db:link> for selecting container elements, and the option of specifying a reduce function for combining the remaining elements.</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>One call</db:para>
</db:td>
<db:td>
<db:para>A long running operation has to be put in another thread. During the course of processing, status information should be sent to the GUI thread.</db:para>
</db:td>
<db:td>
<db:para>Use <db:link xlink:href="qthread.xml">QThread</db:link>, reimplement run and emit signals as needed. Connect the signals to the GUI thread's slots using queued signal/slot connections.</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>Permanent</db:para>
</db:td>
<db:td>
<db:para>Have an object living in another thread and let it perform different tasks upon request. This means communication to and from the worker thread is required.</db:para>
</db:td>
<db:td>
<db:para>Derive a class from <db:link xlink:href="qobject.xml">QObject</db:link> and implement the necessary slots and signals, move the object to a thread with a running event loop and communicate with the object over queued signal/slot connections.</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>Permanent</db:para>
</db:td>
<db:td>
<db:para>Have an object living in another thread, let the object perform repeated tasks such as polling a port and enable communication with the GUI thread.</db:para>
</db:td>
<db:td>
<db:para>Same as above but also use a timer in the worker thread to implement polling. However, the best solution for polling is to avoid it completely. Sometimes using <db:link xlink:href="qsocketnotifier.xml">QSocketNotifier</db:link> is an alternative.</db:para>
</db:td>
</db:tr>
</db:informaltable>
</db:section>
</db:section>
<db:section xml:id="qt-thread-basics">
<db:title>Qt Thread Basics</db:title>
<db:para><db:link xlink:href="qthread.xml">QThread</db:link> is a very convenient cross platform abstraction of native platform threads. Starting a thread is very simple. Let us look at a short piece of code that generates another thread which says hello in that thread and then exits.</db:para>
<db:programlisting language="cpp">// hellothread/hellothread.h
class HelloThread : public QThread
{
    Q_OBJECT
private:
    void run();
};
</db:programlisting>
<db:para>We derive a class from <db:link xlink:href="qthread.xml">QThread</db:link> and reimplement the <db:link xlink:href="qthread.xml#run">run</db:link>() method.</db:para>
<db:programlisting language="cpp">// hellothread/hellothread.cpp
void HelloThread::run()
{
     qDebug() &lt;&lt; &quot;hello from worker thread &quot; &lt;&lt; thread()-&gt;currentThreadId();
}
</db:programlisting>
<db:para>The run method contains the code that will be run in a separate thread. In this example, a message containing the thread ID will be printed. <db:link xlink:href="qthread.xml#start">QThread::start</db:link>() will call the method in another thread.</db:para>
<db:programlisting language="cpp">int main(int argc, char *argv[])
{
    QCoreApplication app(argc, argv);
    HelloThread thread;
    thread.start();
    qDebug() &lt;&lt; &quot;hello from GUI thread &quot; &lt;&lt; app.thread()-&gt;currentThreadId();
    thread.wait();  // do not exit before the thread is completed!
    return 0;
}
</db:programlisting>
<db:para>To start the thread, our thread object needs to be instantiated. The <db:link xlink:href="qthread.xml#start">start</db:link>() method creates a new thread and calls the reimplemented <db:link xlink:href="qthread.xml#run">run</db:link>() method in this new thread. Right after <db:link xlink:href="qthread.xml#start">start</db:link>() is called, two program counters walk through the program code. The main function starts with only the GUI thread running and it should terminate with only the GUI thread running. Exiting the program when another thread is still busy is a programming error, and therefore, wait is called which blocks the calling thread until the <db:link xlink:href="qthread.xml#run">run</db:link>() method has completed.</db:para>
<db:para>This is the result of running the code:</db:para>
<db:programlisting language="cpp">//bad code
hello from GUI thread  3079423696
hello from worker thread  3076111216
</db:programlisting>
<db:section xml:id="qobject-and-threads">
<db:title>QObject and Threads</db:title>
<db:para>A <db:link xlink:href="qobject.xml">QObject</db:link> is said to have a <db:emphasis>thread affinity</db:emphasis> or, in other words, that it lives in a certain thread. This means that, at creation time, <db:link xlink:href="qobject.xml">QObject</db:link> saves a pointer to the current thread. This information becomes relevant when an event is posted with <db:link xlink:href="qcoreapplication.xml#postEvent">postEvent</db:link>(). The event will be put in the corresponding thread's event loop. If the thread where the <db:link xlink:href="qobject.xml">QObject</db:link> lives doesn't have an event loop, the event will never be delivered.</db:para>
<db:para>To start an event loop, <db:link xlink:href="qthread.xml#exec">exec</db:link>() must be called inside <db:link xlink:href="qthread.xml#run">run</db:link>(). Thread affinity can be changed using <db:link xlink:href="qobject.xml#moveToThread">moveToThread</db:link>().</db:para>
<db:para>As mentioned above, developers must always be careful when calling objects' methods from other threads. Thread affinity does not change this situation. Qt documentation marks several methods as thread-safe. <db:link xlink:href="qcoreapplication.xml#postEvent">postEvent</db:link>() is a noteworthy example. A thread-safe method may be called from different threads simultaneously.</db:para>
<db:para>In cases where there is usually no concurrent access to methods, calling non-thread-safe methods of objects in other threads may work thousands of times before a concurrent access occurs, causing unexpected behavior. Writing test code does not entirely ensure thread correctness, but it is still important. On Linux, Valgrind and Helgrind can help detect threading errors.</db:para>
<db:para>The anatomy of <db:link xlink:href="qthread.xml">QThread</db:link> is quite interesting:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:link xlink:href="qthread.xml">QThread</db:link> does not live in the new thread where <db:link xlink:href="qthread.xml#run">run</db:link>() is executed. It lives in the old thread.</db:para>
</db:listitem>
<db:listitem>
<db:para>Most <db:link xlink:href="qthread.xml">QThread</db:link> methods are the thread's control interface and are meant to be called from the old thread. Do not move this interface to the newly created thread using <db:link xlink:href="qobject.xml#moveToThread">moveToThread</db:link>(); i.e., calling <db:link xlink:href="qobject.xml#moveToThread">moveToThread</db:link>(this) is regarded as bad practice.</db:para>
</db:listitem>
<db:listitem>
<db:para><db:link xlink:href="qthread.xml#exec">exec</db:link>() and the static methods <db:link xlink:href="qthread.xml#usleep">usleep</db:link>(), <db:link xlink:href="qthread.xml#msleep">msleep</db:link>(), <db:link xlink:href="qthread.xml#sleep">sleep</db:link>() are meant to be called from the newly created thread.</db:para>
</db:listitem>
<db:listitem>
<db:para>Additional members defined in the <db:link xlink:href="qthread.xml">QThread</db:link> subclass are accessible by both threads. The developer is responsible for coordinating access. A typical strategy is to set the members before <db:link xlink:href="qthread.xml#start">start</db:link>() is called. Once the worker thread is running, the main thread should not touch the additional members anymore. After the worker has terminated, the main thread can access the additional members again. This is a convenient strategy for passing parameters to a thread before it is started as well as for collecting the result once it has terminated.</db:para>
</db:listitem>
</db:itemizedlist>
<db:para>A <db:link xlink:href="qobject.xml">QObject</db:link>'s parent must always be in the same thread. This has a surprising consequence for objects generated within the <db:link xlink:href="qthread.xml#run">run</db:link>() method:</db:para>
<db:programlisting language="cpp">void HelloThread::run()
{
     QObject *object1 = new QObject(this);  //error, parent must be in the same thread
     QObject object2;  // OK
     QSharedPointer &lt;QObject&gt; object3(new QObject); // OK
}
</db:programlisting>
</db:section>
<db:section xml:id="using-a-mutex-to-protect-the-integrity-of-data">
<db:title>Using a Mutex to Protect the Integrity of Data</db:title>
<db:para>A mutex is an object that has <db:link xlink:href="qmutex.xml#lock">lock</db:link>() and <db:link xlink:href="qmutex.xml#unlock">unlock</db:link>() methods and remembers if it is already locked. A mutex is designed to be called from multiple threads. <db:link xlink:href="qmutex.xml#lock">lock</db:link>() returns immediately if the mutex is not locked. The next call from another thread will find the mutex in a locked state and then <db:link xlink:href="qmutex.xml#lock">lock</db:link>() will block the thread until the other thread calls <db:link xlink:href="qmutex.xml#unlock">unlock</db:link>(). This functionality can make sure that a code section will be executed by only one thread at a time.</db:para>
<db:para>The following line sketches how a mutex can be used to make a method thread-safe:</db:para>
<db:programlisting language="cpp">void Worker::work()
{
    this-&gt;mutex.lock();  // first thread can pass, other threads will be blocked here
    doWork();
    this-&gt;mutex.unlock();
}
</db:programlisting>
<db:para>What happens if one thread does not unlock a mutex? The result can be a frozen application. In the example above, an exception might be thrown and mutex.unlock() will never be reached. To prevent problems like this, <db:link xlink:href="qmutexlocker.xml">QMutexLocker</db:link> should be used.</db:para>
<db:programlisting language="cpp">void Worker::work()
{
    QMutexLocker locker(&amp;mutex);  // Locks the mutex and unlocks when locker exits the scope
    doWork();
}
</db:programlisting>
<db:para>This looks easy, but mutexes introduce a new class of problems: deadlocks. A deadlock happens when a thread waits for a mutex to become unlocked, but the mutex remains locked because the owning thread is waiting for the first thread to unlock it. The result is a frozen application. Mutexes can be used to make a method thread safe. Most Qt methods aren't thread safe because there is always a performance penalty when using mutexes.</db:para>
<db:para>It isn't always possible to lock and unlock a mutex in a method. Sometimes the need to lock spans several calls. For example, modifying a container with an iterator requires a sequence of several calls which should not be interrupted by other threads. In such a scenario, locking can be achieved with a mutex that is kept outside of the object to be manipulated. With an external mutex, the duration of locking can be adjusted to the needs of the operation. One disadvantage is that external mutexes aid locking, but do not enforce it because users of the object may forget to use it.</db:para>
</db:section>
<db:section xml:id="using-the-event-loop-to-prevent-data-corruption">
<db:title>Using the Event Loop to Prevent Data Corruption</db:title>
<db:para>The event loops of Qt are a very valuable tool for inter-thread communication. Every thread may have its own event loop. A safe way of calling a slot in another thread is by placing that call in another thread's event loop. This ensures that the target object finishes the method that is currently running before another method is started.</db:para>
<db:para>So how is it possible to put a method invocation in an event loop? Qt has two ways of doing this. One way is via queued signal-slot connections; the other way is to post an event with <db:link xlink:href="qcoreapplication.xml#postEvent">QCoreApplication::postEvent</db:link>(). A queued signal-slot connection is a signal slot connection that is executed asynchronously. The internal implementation is based on posted events. The arguments of the signal are put into the event loop and the signal method returns immediately.</db:para>
<db:para>The connected slot will be executed at a time which depends on what else is in the event loop.</db:para>
<db:para>Communication via the event loop eliminates the deadlock problem we face when using mutexes. This is why we recommend using the event loop rather than locking an object using a mutex.</db:para>
</db:section>
<db:section xml:id="dealing-with-asynchronous-execution">
<db:title>Dealing with Asynchronous Execution</db:title>
<db:para>One way to obtain a worker thread's result is by waiting for the thread to terminate. In many cases, however, a blocking wait isn't acceptable. The alternative to a blocking wait are asynchronous result deliveries with either posted events or queued signals and slots. This generates a certain overhead because an operation's result does not appear on the next source line, but in a slot located somewhere else in the source file. Qt developers are used to working with this kind of asynchronous behavior because it is much similar to the kind of event-driven programming used in GUI applications.</db:para>
</db:section>
</db:section>
<db:section xml:id="examples">
<db:title>Examples</db:title>
<db:para>This tutorial comes with examples for Qt's three basic ways of working with threads. Two more examples show how to communicate with a running thread and how a <db:link xlink:href="qobject.xml">QObject</db:link> can be placed in another thread, providing service to the main thread.</db:para>
<db:itemizedlist>
<db:listitem>
<db:para>Using <db:link xlink:href="qthread.xml">QThread</db:link> as shown <db:link xlink:href="thread-basics.xml#qt-thread-basics">above</db:link></db:para>
</db:listitem>
<db:listitem>
<db:para><db:link xlink:href="thread-basics.xml#example-1-using-the-thread-pool">Using the global QThreadPool</db:link></db:para>
</db:listitem>
<db:listitem>
<db:para><db:link xlink:href="thread-basics.xml#example-2-using-qtconcurrent">Using QtConcurrent</db:link></db:para>
</db:listitem>
<db:listitem>
<db:para><db:link xlink:href="thread-basics.xml#example-3-clock">Communication with the GUI thread</db:link></db:para>
</db:listitem>
<db:listitem>
<db:para><db:link xlink:href="thread-basics.xml#example-4-a-permanent-thread">A permanent QObject in another thread provides service to the main thread</db:link></db:para>
</db:listitem>
</db:itemizedlist>
<db:para>The following examples can all be compiled and run independently. The source can be found in the examples directory: examples/tutorials/threads/</db:para>
<db:section xml:id="example-1-using-the-thread-pool">
<db:title>Example 1: Using the Thread Pool</db:title>
<db:para>Creating and destroying threads frequently can be expensive. To avoid the cost of thread creation, a thread pool can be used. A thread pool is a place where threads can be parked and fetched. We can write the same &quot;hello thread&quot; program as <db:link xlink:href="thread-basics.xml#qt-thread-basics">above</db:link> using the global thread pool. We derive a class from <db:link xlink:href="qrunnable.xml">QRunnable</db:link>. The code we want to run in another thread needs to be placed in the reimplemented <db:link xlink:href="qrunnable.xml#run">QRunnable::run</db:link>() method.</db:para>
<db:programlisting language="cpp">// hellothreadpool/main.cpp
class Work : public QRunnable
{
public:
    void run()
    {
        qDebug() &lt;&lt; &quot;Hello from thread &quot; &lt;&lt; QThread::currentThread();
    }
};

int main(int argc, char *argv[])
{
    QCoreApplication app(argc, argv);
    Work work;
    work.setAutoDelete(false);
    QThreadPool *threadPool = QThreadPool::globalInstance();
    threadPool-&gt;start(&amp;work);
    qDebug() &lt;&lt; &quot;hello from GUI thread &quot; &lt;&lt; QThread::currentThread();
    threadPool-&gt;waitForDone();
    return 0;
}
</db:programlisting>
<db:para>We instantiate Work in main(), locate the global thread pool and use the <db:link xlink:href="qthreadpool.xml#start">QThreadPool::start</db:link>() method. Now the thread pool runs our worker in another thread. Using the thread pool has a performance advantage because threads are not destroyed after they have finished running. They are kept in a pool and wait to be used again later.</db:para>
</db:section>
<db:section xml:id="example-2-using-qtconcurrent">
<db:title>Example 2: Using QtConcurrent</db:title>
<db:programlisting language="cpp">// helloconcurrent/main.cpp
void hello()
{
    qDebug() &lt;&lt; &quot;Hello from thread &quot; &lt;&lt; QThread::currentThread();
}

int main(int argc, char *argv[])
{
    QCoreApplication app(argc, argv);
    QFuture&lt;void&gt; future = QtConcurrent::run(hello);
    qDebug() &lt;&lt; &quot;hello from GUI thread &quot; &lt;&lt; QThread::currentThread();
    future.waitForFinished();
    return 0;
}
</db:programlisting>
<db:para>We write a global function hello() to implement the work. QtConcurrent::run() is used to run the function in another thread. The result is a <db:link xlink:href="qfuture.xml">QFuture</db:link>. <db:link xlink:href="qfuture.xml">QFuture</db:link> provides a method called <db:link xlink:href="">waitForFinished()</db:link>, which blocks until the calculation is completed. The real power of <db:link xlink:href="qtconcurrent-module.xml">QtConcurrent</db:link> becomes visible when data can be made available in a container. <db:link xlink:href="qtconcurrent-module.xml">QtConcurrent</db:link> provides several functions that are able to process itemized data on all available cores simultaneously. The use of <db:link xlink:href="qtconcurrent-module.xml">QtConcurrent</db:link> is very similar to applying an STL algorithm to an STL container. <db:link xlink:href="">QtConcurrent Map</db:link> is a very short and clear example about how a container of images can be scaled on all available cores. The image scaling example uses the blocking variants of the functions used. For every blocking function there is also a non-blocking, asynchronous counterpart. Getting results asynchronously is implemented with <db:link xlink:href="qfuture.xml">QFuture</db:link> and <db:link xlink:href="qfuturewatcher.xml">QFutureWatcher</db:link>.</db:para>
</db:section>
<db:section xml:id="example-3-clock">
<db:title>Example 3: Clock</db:title>
<db:mediaobject>
<db:alt>&quot;clock&quot;</db:alt>
<db:imageobject>
<db:imagedata fileref="images/thread_clock.png"/>
</db:imageobject>
</db:mediaobject>
<db:para>We want to produce a clock application. The application has a GUI and a worker thread. The worker thread checks every 10 milliseconds what time it is. If the formatted time has changed, the result will be sent to the GUI thread where it is displayed.</db:para>
<db:para>Of course, this is an overly complicated way of designing a clock and, actually, a separate thread is unnecessary. We would be better off placing the timer in the main thread because the calculation made in the timer slot is very short-lived. This example is purely for instructional use and shows how to communicate from a worker thread to a GUI thread. Note that communication in this direction is easy. We only need to add a signal to <db:link xlink:href="qthread.xml">QThread</db:link> and make a queued signal/slot connection to the main thread. Communication from the GUI to the worker thread is shown in the next example.</db:para>
<db:programlisting language="cpp">int main(int argc, char *argv[])
{
    QApplication app(argc, argv);
    // build gui
    QWidget widget;
    QLabel *label = new QLabel;
    QHBoxLayout *layout = new QHBoxLayout(&amp;widget);
    layout-&gt;addWidget(label);
    widget.setWindowTitle(&quot;clock&quot;);

    //instantiate thread object
    ClockThread clockThread;
    QObject::connect(&amp;clockThread, SIGNAL(sendTime(QString)), label, SLOT(setText(QString)), Qt::QueuedConnection);
    clockThread.start();
    widget.show();
    app.exec();
    clockThread.quit();
    clockThread.wait();
    return 0;
}
</db:programlisting>
<db:para>We've connected the clockThread with the label. The connection must be a queued signal-slot connection because we want to put the call in the event loop.</db:para>
<db:programlisting language="cpp">// clock/clockthread.h
class ClockThread : public QThread
{
    Q_OBJECT
signals:
    void sendTime(QString time);
private:
    void run();
    QString m_lastTime;
private slots:
    void timerHit();

};
</db:programlisting>
<db:para>We have derived a class from <db:link xlink:href="qthread.xml">QThread</db:link> and declared the sendTime() signal.</db:para>
<db:programlisting language="cpp">// clock/clockthread.cpp
void ClockThread::run()
{
    QTimer timer;
    connect(&amp;timer, SIGNAL(timeout()), this, SLOT(timerHit()), Qt::DirectConnection);
    timer.setInterval(10);
    timer.start();   // puts one event in the threads event queue
    exec();
    timer.stop();
}

void ClockThread::timerHit()
{
    QString newTime= QDateTime::currentDateTime().toString(&quot;ddd MMMM d yy, hh:mm:ss&quot;);
    if(m_lastTime != newTime ){
        m_lastTime = newTime;
        emit sendTime(newTime) ;
    }
}
</db:programlisting>
<db:para>The trickiest part of this example is that the timer is connected to its slot via a direct connection. A default connection would produce a queued signal-slot connection because the connected objects live in different threads; remember that <db:link xlink:href="qthread.xml">QThread</db:link> does not live in the thread it creates.</db:para>
<db:para>Still it is safe to access ClockThread::timerHit() from the worker thread because ClockThread::timerHit() is private and only touches local variables and a private member that isn't touched by public methods. <db:link xlink:href="qdatetime.xml#currentDateTime">QDateTime::currentDateTime</db:link>() isn't marked as thread-safe in Qt documentation, however we can get away with using it in this small example because we know that the <db:link xlink:href="qdatetime.xml#currentDateTime">QDateTime::currentDateTime</db:link>() static method isn't used in any other threads.</db:para>
</db:section>
<db:section xml:id="example-4-a-permanent-thread">
<db:title>Example 4: A Permanent Thread</db:title>
<db:para>This example shows how it is possible to have a <db:link xlink:href="qobject.xml">QObject</db:link> in a worker thread that accepts requests from the GUI thread, does polling using a timer and continuously reports results back to the GUI thread. The actual work including the polling must be implemented in a class derived from <db:link xlink:href="qobject.xml">QObject</db:link>. We have called this class WorkerObject in the code shown below. The thread-specific code is hidden in a class called Thread, derived from <db:link xlink:href="qthread.xml">QThread</db:link>. Thread has two additional public members. The launchWorker() member takes the worker object and moves it to another thread with a started event loop. The call blocks for a very short moment until the thread creation operation is completed, allowing the worker object to be used again on the next line. The Thread class's code is short but somewhat involved, so we only show how to use the class.</db:para>
<db:programlisting language="cpp">// movedobject/main.cpp
int main(int argc, char *argv[])
{
    QCoreApplication app(argc, argv);
    Thread thread;
    qDebug() &lt;&lt; &quot;main thread ID: &quot; &lt;&lt; app.thread()-&gt;currentThreadId();
    WorkerObject *worker = new WorkerObject;
    thread.launchWorker(worker);
    QMetaObject::invokeMethod(worker, &quot;doWork&quot;, Qt::QueuedConnection);
    QMetaObject::invokeMethod(worker, &quot;startPolling&quot;,  Qt::QueuedConnection,  Q_ARG(int, 500));
    //let application produce output for 3 seconds and quit
    QTimer::singleShot(3000, &amp;app, SLOT(quit()));
    app.exec();
    thread.stop();
    thread.wait();
    delete worker;
    return 0;
}
</db:programlisting>
<db:para><db:link xlink:href="qmetaobject.xml#invokeMethod">QMetaObject::invokeMethod</db:link>() calls a slot via the event loop. The worker object's methods should not be called directly after the object has been moved to another thread. We let the worker thread do some work and polling, and use a timer to shut the application down after 3 seconds. Shutting the worker down needs some care. We call Thread::stop() to exit the event loop. We wait for the thread to terminate and, after this has occurred, we delete the worker.</db:para>
</db:section>
</db:section>
<db:section xml:id="digging-deeper">
<db:title>Digging Deeper</db:title>
<db:para>Threading is a very complicated subject. Qt offers more classes for threading than we have presented in this tutorial. The following materials can help you go into the subject in more depth:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para>Good video tutorials about threads with Qt can be found in the material from the <db:link xlink:href="">Training Day at Qt Developer Days 2009</db:link>.</db:para>
</db:listitem>
<db:listitem>
<db:para>The <db:link xlink:href="threads.xml">Thread Support in Qt</db:link> document is a good starting point into the reference documentation.</db:para>
</db:listitem>
<db:listitem>
<db:para>Qt comes with several additional examples for <db:link xlink:href="">QThread and QtConcurrent</db:link>.</db:para>
</db:listitem>
<db:listitem>
<db:para>Several good books describe how to work with Qt threads. The most extensive coverage can be found in <db:emphasis>Advanced Qt Programming</db:emphasis> by Mark Summerfield, Prentice Hall - roughly 70 of 500 pages cover <db:link xlink:href="qthread.xml">QThread</db:link> and <db:link xlink:href="qtconcurrent-module.xml">QtConcurrent</db:link>.</db:para>
</db:listitem>
</db:itemizedlist>
</db:section>
</db:article>
