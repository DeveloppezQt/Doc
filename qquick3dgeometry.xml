<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en">
<db:info>
<db:title>QQuick3DGeometry Class</db:title>
<db:productname>QtQuick3D</db:productname>
<db:edition>Qt Quick 3D | Commercial or GPLv3</db:edition>
<db:titleabbrev>Qt Quick 3D Reference Documentation</db:titleabbrev>
<db:abstract>
<db:para>Base class for defining custom geometry.</db:para>
</db:abstract>
<db:pubdate>2024-02-14</db:pubdate>
<db:date>2024-02-14</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:variablelist>
<db:varlistentry>
<db:term>Header</db:term>
<db:listitem>
<db:para>QQuick3DGeometry</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Inherited By</db:term>
<db:listitem>
<db:para/>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Instantiated By</db:term>
<db:listitem>
<db:para>qml-qtquick3d-geometry.xml</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Inherits</db:term>
<db:listitem>
<db:para><db:link xlink:href="qquick3dobject.xml" xlink:role="class">QQuick3DObject</db:link></db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Inherited By</db:term>
<db:listitem>
<db:para/>
</db:listitem>
</db:varlistentry>
</db:variablelist>
<db:section xml:id="details">
<db:title>Detailed Description</db:title>
<db:para>The <db:link xlink:href="qquick3dgeometry.xml">QQuick3DGeometry</db:link> can be used to specify custom geometry for a Model in the Qt Quick 3D scene.</db:para>
<db:para>While not strictly required, the typical usage is to inherit from this class. The subclass is then exposed to QML by registering it to the type system. The <db:link xlink:href="qml-qtquick3d-model.xml#geometry-prop">geometry</db:link> property of a Model can then be set to reference an instance of the registered type.</db:para>
<db:para>The high-level structure of such a class is typically similar to the following:</db:para>
<db:programlisting language="cpp">class CustomGeometry : public QQuick3DGeometry
{
public:
    CustomGeometry() { rebuildGeometry(); }

    void setSomething() {
       // Change relevant internal data.
       // ...

       // Then rebuild the vertex and index data and pass it to QQuick3DGeometry.
       rebuildGeometry();

       // Finally, trigger an update. This is relevant in case nothing else
       // is changing in the scene; this way we make sure a new frame will
       // be rendered.
       update();
    }

private:
    void rebuildGeometry()
    {
        QByteArray vertices;
        QByteArray indices;
        ...
        setPrimitiveType(Lines);
        setVertexBuffer(vertices);
        setIndexBuffer(indices);
        setStride(3 * sizeof(float)); // e.g. when having 3 components per vertex
        setBounds(...); // minimum and maximum extents, for picking
        addAttribute(PositionSemantic, 0, F32Type);
        ...
    }
};
</db:programlisting>
<db:para>This class can then be registered as a QML type and used with <db:link xlink:href="qml-qtquick3d-model.xml">Model</db:link>.</db:para>
<db:para>In Qt 5 type registration happened with <db:link xlink:href="qqmlengine.xml#qmlRegisterType-1">qmlRegisterType</db:link>:</db:para>
<db:programlisting language="cpp">qmlRegisterType&amp;lt;CustomGeometry&amp;gt;(&quot;Example&quot;, 1, 0, &quot;CustomGeometry&quot;);
</db:programlisting>
<db:para>In Qt 6 the default approach is to use automatic registration with the help of the build system. Instead of calling <db:link xlink:href="qqmlengine.xml#qmlRegisterType-1">qmlRegisterType</db:link>, the <db:code>.pro</db:code> file can now contain:</db:para>
<db:programlisting language="cpp">CONFIG += qmltypes
QML_IMPORT_NAME = Example
QML_IMPORT_MAJOR_VERSION = 1
</db:programlisting>
<db:para>With CMake, automatic registration is the default behavior, so no special settings are needed beyond basic QML module setup:</db:para>
<db:programlisting language="cpp">qt_add_qml_module(application
    URI Example
    VERSION 1.0
)
</db:programlisting>
<db:para>The class implementation should add <db:link xlink:href="qqmlengine.xml#QML_NAMED_ELEMENT">QML_NAMED_ELEMENT</db:link>:</db:para>
<db:programlisting language="cpp">class CustomGeometry : public QQuick3DGeometry
{
    Q_OBJECT
    QML_NAMED_ELEMENT(CustomGeometry)
    ...
};
</db:programlisting>
<db:para>The QML code can then use the custom type:</db:para>
<db:programlisting language="cpp">import Example 1.0

Model {
    id: customModel
    geometry: CustomGeometry {
    }
}
</db:programlisting>
<db:para>At minimum, a custom geometry should have the following specified:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para>vertex data,</db:para>
</db:listitem>
<db:listitem>
<db:para>vertex stride,</db:para>
</db:listitem>
<db:listitem>
<db:para>primitive type,</db:para>
</db:listitem>
<db:listitem>
<db:para>an attribute with PositionSemantic.</db:para>
</db:listitem>
</db:itemizedlist>
<db:para>These are sufficient to render the mesh. For indexed drawing, the index buffer data and an attribute with IndexSemantic needs to be specified as well. In order to support picking (input), the class must specify the bounding volume using <db:link xlink:href="qquick3dgeometry.xml#setBounds">setBounds</db:link>(). For proper lighting, an attribute with NormalSemantic is needed. When the material uses texturing, at least one set of UV coordinates must be provided and described in an TexCoord0Semantic or TexCoord1Semantic attribute. Some materials may require tangents and binormals as well.</db:para>
<db:para>As a concrete, minimal example, the following class would provide geometry for a single triangle:</db:para>
<db:programlisting language="cpp">class ExampleGeometry : public QQuick3DGeometry
{
    Q_OBJECT
    QML_NAMED_ELEMENT(ExampleGeometry)

public:
    ExampleGeometry();

private:
    void updateData();
};

ExampleGeometry::ExampleGeometry()
{
    updateData();
}

void ExampleGeometry::updateData()
{
    QByteArray v;
    v.resize(3 * 3 * sizeof(float));
    float *p = reinterpret_cast&amp;lt;float *&amp;gt;(v.data());

    // a triangle, front face = counter-clockwise
    *p++ = -1.0f; *p++ = -1.0f; *p++ = 0.0f;
    *p++ = 1.0f; *p++ = -1.0f; *p++ = 0.0f;
    *p++ = 0.0f; *p++ = 1.0f; *p++ = 0.0f;

    setVertexData(v);
    setStride(3 * sizeof(float));

    setPrimitiveType(QQuick3DGeometry::PrimitiveType::Triangles);

    addAttribute(QQuick3DGeometry::Attribute::PositionSemantic,
                 0,
                 QQuick3DGeometry::Attribute::F32Type);
}
</db:programlisting>
<db:para>Depending on the lighting in the scene, the result of referencing this geometry from a Model:</db:para>
<db:mediaobject>
<db:imageobject>
<db:imagedata fileref="images/customgeometry.jpg"/>
</db:imageobject>
</db:mediaobject>
<db:note>
<db:para>Vertex data is expected to follow OpenGL conventions. This means the data must be provided with the assumption that the Y axis is pointing up in the normalized device coordinate system, and that front faces have a counter clockwise winding.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qml-qtquick3d-model.xml">Model</db:link></db:member>
<db:member><db:link xlink:href="qml-qtquick3d-geometry.xml">Geometry</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="member-function-documentation">
<db:title>Member Function Documentation</db:title>
<db:section xml:id="addAttribute">
<db:title>void QQuick3DGeometry::addAttribute(Attribute::Semantic <db:emphasis>semantic</db:emphasis>, int <db:emphasis>offset</db:emphasis>, Attribute::ComponentType <db:emphasis>componentType</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>addAttribute</db:methodname>
<db:methodparam>
<db:type>Attribute::Semantic</db:type>
<db:parameter>semantic</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>offset</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>Attribute::ComponentType</db:type>
<db:parameter>componentType</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void addAttribute(Attribute::Semantic semantic, int offset, Attribute::ComponentType componentType)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Adds vertex attribute description. Each attribute has a <db:code role="parameter">semantic</db:code>, which specifies the usage of the attribute and the number of components it has, an <db:code role="parameter">offset</db:code> from the beginning to the vertex to the attribute location inside a vertex and a <db:code role="parameter">componentType</db:code> specifying the datatype and size of the attribute.</db:para>
<db:para>The semantic can be one of the following:</db:para>
<db:informaltable>
<db:thead>
<db:tr>
<db:th>Constant</db:th>
<db:th>Description</db:th>
</db:tr>
</db:thead>
<db:tr>
<db:td>
<db:para>PositionSemantic</db:para>
</db:td>
<db:td>
<db:para>The attribute is a position. 3 components: <db:emphasis>x</db:emphasis>, <db:emphasis>y</db:emphasis>, and <db:emphasis>z</db:emphasis></db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para>NormalSemantic</db:para>
</db:td>
<db:td>
<db:para>The attribute is a normal vector. 3 components: <db:emphasis>x</db:emphasis>, <db:emphasis>y</db:emphasis>, and <db:emphasis>z</db:emphasis></db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para>TexCoord0Semantic</db:para>
</db:td>
<db:td>
<db:para>The attribute is a texture coordinate. 2 components: <db:emphasis>u</db:emphasis> and <db:emphasis>v</db:emphasis></db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para>TexCoord1Semantic</db:para>
</db:td>
<db:td>
<db:para>The attribute is a texture coordinate. 2 components: <db:emphasis>u</db:emphasis> and <db:emphasis>v</db:emphasis></db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para>TangentSemantic</db:para>
</db:td>
<db:td>
<db:para>The attribute is a tangent vector. 3 components: <db:emphasis>x</db:emphasis>, <db:emphasis>y</db:emphasis>, and <db:emphasis>z</db:emphasis></db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para>BinormalSemantic</db:para>
</db:td>
<db:td>
<db:para>The attribute is a binormal vector. 3 components: <db:emphasis>x</db:emphasis>, <db:emphasis>y</db:emphasis>, and <db:emphasis>z</db:emphasis></db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para>JointSemantic</db:para>
</db:td>
<db:td>
<db:para>The attribute is a joint index vector for <db:link xlink:href="quick3d-vertex-skinning.xml">skinning</db:link>. 4 components: joint index 1-4</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para>WeightSemantic</db:para>
</db:td>
<db:td>
<db:para>The attribute is a weight vector for <db:link xlink:href="quick3d-vertex-skinning.xml">skinning</db:link>. 4 components: joint weight 1-4</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para>ColorSemantic</db:para>
</db:td>
<db:td>
<db:para>The attribute is a vertex color vector. 4 components: <db:emphasis>r</db:emphasis>, <db:emphasis>g</db:emphasis>, <db:emphasis>b</db:emphasis>, and <db:emphasis>a</db:emphasis></db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para>TargetPositionSemantic</db:para>
</db:td>
<db:td>
<db:para>The attribute is a position for the first <db:link xlink:href="quick3d-morphing.xml">morph target</db:link>. 3 components: <db:emphasis>x</db:emphasis>, <db:emphasis>y</db:emphasis>, and <db:emphasis>z</db:emphasis></db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para>TargetNormalSemantic</db:para>
</db:td>
<db:td>
<db:para>The attribute is a normal vector for the first <db:link xlink:href="quick3d-morphing.xml">morph target</db:link>. 3 components: <db:emphasis>x</db:emphasis>, <db:emphasis>y</db:emphasis>, and <db:emphasis>z</db:emphasis></db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para>TargetTangentSemantic</db:para>
</db:td>
<db:td>
<db:para>The attribute is a tangent vector for the first <db:link xlink:href="quick3d-morphing.xml">morph target</db:link>. 3 components: <db:emphasis>x</db:emphasis>, <db:emphasis>y</db:emphasis>, and <db:emphasis>z</db:emphasis></db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para>TargetBinormalSemantic</db:para>
</db:td>
<db:td>
<db:para>The attribute is a binormal vector for the first <db:link xlink:href="quick3d-morphing.xml">morph target</db:link>. 3 components: <db:emphasis>x</db:emphasis>, <db:emphasis>y</db:emphasis>, and <db:emphasis>z</db:emphasis></db:para>
</db:td>
</db:tr>
</db:informaltable>
<db:para>In addition, <db:code role="parameter">semantic</db:code> can be <db:code>IndexSemantic</db:code>. In this case the attribute does not represent an entry in the vertex buffer, but rather describes the index data in the index buffer. Since there is always just one index per vertex, <db:code role="parameter">offset</db:code> makes no sense for the index buffer, and should be left at zero.</db:para>
<db:para>The component type can be one of the following:</db:para>
<db:informaltable>
<db:thead>
<db:tr>
<db:th>Constant</db:th>
<db:th>Description</db:th>
</db:tr>
</db:thead>
<db:tr>
<db:td>
<db:para>U16Type</db:para>
</db:td>
<db:td>
<db:para>The index component type is unsigned 16-bit integer. Only supported for <db:code>IndexSemantic</db:code>.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para>U32Type</db:para>
</db:td>
<db:td>
<db:para>The attribute (or index component) is an unsigned 32-bit integer.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para>I32Type</db:para>
</db:td>
<db:td>
<db:para>The attribute is a signed 32-bit integer. Be aware that old OpenGL versions (such as, 2.1 or OpenGL ES 2.0) may not support this data type.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para>F32Type</db:para>
</db:td>
<db:td>
<db:para>The attribute is a single-precision float.</db:para>
</db:td>
</db:tr>
</db:informaltable>
<db:note>
<db:para>The joint index data is typically <db:code>I32Type</db:code>. <db:code>F32Type</db:code> is also supported in order to enable functioning with APIs, such as OpenGL ES 2.0, that do not support integer vertex input attributes.</db:para>
</db:note>
<db:note>
<db:para>For index data (<db:code>IndexSemantic</db:code>) only U16Type and U32Type are sensible and supported.</db:para>
</db:note>
</db:section>
<db:section xml:id="addAttribute-1">
<db:title>void QQuick3DGeometry::addAttribute(const QQuick3DGeometry::Attribute &amp;<db:emphasis>attribute</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>addAttribute</db:methodname>
<db:methodparam>
<db:type>const QQuick3DGeometry::Attribute &amp;</db:type>
<db:parameter>attribute</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">void addAttribute(const QQuick3DGeometry::Attribute &amp;attribute)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>Adds vertex attribute description. Each attribute has a semantic, which specifies the usage of the attribute and the number of components it has, an offset from the beginning to the vertex to the attribute location inside a vertex and a componentType specifying the datatype and size of the attribute.</db:para>
</db:section>
<db:section xml:id="addSubset">
<db:title>void QQuick3DGeometry::addSubset(int <db:emphasis>offset</db:emphasis>, int <db:emphasis>count</db:emphasis>, const QVector3D &amp;<db:emphasis>boundsMin</db:emphasis>, const QVector3D &amp;<db:emphasis>boundsMax</db:emphasis>, const QString &amp;<db:emphasis>name</db:emphasis> = {})</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>addSubset</db:methodname>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>offset</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>count</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const QVector3D &amp;</db:type>
<db:parameter>boundsMin</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const QVector3D &amp;</db:type>
<db:parameter>boundsMax</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const QString &amp;</db:type>
<db:parameter>name</db:parameter>
<db:initializer>{}</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void addSubset(int offset, int count, const QVector3D &amp;boundsMin, const QVector3D &amp;boundsMax, const QString &amp;name)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Adds new subset to the geometry. Subsets allow rendering parts of the geometry with different materials. The materials are specified in the <db:link xlink:href="qml-qtquick3d-model.xml#materials-prop">model</db:link>.</db:para>
<db:para>If the geometry has index buffer, then the <db:code role="parameter">offset</db:code> and <db:code role="parameter">count</db:code> are the primitive offset and count of indices in the subset. If the geometry has only vertex buffer, the offset is the vertex offset and count is the number of vertices in the subset.</db:para>
<db:para>The bounds <db:code role="parameter">boundsMin</db:code> and <db:code role="parameter">boundsMax</db:code> should enclose the subset just like geometry bounds. Also the subset can have a <db:code role="parameter">name</db:code>.</db:para>
</db:section>
<db:section xml:id="attribute">
<db:title>QQuick3DGeometry::Attribute QQuick3DGeometry::attribute(int <db:emphasis>index</db:emphasis>) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QQuick3DGeometry::Attribute</db:type>
<db:methodname>attribute</db:methodname>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>index</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QQuick3DGeometry::Attribute attribute(int index) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns attribute definition number <db:code role="parameter">index</db:code></db:para>
<db:para>The attribute definitions are numbered from 0 to <db:code>attributeCount() - 1</db:code></db:para>
</db:section>
<db:section xml:id="attributeCount">
<db:title>int QQuick3DGeometry::attributeCount() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>int</db:type>
<db:methodname>attributeCount</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">int attributeCount() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the number of attributes defined for this geometry.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qquick3dgeometry.xml#attribute">attribute</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="boundsMax">
<db:title>QVector3D QQuick3DGeometry::boundsMax() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QVector3D</db:type>
<db:methodname>boundsMax</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QVector3D boundsMax() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the maximum coordinate of the bounding volume.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qquick3dgeometry.xml#setBounds">setBounds</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="boundsMin">
<db:title>QVector3D QQuick3DGeometry::boundsMin() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QVector3D</db:type>
<db:methodname>boundsMin</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QVector3D boundsMin() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the minimum coordinate of the bounding volume.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qquick3dgeometry.xml#setBounds">setBounds</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="clear">
<db:title>void QQuick3DGeometry::clear()</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>clear</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void clear()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Resets the geometry to its initial state, clearing previously set vertex and index data as well as attributes.</db:para>
</db:section>
<db:section xml:id="indexData">
<db:title>QByteArray QQuick3DGeometry::indexData() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QByteArray</db:type>
<db:methodname>indexData</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QByteArray indexData() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the index buffer data.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qquick3dgeometry.xml#setIndexData">setIndexData</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="primitiveType">
<db:title>QQuick3DGeometry::PrimitiveType QQuick3DGeometry::primitiveType() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QQuick3DGeometry::PrimitiveType</db:type>
<db:methodname>primitiveType</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QQuick3DGeometry::PrimitiveType primitiveType() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the primitive type used when rendering. The default is <db:code>Triangles</db:code>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qquick3dgeometry.xml#setPrimitiveType">setPrimitiveType</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setBounds">
<db:title>void QQuick3DGeometry::setBounds(const QVector3D &amp;<db:emphasis>min</db:emphasis>, const QVector3D &amp;<db:emphasis>max</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>setBounds</db:methodname>
<db:methodparam>
<db:type>const QVector3D &amp;</db:type>
<db:parameter>min</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const QVector3D &amp;</db:type>
<db:parameter>max</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void setBounds(const QVector3D &amp;min, const QVector3D &amp;max)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Sets the bounding volume of the geometry to the cube defined by the points <db:code role="parameter">min</db:code> and <db:code role="parameter">max</db:code>. This is used for <db:link xlink:href="qml-qtquick3d-view3d.xml#pick-method">picking</db:link>.</db:para>
</db:section>
<db:section xml:id="setIndexData">
<db:title>void QQuick3DGeometry::setIndexData(const QByteArray &amp;<db:emphasis>data</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>setIndexData</db:methodname>
<db:methodparam>
<db:type>const QByteArray &amp;</db:type>
<db:parameter>data</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void setIndexData(const QByteArray &amp;data)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Sets the index buffer to <db:code role="parameter">data</db:code>. To use indexed drawing, add an attribute with <db:code>IndexSemantic</db:code></db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qquick3dgeometry.xml#indexData">indexData</db:link>()</db:member>
<db:member><db:link xlink:href="qquick3dgeometry.xml#addAttribute">addAttribute</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setIndexData-1">
<db:title>void QQuick3DGeometry::setIndexData(int <db:emphasis>offset</db:emphasis>, const QByteArray &amp;<db:emphasis>data</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>setIndexData</db:methodname>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>offset</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const QByteArray &amp;</db:type>
<db:parameter>data</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">void setIndexData(int offset, const QByteArray &amp;data)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>Updates a subset of the index buffer. <db:code role="parameter">offset</db:code> specifies the offset in bytes, <db:code role="parameter">data</db:code> specifies the size and the data.</db:para>
<db:para>This function will not resize the buffer. If <db:code>offset + data.size()</db:code> is greater than the current size of the buffer, the overshooting data will be ignored.</db:para>
<db:note>
<db:para>The partial update functions for vertex and index data do not offer any guarantee on how such changes are implemented internally. Depending on the underlying implementation, even partial changes may lead to updating the entire graphics resource.</db:para>
</db:note>
</db:section>
<db:section xml:id="setPrimitiveType">
<db:title>void QQuick3DGeometry::setPrimitiveType(QQuick3DGeometry::PrimitiveType <db:emphasis>type</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>setPrimitiveType</db:methodname>
<db:methodparam>
<db:type>QQuick3DGeometry::PrimitiveType</db:type>
<db:parameter>type</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void setPrimitiveType(QQuick3DGeometry::PrimitiveType type)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Sets the primitive type used for rendering to <db:code role="parameter">type</db:code>.</db:para>
<db:informaltable>
<db:thead>
<db:tr>
<db:th>Constant</db:th>
<db:th>Description</db:th>
</db:tr>
</db:thead>
<db:tr>
<db:td>
<db:para>Points</db:para>
</db:td>
<db:td>
<db:para>The primitives are points.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para>LineStrip</db:para>
</db:td>
<db:td>
<db:para>The primitives are lines in a strip.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para>Lines</db:para>
</db:td>
<db:td>
<db:para>The primitives are lines in a list.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para>TriangleStrip</db:para>
</db:td>
<db:td>
<db:para>The primitives are triangles in a strip.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para>TriangleFan</db:para>
</db:td>
<db:td>
<db:para>The primitives are triangles in a fan. Be aware that triangle fans may not be supported at run time, depending on the underlying graphics API.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para>Triangles</db:para>
</db:td>
<db:td>
<db:para>The primitives are triangles in a list.</db:para>
</db:td>
</db:tr>
</db:informaltable>
<db:para>The initial value is <db:code>Triangles</db:code>.</db:para>
<db:note>
<db:para>Be aware that triangle fans (TriangleFan) may not be supported at run time, depending on the underlying graphics API. For example, with Direct 3D this topology will not be functional at all.</db:para>
</db:note>
<db:note>
<db:para>The point size for Points and the line width for Lines and LineStrip are controlled by the <db:link xlink:href="qml-qtquick3d-principledmaterial.xml#pointSize-prop">material</db:link>. Be aware however that sizes other than 1 may not be supported at run time, depending on the underlying graphics API.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qquick3dgeometry.xml#primitiveType">primitiveType</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setStride">
<db:title>void QQuick3DGeometry::setStride(int <db:emphasis>stride</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>setStride</db:methodname>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>stride</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void setStride(int stride)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Sets the stride of the vertex buffer to <db:code role="parameter">stride</db:code>, measured in bytes. This is the distance between two consecutive vertices in the buffer.</db:para>
<db:para>For example, a tightly packed, interleaved vertex buffer for a geometry using <db:code>PositionSemantic</db:code>, <db:code>IndexSemantic</db:code>, and <db:code>ColorSemantic</db:code> will have a stride of <db:code>28</db:code> (Seven floats in total: Three for position, four for color, and none for indexes, which do not go in the vertex buffer.)</db:para>
<db:note>
<db:para><db:link xlink:href="qquick3dgeometry.xml">QQuick3DGeometry</db:link> expects, and works only with, vertex data with an interleaved attribute layout.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qquick3dgeometry.xml#stride">stride</db:link>()</db:member>
<db:member><db:link xlink:href="qquick3dgeometry.xml#addAttribute">addAttribute</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setVertexData">
<db:title>void QQuick3DGeometry::setVertexData(const QByteArray &amp;<db:emphasis>data</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>setVertexData</db:methodname>
<db:methodparam>
<db:type>const QByteArray &amp;</db:type>
<db:parameter>data</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void setVertexData(const QByteArray &amp;data)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Sets the vertex buffer <db:code role="parameter">data</db:code>. The buffer should hold all the vertex data packed in the array, as described by the attribute definitions. Note that this does not include attributes with <db:code>IndexSemantic</db:code>, which belong in the index buffer.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qquick3dgeometry.xml#vertexData">vertexData</db:link>()</db:member>
<db:member><db:link xlink:href="qquick3dgeometry.xml#addAttribute">addAttribute</db:link></db:member>
<db:member><db:link xlink:href="qquick3dgeometry.xml#setStride">setStride</db:link></db:member>
<db:member><db:link xlink:href="qquick3dgeometry.xml#setIndexData">setIndexData</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setVertexData-1">
<db:title>void QQuick3DGeometry::setVertexData(int <db:emphasis>offset</db:emphasis>, const QByteArray &amp;<db:emphasis>data</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>setVertexData</db:methodname>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>offset</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const QByteArray &amp;</db:type>
<db:parameter>data</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">void setVertexData(int offset, const QByteArray &amp;data)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>Updates a subset of the vertex buffer. <db:code role="parameter">offset</db:code> specifies the offset in bytes, <db:code role="parameter">data</db:code> specifies the size and the data.</db:para>
<db:para>This function will not resize the buffer. If <db:code>offset + data.size()</db:code> is greater than the current size of the buffer, the overshooting data will be ignored.</db:para>
<db:note>
<db:para>The partial update functions for vertex and index data do not offer any guarantee on how such changes are implemented internally. Depending on the underlying implementation, even partial changes may lead to updating the entire graphics resource.</db:para>
</db:note>
</db:section>
<db:section xml:id="stride">
<db:title>int QQuick3DGeometry::stride() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>int</db:type>
<db:methodname>stride</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">int stride() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the byte stride of the vertex buffer.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qquick3dgeometry.xml#setStride">setStride</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="subsetBoundsMax">
<db:title>QVector3D QQuick3DGeometry::subsetBoundsMax(int <db:emphasis>subset</db:emphasis>) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QVector3D</db:type>
<db:methodname>subsetBoundsMax</db:methodname>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>subset</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QVector3D subsetBoundsMax(int subset) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the number of maximum bounds of a <db:code role="parameter">subset</db:code>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qquick3dgeometry.xml#subsetBoundsMin">subsetBoundsMin</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="subsetBoundsMin">
<db:title>QVector3D QQuick3DGeometry::subsetBoundsMin(int <db:emphasis>subset</db:emphasis>) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QVector3D</db:type>
<db:methodname>subsetBoundsMin</db:methodname>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>subset</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QVector3D subsetBoundsMin(int subset) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the number of minimum bounds of a <db:code role="parameter">subset</db:code>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qquick3dgeometry.xml#subsetBoundsMax">subsetBoundsMax</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="subsetCount">
<db:title>int QQuick3DGeometry::subsetCount() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>int</db:type>
<db:methodname>subsetCount</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">int subsetCount() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the number of subsets.</db:para>
</db:section>
<db:section xml:id="subsetCount-1">
<db:title>int QQuick3DGeometry::subsetCount(int <db:emphasis>subset</db:emphasis>) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>int</db:type>
<db:methodname>subsetCount</db:methodname>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>subset</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">int subsetCount(int subset) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the subset primitive count.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qquick3dgeometry.xml#subsetOffset">subsetOffset</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="subsetName">
<db:title>QString QQuick3DGeometry::subsetName(int <db:emphasis>subset</db:emphasis>) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QString</db:type>
<db:methodname>subsetName</db:methodname>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>subset</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QString subsetName(int subset) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the <db:code role="parameter">subset</db:code> name.</db:para>
</db:section>
<db:section xml:id="subsetOffset">
<db:title>int QQuick3DGeometry::subsetOffset(int <db:emphasis>subset</db:emphasis>) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>int</db:type>
<db:methodname>subsetOffset</db:methodname>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>subset</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">int subsetOffset(int subset) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the <db:code role="parameter">subset</db:code> offset to the vertex or index buffer.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qquick3dgeometry.xml#subsetCount">subsetCount</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="vertexData">
<db:title>QByteArray QQuick3DGeometry::vertexData() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QByteArray</db:type>
<db:methodname>vertexData</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QByteArray vertexData() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the vertex buffer data set by <db:link xlink:href="qquick3dgeometry.xml#setVertexData">setVertexData</db:link>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qquick3dgeometry.xml#setVertexData">setVertexData</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
</db:section>
</db:article>
