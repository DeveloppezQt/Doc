<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en">
<db:info>
<db:title>Part 2 - Adding Addresses</db:title>
<db:productname>QtWidgets</db:productname>
<db:edition>Qt 5.13.2 Reference Documentation</db:edition>
<db:titleabbrev>Qt Widgets Reference Documentation</db:titleabbrev>
<db:abstract>
<db:para>Describes the code for inserting records in the Address Book Example.</db:para>
</db:abstract>
<db:pubdate>2024-12-27</db:pubdate>
<db:date>2024-12-27</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:para>The next step in creating the address book is to implement some user interactions.</db:para>
<db:mediaobject>
<db:imageobject>
<db:imagedata fileref="images/addressbook-tutorial-part2-add-contact.png"/>
</db:imageobject>
</db:mediaobject>
<db:para>We will provide a push button that the user can click to add a new contact. Also, some form of data structure is needed to store these contacts in an organized way.</db:para>
<db:section xml:id="defining-the-addressbook-class">
<db:title>Defining the AddressBook Class</db:title>
<db:para>Now that we have the labels and input fields set up, we add push buttons to complete the process of adding a contact. This means that our <db:code>addressbook.h</db:code> file now has three QPushButton objects declared and three corresponding public slots.</db:para>
<db:programlisting language="cpp">public slots:
    void addContact();
    void submitContact();
    void cancel();
</db:programlisting>
<db:para>A slot is a function that responds to a particular signal. We will discuss this concept in further detail when implementing the <db:code>AddressBook</db:code> class. However, for an overview of Qt's signals and slots concept, you can refer to the <db:link xlink:href="signalsandslots.xml">Signals and Slots</db:link> document.</db:para>
<db:para>Three QPushButton objects (<db:code>addButton</db:code>, <db:code>submitButton</db:code>, and <db:code>cancelButton</db:code>) are now included in our private variable declarations, along with <db:code>nameLine</db:code> and <db:code>addressText</db:code>.</db:para>
<db:programlisting language="cpp">private:
    QPushButton *addButton;
    QPushButton *submitButton;
    QPushButton *cancelButton;
    QLineEdit *nameLine;
    QTextEdit *addressText;
</db:programlisting>
<db:para>We need a container to store our address book contacts, so that we can traverse and display them. A <db:link xlink:href="qmap.xml">QMap</db:link> object, <db:code>contacts</db:code>, is used for this purpose as it holds a key-value pair: the contact's name as the <db:emphasis>key</db:emphasis>, and the contact's address as the <db:emphasis>value</db:emphasis>.</db:para>
<db:programlisting language="cpp">    QMap&amp;lt;QString, QString&amp;gt; contacts;
    QString oldName;
    QString oldAddress;
};
</db:programlisting>
<db:para>We also declare two private QString objects, <db:code>oldName</db:code> and <db:code>oldAddress</db:code>. These objects are needed to hold the name and address of the contact that was last displayed, before the user clicked <db:guilabel>Add</db:guilabel>. So, when the user clicks <db:guilabel>Cancel</db:guilabel>, we can revert to displaying the details of the last contact.</db:para>
</db:section>
<db:section xml:id="implementing-the-addressbook-class">
<db:title>Implementing the AddressBook Class</db:title>
<db:para>Within the constructor of <db:code>AddressBook</db:code>, we set the <db:code>nameLine</db:code> and <db:code>addressText</db:code> to read-only, so that we can only display but not edit existing contact details.</db:para>
<db:programlisting language="cpp">    ...
    nameLine-&amp;gt;setReadOnly(true);
    ...
    addressText-&amp;gt;setReadOnly(true);
</db:programlisting>
<db:para>Then, we instantiate our push buttons: <db:code>addButton</db:code>, <db:code>submitButton</db:code>, and <db:code>cancelButton</db:code>.</db:para>
<db:programlisting language="cpp">    addButton = new QPushButton(tr(&quot;&amp;amp;Add&quot;));
    addButton-&amp;gt;show();
    submitButton = new QPushButton(tr(&quot;&amp;amp;Submit&quot;));
    submitButton-&amp;gt;hide();
    cancelButton = new QPushButton(tr(&quot;&amp;amp;Cancel&quot;));
    cancelButton-&amp;gt;hide();
</db:programlisting>
<db:para>The <db:code>addButton</db:code> is displayed by invoking the <db:link xlink:href="">show()</db:link> function, while the <db:code>submitButton</db:code> and <db:code>cancelButton</db:code> are hidden by invoking <db:link xlink:href="">hide()</db:link>. These two push buttons will only be displayed when the user clicks <db:guilabel>Add</db:guilabel> and this is handled by the <db:code>addContact()</db:code> function discussed below.</db:para>
<db:programlisting language="cpp">    connect(addButton, &amp;amp;QPushButton::clicked,
            this, &amp;amp;AddressBook::addContact);
    connect(submitButton, &amp;amp;QPushButton::clicked,
            this, &amp;amp;AddressBook::submitContact);
    connect(cancelButton, &amp;amp;QPushButton::clicked,
            this, &amp;amp;AddressBook::cancel);
</db:programlisting>
<db:para>We connect the push buttons' <db:link xlink:href="">clicked()</db:link> signal to their respective slots. The figure below illustrates this.</db:para>
<db:mediaobject>
<db:imageobject>
<db:imagedata fileref="images/addressbook-tutorial-part2-signals-and-slots.png"/>
</db:imageobject>
</db:mediaobject>
<db:para>Next, we arrange our push buttons neatly to the right of our address book widget, using a QVBoxLayout to line them up vertically.</db:para>
<db:programlisting language="cpp">    QVBoxLayout *buttonLayout1 = new QVBoxLayout;
    buttonLayout1-&amp;gt;addWidget(addButton, Qt::AlignTop);
    buttonLayout1-&amp;gt;addWidget(submitButton);
    buttonLayout1-&amp;gt;addWidget(cancelButton);
    buttonLayout1-&amp;gt;addStretch();
</db:programlisting>
<db:para>The <db:link xlink:href="">addStretch()</db:link> function is used to ensure the push buttons are not evenly spaced, but arranged closer to the top of the widget. The figure below shows the difference between using <db:link xlink:href="">addStretch()</db:link> and not using it.</db:para>
<db:mediaobject>
<db:imageobject>
<db:imagedata fileref="images/addressbook-tutorial-part2-stretch-effects.png"/>
</db:imageobject>
</db:mediaobject>
<db:para>We then add <db:code>buttonLayout1</db:code> to <db:code>mainLayout</db:code>, using <db:link xlink:href="">addLayout()</db:link>. This gives us nested layouts as <db:code>buttonLayout1</db:code> is now a child of <db:code>mainLayout</db:code>.</db:para>
<db:programlisting language="cpp">    QGridLayout *mainLayout = new QGridLayout;
    mainLayout-&amp;gt;addWidget(nameLabel, 0, 0);
    mainLayout-&amp;gt;addWidget(nameLine, 0, 1);
    mainLayout-&amp;gt;addWidget(addressLabel, 1, 0, Qt::AlignTop);
    mainLayout-&amp;gt;addWidget(addressText, 1, 1);
    mainLayout-&amp;gt;addLayout(buttonLayout1, 1, 2);
</db:programlisting>
<db:para>Our layout coordinates now look like this:</db:para>
<db:mediaobject>
<db:imageobject>
<db:imagedata fileref="images/addressbook-tutorial-part2-labeled-layout.png"/>
</db:imageobject>
</db:mediaobject>
<db:para>In the <db:code>addContact()</db:code> function, we store the last displayed contact details in <db:code>oldName</db:code> and <db:code>oldAddress</db:code>. Then we clear these input fields and turn off the read-only mode. The focus is set on <db:code>nameLine</db:code> and we display <db:code>submitButton</db:code> and <db:code>cancelButton</db:code>.</db:para>
<db:programlisting language="cpp">void AddressBook::addContact()
{
    oldName = nameLine-&amp;gt;text();
    oldAddress = addressText-&amp;gt;toPlainText();

    nameLine-&amp;gt;clear();
    addressText-&amp;gt;clear();

    nameLine-&amp;gt;setReadOnly(false);
    nameLine-&amp;gt;setFocus(Qt::OtherFocusReason);
    addressText-&amp;gt;setReadOnly(false);

    addButton-&amp;gt;setEnabled(false);
    submitButton-&amp;gt;show();
    cancelButton-&amp;gt;show();
}
</db:programlisting>
<db:para>The <db:code>submitContact()</db:code> function can be divided into three parts:</db:para>
<db:orderedlist numeration="arabic">
<db:listitem>
<db:para>We extract the contact's details from <db:code>nameLine</db:code> and <db:code>addressText</db:code> and store them in QString objects. We also validate to make sure that the user did not click <db:guilabel>Submit</db:guilabel> with empty input fields; otherwise, a QMessageBox is displayed to remind the user for a name and address.</db:para>
<db:programlisting language="cpp">void AddressBook::submitContact()
{
    QString name = nameLine-&amp;gt;text();
    QString address = addressText-&amp;gt;toPlainText();

    if (name.isEmpty() || address.isEmpty()) {
        QMessageBox::information(this, tr(&quot;Empty Field&quot;),
            tr(&quot;Please enter a name and address.&quot;));
        return;
    }
</db:programlisting>
</db:listitem>
<db:listitem>
<db:para>We then proceed to check if the contact already exists. If it does not exist, we add the contact to <db:code>contacts</db:code> and we display a QMessageBox to inform the user that the contact has been added.</db:para>
<db:programlisting language="cpp">    if (!contacts.contains(name)) {
        contacts.insert(name, address);
        QMessageBox::information(this, tr(&quot;Add Successful&quot;),
            tr(&quot;\&quot;%1\&quot; has been added to your address book.&quot;).arg(name));
    } else {
        QMessageBox::information(this, tr(&quot;Add Unsuccessful&quot;),
            tr(&quot;Sorry, \&quot;%1\&quot; is already in your address book.&quot;).arg(name));
        return;
    }
</db:programlisting>
<db:para>If the contact already exists, again, we display a QMessageBox to inform the user about this, preventing the user from adding duplicate contacts. Our <db:code>contacts</db:code> object is based on key-value pairs of name and address, hence, we want to ensure that <db:emphasis>key</db:emphasis> is unique.</db:para>
</db:listitem>
<db:listitem>
<db:para>Once we have handled both cases mentioned above, we restore the push buttons to their normal state with the following code:</db:para>
<db:programlisting language="cpp">    if (contacts.isEmpty()) {
        nameLine-&amp;gt;clear();
        addressText-&amp;gt;clear();
    }

    nameLine-&amp;gt;setReadOnly(true);
    addressText-&amp;gt;setReadOnly(true);
    addButton-&amp;gt;setEnabled(true);
    submitButton-&amp;gt;hide();
    cancelButton-&amp;gt;hide();
}
</db:programlisting>
</db:listitem>
</db:orderedlist>
<db:para>The screenshot below shows the QMessageBox object we use to display information messages to the user.</db:para>
<db:mediaobject>
<db:imageobject>
<db:imagedata fileref="images/addressbook-tutorial-part2-add-successful.png"/>
</db:imageobject>
</db:mediaobject>
<db:para>The <db:code>cancel()</db:code> function restores the last displayed contact details and enables <db:code>addButton</db:code>, as well as hides <db:code>submitButton</db:code> and <db:code>cancelButton</db:code>.</db:para>
<db:programlisting language="cpp">void AddressBook::cancel()
{
    nameLine-&amp;gt;setText(oldName);
    nameLine-&amp;gt;setReadOnly(true);

    addressText-&amp;gt;setText(oldAddress);
    addressText-&amp;gt;setReadOnly(true);

    addButton-&amp;gt;setEnabled(true);
    submitButton-&amp;gt;hide();
    cancelButton-&amp;gt;hide();
}
</db:programlisting>
<db:para>The general idea behind adding a contact is to give the user the flexibility to click <db:guilabel>Submit</db:guilabel> or <db:guilabel>Cancel</db:guilabel> at any time. The flowchart below further explains this concept:</db:para>
<db:mediaobject>
<db:imageobject>
<db:imagedata fileref="images/addressbook-tutorial-part2-add-flowchart.png"/>
</db:imageobject>
</db:mediaobject>
</db:section>
<db:section>
<db:title>Example project</db:title>
<db:para><db:link xlink:href="https://code.qt.io/cgit/qt/qtbase.git/tree/examples/widgets/tutorials/addressbook/part2?h=5.13">Example project @ code.qt.io</db:link></db:para>
</db:section>
</db:article>
