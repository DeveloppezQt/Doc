<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en">
<db:info>
<db:title>Part 2 - Adding Addresses</db:title>
<db:productname>QtWidgets</db:productname>
<db:edition>Qt 5.6.3 Reference Documentation</db:edition>
<db:titleabbrev>Qt Widgets Reference Documentation</db:titleabbrev>
<db:abstract>
<db:para>Qt Widgets Reference Documentation.</db:para></db:abstract>
<db:pubdate>2025-06-29</db:pubdate>
<db:date>2025-06-29</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:para>The next step in creating the address book is to implement some user interactions.</db:para>
<db:mediaobject>
<db:imageobject>
<db:imagedata fileref="images/addressbook-tutorial-part2-add-contact.png"/>
</db:imageobject>
</db:mediaobject>
<db:para>We will provide a push button that the user can click to add a new contact. Also, some form of data structure is needed to store these contacts in an organized way.</db:para>
<db:section xml:id="defining-the-addressbook-class">
<db:title>Defining the AddressBook Class</db:title>
<db:para>Now that we have the labels and input fields set up, we add push buttons to complete the process of adding a contact. This means that our addressbook.h file now has three <db:link xlink:href="qpushbutton.xml">QPushButton</db:link> objects declared and three corresponding public slots.</db:para>
<db:programlisting language="cpp">public slots:
    void addContact();
    void submitContact();
    void cancel();
</db:programlisting>
<db:para>A slot is a function that responds to a particular signal. We will discuss this concept in further detail when implementing the AddressBook class. However, for an overview of Qt's signals and slots concept, you can refer to the <db:link xlink:href="signalsandslots.xml">Signals and Slots</db:link> document.</db:para>
<db:para>Three <db:link xlink:href="qpushbutton.xml">QPushButton</db:link> objects (addButton, submitButton, and cancelButton) are now included in our private variable declarations, along with nameLine and addressText.</db:para>
<db:programlisting language="cpp">private:
    QPushButton *addButton;
    QPushButton *submitButton;
    QPushButton *cancelButton;
    QLineEdit *nameLine;
    QTextEdit *addressText;
</db:programlisting>
<db:para>We need a container to store our address book contacts, so that we can traverse and display them. A <db:link xlink:href="qmap.xml">QMap</db:link> object, contacts, is used for this purpose as it holds a key-value pair: the contact's name as the <db:emphasis>key</db:emphasis>, and the contact's address as the <db:emphasis>value</db:emphasis>.</db:para>
<db:programlisting language="cpp">    QMap&lt;QString, QString&gt; contacts;
    QString oldName;
    QString oldAddress;
};
</db:programlisting>
<db:para>We also declare two private <db:link xlink:href="qstring.xml">QString</db:link> objects, oldName and oldAddress. These objects are needed to hold the name and address of the contact that was last displayed, before the user clicked <db:guilabel>Add</db:guilabel>. So, when the user clicks <db:guilabel>Cancel</db:guilabel>, we can revert to displaying the details of the last contact.</db:para>
</db:section>
<db:section xml:id="implementing-the-addressbook-class">
<db:title>Implementing the AddressBook Class</db:title>
<db:para>Within the constructor of AddressBook, we set the nameLine and addressText to read-only, so that we can only display but not edit existing contact details.</db:para>
<db:programlisting language="cpp">    ...
    nameLine-&gt;setReadOnly(true);
    ...
    addressText-&gt;setReadOnly(true);
</db:programlisting>
<db:para>Then, we instantiate our push buttons: addButton, submitButton, and cancelButton.</db:para>
<db:programlisting language="cpp">    addButton = new QPushButton(tr(&quot;&amp;Add&quot;));
    addButton-&gt;show();
    submitButton = new QPushButton(tr(&quot;&amp;Submit&quot;));
    submitButton-&gt;hide();
    cancelButton = new QPushButton(tr(&quot;&amp;Cancel&quot;));
    cancelButton-&gt;hide();
</db:programlisting>
<db:para>The addButton is displayed by invoking the <db:link xlink:href="qwidget.xml#show">show</db:link>() function, while the submitButton and cancelButton are hidden by invoking <db:link xlink:href="qwidget.xml#hide">hide</db:link>(). These two push buttons will only be displayed when the user clicks <db:guilabel>Add</db:guilabel> and this is handled by the addContact() function discussed below.</db:para>
<db:programlisting language="cpp">    connect(addButton, SIGNAL(clicked()), this, SLOT(addContact()));
    connect(submitButton, SIGNAL(clicked()), this, SLOT(submitContact()));
    connect(cancelButton, SIGNAL(clicked()), this, SLOT(cancel()));
</db:programlisting>
<db:para>We connect the push buttons' <db:link xlink:href="qabstractbutton.xml#clicked">clicked</db:link>() signal to their respective slots. The figure below illustrates this.</db:para>
<db:mediaobject>
<db:imageobject>
<db:imagedata fileref="images/addressbook-tutorial-part2-signals-and-slots.png"/>
</db:imageobject>
</db:mediaobject>
<db:para>Next, we arrange our push buttons neatly to the right of our address book widget, using a <db:link xlink:href="qvboxlayout.xml">QVBoxLayout</db:link> to line them up vertically.</db:para>
<db:programlisting language="cpp">    QVBoxLayout *buttonLayout1 = new QVBoxLayout;
    buttonLayout1-&gt;addWidget(addButton, Qt::AlignTop);
    buttonLayout1-&gt;addWidget(submitButton);
    buttonLayout1-&gt;addWidget(cancelButton);
    buttonLayout1-&gt;addStretch();
</db:programlisting>
<db:para>The <db:link xlink:href="qboxlayout.xml#addStretch">addStretch</db:link>() function is used to ensure the push buttons are not evenly spaced, but arranged closer to the top of the widget. The figure below shows the difference between using <db:link xlink:href="qboxlayout.xml#addStretch">addStretch</db:link>() and not using it.</db:para>
<db:mediaobject>
<db:imageobject>
<db:imagedata fileref="images/addressbook-tutorial-part2-stretch-effects.png"/>
</db:imageobject>
</db:mediaobject>
<db:para>We then add buttonLayout1 to mainLayout, using <db:link xlink:href="qgridlayout.xml#addLayout">addLayout</db:link>(). This gives us nested layouts as buttonLayout1 is now a child of mainLayout.</db:para>
<db:programlisting language="cpp">    QGridLayout *mainLayout = new QGridLayout;
    mainLayout-&gt;addWidget(nameLabel, 0, 0);
    mainLayout-&gt;addWidget(nameLine, 0, 1);
    mainLayout-&gt;addWidget(addressLabel, 1, 0, Qt::AlignTop);
    mainLayout-&gt;addWidget(addressText, 1, 1);
    mainLayout-&gt;addLayout(buttonLayout1, 1, 2);
</db:programlisting>
<db:para>Our layout coordinates now look like this:</db:para>
<db:mediaobject>
<db:imageobject>
<db:imagedata fileref="images/addressbook-tutorial-part2-labeled-layout.png"/>
</db:imageobject>
</db:mediaobject>
<db:para>In the addContact() function, we store the last displayed contact details in oldName and oldAddress. Then we clear these input fields and turn off the read-only mode. The focus is set on nameLine and we display submitButton and cancelButton.</db:para>
<db:programlisting language="cpp">void AddressBook::addContact()
{
    oldName = nameLine-&gt;text();
    oldAddress = addressText-&gt;toPlainText();

    nameLine-&gt;clear();
    addressText-&gt;clear();

    nameLine-&gt;setReadOnly(false);
    nameLine-&gt;setFocus(Qt::OtherFocusReason);
    addressText-&gt;setReadOnly(false);

    addButton-&gt;setEnabled(false);
    submitButton-&gt;show();
    cancelButton-&gt;show();
}
</db:programlisting>
<db:para>The submitContact() function can be divided into three parts:</db:para>
<db:orderedlist numeration="arabic">
<db:listitem>
<db:para>We extract the contact's details from nameLine and addressText and store them in <db:link xlink:href="qstring.xml">QString</db:link> objects. We also validate to make sure that the user did not click <db:guilabel>Submit</db:guilabel> with empty input fields; otherwise, a <db:link xlink:href="qmessagebox.xml">QMessageBox</db:link> is displayed to remind the user for a name and address.</db:para>
<db:programlisting language="cpp">void AddressBook::submitContact()
{
    QString name = nameLine-&gt;text();
    QString address = addressText-&gt;toPlainText();

    if (name.isEmpty() || address.isEmpty()) {
        QMessageBox::information(this, tr(&quot;Empty Field&quot;),
            tr(&quot;Please enter a name and address.&quot;));
        return;
    }
</db:programlisting>
</db:listitem>
<db:listitem>
<db:para>We then proceed to check if the contact already exists. If it does not exist, we add the contact to contacts and we display a <db:link xlink:href="qmessagebox.xml">QMessageBox</db:link> to inform the user that the contact has been added.</db:para>
<db:programlisting language="cpp">    if (!contacts.contains(name)) {
        contacts.insert(name, address);
        QMessageBox::information(this, tr(&quot;Add Successful&quot;),
            tr(&quot;\&quot;%1\&quot; has been added to your address book.&quot;).arg(name));
    } else {
        QMessageBox::information(this, tr(&quot;Add Unsuccessful&quot;),
            tr(&quot;Sorry, \&quot;%1\&quot; is already in your address book.&quot;).arg(name));
        return;
    }
</db:programlisting>
<db:para>If the contact already exists, again, we display a <db:link xlink:href="qmessagebox.xml">QMessageBox</db:link> to inform the user about this, preventing the user from adding duplicate contacts. Our contacts object is based on key-value pairs of name and address, hence, we want to ensure that <db:emphasis>key</db:emphasis> is unique.</db:para>
</db:listitem>
<db:listitem>
<db:para>Once we have handled both cases mentioned above, we restore the push buttons to their normal state with the following code:</db:para>
<db:programlisting language="cpp">    if (contacts.isEmpty()) {
        nameLine-&gt;clear();
        addressText-&gt;clear();
    }

    nameLine-&gt;setReadOnly(true);
    addressText-&gt;setReadOnly(true);
    addButton-&gt;setEnabled(true);
    submitButton-&gt;hide();
    cancelButton-&gt;hide();
}
</db:programlisting>
</db:listitem>
</db:orderedlist>
<db:para>The screenshot below shows the <db:link xlink:href="qmessagebox.xml">QMessageBox</db:link> object we use to display information messages to the user.</db:para>
<db:mediaobject>
<db:imageobject>
<db:imagedata fileref="images/addressbook-tutorial-part2-add-successful.png"/>
</db:imageobject>
</db:mediaobject>
<db:para>The cancel() function restores the last displayed contact details and enables addButton, as well as hides submitButton and cancelButton.</db:para>
<db:programlisting language="cpp">void AddressBook::cancel()
{
    nameLine-&gt;setText(oldName);
    nameLine-&gt;setReadOnly(true);

    addressText-&gt;setText(oldAddress);
    addressText-&gt;setReadOnly(true);

    addButton-&gt;setEnabled(true);
    submitButton-&gt;hide();
    cancelButton-&gt;hide();
}
</db:programlisting>
<db:para>The general idea behind adding a contact is to give the user the flexibility to click <db:guilabel>Submit</db:guilabel> or <db:guilabel>Cancel</db:guilabel> at any time. The flowchart below further explains this concept:</db:para>
<db:mediaobject>
<db:imageobject>
<db:imagedata fileref="images/addressbook-tutorial-part2-add-flowchart.png"/>
</db:imageobject>
</db:mediaobject>
</db:section>
<db:section>
<db:title>List of Files</db:title>
<db:para>Files:</db:para>
<db:section>
<db:title>List of Files</db:title>
<db:itemizedlist>
<db:listitem>
<db:para><db:link xlink:href="tutorials/addressbook/part2/addressbook.cpp">tutorials/addressbook/part2/addressbook.cpp</db:link></db:para></db:listitem>
<db:listitem>
<db:para><db:link xlink:href="tutorials/addressbook/part2/addressbook.h">tutorials/addressbook/part2/addressbook.h</db:link></db:para></db:listitem>
<db:listitem>
<db:para><db:link xlink:href="tutorials/addressbook/part2/main.cpp">tutorials/addressbook/part2/main.cpp</db:link></db:para></db:listitem>
<db:listitem>
<db:para><db:link xlink:href="tutorials/addressbook/part2/part2.pro">tutorials/addressbook/part2/part2.pro</db:link></db:para></db:listitem>
</db:itemizedlist>
</db:section>
</db:section></db:article>
