<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en">
<db:info>
<db:title>Scatter Example</db:title>
<db:productname>QtDataVisualization</db:productname>
<db:edition>Qt 5.7.1 Reference Documentation</db:edition>
<db:titleabbrev>Qt Data Visualization Reference Documentation</db:titleabbrev>
<db:abstract>
<db:para>Using Q3DScatter in a widget application.</db:para>
</db:abstract>
<db:pubdate>2025-06-29</db:pubdate>
<db:date>2025-06-29</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:para>The scatter example shows how to make a simple 3D scatter graph using Q3DScatter and combining the use of widgets for adjusting several adjustable qualities. The example shows how to:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para>Create an application with Q3DScatter and some widgets</db:para>
</db:listitem>
<db:listitem>
<db:para>Use QScatterDataProxy to set data to the graph</db:para>
</db:listitem>
<db:listitem>
<db:para>Adjust some graph properties using widget controls</db:para>
</db:listitem>
</db:itemizedlist>
<db:para>For instructions about how to interact with the graph, see <db:link xlink:href="qtdatavisualization-interacting-with-data.xml">this page</db:link>.</db:para>
<db:mediaobject>
<db:imageobject>
<db:imagedata fileref="images/scatter-example.png"/>
</db:imageobject>
</db:mediaobject>
<db:section xml:id="creating-the-application">
<db:title>Creating the application</db:title>
<db:para>First, in main.cpp, we create a <db:link xlink:href="qapplication.xml">QApplication</db:link>, instantiate Q3DScatter, and a window container for it:</db:para>
<db:programlisting language="cpp">QApplication app(argc, argv);
Q3DScatter *graph = new Q3DScatter();
QWidget *container = QWidget::createWindowContainer(graph);
</db:programlisting>
<db:para>The call to <db:link xlink:href="qwidget.xml#createWindowContainer">QWidget::createWindowContainer</db:link> is required, as all data visualization graph classes (Q3DBars, Q3DScatter, and Q3DSurface) inherit <db:link xlink:href="qwindow.xml">QWindow</db:link>. Any class inheriting <db:link xlink:href="qwindow.xml">QWindow</db:link> cannot be used as a widget any other way.</db:para>
<db:para>Then we'll create horizontal and vertical layouts. We'll add the graph and the vertical layout into the horizontal one:</db:para>
<db:programlisting language="cpp">QWidget *widget = new QWidget;
QHBoxLayout *hLayout = new QHBoxLayout(widget);
QVBoxLayout *vLayout = new QVBoxLayout();
hLayout-&gt;addWidget(container, 1);
hLayout-&gt;addLayout(vLayout);
</db:programlisting>
<db:para>We're not using the vertical layout for anything yet, but we'll get back to it in <db:link xlink:href="qtdatavisualization-scatter-example.xml#using-widgets-to-control-the-graph">Using widgets to control the graph</db:link></db:para>
<db:para>Next, let's create another class to handle the data addition and other interaction with the graph. Let's call it <db:code>ScatterDataModifier</db:code> (See <db:link xlink:href="qtdatavisualization-scatter-example.xml#setting-up-the-graph">Setting up the graph</db:link> and <db:link xlink:href="qtdatavisualization-scatter-example.xml#adding-data-to-the-graph">Adding data to the graph</db:link> for details):</db:para>
<db:programlisting language="cpp">ScatterDataModifier *modifier = new ScatterDataModifier(graph);
</db:programlisting>
<db:para>The application main is done. We can show the graph and start the event loop:</db:para>
<db:programlisting language="cpp">widget-&gt;show();
return app.exec();
</db:programlisting>
</db:section>
<db:section xml:id="setting-up-the-graph">
<db:title>Setting up the graph</db:title>
<db:para>Let's set up some visual qualities for the graph in the constructor of the <db:code>ScatterDataModifier</db:code> class we instantiated in the application main:</db:para>
<db:programlisting language="cpp">m_graph-&gt;activeTheme()-&gt;setType(Q3DTheme::ThemeEbony);
QFont font = m_graph-&gt;activeTheme()-&gt;font();
font.setPointSize(m_fontSize);
m_graph-&gt;activeTheme()-&gt;setFont(font);
m_graph-&gt;setShadowQuality(QAbstract3DGraph::ShadowQualitySoftLow);
m_graph-&gt;scene()-&gt;activeCamera()-&gt;setCameraPreset(Q3DCamera::CameraPresetFront);
</db:programlisting>
<db:para>None of these are required, but are used to override graph defaults. You can try how it looks with the preset defaults by commenting the block above out.</db:para>
<db:para>Finally we create a QScatterDataProxy and the associated QScatter3DSeries. We set custom label format and mesh smoothing for the series and add it to the graph:</db:para>
<db:programlisting language="cpp">QScatterDataProxy *proxy = new QScatterDataProxy;
QScatter3DSeries *series = new QScatter3DSeries(proxy);
series-&gt;setItemLabelFormat(QStringLiteral(&quot;@xTitle: @xLabel @yTitle: @yLabel @zTitle: @zLabel&quot;));
series-&gt;setMeshSmooth(m_smooth);
m_graph-&gt;addSeries(series);
</db:programlisting>
<db:para>That concludes setting up the graph.</db:para>
</db:section>
<db:section xml:id="adding-data-to-the-graph">
<db:title>Adding data to the graph</db:title>
<db:para>The last thing we do in the <db:code>ScatterDataModifier</db:code> constructor is to add data to the graph:</db:para>
<db:programlisting language="cpp">addData();
</db:programlisting>
<db:para>The actual data addition is done in <db:code>addData()</db:code> method. First we configure the axes:</db:para>
<db:programlisting language="cpp">m_graph-&gt;axisX()-&gt;setTitle(&quot;X&quot;);
m_graph-&gt;axisY()-&gt;setTitle(&quot;Y&quot;);
m_graph-&gt;axisZ()-&gt;setTitle(&quot;Z&quot;);
</db:programlisting>
<db:para>This could have been done in the constructor of <db:code>ScatterDataModifier</db:code>, but we added it here to keep the constructor simpler and the axes configuration near the data.</db:para>
<db:para>Next we create a data array:</db:para>
<db:programlisting language="cpp">QScatterDataArray *dataArray = new QScatterDataArray;
dataArray-&gt;resize(m_itemCount);
QScatterDataItem *ptrToDataArray = &amp;dataArray-&gt;first();
</db:programlisting>
<db:para>and populate it:</db:para>
<db:programlisting language="cpp">float limit = qSqrt(m_itemCount) / 2.0f;
for (float i = -limit; i &lt; limit; i++) {
    for (float j = -limit; j &lt; limit; j++) {
        ptrToDataArray-&gt;setPosition(QVector3D(i + 0.5f,
                                              qCos(qDegreesToRadians((i * j) / m_curveDivider)),
                                              j + 0.5f));
        ptrToDataArray++;
    }
}
</db:programlisting>
<db:para>Finally we tell the proxy to start using the data we gave it:</db:para>
<db:programlisting language="cpp">m_graph-&gt;seriesList().at(0)-&gt;dataProxy()-&gt;resetArray(dataArray);
</db:programlisting>
<db:para>Now our graph has the data and is ready to be used. There isn't much interaction yet, though, so let's continue by adding some widgets to play with.</db:para>
</db:section>
<db:section xml:id="using-widgets-to-control-the-graph">
<db:title>Using widgets to control the graph</db:title>
<db:para>First, back in the application main, we'll create some widgets:</db:para>
<db:programlisting language="cpp">QComboBox *themeList = new QComboBox(widget);
themeList-&gt;addItem(QStringLiteral(&quot;Qt&quot;));
themeList-&gt;addItem(QStringLiteral(&quot;Primary Colors&quot;));
themeList-&gt;addItem(QStringLiteral(&quot;Digia&quot;));
themeList-&gt;addItem(QStringLiteral(&quot;Stone Moss&quot;));
themeList-&gt;addItem(QStringLiteral(&quot;Army Blue&quot;));
themeList-&gt;addItem(QStringLiteral(&quot;Retro&quot;));
themeList-&gt;addItem(QStringLiteral(&quot;Ebony&quot;));
themeList-&gt;addItem(QStringLiteral(&quot;Isabelle&quot;));
themeList-&gt;setCurrentIndex(6);

QPushButton *labelButton = new QPushButton(widget);
labelButton-&gt;setText(QStringLiteral(&quot;Change label style&quot;));

QCheckBox *smoothCheckBox = new QCheckBox(widget);
smoothCheckBox-&gt;setText(QStringLiteral(&quot;Smooth dots&quot;));
smoothCheckBox-&gt;setChecked(true);

QComboBox *itemStyleList = new QComboBox(widget);
itemStyleList-&gt;addItem(QStringLiteral(&quot;Sphere&quot;), int(QAbstract3DSeries::MeshSphere));
itemStyleList-&gt;addItem(QStringLiteral(&quot;Cube&quot;), int(QAbstract3DSeries::MeshCube));
itemStyleList-&gt;addItem(QStringLiteral(&quot;Minimal&quot;), int(QAbstract3DSeries::MeshMinimal));
itemStyleList-&gt;addItem(QStringLiteral(&quot;Point&quot;), int(QAbstract3DSeries::MeshPoint));
itemStyleList-&gt;setCurrentIndex(0);

QPushButton *cameraButton = new QPushButton(widget);
cameraButton-&gt;setText(QStringLiteral(&quot;Change camera preset&quot;));

QPushButton *itemCountButton = new QPushButton(widget);
itemCountButton-&gt;setText(QStringLiteral(&quot;Toggle item count&quot;));

QCheckBox *backgroundCheckBox = new QCheckBox(widget);
backgroundCheckBox-&gt;setText(QStringLiteral(&quot;Show background&quot;));
backgroundCheckBox-&gt;setChecked(true);

QCheckBox *gridCheckBox = new QCheckBox(widget);
gridCheckBox-&gt;setText(QStringLiteral(&quot;Show grid&quot;));
gridCheckBox-&gt;setChecked(true);

QComboBox *shadowQuality = new QComboBox(widget);
shadowQuality-&gt;addItem(QStringLiteral(&quot;None&quot;));
shadowQuality-&gt;addItem(QStringLiteral(&quot;Low&quot;));
shadowQuality-&gt;addItem(QStringLiteral(&quot;Medium&quot;));
shadowQuality-&gt;addItem(QStringLiteral(&quot;High&quot;));
shadowQuality-&gt;addItem(QStringLiteral(&quot;Low Soft&quot;));
shadowQuality-&gt;addItem(QStringLiteral(&quot;Medium Soft&quot;));
shadowQuality-&gt;addItem(QStringLiteral(&quot;High Soft&quot;));
shadowQuality-&gt;setCurrentIndex(4);

QFontComboBox *fontList = new QFontComboBox(widget);
fontList-&gt;setCurrentFont(QFont(&quot;Arial&quot;));
</db:programlisting>
<db:para>And add them to the vertical layout we created earlier:</db:para>
<db:programlisting language="cpp">vLayout-&gt;addWidget(labelButton, 0, Qt::AlignTop);
vLayout-&gt;addWidget(cameraButton, 0, Qt::AlignTop);
vLayout-&gt;addWidget(itemCountButton, 0, Qt::AlignTop);
vLayout-&gt;addWidget(backgroundCheckBox);
vLayout-&gt;addWidget(gridCheckBox);
vLayout-&gt;addWidget(smoothCheckBox, 0, Qt::AlignTop);
vLayout-&gt;addWidget(new QLabel(QStringLiteral(&quot;Change dot style&quot;)));
vLayout-&gt;addWidget(itemStyleList);
vLayout-&gt;addWidget(new QLabel(QStringLiteral(&quot;Change theme&quot;)));
vLayout-&gt;addWidget(themeList);
vLayout-&gt;addWidget(new QLabel(QStringLiteral(&quot;Adjust shadow quality&quot;)));
vLayout-&gt;addWidget(shadowQuality);
vLayout-&gt;addWidget(new QLabel(QStringLiteral(&quot;Change font&quot;)));
vLayout-&gt;addWidget(fontList, 1, Qt::AlignTop);
</db:programlisting>
<db:para>Now, let's connect them to methods in ScatterDataModifier:</db:para>
<db:programlisting language="cpp">QObject::connect(cameraButton, &amp;QPushButton::clicked, modifier,
                 &amp;ScatterDataModifier::changePresetCamera);
QObject::connect(labelButton, &amp;QPushButton::clicked, modifier,
                 &amp;ScatterDataModifier::changeLabelStyle);
QObject::connect(itemCountButton, &amp;QPushButton::clicked, modifier,
                 &amp;ScatterDataModifier::toggleItemCount);

QObject::connect(backgroundCheckBox, &amp;QCheckBox::stateChanged, modifier,
                 &amp;ScatterDataModifier::setBackgroundEnabled);
QObject::connect(gridCheckBox, &amp;QCheckBox::stateChanged, modifier,
                 &amp;ScatterDataModifier::setGridEnabled);
QObject::connect(smoothCheckBox, &amp;QCheckBox::stateChanged, modifier,
                 &amp;ScatterDataModifier::setSmoothDots);

QObject::connect(modifier, &amp;ScatterDataModifier::backgroundEnabledChanged,
                 backgroundCheckBox, &amp;QCheckBox::setChecked);
QObject::connect(modifier, &amp;ScatterDataModifier::gridEnabledChanged,
                 gridCheckBox, &amp;QCheckBox::setChecked);
QObject::connect(itemStyleList, SIGNAL(currentIndexChanged(int)), modifier,
                 SLOT(changeStyle(int)));

QObject::connect(themeList, SIGNAL(currentIndexChanged(int)), modifier,
                 SLOT(changeTheme(int)));

QObject::connect(shadowQuality, SIGNAL(currentIndexChanged(int)), modifier,
                 SLOT(changeShadowQuality(int)));

QObject::connect(modifier, &amp;ScatterDataModifier::shadowQualityChanged, shadowQuality,
                 &amp;QComboBox::setCurrentIndex);
QObject::connect(graph, &amp;Q3DScatter::shadowQualityChanged, modifier,
                 &amp;ScatterDataModifier::shadowQualityUpdatedByVisual);

QObject::connect(fontList, &amp;QFontComboBox::currentFontChanged, modifier,
                 &amp;ScatterDataModifier::changeFont);

QObject::connect(modifier, &amp;ScatterDataModifier::fontChanged, fontList,
                 &amp;QFontComboBox::setCurrentFont);
</db:programlisting>
<db:para>Here are the methods in ScatterDataModifier the signals were connected to:</db:para>
<db:programlisting language="cpp">void ScatterDataModifier::changeStyle(int style)
{
    QComboBox *comboBox = qobject_cast&lt;QComboBox *&gt;(sender());
    if (comboBox) {
        m_style = QAbstract3DSeries::Mesh(comboBox-&gt;itemData(style).toInt());
        if (m_graph-&gt;seriesList().size())
            m_graph-&gt;seriesList().at(0)-&gt;setMesh(m_style);
    }
}

void ScatterDataModifier::setSmoothDots(int smooth)
{
    m_smooth = bool(smooth);
    QScatter3DSeries *series = m_graph-&gt;seriesList().at(0);
    series-&gt;setMeshSmooth(m_smooth);
}

void ScatterDataModifier::changeTheme(int theme)
{
    Q3DTheme *currentTheme = m_graph-&gt;activeTheme();
    currentTheme-&gt;setType(Q3DTheme::Theme(theme));
    emit backgroundEnabledChanged(currentTheme-&gt;isBackgroundEnabled());
    emit gridEnabledChanged(currentTheme-&gt;isGridEnabled());
    emit fontChanged(currentTheme-&gt;font());
}

void ScatterDataModifier::changePresetCamera()
{
    static int preset = Q3DCamera::CameraPresetFrontLow;

    m_graph-&gt;scene()-&gt;activeCamera()-&gt;setCameraPreset((Q3DCamera::CameraPreset)preset);

    if (++preset &gt; Q3DCamera::CameraPresetDirectlyBelow)
        preset = Q3DCamera::CameraPresetFrontLow;
}

void ScatterDataModifier::changeLabelStyle()
{
    m_graph-&gt;activeTheme()-&gt;setLabelBackgroundEnabled(!m_graph-&gt;activeTheme()-&gt;isLabelBackgroundEnabled());
}

void ScatterDataModifier::changeFont(const QFont &amp;font)
{
    QFont newFont = font;
    newFont.setPointSizeF(m_fontSize);
    m_graph-&gt;activeTheme()-&gt;setFont(newFont);
}

void ScatterDataModifier::shadowQualityUpdatedByVisual(QAbstract3DGraph::ShadowQuality sq)
{
    int quality = int(sq);
    emit shadowQualityChanged(quality); // connected to a checkbox in main.cpp
}

void ScatterDataModifier::changeShadowQuality(int quality)
{
    QAbstract3DGraph::ShadowQuality sq = QAbstract3DGraph::ShadowQuality(quality);
    m_graph-&gt;setShadowQuality(sq);
}

void ScatterDataModifier::setBackgroundEnabled(int enabled)
{
    m_graph-&gt;activeTheme()-&gt;setBackgroundEnabled((bool)enabled);
}

void ScatterDataModifier::setGridEnabled(int enabled)
{
    m_graph-&gt;activeTheme()-&gt;setGridEnabled((bool)enabled);
}
</db:programlisting>
<db:para>And so we have an application in which we can control:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para>Label style</db:para>
</db:listitem>
<db:listitem>
<db:para>Camera preset</db:para>
</db:listitem>
<db:listitem>
<db:para>Background visibility</db:para>
</db:listitem>
<db:listitem>
<db:para>Grid visibility</db:para>
</db:listitem>
<db:listitem>
<db:para>Dot shading smoothness</db:para>
</db:listitem>
<db:listitem>
<db:para>Dot style</db:para>
</db:listitem>
<db:listitem>
<db:para>Theme</db:para>
</db:listitem>
<db:listitem>
<db:para>Shadow quality</db:para>
</db:listitem>
<db:listitem>
<db:para>Label font</db:para>
</db:listitem>
</db:itemizedlist>
</db:section>
<db:section xml:id="example-contents">
<db:title>Example contents</db:title>
<db:section>
<db:title>List of Files</db:title>
<db:para>Files:</db:para>
<db:section>
<db:title>List of Files</db:title>
<db:itemizedlist>
<db:listitem>
<db:para><db:link xlink:href="scatter/main.cpp">scatter/main.cpp</db:link></db:para></db:listitem>
<db:listitem>
<db:para><db:link xlink:href="scatter/scatter.pro">scatter/scatter.pro</db:link></db:para></db:listitem>
<db:listitem>
<db:para><db:link xlink:href="scatter/scatterdatamodifier.cpp">scatter/scatterdatamodifier.cpp</db:link></db:para></db:listitem>
<db:listitem>
<db:para><db:link xlink:href="scatter/scatterdatamodifier.h">scatter/scatterdatamodifier.h</db:link></db:para></db:listitem>
</db:itemizedlist>
</db:section>
</db:section>
</db:section></db:article>
