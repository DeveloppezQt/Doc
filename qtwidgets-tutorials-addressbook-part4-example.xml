<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en">
<db:info>
<db:title>Part 4 - Editing and Removing Addresses</db:title>
<db:productname>QtWidgets</db:productname>
<db:edition>Qt 5.12.12 Reference Documentation</db:edition>
<db:titleabbrev>Qt Widgets Reference Documentation</db:titleabbrev>
<db:abstract>
<db:para>Explains how to add edit and remove functionality.</db:para>
</db:abstract>
<db:pubdate>2024-12-27</db:pubdate>
<db:date>2024-12-27</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:para>Now we look at ways to modify the contents of contacts stored in the address book.</db:para>
<db:mediaobject>
<db:imageobject>
<db:imagedata fileref="images/addressbook-tutorial-screenshot.png"/>
</db:imageobject>
</db:mediaobject>
<db:para>We now have an address book that not only holds contacts in an organized manner, but also allows navigation. It would be convenient to include edit and remove functions so that a contact's details can be changed when needed. However, this requires a little improvement, in the form of enums. We defined two modes: AddingMode and NavigationMode, but they were not defined as enum values. Instead, we enabled and disabled the corresponding buttons manually, resulting in multiple lines of repeated code.</db:para>
<db:para>Here we define the Mode enum with three different values:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para>NavigationMode,</db:para>
</db:listitem>
<db:listitem>
<db:para>AddingMode, and</db:para>
</db:listitem>
<db:listitem>
<db:para>EditingMode.</db:para>
</db:listitem>
</db:itemizedlist>
<db:section xml:id="defining-the-addressbook-class">
<db:title>Defining the AddressBook Class</db:title>
<db:para>The addressbook.h file is updated to contain the Mode enum:</db:para>
<db:programlisting language="cpp">    enum Mode { NavigationMode, AddingMode, EditingMode };
</db:programlisting>
<db:para>We also add two new slots, editContact() and removeContact(), to our current list of public slots.</db:para>
<db:programlisting language="cpp">    void editContact();
    void removeContact();
</db:programlisting>
<db:para>In order to switch between modes, we introduce the updateInterface() function to control the enabling and disabling of all <db:link xlink:href="qpushbutton.xml">QPushButton</db:link> objects. We also add two new push buttons, editButton and removeButton, for the edit and remove functions mentioned earlier.</db:para>
<db:programlisting language="cpp">    void updateInterface(Mode mode);
    ...
    QPushButton *editButton;
    QPushButton *removeButton;
    ...
    Mode currentMode;
</db:programlisting>
<db:para>Lastly, we declare currentMode to keep track of the enum's current mode.</db:para>
</db:section>
<db:section xml:id="implementing-the-addressbook-class">
<db:title>Implementing the AddressBook Class</db:title>
<db:para>We now implement the mode-changing features of the address book. The editButton and removeButton are instantiated and disabled by default. The address book starts with zero contacts in memory.</db:para>
<db:programlisting language="cpp">    editButton = new QPushButton(tr(&quot;&amp;amp;Edit&quot;));
    editButton-&amp;gt;setEnabled(false);
    removeButton = new QPushButton(tr(&quot;&amp;amp;Remove&quot;));
    removeButton-&amp;gt;setEnabled(false);
</db:programlisting>
<db:para>These buttons are then connected to their respective slots, editContact() and removeContact(), and we add them to buttonLayout1.</db:para>
<db:programlisting language="cpp">    connect(editButton, SIGNAL(clicked()), this, SLOT(editContact()));
    connect(removeButton, SIGNAL(clicked()), this, SLOT(removeContact()));
    ...
    buttonLayout1-&amp;gt;addWidget(editButton);
    buttonLayout1-&amp;gt;addWidget(removeButton);
</db:programlisting>
<db:para>The editContact() function stores the contact's old details in oldName and oldAddress, before switching the mode to EditingMode. In this mode, the submitButton and cancelButton are both enabled, hence, the user can change the contact's details and click either button.</db:para>
<db:programlisting language="cpp">void AddressBook::editContact()
{
    oldName = nameLine-&amp;gt;text();
    oldAddress = addressText-&amp;gt;toPlainText();

    updateInterface(EditingMode);
}
</db:programlisting>
<db:para>The submitContact() function has been divided in two with an if-else statement. We check currentMode to see if it's in AddingMode. If it is, we proceed with our adding process.</db:para>
<db:programlisting language="cpp">void AddressBook::submitContact()
{
    ...
    if (currentMode == AddingMode) {

        if (!contacts.contains(name)) {
            contacts.insert(name, address);
            QMessageBox::information(this, tr(&quot;Add Successful&quot;),
                tr(&quot;\&quot;%1\&quot; has been added to your address book.&quot;).arg(name));
        } else {
            QMessageBox::information(this, tr(&quot;Add Unsuccessful&quot;),
                tr(&quot;Sorry, \&quot;%1\&quot; is already in your address book.&quot;).arg(name));
        }
</db:programlisting>
<db:para>Otherwise, we check to see if currentMode is in EditingMode. If it is, we compare oldName with name. If the name has changed, we remove the old contact from contacts and insert the newly updated contact.</db:para>
<db:programlisting language="cpp">    } else if (currentMode == EditingMode) {

        if (oldName != name) {
            if (!contacts.contains(name)) {
                QMessageBox::information(this, tr(&quot;Edit Successful&quot;),
                    tr(&quot;\&quot;%1\&quot; has been edited in your address book.&quot;).arg(oldName));
                contacts.remove(oldName);
                contacts.insert(name, address);
            } else {
                QMessageBox::information(this, tr(&quot;Edit Unsuccessful&quot;),
                    tr(&quot;Sorry, \&quot;%1\&quot; is already in your address book.&quot;).arg(name));
            }
        } else if (oldAddress != address) {
            QMessageBox::information(this, tr(&quot;Edit Successful&quot;),
                tr(&quot;\&quot;%1\&quot; has been edited in your address book.&quot;).arg(name));
            contacts[name] = address;
        }
    }

    updateInterface(NavigationMode);
}
</db:programlisting>
<db:para>If only the address has changed (i.e., oldAddress is not the same as address), we update the contact's address. Lastly, we set currentMode to NavigationMode. This is an important step as it re-enables all the disabled push buttons.</db:para>
<db:para>To remove a contact from the address book, we implement the removeContact() function. This function checks to see if the contact exists in contacts.</db:para>
<db:programlisting language="cpp">void AddressBook::removeContact()
{
    QString name = nameLine-&amp;gt;text();
    QString address = addressText-&amp;gt;toPlainText();

    if (contacts.contains(name)) {

        int button = QMessageBox::question(this,
            tr(&quot;Confirm Remove&quot;),
            tr(&quot;Are you sure you want to remove \&quot;%1\&quot;?&quot;).arg(name),
            QMessageBox::Yes | QMessageBox::No);

        if (button == QMessageBox::Yes) {

            previous();
            contacts.remove(name);

            QMessageBox::information(this, tr(&quot;Remove Successful&quot;),
                tr(&quot;\&quot;%1\&quot; has been removed from your address book.&quot;).arg(name));
        }
    }

    updateInterface(NavigationMode);
}
</db:programlisting>
<db:para>If it does, we display a <db:link xlink:href="qmessagebox.xml">QMessageBox</db:link>, to confirm the removal with the user. Once the user has confirmed, we call previous() to ensure that the user interface shows another contact, and we remove the contact using <db:link xlink:href="qmap.xml">QMap</db:link>'s <db:link xlink:href="qmap.xml#remove">remove</db:link>() function. As a courtesy, we display a <db:link xlink:href="qmessagebox.xml">QMessageBox</db:link> to inform the user. Both the message boxes used in this function are shown below:</db:para>
<db:mediaobject>
<db:imageobject>
<db:imagedata fileref="images/addressbook-tutorial-part4-remove.png"/>
</db:imageobject>
</db:mediaobject>
<db:section xml:id="updating-the-user-interface">
<db:title>Updating the User Interface</db:title>
<db:para>We mentioned the updateInterface() function earlier as a means to enable and disable the push buttons depending on the current mode. The function updates the current mode according to the mode argument passed to it, assigning it to currentMode before checking its value.</db:para>
<db:para>Each of the push buttons is then enabled or disabled, depending on the current mode. The code for AddingMode and EditingMode is shown below:</db:para>
<db:programlisting language="cpp">void AddressBook::updateInterface(Mode mode)
{
    currentMode = mode;

    switch (currentMode) {

    case AddingMode:
    case EditingMode:

        nameLine-&amp;gt;setReadOnly(false);
        nameLine-&amp;gt;setFocus(Qt::OtherFocusReason);
        addressText-&amp;gt;setReadOnly(false);

        addButton-&amp;gt;setEnabled(false);
        editButton-&amp;gt;setEnabled(false);
        removeButton-&amp;gt;setEnabled(false);

        nextButton-&amp;gt;setEnabled(false);
        previousButton-&amp;gt;setEnabled(false);

        submitButton-&amp;gt;show();
        cancelButton-&amp;gt;show();
        break;
</db:programlisting>
<db:para>For NavigationMode, however, we include conditions within the parameters of the <db:link xlink:href="qwidget.xml#enabled-prop">QPushButton::setEnabled</db:link>() function. This is to ensure that editButton and removeButton are enabled when there is at least one contact in the address book; nextButton and previousButton are only enabled when there is more than one contact in the address book.</db:para>
<db:programlisting language="cpp">    case NavigationMode:

        if (contacts.isEmpty()) {
            nameLine-&amp;gt;clear();
            addressText-&amp;gt;clear();
        }

        nameLine-&amp;gt;setReadOnly(true);
        addressText-&amp;gt;setReadOnly(true);
        addButton-&amp;gt;setEnabled(true);

        int number = contacts.size();
        editButton-&amp;gt;setEnabled(number &amp;gt;= 1);
        removeButton-&amp;gt;setEnabled(number &amp;gt;= 1);
        nextButton-&amp;gt;setEnabled(number &amp;gt; 1);
        previousButton-&amp;gt;setEnabled(number &amp;gt;1 );

        submitButton-&amp;gt;hide();
        cancelButton-&amp;gt;hide();
        break;
    }
}
</db:programlisting>
<db:para>By setting the mode and updating the user interface in the same function, we avoid the possibility of the user interface getting out of sync with the internal state of the application.</db:para>
</db:section>
</db:section>
<db:section>
<db:title>List of Files</db:title>
<db:para>Files:</db:para>
<db:section>
<db:title>List of Files</db:title>
<db:itemizedlist>
<db:listitem>
<db:para><db:link xlink:href="tutorials/addressbook/part4/addressbook.cpp">tutorials/addressbook/part4/addressbook.cpp</db:link></db:para></db:listitem>
<db:listitem>
<db:para><db:link xlink:href="tutorials/addressbook/part4/addressbook.h">tutorials/addressbook/part4/addressbook.h</db:link></db:para></db:listitem>
<db:listitem>
<db:para><db:link xlink:href="tutorials/addressbook/part4/main.cpp">tutorials/addressbook/part4/main.cpp</db:link></db:para></db:listitem>
<db:listitem>
<db:para><db:link xlink:href="tutorials/addressbook/part4/part4.pro">tutorials/addressbook/part4/part4.pro</db:link></db:para></db:listitem>
</db:itemizedlist>
</db:section>
</db:section></db:article>
