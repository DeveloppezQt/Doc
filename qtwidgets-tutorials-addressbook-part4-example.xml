<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en">
<db:info>
<db:title>Part 4 - Editing and Removing Addresses</db:title>
<db:productname>QtWidgets</db:productname>
<db:edition>Qt 5.14.2 Reference Documentation</db:edition>
<db:titleabbrev>Qt Widgets Reference Documentation</db:titleabbrev>
<db:abstract>
<db:para>Explains how to add edit and remove functionality.</db:para>
</db:abstract>
<db:pubdate>2024-12-27</db:pubdate>
<db:date>2024-12-27</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:para>Now we look at ways to modify the contents of contacts stored in the address book.</db:para>
<db:mediaobject>
<db:imageobject>
<db:imagedata fileref="images/addressbook-tutorial-screenshot.png"/>
</db:imageobject>
</db:mediaobject>
<db:para>We now have an address book that not only holds contacts in an organized manner, but also allows navigation. It would be convenient to include edit and remove functions so that a contact's details can be changed when needed. However, this requires a little improvement, in the form of enums. We defined two modes: <db:code>AddingMode</db:code> and <db:code>NavigationMode</db:code>, but they were not defined as enum values. Instead, we enabled and disabled the corresponding buttons manually, resulting in multiple lines of repeated code.</db:para>
<db:para>Here we define the <db:code>Mode</db:code> enum with three different values:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:code>NavigationMode</db:code>,</db:para>
</db:listitem>
<db:listitem>
<db:para><db:code>AddingMode</db:code>, and</db:para>
</db:listitem>
<db:listitem>
<db:para><db:code>EditingMode</db:code>.</db:para>
</db:listitem>
</db:itemizedlist>
<db:section xml:id="defining-the-addressbook-class">
<db:title>Defining the AddressBook Class</db:title>
<db:para>The <db:code>addressbook.h</db:code> file is updated to contain the <db:code>Mode</db:code> enum:</db:para>
<db:programlisting language="cpp">    enum Mode { NavigationMode, AddingMode, EditingMode };
</db:programlisting>
<db:para>We also add two new slots, <db:code>editContact()</db:code> and <db:code>removeContact()</db:code>, to our current list of public slots.</db:para>
<db:programlisting language="cpp">    void editContact();
    void removeContact();
</db:programlisting>
<db:para>In order to switch between modes, we introduce the <db:code>updateInterface()</db:code> function to control the enabling and disabling of all QPushButton objects. We also add two new push buttons, <db:code>editButton</db:code> and <db:code>removeButton</db:code>, for the edit and remove functions mentioned earlier.</db:para>
<db:programlisting language="cpp">    void updateInterface(Mode mode);
    ...
    QPushButton *editButton;
    QPushButton *removeButton;
    ...
    Mode currentMode;
</db:programlisting>
<db:para>Lastly, we declare <db:code>currentMode</db:code> to keep track of the enum's current mode.</db:para>
</db:section>
<db:section xml:id="implementing-the-addressbook-class">
<db:title>Implementing the AddressBook Class</db:title>
<db:para>We now implement the mode-changing features of the address book. The <db:code>editButton</db:code> and <db:code>removeButton</db:code> are instantiated and disabled by default. The address book starts with zero contacts in memory.</db:para>
<db:programlisting language="cpp">    editButton = new QPushButton(tr(&quot;&amp;amp;Edit&quot;));
    editButton-&amp;gt;setEnabled(false);
    removeButton = new QPushButton(tr(&quot;&amp;amp;Remove&quot;));
    removeButton-&amp;gt;setEnabled(false);
</db:programlisting>
<db:para>These buttons are then connected to their respective slots, <db:code>editContact()</db:code> and <db:code>removeContact()</db:code>, and we add them to <db:code>buttonLayout1</db:code>.</db:para>
<db:programlisting language="cpp">    connect(editButton, &amp;amp;QPushButton::clicked,
            this, &amp;amp;AddressBook::editContact);
    connect(removeButton, &amp;amp;QPushButton::clicked,
            this, &amp;amp;AddressBook::removeContact);
    ...
    buttonLayout1-&amp;gt;addWidget(editButton);
    buttonLayout1-&amp;gt;addWidget(removeButton);
</db:programlisting>
<db:para>The <db:code>editContact()</db:code> function stores the contact's old details in <db:code>oldName</db:code> and <db:code>oldAddress</db:code>, before switching the mode to <db:code>EditingMode</db:code>. In this mode, the <db:code>submitButton</db:code> and <db:code>cancelButton</db:code> are both enabled, hence, the user can change the contact's details and click either button.</db:para>
<db:programlisting language="cpp">void AddressBook::editContact()
{
    oldName = nameLine-&amp;gt;text();
    oldAddress = addressText-&amp;gt;toPlainText();

    updateInterface(EditingMode);
}
</db:programlisting>
<db:para>The <db:code>submitContact()</db:code> function has been divided in two with an <db:code>if-else</db:code> statement. We check <db:code>currentMode</db:code> to see if it's in <db:code>AddingMode</db:code>. If it is, we proceed with our adding process.</db:para>
<db:programlisting language="cpp">void AddressBook::submitContact()
{
    ...
    if (currentMode == AddingMode) {

        if (!contacts.contains(name)) {
            contacts.insert(name, address);
            QMessageBox::information(this, tr(&quot;Add Successful&quot;),
                tr(&quot;\&quot;%1\&quot; has been added to your address book.&quot;).arg(name));
        } else {
            QMessageBox::information(this, tr(&quot;Add Unsuccessful&quot;),
                tr(&quot;Sorry, \&quot;%1\&quot; is already in your address book.&quot;).arg(name));
        }
</db:programlisting>
<db:para>Otherwise, we check to see if <db:code>currentMode</db:code> is in <db:code>EditingMode</db:code>. If it is, we compare <db:code>oldName</db:code> with <db:code>name</db:code>. If the name has changed, we remove the old contact from <db:code>contacts</db:code> and insert the newly updated contact.</db:para>
<db:programlisting language="cpp">    } else if (currentMode == EditingMode) {

        if (oldName != name) {
            if (!contacts.contains(name)) {
                QMessageBox::information(this, tr(&quot;Edit Successful&quot;),
                    tr(&quot;\&quot;%1\&quot; has been edited in your address book.&quot;).arg(oldName));
                contacts.remove(oldName);
                contacts.insert(name, address);
            } else {
                QMessageBox::information(this, tr(&quot;Edit Unsuccessful&quot;),
                    tr(&quot;Sorry, \&quot;%1\&quot; is already in your address book.&quot;).arg(name));
            }
        } else if (oldAddress != address) {
            QMessageBox::information(this, tr(&quot;Edit Successful&quot;),
                tr(&quot;\&quot;%1\&quot; has been edited in your address book.&quot;).arg(name));
            contacts[name] = address;
        }
    }

    updateInterface(NavigationMode);
}
</db:programlisting>
<db:para>If only the address has changed (i.e., <db:code>oldAddress</db:code> is not the same as <db:code>address</db:code>), we update the contact's address. Lastly, we set <db:code>currentMode</db:code> to <db:code>NavigationMode</db:code>. This is an important step as it re-enables all the disabled push buttons.</db:para>
<db:para>To remove a contact from the address book, we implement the <db:code>removeContact()</db:code> function. This function checks to see if the contact exists in <db:code>contacts</db:code>.</db:para>
<db:programlisting language="cpp">void AddressBook::removeContact()
{
    QString name = nameLine-&amp;gt;text();
    QString address = addressText-&amp;gt;toPlainText();

    if (contacts.contains(name)) {

        int button = QMessageBox::question(this,
            tr(&quot;Confirm Remove&quot;),
            tr(&quot;Are you sure you want to remove \&quot;%1\&quot;?&quot;).arg(name),
            QMessageBox::Yes | QMessageBox::No);

        if (button == QMessageBox::Yes) {

            previous();
            contacts.remove(name);

            QMessageBox::information(this, tr(&quot;Remove Successful&quot;),
                tr(&quot;\&quot;%1\&quot; has been removed from your address book.&quot;).arg(name));
        }
    }

    updateInterface(NavigationMode);
}
</db:programlisting>
<db:para>If it does, we display a QMessageBox, to confirm the removal with the user. Once the user has confirmed, we call <db:code>previous()</db:code> to ensure that the user interface shows another contact, and we remove the contact using <db:link xlink:href="qmap.xml">QMap</db:link>'s <db:link xlink:href="qmap.xml#remove">remove</db:link>() function. As a courtesy, we display a QMessageBox to inform the user. Both the message boxes used in this function are shown below:</db:para>
<db:mediaobject>
<db:imageobject>
<db:imagedata fileref="images/addressbook-tutorial-part4-remove.png"/>
</db:imageobject>
</db:mediaobject>
<db:section xml:id="updating-the-user-interface">
<db:title>Updating the User Interface</db:title>
<db:para>We mentioned the <db:code>updateInterface()</db:code> function earlier as a means to enable and disable the push buttons depending on the current mode. The function updates the current mode according to the <db:code>mode</db:code> argument passed to it, assigning it to <db:code>currentMode</db:code> before checking its value.</db:para>
<db:para>Each of the push buttons is then enabled or disabled, depending on the current mode. The code for <db:code>AddingMode</db:code> and <db:code>EditingMode</db:code> is shown below:</db:para>
<db:programlisting language="cpp">void AddressBook::updateInterface(Mode mode)
{
    currentMode = mode;

    switch (currentMode) {

    case AddingMode:
    case EditingMode:

        nameLine-&amp;gt;setReadOnly(false);
        nameLine-&amp;gt;setFocus(Qt::OtherFocusReason);
        addressText-&amp;gt;setReadOnly(false);

        addButton-&amp;gt;setEnabled(false);
        editButton-&amp;gt;setEnabled(false);
        removeButton-&amp;gt;setEnabled(false);

        nextButton-&amp;gt;setEnabled(false);
        previousButton-&amp;gt;setEnabled(false);

        submitButton-&amp;gt;show();
        cancelButton-&amp;gt;show();
        break;
</db:programlisting>
<db:para>For <db:code>NavigationMode</db:code>, however, we include conditions within the parameters of the QPushButton::setEnabled() function. This is to ensure that <db:code>editButton</db:code> and <db:code>removeButton</db:code> are enabled when there is at least one contact in the address book; <db:code>nextButton</db:code> and <db:code>previousButton</db:code> are only enabled when there is more than one contact in the address book.</db:para>
<db:programlisting language="cpp">    case NavigationMode:

        if (contacts.isEmpty()) {
            nameLine-&amp;gt;clear();
            addressText-&amp;gt;clear();
        }

        nameLine-&amp;gt;setReadOnly(true);
        addressText-&amp;gt;setReadOnly(true);
        addButton-&amp;gt;setEnabled(true);

        int number = contacts.size();
        editButton-&amp;gt;setEnabled(number &amp;gt;= 1);
        removeButton-&amp;gt;setEnabled(number &amp;gt;= 1);
        nextButton-&amp;gt;setEnabled(number &amp;gt; 1);
        previousButton-&amp;gt;setEnabled(number &amp;gt;1 );

        submitButton-&amp;gt;hide();
        cancelButton-&amp;gt;hide();
        break;
    }
}
</db:programlisting>
<db:para>By setting the mode and updating the user interface in the same function, we avoid the possibility of the user interface getting out of sync with the internal state of the application.</db:para>
</db:section>
</db:section>
<db:section>
<db:title>Example project</db:title>
<db:para><db:link xlink:href="https://code.qt.io/cgit/qt/qtbase.git/tree/examples/widgets/tutorials/addressbook/part4?h=5.14">Example project @ code.qt.io</db:link></db:para>
</db:section>
</db:article>
