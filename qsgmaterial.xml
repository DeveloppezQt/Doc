<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en">
<db:info>
<db:title>QSGMaterial Class</db:title>
<db:productname>QtQuick</db:productname>
<db:edition>Qt 6.8.3 Reference Documentation</db:edition>
<db:titleabbrev>Qt Quick Reference Documentation</db:titleabbrev>
<db:abstract>
<db:para>The <db:link xlink:href="qsgmaterial.xml">QSGMaterial</db:link> class encapsulates rendering state for a shader program.</db:para>
</db:abstract>
<db:pubdate>2025-06-29</db:pubdate>
<db:date>2025-06-29</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:variablelist>
<db:varlistentry>
<db:term>Header</db:term>
<db:listitem>
<db:para>QSGMaterial</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>CMake</db:term>
<db:listitem>
<db:para>find_package(Qt6 REQUIRED COMPONENTS Quick)</db:para>
<db:para>target_link_libraries(mytarget PRIVATE Qt6::Quick)</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>qmake</db:term>
<db:listitem>
<db:para>QT += quick</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Inherited By</db:term>
<db:listitem>
<db:para><db:link xlink:href="qsgflatcolormaterial.xml" xlink:role="class">QSGFlatColorMaterial</db:link>, <db:link xlink:href="qsgopaquetexturematerial.xml" xlink:role="class">QSGOpaqueTextureMaterial</db:link>, and <db:link xlink:href="qsgvertexcolormaterial.xml" xlink:role="class">QSGVertexColorMaterial</db:link></db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Group</db:term>
<db:listitem>
<db:para>QSGMaterial is part of <db:simplelist><db:member><db:link xlink:href="qtquick-scenegraph-materials.xml">Qt Quick Scene Graph Material Classes</db:link></db:member></db:simplelist>
</db:para>
</db:listitem>
</db:varlistentry>
</db:variablelist>
<db:section xml:id="details">
<db:title>Detailed Description</db:title>
<db:para><db:link xlink:href="qsgmaterial.xml">QSGMaterial</db:link> and <db:link xlink:href="qsgmaterialshader.xml">QSGMaterialShader</db:link> subclasses form a tight relationship. For one scene graph (including nested graphs), there is one unique <db:link xlink:href="qsgmaterialshader.xml">QSGMaterialShader</db:link> instance which encapsulates the shaders the scene graph uses to render that material, such as a shader to flat coloring of geometry. Each <db:link xlink:href="qsggeometrynode.xml">QSGGeometryNode</db:link> can have a unique <db:link xlink:href="qsgmaterial.xml">QSGMaterial</db:link> containing the how the shader should be configured when drawing that node, such as the actual color to used to render the geometry.</db:para>
<db:para><db:link xlink:href="qsgmaterial.xml">QSGMaterial</db:link> has two virtual functions that both need to be implemented. The function <db:link xlink:href="qsgmaterial.xml#type">type</db:link>() should return a unique instance for all instances of a specific subclass. The <db:link xlink:href="qsgmaterial.xml#createShader">createShader</db:link>() function should return a new instance of <db:link xlink:href="qsgmaterialshader.xml">QSGMaterialShader</db:link>, specific to that subclass of <db:link xlink:href="qsgmaterial.xml">QSGMaterial</db:link>.</db:para>
<db:para>A minimal <db:link xlink:href="qsgmaterial.xml">QSGMaterial</db:link> implementation could look like this:</db:para>
<db:programlisting language="cpp">class Material : public QSGMaterial
{
public:
    QSGMaterialType *type() const override { static QSGMaterialType type; return &amp;type; }
    QSGMaterialShader *createShader(QSGRendererInterface::RenderMode) const override { return new Shader; }
};
</db:programlisting>
<db:para>See the <db:link xlink:href="qtquick-scenegraph-custommaterial-example.xml">Custom Material example</db:link> for an introduction on implementing a <db:link xlink:href="qquickitem.xml">QQuickItem</db:link> subclass backed by a <db:link xlink:href="qsggeometrynode.xml">QSGGeometryNode</db:link> and a custom material.</db:para>
<db:note>
<db:para><db:link xlink:href="qsgmaterial.xml#createShader">createShader</db:link>() is called only once per <db:link xlink:href="qsgmaterialtype.xml">QSGMaterialType</db:link>, to reduce redundant work with shader preparation. If a <db:link xlink:href="qsgmaterial.xml">QSGMaterial</db:link> is backed by multiple sets of vertex and fragment shader combinations, the implementation of <db:link xlink:href="qsgmaterial.xml#type">type</db:link>() must return a different, unique <db:link xlink:href="qsgmaterialtype.xml">QSGMaterialType</db:link> pointer for each combination of shaders.</db:para>
</db:note>
<db:note>
<db:para>All classes with QSG prefix should be used solely on the scene graph's rendering thread. See <db:link xlink:href="qtquick-visualcanvas-scenegraph.xml#scene-graph-and-rendering">Scene Graph and Rendering</db:link> for more information.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qsgmaterialshader.xml">QSGMaterialShader</db:link></db:member>
<db:member><db:link xlink:href="qtquick-scenegraph-custommaterial-example.xml">Scene Graph - Custom Material</db:link></db:member>
<db:member><db:link xlink:href="qtquick-scenegraph-twotextureproviders-example.xml">Scene Graph - Two Texture Providers</db:link></db:member>
<db:member><db:link xlink:href="qtquick-scenegraph-graph-example.xml">Scene Graph - Graph</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="member-type-documentation">
<db:title>Member Type Documentation</db:title>
<db:section xml:id="Flag-enum">
<db:title>enum QSGMaterial::Flag</db:title>
<db:bridgehead renderas="sect2">flags QSGMaterial::Flags</db:bridgehead>
<db:informaltable>
<db:thead>
<db:tr>
<db:th>Constant</db:th>
<db:th>Value</db:th>
<db:th>Description</db:th>
</db:tr>
</db:thead>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qsgmaterial.xml">QSGMaterial</db:link></db:emphasis>::Blending</db:code></db:para>
</db:td>
<db:td><db:code>0x0001</db:code></db:td>
<db:td>
<db:para>Set this flag to true if the material requires blending to be enabled during rendering.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qsgmaterial.xml">QSGMaterial</db:link></db:emphasis>::RequiresDeterminant</db:code></db:para>
</db:td>
<db:td><db:code>0x0002</db:code></db:td>
<db:td>
<db:para>Set this flag to true if the material relies on the determinant of the matrix of the geometry nodes for rendering.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qsgmaterial.xml">QSGMaterial</db:link></db:emphasis>::RequiresFullMatrixExceptTranslate</db:code></db:para>
</db:td>
<db:td><db:code>0x0004 | RequiresDeterminant</db:code></db:td>
<db:td>
<db:para>Set this flag to true if the material relies on the full matrix of the geometry nodes for rendering, except the translation part.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qsgmaterial.xml">QSGMaterial</db:link></db:emphasis>::RequiresFullMatrix</db:code></db:para>
</db:td>
<db:td><db:code>0x0008 | RequiresFullMatrixExceptTranslate</db:code></db:td>
<db:td>
<db:para>Set this flag to true if the material relies on the full matrix of the geometry nodes for rendering.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qsgmaterial.xml">QSGMaterial</db:link></db:emphasis>::NoBatching</db:code></db:para>
</db:td>
<db:td><db:code>0x0010</db:code></db:td>
<db:td>
<db:para>Set this flag to true if the material uses shaders that are incompatible with the <db:link xlink:href="qtquick-visualcanvas-scenegraph-renderer.xml">scene graph's batching mechanism</db:link>. This is relevant in certain advanced usages, such as, directly manipulating <db:code>gl_Position.z</db:code> in the vertex shader. Such solutions are often tied to a specific scene structure, and are likely not safe to use with arbitrary contents in a scene. Thus this flag should only be set after appropriate investigation, and will never be needed for the vast majority of materials. Setting this flag can lead to reduced performance due to having to issue more draw calls. This flag was introduced in Qt 6.3.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qsgmaterial.xml">QSGMaterial</db:link></db:emphasis>::CustomCompileStep</db:code></db:para>
</db:td>
<db:td><db:code>NoBatching</db:code></db:td>
<db:td>
<db:para>In Qt 6 this flag is identical to NoBatching. Prefer using NoBatching instead.</db:para>
</db:td>
</db:tr>
</db:informaltable>
<db:para>The <db:code>Flags</db:code> type is a typedef for <db:code><db:link xlink:href="qflags.xml">QFlags</db:link>&lt;Flag&gt;. </db:code>It stores an OR combination of <db:code>Flag</db:code> values.</db:para>
</db:section>
</db:section>
<db:section xml:id="member-function-documentation">
<db:title>Member Function Documentation</db:title>
<db:section xml:id="compare">
<db:title>[virtual] int QSGMaterial::compare(const QSGMaterial *<db:emphasis>other</db:emphasis>) const</db:title>
<db:para>Compares this material to <db:code role="parameter">other</db:code> and returns 0 if they are equal; -1 if this material should sort before <db:code role="parameter">other</db:code> and 1 if <db:code role="parameter">other</db:code> should sort before.</db:para>
<db:para>The scene graph can reorder geometry nodes to minimize state changes. The compare function is called during the sorting process so that the materials can be sorted to minimize state changes in each call to QSGMaterialShader::updateState().</db:para>
<db:para>The this pointer and <db:code role="parameter">other</db:code> is guaranteed to have the same <db:link xlink:href="qsgmaterial.xml#type">type</db:link>().</db:para>
</db:section>
<db:section xml:id="createShader">
<db:title>[pure virtual] QSGMaterialShader *QSGMaterial::createShader(QSGRendererInterface::RenderMode <db:emphasis>renderMode</db:emphasis>) const</db:title>
<db:para>This function returns a new instance of a the <db:link xlink:href="qsgmaterialshader.xml">QSGMaterialShader</db:link> implementation used to render geometry for a specific implementation of <db:link xlink:href="qsgmaterial.xml">QSGMaterial</db:link>.</db:para>
<db:para>The function will be called only once for each combination of material type and <db:code role="parameter">renderMode</db:code> and will be cached internally.</db:para>
<db:para>For most materials, the <db:code role="parameter">renderMode</db:code> can be ignored. A few materials may need custom handling for specific render modes. For instance if the material implements antialiasing in a way that needs to account for perspective transformations when RenderMode3D is in use.</db:para>
</db:section>
<db:section xml:id="flags">
<db:title>QSGMaterial::Flags QSGMaterial::flags() const</db:title>
<db:para>Returns the material's flags.</db:para>
</db:section>
<db:section xml:id="setFlag">
<db:title>void QSGMaterial::setFlag(QSGMaterial::Flags <db:emphasis>flags</db:emphasis>, bool <db:emphasis>on</db:emphasis> = true)</db:title>
<db:para>Sets the flags <db:code role="parameter">flags</db:code> on this material if <db:code role="parameter">on</db:code> is true; otherwise clears the attribute.</db:para>
</db:section>
<db:section xml:id="type">
<db:title>[pure virtual] QSGMaterialType *QSGMaterial::type() const</db:title>
<db:para>This function is called by the scene graph to query an identifier that is unique to the <db:link xlink:href="qsgmaterialshader.xml">QSGMaterialShader</db:link> instantiated by <db:link xlink:href="qsgmaterial.xml#createShader">createShader</db:link>().</db:para>
<db:para>For many materials, the typical approach will be to return a pointer to a static, and so globally available, <db:link xlink:href="qsgmaterialtype.xml">QSGMaterialType</db:link> instance. The <db:link xlink:href="qsgmaterialtype.xml">QSGMaterialType</db:link> is an opaque object. Its purpose is only to serve as a type-safe, simple way to generate unique material identifiers.</db:para>
<db:programlisting language="cpp">QSGMaterialType *type() const override
{
    static QSGMaterialType type;
    return &amp;type;
}
</db:programlisting>
</db:section>
<db:section xml:id="viewCount">
<db:title>[since 6.8] int QSGMaterial::viewCount() const</db:title>
<db:para>Returns The number of views in case of the material is used in multiview rendering.</db:para>
<db:note>
<db:para>The return value is valid only when called from <db:link xlink:href="qsgmaterial.xml#createShader">createShader</db:link>(), and afterwards. The value is not necessarily up-to-date before <db:link xlink:href="qsgmaterial.xml#createShader">createShader</db:link>() is invokved by the scene graph.</db:para>
</db:note>
<db:para>Normally the return value is <db:code>1</db:code>. A view count greater than 2 implies a <db:emphasis>multiview render pass</db:emphasis>. Materials that support multiview are expected to query viewCount() in <db:link xlink:href="qsgmaterial.xml#createShader">createShader</db:link>(), or in their <db:link xlink:href="qsgmaterialshader.xml">QSGMaterialShader</db:link> constructor, and ensure the appropriate shaders are picked. The vertex shader is then expected to use <db:code>gl_ViewIndex</db:code> to index the modelview-projection matrix array as there are multiple matrices in multiview mode. (one for each view)</db:para>
<db:para>As an example, take the following simple vertex shader:</db:para>
<db:programlisting language="cpp" role="bad">#version 440

layout(location = 0) in vec4 vertexCoord;
layout(location = 1) in vec4 vertexColor;

layout(location = 0) out vec4 color;

layout(std140, binding = 0) uniform buf {
    mat4 matrix[2];
    float opacity;
};

void main()
{
    gl_Position = matrix[gl_ViewIndex] * vertexCoord;
    color = vertexColor * opacity;
}
</db:programlisting>
<db:para>This shader is prepared to handle 2 views, and 2 views only. It is not compatible with other view counts. When conditioning the shader, the <db:code>qsb</db:code> tool has to be invoked with <db:code>--view-count 2</db:code> or, if using the CMake integration, <db:code>VIEW_COUNT 2</db:code> must be specified in the <db:code>qt_add_shaders()</db:code> command.</db:para>
<db:note>
<db:para>A line with <db:code>#extension GL_EXT_multiview : require</db:code> is injected automatically by <db:code>qsb</db:code> whenever a view count of 2 or greater is set.</db:para>
</db:note>
<db:para>Developers are encouraged to use the automatically injected preprocessor variable <db:code>QSHADER_VIEW_COUNT</db:code> to simplify the handling of the different number of views. For example, if there is a need to support both non-multiview and multiview with a view count of 2 in the same source file, the following could be done:</db:para>
<db:programlisting language="cpp" role="bad">#version 440

layout(location = 0) in vec4 vertexCoord;
layout(location = 1) in vec4 vertexColor;

layout(location = 0) out vec4 color;

layout(std140, binding = 0) uniform buf {
#if QSHADER_VIEW_COUNT &gt;= 2
    mat4 matrix[QSHADER_VIEW_COUNT];
#else
    mat4 matrix;
#endif
    float opacity;
};

void main()
{
#if QSHADER_VIEW_COUNT &gt;= 2
    gl_Position = matrix[gl_ViewIndex] * vertexCoord;
#else
    gl_Position = matrix * vertexCoord;
#endif
    color = vertexColor * opacity;
}
</db:programlisting>
<db:para>The same source file can now be run through <db:code>qsb</db:code> or <db:code>qt_add_shaders()</db:code> twice, once without specify the view count, and once with the view count set to 2. The material can then pick the appropriate .qsb file based on viewCount() at run time.</db:para>
<db:para>With CMake, this could looks similar to the following. With this example the corresponding <db:link xlink:href="qsgmaterialshader.xml">QSGMaterialShader</db:link> is expected to choose between <db:code>:/shaders/example.vert.qsb</db:code> and <db:code>:/shaders/multiview/example.vert.qsb</db:code> based on the value of viewCount(). (same goes for the fragment shader)</db:para>
<db:programlisting language="cpp" role="bad">qt_add_shaders(application &quot;application_shaders&quot;
    PREFIX
        /
    FILES
        shaders/example.vert
        shaders/example.frag
)

qt_add_shaders(application &quot;application_multiview_shaders&quot;
    GLSL
        330,300es
    HLSL
        61
    MSL
        12
    VIEW_COUNT
        2
    PREFIX
        /
    FILES
        shaders/example.vert
        shaders/example.frag
    OUTPUTS
        shaders/multiview/example.vert
        shaders/multiview/example.frag
)
</db:programlisting>
<db:note>
<db:para>The fragment shader should be treated the same way the vertex shader is, even though the fragment shader code cannot have any dependency on the view count (<db:code>gl_ViewIndex</db:code>), for maximum portability. There are two reasons for including fragment shaders too in the multiview set. One is that mixing different shader versions within the same graphics pipeline can be problematic, depending on the underlying graphics API: with D3D12 for example, mixing HLSL shaders for shader model 5.0 and 6.1 would generate an error. The other is that having <db:code>QSHADER_VIEW_COUNT</db:code> defined in fragment shaders can be very useful, for example when sharing a uniform buffer layout between the vertex and fragment stages.</db:para>
</db:note>
<db:note>
<db:para>For OpenGL the minimum GLSL version for vertex shaders relying on <db:code>gl_ViewIndex</db:code> is <db:code>330</db:code>. Lower versions may be accepted at build time, but may lead to an error at run time, depending on the OpenGL implementation.</db:para>
</db:note>
<db:para>As a convenience, there is also a <db:code>MULTIVIEW</db:code> option for qt_add_shaders(). This first runs the <db:code>qsb</db:code> tool normally, then overrides <db:code>VIEW_COUNT</db:code> to <db:code>2</db:code>, sets <db:code>GLSL</db:code>, <db:code>HLSL</db:code>, <db:code>MSL</db:code> to some suitable defaults, and runs <db:code>qsb</db:code> again, this time outputting .qsb files with a suffix added. The material implementation can then use the <db:link xlink:href="qsgmaterialshader.xml#setShaderFileName">QSGMaterialShader::setShaderFileName</db:link>() overload taking a <db:code>viewCount</db:code> argument, that automatically picks the correct .qsb file.</db:para>
<db:para>The following is therefore mostly equivalent to the example call shown above, except that no manually managed output files need to be specified. Note that there can be cases when the automatically chosen shading language versions are not sufficient, in which case applications should continue specify everything explicitly.</db:para>
<db:programlisting language="cpp" role="bad">qt_add_shaders(application &quot;application_multiview_shaders&quot;
    MULTIVIEW
    PREFIX
        /
    FILES
        shaders/example.vert
        shaders/example.frag
)
</db:programlisting>
<db:para>See <db:link xlink:href="qrhi.xml#Feature-enum">QRhi::MultiView</db:link>, <db:link xlink:href="">QRhiColorAttachment::setMultiViewCount()</db:link>, and <db:link xlink:href="">QRhiGraphicsPipeline::setMultiViewCount()</db:link> for further, lower-level details on multiview support in Qt. The Qt Quick scene graph renderer is prepared to recognize multiview render targets, when specified via <db:link xlink:href="qquickrendertarget.xml#fromRhiRenderTarget">QQuickRenderTarget::fromRhiRenderTarget</db:link>() or the 3D API specific functions, such as <db:link xlink:href="qquickrendertarget.xml#fromVulkanImage">fromVulkanImage</db:link>() with an <db:code>arraySize</db:code> argument greater than 1. The renderer will then propagate the view count to graphics pipelines and the materials.</db:para>
<db:para>This function was introduced in Qt 6.8.</db:para>
</db:section>
</db:section>
</db:article>
