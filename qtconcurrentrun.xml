<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en">
<db:info>
<db:title>Concurrent Run</db:title>
<db:productname>QtConcurrent</db:productname>
<db:edition>Qt 5.6.3 Reference Documentation</db:edition>
<db:titleabbrev>Qt Concurrent Reference Documentation</db:titleabbrev>
<db:abstract>
<db:para>Qt Concurrent Reference Documentation.</db:para></db:abstract>
<db:pubdate>2025-06-29</db:pubdate>
<db:date>2025-06-29</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:para>The QtConcurrent::run() function runs a function in a separate thread. The return value of the function is made available through the <db:link xlink:href="qfuture.xml">QFuture</db:link> API.</db:para>
<db:para>This function is a part of the <db:link xlink:href="qtconcurrent-index.xml">Qt Concurrent</db:link> framework.</db:para>
<db:section xml:id="running-a-function-in-a-separate-thread">
<db:title>Running a Function in a Separate Thread</db:title>
<db:para>To run a function in another thread, use QtConcurrent::run():</db:para>
<db:programlisting language="cpp">extern void aFunction();
QFuture&lt;void&gt; future = QtConcurrent::run(aFunction);
</db:programlisting>
<db:para>This will run <db:emphasis>aFunction</db:emphasis> in a separate thread obtained from the default <db:link xlink:href="qthreadpool.xml">QThreadPool</db:link>. You can use the <db:link xlink:href="qfuture.xml">QFuture</db:link> and <db:link xlink:href="qfuturewatcher.xml">QFutureWatcher</db:link> classes to monitor the status of the function.</db:para>
<db:para>To use a dedicated thread pool, you can pass the <db:link xlink:href="qthreadpool.xml">QThreadPool</db:link> as the first argument:</db:para>
<db:programlisting language="cpp">extern void aFunction();
QThreadPool pool;
QFuture&lt;void&gt; future = QtConcurrent::run(&amp;pool, aFunction);
</db:programlisting>
</db:section>
<db:section xml:id="passing-arguments-to-the-function">
<db:title>Passing Arguments to the Function</db:title>
<db:para>Passing arguments to the function is done by adding them to the QtConcurrent::run() call immediately after the function name. For example:</db:para>
<db:programlisting language="cpp">extern void aFunctionWithArguments(int arg1, double arg2, const QString &amp;string);

int integer = ...;
double floatingPoint = ...;
QString string = ...;

QFuture&lt;void&gt; future = QtConcurrent::run(aFunctionWithArguments, integer, floatingPoint, string);
</db:programlisting>
<db:para>A copy of each argument is made at the point where QtConcurrent::run() is called, and these values are passed to the thread when it begins executing the function. Changes made to the arguments after calling QtConcurrent::run() are <db:emphasis>not</db:emphasis> visible to the thread.</db:para>
</db:section>
<db:section xml:id="returning-values-from-the-function">
<db:title>Returning Values from the Function</db:title>
<db:para>Any return value from the function is available via <db:link xlink:href="qfuture.xml">QFuture</db:link>:</db:para>
<db:programlisting language="cpp">extern QString functionReturningAString();
QFuture&lt;QString&gt; future = QtConcurrent::run(functionReturningAString);
...
QString result = future.result();
</db:programlisting>
<db:para>As documented above, passing arguments is done like this:</db:para>
<db:programlisting language="cpp">extern QString someFunction(const QByteArray &amp;input);

QByteArray bytearray = ...;

QFuture&lt;QString&gt; future = QtConcurrent::run(someFunction, bytearray);
...
QString result = future.result();
</db:programlisting>
<db:para>Note that the QFuture::result() function blocks and waits for the result to become available. Use <db:link xlink:href="qfuturewatcher.xml">QFutureWatcher</db:link> to get notification when the function has finished execution and the result is available.</db:para>
</db:section>
<db:section xml:id="additional-api-features">
<db:title>Additional API Features</db:title>
<db:section xml:id="using-member-functions">
<db:title>Using Member Functions</db:title>
<db:para>QtConcurrent::run() also accepts pointers to member functions. The first argument must be either a const reference or a pointer to an instance of the class. Passing by const reference is useful when calling const member functions; passing by pointer is useful for calling non-const member functions that modify the instance.</db:para>
<db:para>For example, calling <db:link xlink:href="qbytearray.xml#split">QByteArray::split</db:link>() (a const member function) in a separate thread is done like this:</db:para>
<db:programlisting language="cpp">// call 'QList&lt;QByteArray&gt;  QByteArray::split(char sep) const' in a separate thread
QByteArray bytearray = &quot;hello world&quot;;
QFuture&lt;QList&lt;QByteArray&gt; &gt; future = QtConcurrent::run(bytearray, &amp;QByteArray::split, ',');
...
QList&lt;QByteArray&gt; result = future.result();
</db:programlisting>
<db:para>Calling a non-const member function is done like this:</db:para>
<db:programlisting language="cpp">// call 'void QImage::invertPixels(InvertMode mode)' in a separate thread
QImage image = ...;
QFuture&lt;void&gt; future = QtConcurrent::run(&amp;image, &amp;QImage::invertPixels, QImage::InvertRgba);
...
future.waitForFinished();
// At this point, the pixels in 'image' have been inverted
</db:programlisting>
</db:section>
<db:section xml:id="using-bound-function-arguments">
<db:title>Using Bound Function Arguments</db:title>
<db:para>You can use std::bind() to <db:emphasis>bind</db:emphasis> a number of arguments to a function when called. If C++11 support is not available, <db:link xlink:href="http://www.boost.org/libs/bind/bind.html">boost::bind()</db:link> or <db:link xlink:href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1836.pdf">std::tr1::bind()</db:link> are suitable replacements.</db:para>
<db:para>There are number of reasons for binding:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para>To call a function that takes more than 5 arguments.</db:para>
</db:listitem>
<db:listitem>
<db:para>To simplify calling a function with constant arguments.</db:para>
</db:listitem>
<db:listitem>
<db:para>Changing the order of arguments.</db:para>
</db:listitem>
</db:itemizedlist>
<db:para>See the documentation for the relevant functions for details on how to use the bind API.</db:para>
<db:para>Calling a bound function is done like this:</db:para>
<db:programlisting language="cpp">void someFunction(int arg1, double arg2);
QFuture&lt;void&gt; future = QtConcurrent::run(std::bind(someFunction, 1, 2.0));
...
</db:programlisting>
</db:section>
</db:section>
</db:article>
