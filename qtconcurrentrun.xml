<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en">
<db:info>
<db:title>Concurrent Run</db:title>
<db:productname>QtConcurrent</db:productname>
<db:edition>Qt 5.12.12 Reference Documentation</db:edition>
<db:titleabbrev>Qt Concurrent Reference Documentation</db:titleabbrev>
<db:abstract>
<db:para>Qt Concurrent Reference Documentation.</db:para></db:abstract>
<db:pubdate>2024-12-27</db:pubdate>
<db:date>2024-12-27</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:para>The QtConcurrent::run() function runs a function in a separate thread. The return value of the function is made available through the <db:link xlink:href="qfuture.xml">QFuture</db:link> API.</db:para>
<db:para>This function is a part of the <db:link xlink:href="qtconcurrent-index.xml">Qt Concurrent</db:link> framework.</db:para>
<db:section xml:id="running-a-function-in-a-separate-thread">
<db:title>Running a Function in a Separate Thread</db:title>
<db:para>To run a function in another thread, use QtConcurrent::run():</db:para>
<db:programlisting language="cpp">extern void aFunction();
QFuture&amp;lt;void&amp;gt; future = QtConcurrent::run(aFunction);
</db:programlisting>
<db:para>This will run <db:emphasis>aFunction</db:emphasis> in a separate thread obtained from the default <db:link xlink:href="qthreadpool.xml">QThreadPool</db:link>. You can use the <db:link xlink:href="qfuture.xml">QFuture</db:link> and <db:link xlink:href="qfuturewatcher.xml">QFutureWatcher</db:link> classes to monitor the status of the function.</db:para>
<db:para>To use a dedicated thread pool, you can pass the <db:link xlink:href="qthreadpool.xml">QThreadPool</db:link> as the first argument:</db:para>
<db:programlisting language="cpp">extern void aFunction();
QThreadPool pool;
QFuture&amp;lt;void&amp;gt; future = QtConcurrent::run(&amp;amp;pool, aFunction);
</db:programlisting>
</db:section>
<db:section xml:id="passing-arguments-to-the-function">
<db:title>Passing Arguments to the Function</db:title>
<db:para>Passing arguments to the function is done by adding them to the QtConcurrent::run() call immediately after the function name. For example:</db:para>
<db:programlisting language="cpp">extern void aFunctionWithArguments(int arg1, double arg2, const QString &amp;amp;string);

int integer = ...;
double floatingPoint = ...;
QString string = ...;

QFuture&amp;lt;void&amp;gt; future = QtConcurrent::run(aFunctionWithArguments, integer, floatingPoint, string);
</db:programlisting>
<db:para>A copy of each argument is made at the point where QtConcurrent::run() is called, and these values are passed to the thread when it begins executing the function. Changes made to the arguments after calling QtConcurrent::run() are <db:emphasis>not</db:emphasis> visible to the thread.</db:para>
</db:section>
<db:section xml:id="returning-values-from-the-function">
<db:title>Returning Values from the Function</db:title>
<db:para>Any return value from the function is available via <db:link xlink:href="qfuture.xml">QFuture</db:link>:</db:para>
<db:programlisting language="cpp">extern QString functionReturningAString();
QFuture&amp;lt;QString&amp;gt; future = QtConcurrent::run(functionReturningAString);
...
QString result = future.result();
</db:programlisting>
<db:para>As documented above, passing arguments is done like this:</db:para>
<db:programlisting language="cpp">extern QString someFunction(const QByteArray &amp;amp;input);

QByteArray bytearray = ...;

QFuture&amp;lt;QString&amp;gt; future = QtConcurrent::run(someFunction, bytearray);
...
QString result = future.result();
</db:programlisting>
<db:para>Note that the <db:link xlink:href="qfuture.xml#result">QFuture::result</db:link>() function blocks and waits for the result to become available. Use <db:link xlink:href="qfuturewatcher.xml">QFutureWatcher</db:link> to get notification when the function has finished execution and the result is available.</db:para>
</db:section>
<db:section xml:id="additional-api-features">
<db:title>Additional API Features</db:title>
<db:section xml:id="using-member-functions">
<db:title>Using Member Functions</db:title>
<db:para>QtConcurrent::run() also accepts pointers to member functions. The first argument must be either a const reference or a pointer to an instance of the class. Passing by const reference is useful when calling const member functions; passing by pointer is useful for calling non-const member functions that modify the instance.</db:para>
<db:para>For example, calling <db:link xlink:href="qbytearray.xml#split">QByteArray::split</db:link>() (a const member function) in a separate thread is done like this:</db:para>
<db:programlisting language="cpp">// call 'QList&amp;lt;QByteArray&amp;gt;  QByteArray::split(char sep) const' in a separate thread
QByteArray bytearray = &quot;hello world&quot;;
QFuture&amp;lt;QList&amp;lt;QByteArray&amp;gt; &amp;gt; future = QtConcurrent::run(bytearray, &amp;amp;QByteArray::split, ',');
...
QList&amp;lt;QByteArray&amp;gt; result = future.result();
</db:programlisting>
<db:para>Calling a non-const member function is done like this:</db:para>
<db:programlisting language="cpp">// call 'void QImage::invertPixels(InvertMode mode)' in a separate thread
QImage image = ...;
QFuture&amp;lt;void&amp;gt; future = QtConcurrent::run(&amp;amp;image, &amp;amp;QImage::invertPixels, QImage::InvertRgba);
...
future.waitForFinished();
// At this point, the pixels in 'image' have been inverted
</db:programlisting>
</db:section>
<db:section xml:id="using-lambda-functions">
<db:title>Using Lambda Functions</db:title>
<db:para>Calling a lambda function is done like this:</db:para>
<db:programlisting language="cpp">QFuture&amp;lt;void&amp;gt; future = QtConcurrent::run([=]() {
    // Code in this block will run in another thread
});
...
</db:programlisting>
</db:section>
</db:section>
</db:article>
