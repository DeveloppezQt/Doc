<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en">
<db:info>
<db:title>Creating Qt Script Extensions</db:title>
<db:productname>QtScript</db:productname>
<db:edition>Qt 5.7.1 Reference Documentation</db:edition>
<db:titleabbrev>QtScript Reference Documentation</db:titleabbrev>
<db:abstract>
<db:para>A guide to creating and using Qt Script extensions.</db:para>
</db:abstract>
<db:pubdate>2025-06-29</db:pubdate>
<db:date>2025-06-29</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:para>Qt Script extensions can make additional functionality available to scripts evaluated by a <db:link xlink:href="qscriptengine.xml">QScriptEngine</db:link>. Extensions are imported by calling the <db:link xlink:href="qscriptengine.xml#importExtension">QScriptEngine::importExtension</db:link>() function.</db:para>
<db:para>There are three ways to create an extension:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para>Subclass <db:link xlink:href="qscriptextensionplugin.xml">QScriptExtensionPlugin</db:link> and implement the desired functionality.</db:para>
</db:listitem>
<db:listitem>
<db:para>Implement the functionality in a script file.</db:para>
</db:listitem>
<db:listitem>
<db:para>Use a hybrid approach, where part of the functionality is implemented in a <db:link xlink:href="qscriptextensionplugin.xml">QScriptExtensionPlugin</db:link>, and part is implemented in a script file.</db:para>
</db:listitem>
</db:itemizedlist>
<db:para>The (dot-qualified) extension name is used to determine the path (relative to the application's plugin path) where <db:link xlink:href="qscriptengine.xml">QScriptEngine</db:link> will look for the script file that will initialize the extension; if a file called <db:code>__init__.js</db:code> (usually located in <db:code>[application plugin path]/script/foo/</db:code>) is found in the corresponding folder, its contents will be evaluated by the engine when the extension is imported. As an example, if the extension is called <db:code>&quot;foo.bar.baz&quot;</db:code>, the engine will look for <db:code>__init__.js</db:code> in <db:code>foo/bar/baz</db:code>. Additionally, before importing <db:code>&quot;foo.bar.baz&quot;</db:code>, the engine will ensure that the extensions <db:code>&quot;foo&quot;</db:code> and <db:code>&quot;foo.bar&quot;</db:code> are imported, locating and evaluating the corresponding <db:code>__init__.js</db:code> in the same manner (in folders <db:code>foo</db:code> and <db:code>foo/bar</db:code>, respectively).</db:para>
<db:para>The contents of <db:code>__init__.js</db:code> are evaluated in a new <db:link xlink:href="qscriptcontext.xml">QScriptContext</db:link>, as if it were the body of a function. The engine's Global Object acts as the <db:code>this</db:code> object. The following local variables are initially available to the script:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:emphasis role="bold">__extension__</db:emphasis>: The name of the extension (e.g. <db:code>&quot;foo.bar.baz&quot;</db:code>).</db:para>
</db:listitem>
<db:listitem>
<db:para><db:emphasis role="bold">__setupPackage__</db:emphasis>: A convenience function for setting up a &quot;namespace&quot; in the script environment. A typical application is to call <db:code>__setupPackage__()</db:code> with <db:code>__extension__</db:code> as argument; e.g. <db:code>__setupPackage__(&quot;foo.bar.baz&quot;)</db:code> would ensure that the object chain represented by the expression <db:code>foo.bar.baz</db:code> exists in the script environment. (This function is semantically equivalent to <db:link xlink:href="qscriptextensionplugin.xml#setupPackage">QScriptExtensionPlugin::setupPackage</db:link>().)</db:para>
</db:listitem>
<db:listitem>
<db:para><db:emphasis role="bold">__postInit__</db:emphasis>: By default, this variable is undefined. If you assign a function to it, that function will be called <db:emphasis role="bold">after</db:emphasis> the C++ plugin's initialize() function has been called. You can use this to perform further initialization that depends on e.g. native functions that the C++ plugin registers.</db:para>
</db:listitem>
</db:itemizedlist>
<db:para>An example of a simple <db:code>__init__.js</db:code>:</db:para>
<db:programlisting language="cpp">print(&quot;importing &quot; + __extension__);
__setupPackage__(&quot;cool.stuff&quot;);

cool.stuff.add = function(a, b) { return a + b; }
cool.stuff.subtract = function(a, b) { return a - b; }
</db:programlisting>
<db:para><db:link xlink:href="qscriptengine.xml">QScriptEngine</db:link> will look for a <db:link xlink:href="qscriptextensionplugin.xml">QScriptExtensionPlugin</db:link> that provides the relevant extension by querying each plugin for its keys() until a match is found. The plugin's initialize() function will be called <db:emphasis role="bold">after</db:emphasis> the relevant <db:code>__init__.js</db:code> (if any) has been evaluated.</db:para>
<db:para>Continuining with the example of our imaginary extension <db:code>&quot;foo.bar.baz&quot;</db:code>, the following steps will be performed by <db:link xlink:href="qscriptengine.xml#importExtension">QScriptEngine::importExtension</db:link>():</db:para>
<db:itemizedlist>
<db:listitem>
<db:para>If it exists, <db:code>foo/__init__.js</db:code> is evaluated.</db:para>
</db:listitem>
<db:listitem>
<db:para>If a plugin with <db:code>&quot;foo&quot;</db:code> in its list of keys is found, its initialize() function is called with <db:code>&quot;foo&quot;</db:code> as key.</db:para>
</db:listitem>
<db:listitem>
<db:para>If it exists, <db:code>foo/bar/__init__.js</db:code> is evaluated.</db:para>
</db:listitem>
<db:listitem>
<db:para>If a plugin with <db:code>&quot;foo.bar&quot;</db:code> in its list of keys is found, its initialize() function is called with <db:code>&quot;foo.bar&quot;</db:code> as key.</db:para>
</db:listitem>
<db:listitem>
<db:para>If it exists, <db:code>foo/bar/baz/__init__.js</db:code> is evaluated.</db:para>
</db:listitem>
<db:listitem>
<db:para>If a plugin with &quot;foo.bar.baz&quot; in its list of keys is found, its initialize() function is called with <db:code>&quot;foo.bar.baz&quot;</db:code> as key.</db:para>
</db:listitem>
</db:itemizedlist>
<db:section xml:id="static-extensions">
<db:title>Static Extensions</db:title>
<db:para>When an extension is compiled and linked into your application as a static plugin, Qt Script will look for the optional <db:code>__init__.js</db:code> script in a resource, prefixed by <db:code>:/qtscriptextension</db:code>. For example, if the extension key is &quot;foo.bar&quot;, Qt Script will evaluate the contents of the file <db:code>:/qtscriptextension/foo/bar/__init__.js</db:code>, if it exists. Note that if the resource is built into the plugin, you may need to use the <db:link xlink:href="qdir.xml#Q_INIT_RESOURCE">Q_INIT_RESOURCE</db:link>() macro to initialize the resource before importing the extension.</db:para>
</db:section>
</db:article>
