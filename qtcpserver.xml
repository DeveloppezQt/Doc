<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en">
<db:info>
<db:title>QTcpServer Class</db:title>
<db:productname>QtNetwork</db:productname>
<db:edition>Qt 5.6.3 Reference Documentation</db:edition>
<db:titleabbrev>Qt Network Reference Documentation</db:titleabbrev>
<db:abstract>
<db:para>The <db:link xlink:href="qtcpserver.xml">QTcpServer</db:link> class provides a TCP-based server.</db:para>
<db:note>
<db:para>All functions in this class are <db:link xlink:href="threads-reentrancy.xml">reentrant</db:link>.</db:para>
</db:note>
</db:abstract>
<db:pubdate>2025-06-29</db:pubdate>
<db:date>2025-06-29</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:variablelist>
<db:varlistentry>
<db:term>Header</db:term>
<db:listitem>
<db:para>QTcpServer</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>qmake</db:term>
<db:listitem>
<db:para>QT += network</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Inherits</db:term>
<db:listitem>
<db:para><db:link xlink:href="qobject.xml" xlink:role="class">QObject</db:link></db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Inherited By</db:term>
<db:listitem>
<db:para/>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Group</db:term>
<db:listitem>
<db:para>QTcpServer is part of <db:simplelist><db:member><db:link xlink:href="network.xml">Network Programming API</db:link></db:member></db:simplelist>
</db:para>
</db:listitem>
</db:varlistentry>
</db:variablelist>
<db:section xml:id="details">
<db:title>Detailed Description</db:title>
<db:para>This class makes it possible to accept incoming TCP connections. You can specify the port or have <db:link xlink:href="qtcpserver.xml">QTcpServer</db:link> pick one automatically. You can listen on a specific address or on all the machine's addresses.</db:para>
<db:para>Call <db:link xlink:href="qtcpserver.xml#listen">listen</db:link>() to have the server listen for incoming connections. The <db:link xlink:href="qtcpserver.xml#newConnection">newConnection</db:link>() signal is then emitted each time a client connects to the server.</db:para>
<db:para>Call <db:link xlink:href="qtcpserver.xml#nextPendingConnection">nextPendingConnection</db:link>() to accept the pending connection as a connected <db:link xlink:href="qtcpsocket.xml">QTcpSocket</db:link>. The function returns a pointer to a <db:link xlink:href="qtcpsocket.xml">QTcpSocket</db:link> in <db:link xlink:href="qabstractsocket.xml#SocketState-enum">QAbstractSocket::ConnectedState</db:link> that you can use for communicating with the client.</db:para>
<db:para>If an error occurs, <db:link xlink:href="qtcpserver.xml#serverError">serverError</db:link>() returns the type of error, and <db:link xlink:href="qtcpserver.xml#errorString">errorString</db:link>() can be called to get a human readable description of what happened.</db:para>
<db:para>When listening for connections, the address and port on which the server is listening are available as <db:link xlink:href="qtcpserver.xml#serverAddress">serverAddress</db:link>() and <db:link xlink:href="qtcpserver.xml#serverPort">serverPort</db:link>().</db:para>
<db:para>Calling <db:link xlink:href="qtcpserver.xml#close">close</db:link>() makes <db:link xlink:href="qtcpserver.xml">QTcpServer</db:link> stop listening for incoming connections.</db:para>
<db:para>Although <db:link xlink:href="qtcpserver.xml">QTcpServer</db:link> is mostly designed for use with an event loop, it's possible to use it without one. In that case, you must use <db:link xlink:href="qtcpserver.xml#waitForNewConnection">waitForNewConnection</db:link>(), which blocks until either a connection is available or a timeout expires.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtcpsocket.xml">QTcpSocket</db:link></db:member>
<db:member><db:link xlink:href="qtnetwork-fortuneserver-example.xml">Fortune Server Example</db:link></db:member>
<db:member><db:link xlink:href="qtnetwork-threadedfortuneserver-example.xml">Threaded Fortune Server Example</db:link></db:member>
<db:member><db:link xlink:href="qtnetwork-loopback-example.xml">Loopback Example</db:link></db:member>
<db:member><db:link xlink:href="qtnetwork-torrent-example.xml">Torrent Example</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="member-function-documentation">
<db:title>Member Function Documentation</db:title>
<db:section xml:id="QTcpServer">
<db:title>[explicit] QTcpServer::QTcpServer(QObject *<db:emphasis>parent</db:emphasis> = Q_NULLPTR)</db:title>
<db:para>Constructs a <db:link xlink:href="qtcpserver.xml">QTcpServer</db:link> object.</db:para>
<db:para><db:code role="parameter">parent</db:code> is passed to the <db:link xlink:href="qobject.xml">QObject</db:link> constructor.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtcpserver.xml#listen">listen</db:link>()</db:member>
<db:member><db:link xlink:href="qtcpserver.xml#setSocketDescriptor">setSocketDescriptor</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="dtor.QTcpServer">
<db:title>[virtual noexcept] QTcpServer::~QTcpServer()</db:title>
<db:para>Destroys the <db:link xlink:href="qtcpserver.xml">QTcpServer</db:link> object. If the server is listening for connections, the socket is automatically closed.</db:para>
<db:para>Any client <db:link xlink:href="qtcpsocket.xml">QTcpSocket</db:link>s that are still connected must either disconnect or be reparented before the server is deleted.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtcpserver.xml#close">close</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="acceptError">
<db:title>[since 5.0] void QTcpServer::acceptError(QAbstractSocket::SocketError <db:emphasis>socketError</db:emphasis>)</db:title>
<db:para>This signal is emitted when accepting a new connection results in an error. The <db:code role="parameter">socketError</db:code> parameter describes the type of error that occurred.</db:para>
<db:para>This function was introduced in Qt 5.0.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtcpserver.xml#pauseAccepting">pauseAccepting</db:link>()</db:member>
<db:member><db:link xlink:href="qtcpserver.xml#resumeAccepting">resumeAccepting</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="addPendingConnection">
<db:title>[protected, since 4.7] void QTcpServer::addPendingConnection(QTcpSocket *<db:emphasis>socket</db:emphasis>)</db:title>
<db:para>This function is called by <db:link xlink:href="qtcpserver.xml#incomingConnection">QTcpServer::incomingConnection</db:link>() to add the <db:code role="parameter">socket</db:code> to the list of pending incoming connections.</db:para>
<db:note>
<db:para>Don't forget to call this member from reimplemented <db:link xlink:href="qtcpserver.xml#incomingConnection">incomingConnection</db:link>() if you do not want to break the Pending Connections mechanism.</db:para>
</db:note>
<db:para>This function was introduced in Qt 4.7.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtcpserver.xml#incomingConnection">incomingConnection</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="close">
<db:title>void QTcpServer::close()</db:title>
<db:para>Closes the server. The server will no longer listen for incoming connections.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtcpserver.xml#listen">listen</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="errorString">
<db:title>QString QTcpServer::errorString() const</db:title>
<db:para>Returns a human readable description of the last error that occurred.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtcpserver.xml#serverError">serverError</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="hasPendingConnections">
<db:title>[virtual] bool QTcpServer::hasPendingConnections() const</db:title>
<db:para>Returns true if the server has a pending connection; otherwise returns false.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtcpserver.xml#nextPendingConnection">nextPendingConnection</db:link>()</db:member>
<db:member><db:link xlink:href="qtcpserver.xml#setMaxPendingConnections">setMaxPendingConnections</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="incomingConnection">
<db:title>[virtual protected] void QTcpServer::incomingConnection(qintptr <db:emphasis>socketDescriptor</db:emphasis>)</db:title>
<db:para>This virtual function is called by <db:link xlink:href="qtcpserver.xml">QTcpServer</db:link> when a new connection is available. The <db:code role="parameter">socketDescriptor</db:code> argument is the native socket descriptor for the accepted connection.</db:para>
<db:para>The base implementation creates a <db:link xlink:href="qtcpsocket.xml">QTcpSocket</db:link>, sets the socket descriptor and then stores the <db:link xlink:href="qtcpsocket.xml">QTcpSocket</db:link> in an internal list of pending connections. Finally <db:link xlink:href="qtcpserver.xml#newConnection">newConnection</db:link>() is emitted.</db:para>
<db:para>Reimplement this function to alter the server's behavior when a connection is available.</db:para>
<db:para>If this server is using <db:link xlink:href="qnetworkproxy.xml">QNetworkProxy</db:link> then the <db:code role="parameter">socketDescriptor</db:code> may not be usable with native socket functions, and should only be used with <db:link xlink:href="qabstractsocket.xml#setSocketDescriptor">QTcpSocket::setSocketDescriptor</db:link>().</db:para>
<db:note>
<db:para>If another socket is created in the reimplementation of this method, it needs to be added to the Pending Connections mechanism by calling <db:link xlink:href="qtcpserver.xml#addPendingConnection">addPendingConnection</db:link>().</db:para>
</db:note>
<db:note>
<db:para>If you want to handle an incoming connection as a new <db:link xlink:href="qtcpsocket.xml">QTcpSocket</db:link> object in another thread you have to pass the <db:link xlink:href="qtcpserver.xml#socketDescriptor">socketDescriptor</db:link> to the other thread and create the <db:link xlink:href="qtcpsocket.xml">QTcpSocket</db:link> object there and use its <db:link xlink:href="qtcpserver.xml#setSocketDescriptor">setSocketDescriptor</db:link>() method.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtcpserver.xml#newConnection">newConnection</db:link>()</db:member>
<db:member><db:link xlink:href="qtcpserver.xml#nextPendingConnection">nextPendingConnection</db:link>()</db:member>
<db:member><db:link xlink:href="qtcpserver.xml#addPendingConnection">addPendingConnection</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="isListening">
<db:title>bool QTcpServer::isListening() const</db:title>
<db:para>Returns true if the server is currently listening for incoming connections; otherwise returns false.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtcpserver.xml#listen">listen</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="listen">
<db:title>bool QTcpServer::listen(const QHostAddress &amp;<db:emphasis>address</db:emphasis> = QHostAddress::Any, quint16 <db:emphasis>port</db:emphasis> = 0)</db:title>
<db:para>Tells the server to listen for incoming connections on address <db:code role="parameter">address</db:code> and port <db:code role="parameter">port</db:code>. If <db:code role="parameter">port</db:code> is 0, a port is chosen automatically. If <db:code role="parameter">address</db:code> is <db:link xlink:href="qhostaddress.xml#SpecialAddress-enum">QHostAddress::Any</db:link>, the server will listen on all network interfaces.</db:para>
<db:para>Returns true on success; otherwise returns false.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtcpserver.xml#isListening">isListening</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="maxPendingConnections">
<db:title>int QTcpServer::maxPendingConnections() const</db:title>
<db:para>Returns the maximum number of pending accepted connections. The default is 30.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtcpserver.xml#setMaxPendingConnections">setMaxPendingConnections</db:link>()</db:member>
<db:member><db:link xlink:href="qtcpserver.xml#hasPendingConnections">hasPendingConnections</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="newConnection">
<db:title>void QTcpServer::newConnection()</db:title>
<db:para>This signal is emitted every time a new connection is available.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtcpserver.xml#hasPendingConnections">hasPendingConnections</db:link>()</db:member>
<db:member><db:link xlink:href="qtcpserver.xml#nextPendingConnection">nextPendingConnection</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="nextPendingConnection">
<db:title>[virtual] QTcpSocket *QTcpServer::nextPendingConnection()</db:title>
<db:para>Returns the next pending connection as a connected <db:link xlink:href="qtcpsocket.xml">QTcpSocket</db:link> object.</db:para>
<db:para>The socket is created as a child of the server, which means that it is automatically deleted when the <db:link xlink:href="qtcpserver.xml">QTcpServer</db:link> object is destroyed. It is still a good idea to delete the object explicitly when you are done with it, to avoid wasting memory.</db:para>
<db:para>0 is returned if this function is called when there are no pending connections.</db:para>
<db:note>
<db:para>The returned <db:link xlink:href="qtcpsocket.xml">QTcpSocket</db:link> object cannot be used from another thread. If you want to use an incoming connection from another thread, you need to override <db:link xlink:href="qtcpserver.xml#incomingConnection">incomingConnection</db:link>().</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtcpserver.xml#hasPendingConnections">hasPendingConnections</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="pauseAccepting">
<db:title>[since 5.0] void QTcpServer::pauseAccepting()</db:title>
<db:para>Pauses accepting new connections. Queued connections will remain in queue.</db:para>
<db:para>This function was introduced in Qt 5.0.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtcpserver.xml#resumeAccepting">resumeAccepting</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="proxy">
<db:title>[since 4.1] QNetworkProxy QTcpServer::proxy() const</db:title>
<db:para>Returns the network proxy for this socket. By default <db:link xlink:href="qnetworkproxy.xml#ProxyType-enum">QNetworkProxy::DefaultProxy</db:link> is used.</db:para>
<db:para>This function was introduced in Qt 4.1.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtcpserver.xml#setProxy">setProxy</db:link>()</db:member>
<db:member><db:link xlink:href="qnetworkproxy.xml">QNetworkProxy</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="resumeAccepting">
<db:title>[since 5.0] void QTcpServer::resumeAccepting()</db:title>
<db:para>Resumes accepting new connections.</db:para>
<db:para>This function was introduced in Qt 5.0.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtcpserver.xml#pauseAccepting">pauseAccepting</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="serverAddress">
<db:title>QHostAddress QTcpServer::serverAddress() const</db:title>
<db:para>Returns the server's address if the server is listening for connections; otherwise returns <db:link xlink:href="qhostaddress.xml#SpecialAddress-enum">QHostAddress::Null</db:link>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtcpserver.xml#serverPort">serverPort</db:link>()</db:member>
<db:member><db:link xlink:href="qtcpserver.xml#listen">listen</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="serverError">
<db:title>QAbstractSocket::SocketError QTcpServer::serverError() const</db:title>
<db:para>Returns an error code for the last error that occurred.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtcpserver.xml#errorString">errorString</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="serverPort">
<db:title>quint16 QTcpServer::serverPort() const</db:title>
<db:para>Returns the server's port if the server is listening for connections; otherwise returns 0.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtcpserver.xml#serverAddress">serverAddress</db:link>()</db:member>
<db:member><db:link xlink:href="qtcpserver.xml#listen">listen</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setMaxPendingConnections">
<db:title>void QTcpServer::setMaxPendingConnections(int <db:emphasis>numConnections</db:emphasis>)</db:title>
<db:para>Sets the maximum number of pending accepted connections to <db:code role="parameter">numConnections</db:code>. <db:link xlink:href="qtcpserver.xml">QTcpServer</db:link> will accept no more than <db:code role="parameter">numConnections</db:code> incoming connections before <db:link xlink:href="qtcpserver.xml#nextPendingConnection">nextPendingConnection</db:link>() is called. By default, the limit is 30 pending connections.</db:para>
<db:para>Clients may still able to connect after the server has reached its maximum number of pending connections (i.e., <db:link xlink:href="qtcpsocket.xml">QTcpSocket</db:link> can still emit the connected() signal). <db:link xlink:href="qtcpserver.xml">QTcpServer</db:link> will stop accepting the new connections, but the operating system may still keep them in queue.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtcpserver.xml#maxPendingConnections">maxPendingConnections</db:link>()</db:member>
<db:member><db:link xlink:href="qtcpserver.xml#hasPendingConnections">hasPendingConnections</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setProxy">
<db:title>[since 4.1] void QTcpServer::setProxy(const QNetworkProxy &amp;<db:emphasis>networkProxy</db:emphasis>)</db:title>
<db:para>Sets the explicit network proxy for this socket to <db:code role="parameter">networkProxy</db:code>.</db:para>
<db:para>To disable the use of a proxy for this socket, use the <db:link xlink:href="qnetworkproxy.xml#ProxyType-enum">QNetworkProxy::NoProxy</db:link> proxy type:</db:para>
<db:programlisting language="cpp">server-&gt;setProxy(QNetworkProxy::NoProxy);
</db:programlisting>
<db:para>This function was introduced in Qt 4.1.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtcpserver.xml#proxy">proxy</db:link>()</db:member>
<db:member><db:link xlink:href="qnetworkproxy.xml">QNetworkProxy</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setSocketDescriptor">
<db:title>bool QTcpServer::setSocketDescriptor(qintptr <db:emphasis>socketDescriptor</db:emphasis>)</db:title>
<db:para>Sets the socket descriptor this server should use when listening for incoming connections to <db:code role="parameter">socketDescriptor</db:code>. Returns true if the socket is set successfully; otherwise returns false.</db:para>
<db:para>The socket is assumed to be in listening state.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtcpserver.xml#socketDescriptor">socketDescriptor</db:link>()</db:member>
<db:member><db:link xlink:href="qtcpserver.xml#isListening">isListening</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="socketDescriptor">
<db:title>qintptr QTcpServer::socketDescriptor() const</db:title>
<db:para>Returns the native socket descriptor the server uses to listen for incoming instructions, or -1 if the server is not listening.</db:para>
<db:para>If the server is using <db:link xlink:href="qnetworkproxy.xml">QNetworkProxy</db:link>, the returned descriptor may not be usable with native socket functions.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtcpserver.xml#setSocketDescriptor">setSocketDescriptor</db:link>()</db:member>
<db:member><db:link xlink:href="qtcpserver.xml#isListening">isListening</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="waitForNewConnection">
<db:title>bool QTcpServer::waitForNewConnection(int <db:emphasis>msec</db:emphasis> = 0, bool *<db:emphasis>timedOut</db:emphasis> = Q_NULLPTR)</db:title>
<db:para>Waits for at most <db:code role="parameter">msec</db:code> milliseconds or until an incoming connection is available. Returns true if a connection is available; otherwise returns false. If the operation timed out and <db:code role="parameter">timedOut</db:code> is not 0, *<db:code role="parameter">timedOut</db:code> will be set to true.</db:para>
<db:para>This is a blocking function call. Its use is disadvised in a single-threaded GUI application, since the whole application will stop responding until the function returns. waitForNewConnection() is mostly useful when there is no event loop available.</db:para>
<db:para>The non-blocking alternative is to connect to the <db:link xlink:href="qtcpserver.xml#newConnection">newConnection</db:link>() signal.</db:para>
<db:para>If msec is -1, this function will not time out.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtcpserver.xml#hasPendingConnections">hasPendingConnections</db:link>()</db:member>
<db:member><db:link xlink:href="qtcpserver.xml#nextPendingConnection">nextPendingConnection</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
</db:section>
</db:article>
