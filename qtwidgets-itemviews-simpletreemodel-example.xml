<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en">
<db:info>
<db:title>Simple Tree Model Example</db:title>
<db:productname>QtWidgets</db:productname>
<db:edition>Qt 6.9.1 Reference Documentation</db:edition>
<db:titleabbrev>Qt Widgets Reference Documentation</db:titleabbrev>
<db:abstract>
<db:para>The Simple Tree Model example shows how to use a hierarchical model with Qt's standard view classes.</db:para>
</db:abstract>
<db:pubdate>2025-06-29</db:pubdate>
<db:date>2025-06-29</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:mediaobject>
<db:imageobject>
<db:imagedata fileref="images/simpletreemodel-example.png"/>
</db:imageobject>
</db:mediaobject>
<db:para>Qt's model/view architecture provides a standard way for views to manipulate information in a data source, using an abstract model of the data to simplify and standardize the way it is accessed. Simple models represent data as a table of items, and allow views to access this data via an <db:link xlink:href="model-view-programming.xml#models">index-based</db:link> system. More generally, models can be used to represent data in the form of a tree structure by allowing each item to act as a parent to a table of child items.</db:para>
<db:para>Before attempting to implement a tree model, it is worth considering whether the data is supplied by an external source, or whether it is going to be maintained within the model itself. In this example, we will implement an internal structure to hold data rather than discuss how to package data from an external source.</db:para>
<db:section xml:id="design-and-concepts">
<db:title>Design and Concepts</db:title>
<db:para>The data structure that we use to represent the structure of the data takes the form of a tree built from TreeItem objects. Each TreeItem represents an item in a tree view, and contains several columns of data.</db:para>
<db:anchor xml:id="simpletreemodelstructure"/>
<db:informaltable style="generic">
<db:tr valign="top">
<db:td>
<db:para><db:inlinemediaobject>
<db:imageobject>
<db:imagedata fileref="images/treemodel-structure.png"/>
</db:imageobject>
</db:inlinemediaobject></db:para>
</db:td>
<db:td>
<db:para><db:emphasis role="bold">Simple Tree Model Structure</db:emphasis></db:para>
<db:para>The data is stored internally in the model using TreeItem objects that are linked together in a pointer-based tree structure. Generally, each TreeItem has a parent item, and can have a number of child items. However, the root item in the tree structure has no parent item and it is never referenced outside the model.</db:para>
<db:para>Each TreeItem contains information about its place in the tree structure; it can return its parent item and its row number. Having this information readily available makes implementing the model easier.</db:para>
<db:para>Since each item in a tree view usually contains several columns of data (a title and a summary in this example), it is natural to store this information in each item. For simplicity, we will use a list of <db:link xlink:href="qvariant.xml">QVariant</db:link> objects to store the data for each column in the item.</db:para>
</db:td>
</db:tr>
</db:informaltable>
<db:para>The use of a pointer-based tree structure means that, when passing a model index to a view, we can record the address of the corresponding item in the index (see <db:link xlink:href="qabstractitemmodel.xml#createIndex">QAbstractItemModel::createIndex</db:link>()) and retrieve it later with <db:link xlink:href="qmodelindex.xml#internalPointer">QModelIndex::internalPointer</db:link>(). This makes writing the model easier and ensures that all model indexes that refer to the same item have the same internal data pointer.</db:para>
<db:para>With the appropriate data structure in place, we can create a tree model with a minimal amount of extra code to supply model indexes and data to other components.</db:para>
</db:section>
<db:section xml:id="treeitem-class-definition">
<db:title>TreeItem Class Definition</db:title>
<db:para>The TreeItem class is defined as follows:</db:para>
<db:programlisting language="cpp">class TreeItem
{
public:
    explicit TreeItem(QVariantList data, TreeItem *parentItem = nullptr);

    void appendChild(std::unique_ptr&lt;TreeItem&gt; &amp;&amp;child);

    TreeItem *child(int row);
    int childCount() const;
    int columnCount() const;
    QVariant data(int column) const;
    int row() const;
    TreeItem *parentItem();

private:
    std::vector&lt;std::unique_ptr&lt;TreeItem&gt;&gt; m_childItems;
    QVariantList m_itemData;
    TreeItem *m_parentItem;
};
</db:programlisting>
<db:para>The class is a basic C++ class. It does not inherit from <db:link xlink:href="qobject.xml">QObject</db:link> or provide signals and slots. It is used to hold a list of QVariants, containing column data, and information about its position in the tree structure. The functions provide the following features:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para>The appendChildItem() is used to add data when the model is first constructed and is not used during normal use.</db:para>
</db:listitem>
<db:listitem>
<db:para>The child() and childCount() functions allow the model to obtain information about any child items.</db:para>
</db:listitem>
<db:listitem>
<db:para>Information about the number of columns associated with the item is provided by columnCount(), and the data in each column can be obtained with the data() function.</db:para>
</db:listitem>
<db:listitem>
<db:para>The row() and parent() functions are used to obtain the item's row number and parent item.</db:para>
</db:listitem>
</db:itemizedlist>
<db:para>The parent item and column data are stored in the parentItem and itemData private member variables. The childItems variable contains a list of pointers to the item's own child items.</db:para>
</db:section>
<db:section xml:id="treeitem-class-implementation">
<db:title>TreeItem Class Implementation</db:title>
<db:para>The constructor is only used to record the item's parent and the data associated with each column.</db:para>
<db:programlisting language="cpp">TreeItem::TreeItem(QVariantList data, TreeItem *parent)
    : m_itemData(std::move(data)), m_parentItem(parent)
{}
</db:programlisting>
<db:para>A pointer to each of the child items belonging to this item will be stored in the childItems private member variable as an std::unique_ptr. When the class's destructor is called, the child items will be automatically deleted to ensure that their memory is reused:</db:para>
<db:para>Since each of the child items are constructed when the model is initially populated with data, the function to add child items is straightforward:</db:para>
<db:programlisting language="cpp">void TreeItem::appendChild(std::unique_ptr&lt;TreeItem&gt; &amp;&amp;child)
{
    m_childItems.push_back(std::move(child));
}
</db:programlisting>
<db:para>Each item is able to return any of its child items when given a suitable row number. For example, in the <db:link xlink:href="qtwidgets-itemviews-simpletreemodel-example.xml#simpletreemodelstructure">above diagram</db:link>, the item marked with the letter &quot;A&quot; corresponds to the child of the root item with row = 0, the &quot;B&quot; item is a child of the &quot;A&quot; item with row = 1, and the &quot;C&quot; item is a child of the root item with row = 1.</db:para>
<db:para>The child() function returns the child that corresponds to the specified row number in the item's list of child items:</db:para>
<db:programlisting language="cpp">TreeItem *TreeItem::child(int row)
{
    return row &gt;= 0 &amp;&amp; row &lt; childCount() ? m_childItems.at(row).get() : nullptr;
}
</db:programlisting>
<db:para>The number of child items held can be found with childCount():</db:para>
<db:programlisting language="cpp">int TreeItem::childCount() const
{
    return int(m_childItems.size());
}
</db:programlisting>
<db:para>The TreeModel uses this function to determine the number of rows that exist for a given parent item.</db:para>
<db:para>The row() function reports the item's location within its parent's list of items:</db:para>
<db:programlisting language="cpp">int TreeItem::row() const
{
    if (m_parentItem == nullptr)
        return 0;
    const auto it = std::find_if(m_parentItem-&gt;m_childItems.cbegin(), m_parentItem-&gt;m_childItems.cend(),
                                 [this](const std::unique_ptr&lt;TreeItem&gt; &amp;treeItem) {
                                     return treeItem.get() == this;
                                 });

    if (it != m_parentItem-&gt;m_childItems.cend())
        return std::distance(m_parentItem-&gt;m_childItems.cbegin(), it);
    Q_ASSERT(false); // should not happen
    return -1;
}
</db:programlisting>
<db:para>Note that, although the root item (with no parent item) is automatically assigned a row number of 0, this information is never used by the model.</db:para>
<db:para>The number of columns of data in the item is trivially returned by the columnCount() function.</db:para>
<db:programlisting language="cpp">int TreeItem::columnCount() const
{
    return int(m_itemData.count());
}
</db:programlisting>
<db:para>Column data is returned by the data() function. We use the <db:link xlink:href="qlist.xml#value">QList::value</db:link>() convenience function which checks the bounds and returns a default-constructed <db:link xlink:href="qvariant.xml">QVariant</db:link> in case they are violated:</db:para>
<db:programlisting language="cpp">QVariant TreeItem::data(int column) const
{
    return m_itemData.value(column);
}
</db:programlisting>
<db:para>The item's parent is found with parent():</db:para>
<db:programlisting language="cpp">TreeItem *TreeItem::parentItem()
{
    return m_parentItem;
}
</db:programlisting>
<db:para>Note that, since the root item in the model will not have a parent, this function will return zero in that case. We need to ensure that the model handles this case correctly when we implement the TreeModel::parent() function.</db:para>
</db:section>
<db:section xml:id="treemodel-class-definition">
<db:title>TreeModel Class Definition</db:title>
<db:para>The TreeModel class is defined as follows:</db:para>
<db:programlisting language="cpp">class TreeModel : public QAbstractItemModel
{
    Q_OBJECT

public:
    Q_DISABLE_COPY_MOVE(TreeModel)

    explicit TreeModel(const QString &amp;data, QObject *parent = nullptr);
    ~TreeModel() override;

    QVariant data(const QModelIndex &amp;index, int role) const override;
    Qt::ItemFlags flags(const QModelIndex &amp;index) const override;
    QVariant headerData(int section, Qt::Orientation orientation,
                        int role = Qt::DisplayRole) const override;
    QModelIndex index(int row, int column,
                      const QModelIndex &amp;parent = {}) const override;
    QModelIndex parent(const QModelIndex &amp;index) const override;
    int rowCount(const QModelIndex &amp;parent = {}) const override;
    int columnCount(const QModelIndex &amp;parent = {}) const override;

private:
    static void setupModelData(const QList&lt;QStringView&gt; &amp;lines, TreeItem *parent);

    std::unique_ptr&lt;TreeItem&gt; rootItem;
};
</db:programlisting>
<db:para>This class is similar to most other subclasses of <db:link xlink:href="qabstractitemmodel.xml">QAbstractItemModel</db:link> that provide read-only models. Only the form of the constructor and the setupModelData() function are specific to this model. In addition, we provide a destructor to clean up when the model is destroyed.</db:para>
</db:section>
<db:section xml:id="treemodel-class-implementation">
<db:title>TreeModel Class Implementation</db:title>
<db:para>For simplicity, the model does not allow its data to be edited. As a result, the constructor takes an argument containing the data that the model will share with views and delegates:</db:para>
<db:programlisting language="cpp">TreeModel::TreeModel(const QString &amp;data, QObject *parent)
    : QAbstractItemModel(parent)
    , rootItem(std::make_unique&lt;TreeItem&gt;(QVariantList{tr(&quot;Title&quot;), tr(&quot;Summary&quot;)}))
{
    setupModelData(QStringView{data}.split(u'\n'), rootItem.get());
}
</db:programlisting>
<db:para>It is up to the constructor to create a root item for the model. This item only contains vertical header data for convenience. We also use it to reference the internal data structure that contains the model data, and it is used to represent an imaginary parent of top-level items in the model. The root item is managed with a std::unique_ptr to ensure the entire tree of item is deleted when the model is deleted.</db:para>
<db:para>The model's internal data structure is populated with items by the setupModelData() function. We will examine this function separately at the end of this document.</db:para>
<db:para>The destructor ensures that the root item and all of its descendants are deleted when the model is destroyed. This is done automatically since the root item is stored in a unique_ptr.</db:para>
<db:programlisting language="cpp">TreeModel::~TreeModel() = default;
</db:programlisting>
<db:para>Since we cannot add data to the model after it is constructed and set up, this simplifies the way that the internal tree of items is managed.</db:para>
<db:para>Models must implement an index() function to provide indexes for views and delegates to use when accessing data. Indexes are created for other components when they are referenced by their row and column numbers, and their parent model index. If an invalid model index is specified as the parent, it is up to the model to return an index that corresponds to a top-level item in the model.</db:para>
<db:para>When supplied with a model index, we first check whether it is valid. If it is not, we assume that a top-level item is being referred to; otherwise, we obtain the data pointer from the model index with its <db:link xlink:href="qmodelindex.xml#internalPointer">internalPointer</db:link>() function and use it to reference a TreeItem object. Note that all the model indexes that we construct will contain a pointer to an existing TreeItem, so we can guarantee that any valid model indexes that we receive will contain a valid data pointer.</db:para>
<db:programlisting language="cpp">QModelIndex TreeModel::index(int row, int column, const QModelIndex &amp;parent) const
{
    if (!hasIndex(row, column, parent))
        return {};

    TreeItem *parentItem = parent.isValid()
        ? static_cast&lt;TreeItem*&gt;(parent.internalPointer())
        : rootItem.get();

    if (auto *childItem = parentItem-&gt;child(row))
        return createIndex(row, column, childItem);
    return {};
}
</db:programlisting>
<db:para>Since the row and column arguments to this function refer to a child item of the corresponding parent item, we obtain the item using the TreeItem::child() function. The <db:link xlink:href="qabstractitemmodel.xml#createIndex">createIndex</db:link>() function is used to create a model index to be returned. We specify the row and column numbers, and a pointer to the item itself. The model index can be used later to obtain the item's data.</db:para>
<db:para>The way that the TreeItem objects are defined makes writing the parent() function easy:</db:para>
<db:programlisting language="cpp">QModelIndex TreeModel::parent(const QModelIndex &amp;index) const
{
    if (!index.isValid())
        return {};

    auto *childItem = static_cast&lt;TreeItem*&gt;(index.internalPointer());
    TreeItem *parentItem = childItem-&gt;parentItem();

    return parentItem != rootItem.get()
        ? createIndex(parentItem-&gt;row(), 0, parentItem) : QModelIndex{};
}
</db:programlisting>
<db:para>We only need to ensure that we never return a model index corresponding to the root item. To be consistent with the way that the index() function is implemented, we return an invalid model index for the parent of any top-level items in the model.</db:para>
<db:para>When creating a model index to return, we must specify the row and column numbers of the parent item within its own parent. We can easily discover the row number with the TreeItem::row() function, but we follow a convention of specifying 0 as the column number of the parent. The model index is created with <db:link xlink:href="qabstractitemmodel.xml#createIndex">createIndex</db:link>() in the same way as in the index() function.</db:para>
<db:para>The rowCount() function simply returns the number of child items for the TreeItem that corresponds to a given model index, or the number of top-level items if an invalid index is specified:</db:para>
<db:programlisting language="cpp">int TreeModel::rowCount(const QModelIndex &amp;parent) const
{
    if (parent.column() &gt; 0)
        return 0;

    const TreeItem *parentItem = parent.isValid()
        ? static_cast&lt;const TreeItem*&gt;(parent.internalPointer())
        : rootItem.get();

    return parentItem-&gt;childCount();
}
</db:programlisting>
<db:para>Since each item manages its own column data, the columnCount() function has to call the item's own columnCount() function to determine how many columns are present for a given model index. As with the rowCount() function, if an invalid model index is specified, the number of columns returned is determined from the root item:</db:para>
<db:programlisting language="cpp">int TreeModel::columnCount(const QModelIndex &amp;parent) const
{
    if (parent.isValid())
        return static_cast&lt;TreeItem*&gt;(parent.internalPointer())-&gt;columnCount();
    return rootItem-&gt;columnCount();
}
</db:programlisting>
<db:para>Data is obtained from the model via data(). Since the item manages its own columns, we need to use the column number to retrieve the data with the TreeItem::data() function:</db:para>
<db:programlisting language="cpp">QVariant TreeModel::data(const QModelIndex &amp;index, int role) const
{
    if (!index.isValid() || role != Qt::DisplayRole)
        return {};

    const auto *item = static_cast&lt;const TreeItem*&gt;(index.internalPointer());
    return item-&gt;data(index.column());
}
</db:programlisting>
<db:para>Note that we only support the <db:link xlink:href="qt.xml#ItemDataRole-enum">DisplayRole</db:link> in this implementation, and we also return invalid <db:link xlink:href="qvariant.xml">QVariant</db:link> objects for invalid model indexes.</db:para>
<db:para>We use the flags() function to ensure that views know that the model is read-only:</db:para>
<db:programlisting language="cpp">Qt::ItemFlags TreeModel::flags(const QModelIndex &amp;index) const
{
    return index.isValid()
        ? QAbstractItemModel::flags(index) : Qt::ItemFlags(Qt::NoItemFlags);
}
</db:programlisting>
<db:para>The headerData() function returns data that we conveniently stored in the root item:</db:para>
<db:programlisting language="cpp">QVariant TreeModel::headerData(int section, Qt::Orientation orientation,
                               int role) const
{
    return orientation == Qt::Horizontal &amp;&amp; role == Qt::DisplayRole
        ? rootItem-&gt;data(section) : QVariant{};
}
</db:programlisting>
<db:para>This information could have been supplied in a different way: either specified in the constructor, or hard coded into the headerData() function.</db:para>
</db:section>
<db:section xml:id="setting-up-the-data-in-the-model">
<db:title>Setting Up the Data in the Model</db:title>
<db:para>We use the setupModelData() function to set up the initial data in the model. This function parses a text file, extracting strings of text to use in the model, and creates item objects that record both the data and the overall model structure. Naturally, this function works in a way that is very specific to this model. We provide the following description of its behavior, and refer the reader to the example code itself for more information.</db:para>
<db:para>We begin with a text file in the following format:</db:para>
<db:programlisting language="cpp">Getting Started                         How to familiarize yourself with Qt Widgets Designer
    Launching Designer                  Running the Qt Widgets Designer application
    The User Interface                  How to interact with Qt Widgets Designer
    ...
</db:programlisting>
<db:programlisting language="cpp">Connection Editing Mode                 Connecting widgets together with signals and slots
    Connecting Objects                  Making connections in Qt Widgets Designer
    Editing Connections                 Changing existing connections
</db:programlisting>
<db:para>We process the text file with the following two rules:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para>For each pair of strings on each line, create an item (or node) in a tree structure, and place each string in a column of data in the item.</db:para>
</db:listitem>
<db:listitem>
<db:para>When the first string on a line is indented with respect to the first string on the previous line, make the item a child of the previous item created.</db:para>
</db:listitem>
</db:itemizedlist>
<db:para>To ensure that the model works correctly, it is only necessary to create instances of TreeItem with the correct data and parent item.</db:para>
</db:section>
<db:section xml:id="testing-the-model">
<db:title>Testing the model</db:title>
<db:para>Correctly implementing an item model can be challenging. The class <db:link xlink:href="qabstractitemmodeltester.xml">QAbstractItemModelTester</db:link> from the <db:link xlink:href="qttest-index.xml">Qt Test</db:link> module checks for model consistency, like the model index creation and parent-child relationships.</db:para>
<db:para>You can test your model by just passing a model instance to the class constructor, for instance as part of a Qt unit test:</db:para>
<db:programlisting language="cpp">class TestSimpleTreeModel : public QObject
{
    Q_OBJECT

private slots:
    void testTreeModel();
};

void TestSimpleTreeModel::testTreeModel()
{
    constexpr auto fileName = &quot;:/default.txt&quot;_L1;
    QFile file(fileName);
    QVERIFY2(file.open(QIODevice::ReadOnly | QIODevice::Text),
             qPrintable(fileName + &quot; cannot be opened: &quot;_L1 + file.errorString()));
    TreeModel model(QString::fromUtf8(file.readAll()));

    QAbstractItemModelTester tester(&amp;model);
}

QTEST_APPLESS_MAIN(TestSimpleTreeModel)

#include &quot;test.moc&quot;
</db:programlisting>
<db:para>To create a test which can be run using the ctest executable, add_test() is used:</db:para>
<db:programlisting language="cpp"># Unit Test

include(CTest)

qt_add_executable(simpletreemodel_tester
    test.cpp
    treeitem.cpp treeitem.h
    treemodel.cpp treemodel.h)

target_link_libraries(simpletreemodel_tester PRIVATE
    Qt6::Core
    Qt6::Test
)

if(ANDROID)
    target_link_libraries(simpletreemodel_tester PRIVATE
        Qt6::Gui
    )
endif()

qt_add_resources(simpletreemodel_tester &quot;simpletreemodel_tester&quot;
    PREFIX
        &quot;/&quot;
    FILES
        ${simpletreemodel_resource_files}
)

add_test(NAME simpletreemodel_tester
         COMMAND simpletreemodel_tester)
</db:programlisting>
</db:section>
<db:section>
<db:title>Example project</db:title>
<db:para><db:link xlink:href="https://code.qt.io/cgit/qt/qtbase.git/tree/examples/widgets/itemviews/simpletreemodel?h=6.9">Example project @ code.qt.io</db:link></db:para>
</db:section>
</db:article>
