<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en_US">
<db:info>
<db:title>D-Bus Adaptor Example</db:title>
<db:productname>QtDBus</db:productname>
<db:titleabbrev>QtDBus Reference Documentation</db:titleabbrev>
<db:extendedlink xlink:type="extended"><db:link xlink:to="qdbustypesystem.xml" xlink:type="arc" xlink:arcrole="prev" xlink:title="The Qt D-Bus Type System"/></db:extendedlink>
<db:abstract>
<db:para>QtDBus Reference Documentation.</db:para></db:abstract>
<db:pubdate>2025-06-29</db:pubdate>
<db:date>2025-06-29</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:para><db:emphasis role="bold">&lt;Unknown command&gt;<db:code>contentspage</db:code></db:emphasis>Using Qt D-Bus Adaptors</db:para>
<db:para>The following example code shows how a D-Bus interface can be implemented using an adaptor.</db:para>
<db:para>A sample usage of QDBusAbstractAdaptor is as follows:</db:para>
<db:programlisting language="cpp">class MainApplicationAdaptor: public QDBusAbstractAdaptor
{
    Q_OBJECT
    Q_CLASSINFO(&quot;D-Bus Interface&quot;, &quot;org.kde.DBus.MainApplication&quot;)
    Q_PROPERTY(QString caption READ caption WRITE setCaption)
    Q_PROPERTY(QString organizationName READ organizationName)
    Q_PROPERTY(QString organizationDomain READ organizationDomain)

private:
    QApplication *app;

public:
    MainApplicationAdaptor(QApplication *application)
        : QDBusAbstractAdaptor(application), app(application)
    {
        connect(application, SIGNAL(aboutToQuit()), SIGNAL(aboutToQuit()));
        connect(application, SIGNAL(focusChanged(QWidget*,QWidget*)),
                SLOT(focusChangedSlot(QWidget*,QWidget*)));
    }

    QString caption()
    {
        if (app-&gt;hasMainWindow())
            return app-&gt;mainWindow()-&gt;caption();
        return QString(&quot;&quot;); // must not return a null QString
    }

    void setCaption(const QString &amp;newCaption)
    {
        if (app-&gt;hasMainWindow())
            app-&gt;mainWindow()-&gt;setCaption(newCaption);
    }

    QString organizationName()
    {
        return app-&gt;organizationName();
    }

    QString organizationDomain()
    {
        return app-&gt;organizationDomain();
    }

public slots:
    Q_NOREPLY void quit()
    { app-&gt;quit(); }

    void reparseConfiguration()
    { app-&gt;reparseConfiguration(); }

    QString mainWindowObject()
    {
        if (app-&gt;hasMainWindow())
            return QString(&quot;/%1/mainwindow&quot;).arg(app-&gt;applicationName());
        return QString();
    }

    void setSessionManagement(bool enable)
    {
        if (enable)
           app-&gt;enableSessionManagement();
        else
           app-&gt;disableSessionManagement();
    }

private slots:
    void focusChangedSlot(QWidget *, QWidget *now)
    {
        if (now == app-&gt;mainWindow())
            emit mainWindowHasFocus();
    }

signals:
    void aboutToQuit();
    void mainWindowHasFocus();
};
</db:programlisting>
<db:para>The code above would create an interface that could be represented more or less in the following canonical representation:</db:para>
<db:programlisting language="cpp">interface org.kde.DBus.MainApplication
{
    property readwrite STRING caption
    property read STRING organizationName
    property read STRING organizationDomain

    method quit() annotation(&quot;org.freedesktop.DBus.Method.NoReply&quot;, &quot;true&quot;)
    method reparseConfiguration()
    method mainWindowObject(out STRING)
    method disableSessionManagement(in BOOLEAN enable)

    signal aboutToQuit()
    signal mainWindowHasFocus()
}
</db:programlisting>
<db:para>This adaptor could be used in the application's main function as follows</db:para>
<db:programlisting language="cpp">int main(int argc, char **argv)
{
    // create the QApplication object
    QApplication app(argc, argv);

    // create the MainApplication adaptor:
    new MainApplicationAdaptor(app);

    // connect to D-Bus and register as an object:
    QDBusConnection::sessionBus().registerObject(&quot;/MainApplication&quot;, &amp;app);

    // add main window, etc.
    [...]

    app.exec();
}
</db:programlisting>
<db:para>Break-down analysis: </db:para>
<db:section xml:id="the-header">
<db:title>The header</db:title>
<db:para>The header of the example is:</db:para>
<db:programlisting language="cpp">class MainApplicationAdaptor: public QDBusAbstractAdaptor
{
    Q_OBJECT
    Q_CLASSINFO(&quot;D-Bus Interface&quot;, &quot;org.kde.DBus.MainApplication&quot;)
</db:programlisting>
<db:para>The code does the following:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para>it declares the adaptor MainApplicationAdaptor, which descends from QDBusAbstractAdaptor</db:para>
</db:listitem>
<db:listitem>
<db:para>it declares the Qt meta-object data using the <db:link xlink:href="qobject.xml#Q_OBJECT">Q_OBJECT</db:link> macro</db:para>
</db:listitem>
<db:listitem>
<db:para>it declares the name of the D-Bus interface it implements.</db:para>
</db:listitem>
</db:itemizedlist>
</db:section>
<db:section xml:id="the-properties">
<db:title>The properties</db:title>
<db:para>The properties are declared as follows:</db:para>
<db:programlisting language="cpp">    Q_PROPERTY(QString caption READ caption WRITE setCaption)
    Q_PROPERTY(QString organizationName READ organizationName)
    Q_PROPERTY(QString organizationDomain READ organizationDomain)
</db:programlisting>
<db:para>And are implemented as follows:</db:para>
<db:programlisting language="cpp">QString caption()
{
    if (app-&gt;hasMainWindow())
        return app-&gt;mainWindow()-&gt;caption();
    return QString();
}

void setCaption(const QString &amp;newCaption)
{
    if (app-&gt;hasMainWindow())
        app-&gt;mainWindow()-&gt;setCaption(newCaption);
}

QString organizationName()
{
    return app-&gt;organizationName();
}

QString organizationDomain()
{
    return app-&gt;organizationDomain();
}
</db:programlisting>
<db:para>The code declares three properties: one of them is a read-write property called &quot;caption&quot; of string type. The other two are read-only, also of the string type.</db:para>
<db:para>The properties organizationName and organizationDomain are simple relays of the app object's organizationName and organizationDomain properties. However, the caption property requires verifying if the application has a main window associated with it: if there isn't any, the caption property is empty. Note how it is possible to access data defined in other objects through the getter/setter functions.</db:para>
</db:section>
<db:section xml:id="the-constructor">
<db:title>The constructor</db:title>
<db:para>The constructor:</db:para>
<db:programlisting language="cpp">MyInterfaceAdaptor(QApplication *application)
    : QDBusAbstractAdaptor(application), app(application)
{
    connect(application, SIGNAL(aboutToQuit()), SIGNAL(aboutToQuit());
    connect(application, SIGNAL(focusChanged(QWidget*,QWidget*)),
            SLOT(focusChangedSlot(QWidget*,QWidget*)));
}
</db:programlisting>
<db:para>The constructor does the following:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para>it initialises its base class (QDBusAbstractAdaptor) with the parent object it is related to.</db:para>
</db:listitem>
<db:listitem>
<db:para>it stores the app pointer in a member variable. Note that it would be possible to access the same object using the QDBusAbstractAdaptor::object() function, but it would be necessary to use <db:code role="parameter">static_cast&lt;&gt;</db:code> to properly access the methods in QApplication that are not part of <db:link xlink:href="qobject.xml">QObject</db:link>.</db:para>
</db:listitem>
<db:listitem>
<db:para>it connects the application's signal <db:code role="parameter">aboutToQuit</db:code> to its own signal <db:code role="parameter">aboutToQuit</db:code>.</db:para>
</db:listitem>
<db:listitem>
<db:para>it connects the application's signal <db:code role="parameter">focusChanged</db:code> to a private slot to do some further processing before emitting a D-Bus signal.</db:para>
</db:listitem>
</db:itemizedlist>
<db:para>Note that there is no destructor in the example. An eventual destructor could be used to emit one last signal before the object is destroyed, for instance.</db:para>
</db:section>
<db:section xml:id="slots-methods">
<db:title>Slots/methods</db:title>
<db:para>The public slots in the example (which will be exported as D-Bus methods) are the following:</db:para>
<db:programlisting language="cpp">public slots:
    Q_NOREPLY void quit()
    { app-&gt;quit(); }

    void reparseConfiguration()
    { app-&gt;reparseConfiguration(); }

    QString mainWindowObject()
    {
        if (app-&gt;hasMainWindow())
            return QString(&quot;/%1/mainwindow&quot;).arg(app-&gt;applicationName());
        return QString();
    }

    void setSessionManagement(bool enable)
    {
        if (enable)
           app-&gt;enableSessionManagement();
        else
           app-&gt;disableSessionManagement();
    }
</db:programlisting>
<db:para>This snippet of code defines 4 methods with different properties each:</db:para>
<db:orderedlist numeration="arabic">
<db:listitem>
<db:para><db:code>quit</db:code>: this method takes no parameters and is defined to be asynchronous. That is, callers are expected to use &quot;fire-and-forget&quot; mechanism when calling this method, since it provides no useful reply. This is represented in D-Bus by the use of the org.freedesktop.DBus.Method.NoReply annotation. See <db:link xlink:href="qdbusabstractadaptor-qtdbus-proxy.xml#Q_NOREPLY">Q_NOREPLY</db:link> for more information on asynchronous methods</db:para>
</db:listitem>
<db:listitem>
<db:para><db:code>reparseConfiguration</db:code>: this simple method, with no input or output arguments simply relays the call to the application's reparseConfiguration member function.</db:para>
</db:listitem>
<db:listitem>
<db:para><db:code>mainWindowObject</db:code>: this method takes no input parameter, but returns one string output argument, containing the path to the main window object (if the application has a main window), or an empty string if it has no main window. Note that this method could have also been written: void mainWindowObject(<db:link xlink:href="qstring.xml">QString</db:link> &amp;path).</db:para>
</db:listitem>
<db:listitem>
<db:para><db:code>setSessionManagement</db:code>: this method takes one input argument (a boolean) and, depending on its value, it calls one function or another in the application.</db:para>
</db:listitem>
</db:orderedlist>
<db:para>See also: <db:link xlink:href="qdbusabstractadaptor-qtdbus-proxy.xml#Q_NOREPLY">Q_NOREPLY</db:link>.</db:para>
</db:section>
<db:section xml:id="signals">
<db:title>Signals</db:title>
<db:para>The signals in this example are defined as follows:</db:para>
<db:programlisting language="cpp">signals:
    void aboutToQuit();
    void mainWindowHasFocus();
</db:programlisting>
<db:para>However, signal definition isn't enough: signals have to be emitted. One simple way of emitting signals is to connect another signal to them, so that Qt's signal handling system chains them automatically. This is what is done for the <db:code role="parameter">aboutToQuit</db:code> signal.</db:para>
<db:para>When this is the case, one can use the QDBusAbstractAdaptor::setAutoRelaySignals to automatically connect every signal from the real object to the adaptor.</db:para>
<db:para>When simple signal-to-signal connection isn't enough, one can use a private slot do do some work. This is what was done for the mainWindowHasFocus signal:</db:para>
<db:programlisting language="cpp">private slots:
    void focusChangedSlot(QWidget *, QWidget *now)
    {
        if (now == app-&gt;mainWindow())
            emit mainWindowHasFocus();
    }
</db:programlisting>
<db:para>This private slot (which will not be exported as a method via D-Bus) was connected to the <db:code>focusChanged</db:code> signal in the adaptor's constructor. It is therefore able to shape the application's signal into what the interface expects it to be.</db:para>
</db:section>
</db:article>
