<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en">
<db:info>
<db:title>Audiolevels Example</db:title>
<db:productname>QtDataVisualization</db:productname>
<db:edition>Qt Data Visualization | Commercial or GPLv3</db:edition>
<db:titleabbrev>Qt Data Visualization Reference Documentation</db:titleabbrev>
<db:abstract>
<db:para>Simple application showing real time audio data.</db:para>
</db:abstract>
<db:pubdate>2024-12-27</db:pubdate>
<db:date>2024-12-27</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:para>The audiolevels example shows how feed real-time dynamic data to a graph using <db:link xlink:href="q3dbars.xml">Q3DBars</db:link>.</db:para>
<db:para>This example reads the audio levels from a microphone and displays those levels in a bar graph. To increase the load for demonstration purposes, and to make the graph little fancier, slightly modified data is used to fill multiple rows.</db:para>
<db:mediaobject>
<db:imageobject>
<db:imagedata fileref="images/audiolevels-example.png"/>
</db:imageobject>
</db:mediaobject>
<db:para>The interesting stuff happens in <db:code>AudioLevels</db:code> and <db:code>AudioLevelsIODevice</db:code> classes, so we concentrate on those and skip explaining the basic <db:link xlink:href="q3dbars.xml">Q3DBars</db:link> functionality - for that see <db:link xlink:href="qtdatavisualization-bars-example.xml">Bars Example</db:link>.</db:para>
<db:section xml:id="running-the-example">
<db:title>Running the Example</db:title>
<db:para>To run the example from <db:link xlink:href="http://doc.qt.io/qtcreator/index.html">Qt Creator</db:link>, open the <db:emphasis role="bold">Welcome</db:emphasis> mode and select the example from <db:emphasis role="bold">Examples</db:emphasis>. For more information, visit <db:link xlink:href="http://doc.qt.io/qtcreator/creator-build-example-application.html">Building and Running an Example</db:link>.</db:para>
</db:section>
<db:section xml:id="visualizing-audio-levels">
<db:title>Visualizing Audio Levels</db:title>
<db:para><db:code>AudioLevelsIODevice</db:code> subclasses <db:link xlink:href="qiodevice.xml">QIODevice</db:link> and is given as input device for <db:link xlink:href="qaudioinput.xml">QAudioInput</db:link> class, so it receives microphone data.</db:para>
<db:para>In the header file for <db:code>AudioLevels</db:code> class we declare necessary members:</db:para>
<db:programlisting language="cpp">Q3DBars *m_graph;
AudioLevelsIODevice *m_device;
QAudioInput *m_audioInput;
</db:programlisting>
<db:para>And initialize the microphone listening in the source:</db:para>
<db:programlisting language="cpp">QAudioDeviceInfo inputDevice = QAudioDeviceInfo::defaultInputDevice();

if (inputDevice.supportedSampleRates().size() &amp;gt; 0
        &amp;amp;&amp;amp; inputDevice.supportedChannelCounts().size() &amp;gt; 0
        &amp;amp;&amp;amp; inputDevice.supportedSampleSizes().size() &amp;gt; 0
        &amp;amp;&amp;amp; inputDevice.supportedCodecs().size() &amp;gt; 0) {
    QAudioFormat formatAudio;
    formatAudio.setSampleRate(inputDevice.supportedSampleRates().at(0));
    formatAudio.setChannelCount(inputDevice.supportedChannelCounts().at(0));
    formatAudio.setSampleSize(inputDevice.supportedSampleSizes().at(0));
    formatAudio.setCodec(inputDevice.supportedCodecs().at(0));
    formatAudio.setByteOrder(QAudioFormat::LittleEndian);
    formatAudio.setSampleType(QAudioFormat::UnSignedInt);

    m_audioInput = new QAudioInput(inputDevice, formatAudio, this);
#ifdef Q_OS_MAC
    // OS X seems to wait for entire buffer to fill before calling writeData, so use smaller buffer
    m_audioInput-&amp;gt;setBufferSize(256);
#else
    m_audioInput-&amp;gt;setBufferSize(1024);
#endif

    m_device = new AudioLevelsIODevice(m_graph-&amp;gt;seriesList().at(0)-&amp;gt;dataProxy(), this);
    m_device-&amp;gt;open(QIODevice::WriteOnly);

    m_audioInput-&amp;gt;start(m_device);
} else {
    // No graph content can be shown, so add a custom warning label
    QCustom3DLabel *titleLabel = new QCustom3DLabel(&quot;No valid audio input device found&quot;,
                                                    QFont(),
                                                    QVector3D(0.2f, 0.2f, 0.0f),
                                                    QVector3D(1.0f, 1.0f, 0.0f),
                                                    QQuaternion());
    titleLabel-&amp;gt;setPositionAbsolute(true);
    titleLabel-&amp;gt;setFacingCamera(true);
    m_graph-&amp;gt;addCustomItem(titleLabel);
}
</db:programlisting>
<db:para>In the header file for <db:code>AudioLevelsIODevice</db:code> class we store pointers to the data proxy and also the data array we give to the proxy, because we reuse the same array to keep memory reallocations to the minimum:</db:para>
<db:programlisting language="cpp">QBarDataProxy *m_proxy;
QBarDataArray *m_array;
</db:programlisting>
<db:para>In the source file we define some static constants to define size of the data array and the middle row index, as well as the resolution of the visualization. You may need to adjust these values to get decent performance in low-end devices:</db:para>
<db:programlisting language="cpp">static const int resolution = 8;
static const int rowSize = 800;
static const int rowCount = 7; // Must be odd number
static const int middleRow = rowCount / 2;
</db:programlisting>
<db:para>The <db:code>resolution</db:code> constant indicates the sample rate, for example, value 8 means every eighth byte from audio input is visualized. This is necessary to make the data readable, as it would otherwise make the graph scroll too fast.</db:para>
<db:para>In the <db:code>AudioLevelsIODevice</db:code> class constructor we initialize the data array:</db:para>
<db:programlisting language="cpp">m_array-&amp;gt;reserve(rowCount);
for (int i = 0; i &amp;lt; rowCount; i++)
    m_array-&amp;gt;append(new QBarDataRow(rowSize));
</db:programlisting>
<db:para>The <db:code>AudioLevelsIODevice::writeData</db:code> function is called whenever there is new audio data available to be visualized. There we move the old data along the rows and insert new data in the beginning of the rows:</db:para>
<db:programlisting language="cpp">qint64 AudioLevelsIODevice::writeData(const char *data, qint64 maxSize)
{
    // The amount of new data available.
    int newDataSize = maxSize / resolution;

    // If we get more data than array size, we need to adjust the start index for new data.
    int newDataStartIndex = qMax(0, (newDataSize - rowSize));

    // Move the old data ahead in the rows (only do first half of rows + middle one now).
    // If the amount of new data was larger than row size, skip copying.
    if (!newDataStartIndex) {
        for (int i = 0; i &amp;lt;= middleRow; i++) {
            QBarDataItem *srcPos = m_array-&amp;gt;at(i)-&amp;gt;data();
            QBarDataItem *dstPos = srcPos + newDataSize;
            memmove((void *)dstPos, (void *)srcPos, (rowSize - newDataSize) * sizeof(QBarDataItem));
        }
    }

    // Insert data in reverse order, so that newest data is always at the front of the row.
    int index = 0;
    for (int i = newDataSize - 1; i &amp;gt;= newDataStartIndex; i--) {
        // Add 0.01 to the value to avoid gaps in the graph (i.e. zero height bars).
        // Also, scale to 0...100
        float value = float(quint8(data[resolution * i]) - 128) / 1.28f + 0.01f;
        (*m_array-&amp;gt;at(middleRow))[index].setValue(value);
        // Insert a fractional value into front half of the rows.
        for (int j = 1; j &amp;lt;= middleRow; j++) {
            float fractionalValue = value / float(j + 1);
            (*m_array-&amp;gt;at(middleRow - j))[index].setValue(fractionalValue);
        }
        index++;
    }

    // Copy the front half of rows to the back half for symmetry.
    index = 0;
    for (int i = rowCount - 1; i &amp;gt; middleRow; i--) {
        QBarDataItem *srcPos = m_array-&amp;gt;at(index++)-&amp;gt;data();
        QBarDataItem *dstPos = m_array-&amp;gt;at(i)-&amp;gt;data();
        memcpy((void *)dstPos, (void *)srcPos, rowSize * sizeof(QBarDataItem));
    }

    // Reset the proxy array now that data has been updated to trigger a redraw.
    m_proxy-&amp;gt;resetArray(m_array);

    return maxSize;
}
</db:programlisting>
<db:para>We use a couple of techniques here to improve performance. First, we reuse the existing data array, as this allows us to avoid any extra memory allocations in our application code. This also means the data array dimensions do not change, which further improves efficiency in the bar graph renderer. Secondly, since each row is a <db:link xlink:href="qvector.xml">QVector</db:link> of bar data items, which do not allocate any data that needs deletion, we can utilize <db:code>memmove</db:code> and <db:code>memcpy</db:code> functions to quickly move and copy data around.</db:para>
<db:note>
<db:para>In the future versions of Qt Data Visualization, <db:link xlink:href="qbardataitem.xml">QBarDataItem</db:link> might get extended so that it does allocate some memory to store other optional bar properties besides the value. In use cases where those optional properties are used, using <db:code>memmove</db:code> and <db:code>memcpy</db:code> could lead to memory leaks, so use them with care.</db:para>
</db:note>
</db:section>
<db:section>
<db:title>List of Files</db:title>
<db:para>Files:</db:para>
<db:section>
<db:title>List of Files</db:title>
<db:itemizedlist>
<db:listitem>
<db:para><db:link xlink:href="audiolevels/audiolevels.cpp">audiolevels/audiolevels.cpp</db:link></db:para></db:listitem>
<db:listitem>
<db:para><db:link xlink:href="audiolevels/audiolevels.h">audiolevels/audiolevels.h</db:link></db:para></db:listitem>
<db:listitem>
<db:para><db:link xlink:href="audiolevels/audiolevels.pro">audiolevels/audiolevels.pro</db:link></db:para></db:listitem>
<db:listitem>
<db:para><db:link xlink:href="audiolevels/audiolevelsiodevice.cpp">audiolevels/audiolevelsiodevice.cpp</db:link></db:para></db:listitem>
<db:listitem>
<db:para><db:link xlink:href="audiolevels/audiolevelsiodevice.h">audiolevels/audiolevelsiodevice.h</db:link></db:para></db:listitem>
<db:listitem>
<db:para><db:link xlink:href="audiolevels/main.cpp">audiolevels/main.cpp</db:link></db:para></db:listitem>
</db:itemizedlist>
</db:section>
</db:section></db:article>
