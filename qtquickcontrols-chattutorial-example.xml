<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en">
<db:info>
<db:title>Qt Quick Controls - Chat Tutorial</db:title>
<db:productname>QtQuickControls</db:productname>
<db:edition>Qt 6.1.3 Reference Documentation</db:edition>
<db:titleabbrev>Qt Quick Controls Reference Documentation</db:titleabbrev>
<db:abstract>
<db:para>Tutorial about writing a basic chat client using Qt Quick Controls.</db:para>
</db:abstract>
<db:pubdate>2024-12-27</db:pubdate>
<db:date>2024-12-27</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:para>This tutorial shows how to write a basic chat application using Qt Quick Controls. It will also explain how to integrate an SQL database into a Qt application.</db:para>
<db:section xml:id="chapter-1-setting-up">
<db:title>Chapter 1: Setting Up</db:title>
<db:para>When setting up a new project, it's easiest to use <db:link xlink:href="https://doc.qt.io/qtcreator/index.html">Qt Creator</db:link>. For this project, we chose the <db:link xlink:href="https://doc.qt.io/qtcreator/quick-projects.html">Qt Quick application</db:link> template, which creates a basic &quot;Hello World&quot; application with the following files:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:code>MainForm.ui.qml</db:code> - Defines the default UI</db:para>
</db:listitem>
<db:listitem>
<db:para><db:code>main.qml</db:code> - Embeds the default UI in a Window</db:para>
</db:listitem>
<db:listitem>
<db:para><db:code>qml.qrc</db:code> - Lists the <db:code>.qml</db:code> files that are built into the binary</db:para>
</db:listitem>
<db:listitem>
<db:para><db:code>main.cpp</db:code> - Loads <db:code>main.qml</db:code></db:para>
</db:listitem>
<db:listitem>
<db:para><db:code>chattutorial.pro</db:code> - Provides the qmake configuration</db:para>
</db:listitem>
</db:itemizedlist>
<db:note>
<db:para>Delete the <db:code>MainForm.ui.qml</db:code> from the project as we will not use it in this tutorial.</db:para>
</db:note>
<db:section xml:id="main-cpp">
<db:title>main.cpp</db:title>
<db:para>The default code in <db:code>main.cpp</db:code> has two includes:</db:para>
<db:programlisting language="cpp">#include &amp;lt;QGuiApplication&amp;gt;
#include &amp;lt;QQmlApplicationEngine&amp;gt;
</db:programlisting>
<db:para>The first gives us access to <db:link xlink:href="qguiapplication.xml">QGuiApplication</db:link>. All Qt applications require an application object, but the precise type depends on what the application does. <db:link xlink:href="qcoreapplication.xml">QCoreApplication</db:link> is sufficient for non-graphical applications. <db:link xlink:href="qguiapplication.xml">QGuiApplication</db:link> is sufficient for graphical applications that do not use <db:link xlink:href="qtwidgets-index.xml">Qt Widgets</db:link>, while <db:link xlink:href="qapplication.xml">QApplication</db:link> is required for those that do.</db:para>
<db:para>The second include makes <db:link xlink:href="qqmlapplicationengine.xml">QQmlApplicationEngine</db:link> available, along with some useful functions required for making C++ types accessible from QML.</db:para>
<db:para>Within <db:code>main()</db:code>, we set up the application object and QML engine:</db:para>
<db:programlisting language="cpp">int main(int argc, char *argv[])
{
    QGuiApplication app(argc, argv);

    QQmlApplicationEngine engine;
    engine.load(QUrl(QStringLiteral(&quot;qrc:/main.qml&quot;)));

    return app.exec();
}
</db:programlisting>
<db:para>It begins with enabling <db:link xlink:href="highdpi.xml">high DPI scaling</db:link>, which is not part of the default code. It is necessary to do so before the application object is constructed.</db:para>
<db:para>After that's done, we construct the application object, passing any application arguments provided by the user.</db:para>
<db:para>Next, the QML engine is created. <db:link xlink:href="qqmlapplicationengine.xml">QQmlApplicationEngine</db:link> is a convenient wrapper over <db:link xlink:href="qqmlengine.xml">QQmlEngine</db:link>, providing the <db:link xlink:href="qqmlapplicationengine.xml#load">load</db:link>() function to easily load QML for an application. It also adds some convenience for using <db:link xlink:href="qtquickcontrols2-fileselectors.xml">file selectors</db:link>.</db:para>
<db:para>Once we've set up things in C++, we can move on to the user interface in QML.</db:para>
</db:section>
<db:section xml:id="main-qml">
<db:title>main.qml</db:title>
<db:para>Let's modify the default QML code to suit our needs.</db:para>
<db:programlisting language="cpp">import QtQuick
import QtQuick.Controls
</db:programlisting>
<db:para>First, import the <db:link xlink:href="qtquick-index.xml">Qt Quick</db:link> module. This gives us access to graphical primitives such as <db:link xlink:href="qml-qtquick-item.xml">Item</db:link>, <db:link xlink:href="qml-qtquick-rectangle.xml">Rectangle</db:link>, <db:link xlink:href="qml-qtquick-text.xml">Text</db:link>, and so on. For the full list of types, see the <db:link xlink:href="qtquick-qmlmodule.xml">Qt Quick QML Types</db:link> documentation.</db:para>
<db:para>Next, import the Qt Quick Controls module. Amongst other things, this provides access to <db:link xlink:href="qml-qtquick-controls2-applicationwindow.xml">ApplicationWindow</db:link>, which will replace the existing root type, <db:code>Window</db:code>:</db:para>
<db:programlisting language="cpp">ApplicationWindow {
    width: 540
    height: 960
    visible: true
    ...
    }
</db:programlisting>
<db:para><db:link xlink:href="qml-qtquick-controls2-applicationwindow.xml">ApplicationWindow</db:link> is a <db:link xlink:href="qml-qtquick-window.xml">Window</db:link> with some added convenience for creating a <db:link xlink:href="qml-qtquick-controls2-applicationwindow.xml#header-attached-prop">header</db:link> and a <db:link xlink:href="qml-qtquick-controls2-applicationwindow.xml#footer-attached-prop">footer</db:link>. It also provides the foundation for <db:link xlink:href="qml-qtquick-controls2-popup.xml">popups</db:link> and supports some basic styling, such as the background <db:link xlink:href="qml-qtquick-window.xml#color-prop">color</db:link>.</db:para>
<db:para>There are three properties that are almost always set when using <db:link xlink:href="qml-qtquick-controls2-applicationwindow.xml">ApplicationWindow</db:link>: <db:link xlink:href="qml-qtquick-window.xml#width-prop">width</db:link>, <db:link xlink:href="qml-qtquick-window.xml#height-prop">height</db:link>, and <db:link xlink:href="qml-qtquick-window.xml#visible-prop">visible</db:link>. Once we've set these, we have a properly sized, empty window ready to be filled with content.</db:para>
<db:note>
<db:para>The <db:code>title</db:code> property from the default code is removed.</db:para>
</db:note>
<db:para>The first <db:emphasis>&quot;screen&quot;</db:emphasis> in our application will be a list of contacts. It would be nice to have some text at the top of each screen that describes its purpose. The header and footer properties of <db:link xlink:href="qml-qtquick-controls2-applicationwindow.xml">ApplicationWindow</db:link> could work in this situation. They have some characteristics that make them ideal for items that should be displayed on every screen of an application:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para>They are anchored to the top and bottom of the window, respectively.</db:para>
</db:listitem>
<db:listitem>
<db:para>They fill the width of the window.</db:para>
</db:listitem>
</db:itemizedlist>
<db:para>However, when the contents of the header and footer varies depending on which screen the user is viewing, it is much easier to use <db:link xlink:href="qml-qtquick-controls2-page.xml">Page</db:link>. For now, we'll just add one page, but in the next chapter, we'll demonstrate how to navigate between several pages.</db:para>
<db:programlisting language="cpp">    Page {
        anchors.fill: parent
        header: Label {
            padding: 10
            text: qsTr(&quot;Contacts&quot;)
            font.pixelSize: 20
            horizontalAlignment: Text.AlignHCenter
            verticalAlignment: Text.AlignVCenter
        }
    }
</db:programlisting>
<db:para>We replace the default <db:code>MainForm {...}</db:code> code block with a Page, which is sized to occupy all the space on the window using the <db:link xlink:href="qml-qtquick-item.xml#anchors.fill-prop">anchors.fill</db:link> property.</db:para>
<db:para>Then, we assign a <db:link xlink:href="qml-qtquick-controls2-label.xml">Label</db:link> to its <db:link xlink:href="qml-qtquick-controls2-page.xml#header-prop">header</db:link> property. Label extends the primitive <db:link xlink:href="qml-qtquick-text.xml">Text</db:link> item from the Qt Quick module by adding <db:link xlink:href="qtquickcontrols2-styles.xml">styling</db:link> and <db:link xlink:href="qml-qtquick-controls2-control.xml#font-prop">font</db:link> inheritance. This means that a Label can look different depending on which style is in use, and can also propagate its pixel size to its children.</db:para>
<db:para>We want some distance between the top of the application window and the text, so we set the <db:link xlink:href="qml-qtquick-text.xml#padding-prop">padding</db:link> property. This allocates extra space on each side of the label (within its bounds). We can also explicitly set the <db:link xlink:href="qml-qtquick-text.xml#topPadding-prop">topPadding</db:link> and <db:link xlink:href="qml-qtquick-text.xml#bottomPadding-prop">bottomPadding</db:link> properties instead.</db:para>
<db:para>We set the text of the label using the <db:code>qsTr()</db:code> function, which ensures that the text can be translated by <db:link xlink:href="i18n-source-translation.xml">Qt's translation system</db:link>. It's a good practice to follow for text that is visible to the end users of your application.</db:para>
<db:para>By default, text is vertically aligned to the top of its bounds, while the horizontal alignment depends on the natural direction of the text; for example, text that is read from left to right will be aligned to the left. If we used these defaults, our text would be at the top-left corner of the window. This is not desirable for a header, so we align the text to the center of its bounds, both horizontally and vertically.</db:para>
</db:section>
<db:section xml:id="the-project-file">
<db:title>The Project File</db:title>
<db:para>The <db:code>.pro</db:code> or <db:link xlink:href="qmake-project-files.xml">project</db:link> file contains all of the information needed by <db:link xlink:href="qmake-manual.xml">qmake</db:link> to generate a Makefile, which is then used to compile and link the application.</db:para>
<db:programlisting language="cpp">TEMPLATE = app
</db:programlisting>
<db:para>The first line tells <db:code>qmake</db:code> which kind of project this is. We're building an application, so we use the <db:code>app</db:code> template.</db:para>
<db:programlisting language="cpp">QT += qml quick
</db:programlisting>
<db:para>The next line declares the Qt libraries that we want to use from C++.</db:para>
<db:programlisting language="cpp">CONFIG += c++11
</db:programlisting>
<db:para>This line states that a C++11 compatible compiler is required to build the project.</db:para>
<db:programlisting language="cpp">SOURCES += main.cpp
</db:programlisting>
<db:para>The <db:code>SOURCES</db:code> variable lists all of the source files that should be compiled. A similar variable, <db:code>HEADERS</db:code>, is available for header files.</db:para>
<db:programlisting language="cpp">RESOURCES += qml.qrc
</db:programlisting>
<db:para>The next line tells <db:code>qmake</db:code> that we have a collection of <db:link xlink:href="resources.xml">resources</db:link> that should be built into the executable.</db:para>
<db:programlisting language="cpp">target.path = $$[QT_INSTALL_EXAMPLES]/quickcontrols2/chattutorial/chapter1-settingup
</db:programlisting>
<db:para>This line replaces deployment settings that come with the default project file. It determines where the example is copied, on running &quot;<db:code>make install</db:code>&quot;.</db:para>
<db:para>Now we can build and run the application:</db:para>
<db:mediaobject>
<db:imageobject>
<db:imagedata fileref="images/qtquickcontrols2-chattutorial-chapter1.png"/>
</db:imageobject>
</db:mediaobject>
<db:para/>
</db:section>
</db:section>
<db:section xml:id="chapter-2-lists">
<db:title>Chapter 2: Lists</db:title>
<db:para>In this chapter, we'll explain how to create a list of interactive items using <db:link xlink:href="qml-qtquick-listview.xml">ListView</db:link> and <db:link xlink:href="qml-qtquick-controls2-itemdelegate.xml">ItemDelegate</db:link>.</db:para>
<db:para><db:link xlink:href="qml-qtquick-listview.xml">ListView</db:link> comes from the Qt Quick module, and displays a list of items populated from a <db:link xlink:href="qtquick-modelviewsdata-modelview.xml">model</db:link>. <db:link xlink:href="qml-qtquick-controls2-itemdelegate.xml">ItemDelegate</db:link> comes from the Qt Quick Controls module, and provides a standard view item for use in views and controls such as <db:link xlink:href="qml-qtquick-listview.xml">ListView</db:link> and <db:link xlink:href="qml-qtquick-controls2-combobox.xml">ComboBox</db:link>. For example, each <db:link xlink:href="qml-qtquick-controls2-itemdelegate.xml">ItemDelegate</db:link> can display text, be checked on and off, and react to mouse clicks.</db:para>
<db:para>Here is our <db:link xlink:href="qml-qtquick-listview.xml">ListView</db:link>:</db:para>
<db:programlisting language="cpp">        ...

        ListView {
            id: listView
            anchors.fill: parent
            topMargin: 48
            leftMargin: 48
            bottomMargin: 48
            rightMargin: 48
            spacing: 20
            model: [&quot;Albert Einstein&quot;, &quot;Ernest Hemingway&quot;, &quot;Hans Gude&quot;]
            delegate: ItemDelegate {
                text: modelData
                width: listView.width - listView.leftMargin - listView.rightMargin
                height: avatar.implicitHeight
                leftPadding: avatar.implicitWidth + 32

                Image {
                    id: avatar
                    source: &quot;qrc:/&quot; + modelData.replace(&quot; &quot;, &quot;_&quot;) + &quot;.png&quot;
                }
            }
        }
        ...
</db:programlisting>
<db:section xml:id="sizing-and-positioning">
<db:title>Sizing and Positioning</db:title>
<db:para>The first thing we do is set a size for the view. It should fill the available space on the page, so we use <db:link xlink:href="qml-qtquick-item.xml#anchors.fill-prop">anchors.fill</db:link>. Note that Page ensures that its header and footer have enough of their own space reserved, so the view in this case will sit below the header, for example.</db:para>
<db:para>Next, we set <db:link xlink:href="qml-qtquick-flickable.xml#leftMargin-prop">margins</db:link> around the <db:link xlink:href="qml-qtquick-listview.xml">ListView</db:link> to put some distance between it and the edges of the window. The margin properties reserve space within the bounds of the view, which means that the empty areas can still be <db:emphasis>&quot;flicked&quot;</db:emphasis> by the user.</db:para>
<db:para>The items should be nicely spaced out within the view, so the <db:link xlink:href="qml-qtquick-listview.xml#spacing-prop">spacing</db:link> property is set to <db:code>20</db:code>.</db:para>
</db:section>
<db:section xml:id="model">
<db:title>Model</db:title>
<db:para>In order to quickly populate the view with some items, we've used a JavaScript array as the model. One of the greatest strengths of QML is its ability to make prototyping an application extremely quick, and this is an example of that. It's also possible to simply assign a <db:link xlink:href="qtquick-modelviewsdata-modelview.xml#integers-as-models">number</db:link> to the model property to indicate how many items you need. For example, if you assign <db:code>10</db:code> to the <db:code>model</db:code> property, each item's display text will be a number from <db:code>0</db:code> to <db:code>9</db:code>.</db:para>
<db:para>However, once the application gets past the prototype stage, it quickly becomes necessary to use some real data. For this, it's best to use a proper C++ model by <db:link xlink:href="qabstractitemmodel.xml">subclassing QAbstractItemModel</db:link>.</db:para>
</db:section>
<db:section xml:id="delegate">
<db:title>Delegate</db:title>
<db:para>On to the <db:link xlink:href="qml-qtquick-listview.xml#delegate-prop">delegate</db:link>. We assign the corresponding text from the model to the <db:link xlink:href="qml-qtquick-controls2-abstractbutton.xml#text-prop">text</db:link> property of <db:link xlink:href="qml-qtquick-controls2-itemdelegate.xml">ItemDelegate</db:link>. The exact manner in which the data from the model is made available to each delegate depends on the type of model used. See <db:link xlink:href="qtquick-modelviewsdata-modelview.xml">Models and Views in Qt Quick</db:link> for more information.</db:para>
<db:para>In our application, the width of each item in the view should be the same as the width of the view. This ensures that the user has a lot of room with which to select a contact from the list, which is an important factor on devices with small touch screens, like mobile phones. However, the width of the view includes our <db:code>48</db:code> pixel margins, so we must account for that in our assignment to the width property.</db:para>
<db:para>Next, we define an <db:link xlink:href="qml-qtquick-image.xml">Image</db:link>. This will display a picture of the user's contact. The image will be <db:code>40</db:code> pixels wide and <db:code>40</db:code> pixels high. We'll base the height of the delegate on the image's height, so that we don't have any empty vertical space.</db:para>
<db:mediaobject>
<db:imageobject>
<db:imagedata fileref="images/qtquickcontrols2-chattutorial-chapter2.png"/>
</db:imageobject>
</db:mediaobject>
<db:para/>
<db:para/>
</db:section>
</db:section>
<db:section xml:id="chapter-3-navigation">
<db:title>Chapter 3: Navigation</db:title>
<db:para>In this chapter, you'll learn how to use <db:link xlink:href="qml-qtquick-controls2-stackview.xml">StackView</db:link> to navigate between pages in an application. Here's the revised <db:code>main.qml</db:code>:</db:para>
<db:programlisting language="cpp">import QtQuick
import QtQuick.Controls

ApplicationWindow {
    id: window
    width: 540
    height: 960
    visible: true

    StackView {
        id: stackView
        anchors.fill: parent
        initialItem: ContactPage {}
    }
}
</db:programlisting>
<db:section xml:id="navigating-with-stackview">
<db:title>Navigating with StackView</db:title>
<db:para>As its name suggests, <db:link xlink:href="qml-qtquick-controls2-stackview.xml">StackView</db:link> provides stack-based navigation. The last item to be <db:emphasis>&quot;pushed&quot;</db:emphasis> onto the stack is the first one to be removed, and the top-most item is always the one that is visible.</db:para>
<db:para>In the same manner as we did with Page, we tell the <db:link xlink:href="qml-qtquick-controls2-stackview.xml">StackView</db:link> to fill the application window. The only thing left to do after that is to give it an item to display, via <db:link xlink:href="qml-qtquick-controls2-stackview.xml#initialItem-prop">initialItem</db:link>. <db:link xlink:href="qml-qtquick-controls2-stackview.xml">StackView</db:link> accepts <db:link xlink:href="qml-qtquick-item.xml">items</db:link>, <db:link xlink:href="qml-qtqml-component.xml">components</db:link> and <db:link xlink:href="qml-url.xml">URLs</db:link>.</db:para>
<db:para>You'll notice that we moved the code for the contact list into <db:code>ContactPage.qml</db:code>. It's a good idea to do this as soon as you have a general idea of which screens your application will contain. Doing so not only makes your code easier to read, but ensures that items are only instantiated from a given component when completely necessary, reducing memory usage.</db:para>
<db:note>
<db:para>Qt Creator provides several convenient <db:link xlink:href="http://doc.qt.io/qtcreator/creator-editor-refactoring.html#refactoring-qml-code">refactoring options for QML</db:link>, one of which allows you to move a block of code into a separate file (<db:code>Alt + Enter &gt; Move Component into Separate File</db:code>).</db:para>
</db:note>
<db:para>Another thing to consider when using <db:link xlink:href="qml-qtquick-listview.xml">ListView</db:link> is whether to refer to it by <db:code>id</db:code>, or use the attached <db:link xlink:href="qml-qtquick-listview.xml#view-attached-prop">ListView.view</db:link> property. The best approach depends on a few different factors. Giving the view an id will result in shorter and more efficient binding expressions, as the attached property has a very small amount of overhead. However, if you plan on reusing the delegate in other views, it is better to use the attached properties to avoid tying the delegate to a particular view. For example, using the attached properties, the <db:code>width</db:code> assignment in our delegate becomes:</db:para>
<db:programlisting language="cpp">width: ListView.view.width - ListView.view.leftMargin - ListView.view.rightMargin
</db:programlisting>
<db:para>In chapter 2, we added a <db:link xlink:href="qml-qtquick-listview.xml">ListView</db:link> below the header. If you run the application for that chapter, you'll see that the contents of the view can be scrolled over the top of the header:</db:para>
<db:mediaobject>
<db:imageobject>
<db:imagedata fileref="images/qtquickcontrols2-chattutorial-chapter2-listview-header.gif"/>
</db:imageobject>
</db:mediaobject>
<db:para>This is not that nice, especially if the text in the delegates is long enough that it reaches the text in the header. What we ideally want to do is to have a solid block of color under the header text, but <db:emphasis>above</db:emphasis> the view. This ensures that the listview contents can't visually interfere with the header contents. Note that it's also possible to achieve this by setting the <db:link xlink:href="qml-qtquick-item.xml#clip-prop">clip</db:link> property of the view to <db:code>true</db:code>, but doing so <db:link xlink:href="qpainter.xml#clipping">can affect performance</db:link>.</db:para>
<db:para><db:link xlink:href="qml-qtquick-controls2-toolbar.xml">ToolBar</db:link> is the right tool for this job. It is a container of both application-wide and context-sensitive actions and controls, such as navigation buttons and search fields. Best of all, it has a background color that, as usual, comes from the application style. Here it is in action:</db:para>
<db:programlisting language="cpp">    header: ToolBar {
        Label {
            text: qsTr(&quot;Contacts&quot;)
            font.pixelSize: 20
            anchors.centerIn: parent
        }
    }
</db:programlisting>
<db:mediaobject>
<db:imageobject>
<db:imagedata fileref="images/qtquickcontrols2-chattutorial-chapter3-listview-header.gif"/>
</db:imageobject>
</db:mediaobject>
<db:para>It has no layout of its own, so we center the label within it ourselves.</db:para>
<db:para>The rest of the code is the same as it was in chapter 2, except that we've taken advantage of the <db:link xlink:href="qml-qtquick-controls2-abstractbutton.xml#clicked-signal">clicked</db:link> signal to push the next page onto the stackview:</db:para>
<db:programlisting language="cpp">            onClicked: root.StackView.view.push(&quot;qrc:/ConversationPage.qml&quot;, { inConversationWith: modelData })
</db:programlisting>
<db:para>When pushing a <db:link xlink:href="qml-qtqml-component.xml">Component</db:link> or <db:link xlink:href="qml-url.xml">url</db:link> onto <db:link xlink:href="qml-qtquick-controls2-stackview.xml">StackView</db:link>, it's often necessary to initialize the (eventually) instantiated item with some variables. <db:link xlink:href="qml-qtquick-controls2-stackview.xml">StackView</db:link>'s <db:link xlink:href="qml-qtquick-controls2-stackview.xml#push-method">push</db:link>() function accounts for this, by taking a JavaScript object as the second argument. We use this to provide the next page with a contact's name, which it then uses to display the relevant conversation. Note the <db:code>root.StackView.view.push</db:code> syntax; this is necessary because of how <db:link xlink:href="qtqml-syntax-objectattributes.xml#a-note-about-accessing-attached-properties-and-signal-handlers">attached properties</db:link> work.</db:para>
<db:para>Let's step through <db:code>ConversationPage.qml</db:code>, beginning with the imports:</db:para>
<db:programlisting language="cpp">import QtQuick
import QtQuick.Layouts
import QtQuick.Controls
</db:programlisting>
<db:para>These are the same as before, except for the addition of the <db:code>QtQuick.Layouts</db:code> import, which we'll cover shortly.</db:para>
<db:programlisting language="cpp">Page {
    id: root

    property string inConversationWith

    header: ToolBar {
        ToolButton {
            text: qsTr(&quot;Back&quot;)
            anchors.left: parent.left
            anchors.leftMargin: 10
            anchors.verticalCenter: parent.verticalCenter
            onClicked: root.StackView.view.pop()
        }

        Label {
            id: pageTitle
            text: inConversationWith
            font.pixelSize: 20
            anchors.centerIn: parent
        }
    }
    ...
</db:programlisting>
<db:para>The root item of this component is another Page, which has a custom property called <db:code>inConversationWith</db:code>. For now, this property will simply determine what the label in the header displays. Later on, we'll use it in the SQL query that populates the list of messages in the conversation.</db:para>
<db:para>To allow the user to go back to the Contact page, we add a <db:link xlink:href="qml-qtquick-controls2-toolbutton.xml">ToolButton</db:link> that calls <db:link xlink:href="qml-qtquick-controls2-stackview.xml#pop-method">pop</db:link>() when clicked. A <db:link xlink:href="qml-qtquick-controls2-toolbutton.xml">ToolButton</db:link> is functionally similar to <db:link xlink:href="qml-qtquick-controls2-button.xml">Button</db:link>, but provides a look that is more suitable within a <db:link xlink:href="qml-qtquick-controls2-toolbar.xml">ToolBar</db:link>.</db:para>
<db:para>There are two ways of laying out items in QML: <db:link xlink:href="qtquick-positioning-layouts.xml">Item Positioners</db:link> and <db:link xlink:href="qtquicklayouts-index.xml">Qt Quick Layouts</db:link>. Item positioners (<db:link xlink:href="qml-qtquick-row.xml">Row</db:link>, <db:link xlink:href="qml-qtquick-column.xml">Column</db:link>, and so on) are useful for situations where the size of items is known or fixed, and all that is required is to neatly position them in a certain formation. The layouts in Qt Quick Layouts can both position and resize items, making them well suited for resizable user interfaces. Below, we use <db:link xlink:href="qml-qtquick-layouts-columnlayout.xml">ColumnLayout</db:link> to vertically lay out a <db:link xlink:href="qml-qtquick-listview.xml">ListView</db:link> and a <db:link xlink:href="qml-qtquick-controls2-pane.xml">Pane</db:link>:</db:para>
<db:programlisting language="cpp">    ColumnLayout {
        anchors.fill: parent

        ListView {
            id: listView
            Layout.fillWidth: true
            Layout.fillHeight: true
            ...

        }
        ...

        Pane {
            id: pane
            Layout.fillWidth: true
            ...
    }
</db:programlisting>
<db:para>Pane is basically a rectangle whose color comes from the application's style. It is similar to <db:link xlink:href="qml-qtquick-controls2-frame.xml">Frame</db:link>, with the only difference being that it has no stroke around its border.</db:para>
<db:para>Items that are direct children of a layout have various <db:link xlink:href="qml-qtquick-layouts-layout.xml">attached properties</db:link> available to them. We use <db:link xlink:href="qml-qtquick-layouts-layout.xml#fillWidth-attached-prop">Layout.fillWidth</db:link> and <db:link xlink:href="qml-qtquick-layouts-layout.xml#fillHeight-attached-prop">Layout.fillHeight</db:link> on the <db:link xlink:href="qml-qtquick-listview.xml">ListView</db:link> to ensure that it takes as much space within the <db:link xlink:href="qml-qtquick-layouts-columnlayout.xml">ColumnLayout</db:link> as it can. The same is done for the Pane. As <db:link xlink:href="qml-qtquick-layouts-columnlayout.xml">ColumnLayout</db:link> is a vertical layout, there aren't any items to the left or right of each child, so this will result in each item consuming the entire width of the layout.</db:para>
<db:para>On the other hand, the <db:link xlink:href="qml-qtquick-layouts-layout.xml#fillHeight-attached-prop">Layout.fillHeight</db:link> statement in the <db:link xlink:href="qml-qtquick-listview.xml">ListView</db:link> will enable it to occupy the remaining space that is left after accommodating the Pane.</db:para>
<db:para>Let's look at the listview in detail:</db:para>
<db:programlisting language="cpp">        ListView {
            id: listView
            Layout.fillWidth: true
            Layout.fillHeight: true
            Layout.margins: pane.leftPadding + messageField.leftPadding
            displayMarginBeginning: 40
            displayMarginEnd: 40
            verticalLayoutDirection: ListView.BottomToTop
            spacing: 12
            model: 10
            delegate: Row {
                readonly property bool sentByMe: index % 2 == 0

                anchors.right: sentByMe ? listView.contentItem.right : undefined
                spacing: 6

                Rectangle {
                    id: avatar
                    width: height
                    height: parent.height
                    color: &quot;grey&quot;
                    visible: !sentByMe
                }

                Rectangle {
                    width: 80
                    height: 40
                    color: sentByMe ? &quot;lightgrey&quot; : &quot;steelblue&quot;

                    Label {
                        anchors.centerIn: parent
                        text: index
                        color: sentByMe ? &quot;black&quot; : &quot;white&quot;
                    }
                }
            }

            ScrollBar.vertical: ScrollBar {}
        }
</db:programlisting>
<db:para>After filling the width and height of its parent, we also set some margins on the view. This gives us a nice alignment with the placeholder text in the &quot;compose message&quot; field:</db:para>
<db:mediaobject>
<db:imageobject>
<db:imagedata fileref="images/qtquickcontrols2-chattutorial-chapter3-view-margins.png"/>
</db:imageobject>
</db:mediaobject>
<db:para>Next, we set <db:link xlink:href="qml-qtquick-listview.xml#displayMarginBeginning-prop">displayMarginBeginning</db:link> and <db:link xlink:href="qml-qtquick-listview.xml#displayMarginEnd-prop">displayMarginEnd</db:link>. These properties ensure that the delegates outside the bounds of the view do not disappear while scrolling at the edges of the view. It's easiest to understand this by commenting out the properties and seeing what happens when scrolling the view.</db:para>
<db:para>We then flip the vertical direction of the view, so that first items are at the bottom. The delegates are spaced out by 12 pixels, and a <db:emphasis>&quot;dummy&quot;</db:emphasis> model is assigned for testing purposes, until we implement the real model in chapter 4.</db:para>
<db:para>Within the delegate, we declare a <db:link xlink:href="qml-qtquick-row.xml">Row</db:link> as the root item, as we want the avatar to be followed by the message contents, as shown in the image above.</db:para>
<db:para>Messages sent by the user should be distinguished from those sent by a contact. For now, we set a dummy property <db:code>sentByMe</db:code>, which simply uses the index of the delegate to alternate between different authors. Using this property, we distinguish between different authors in three ways:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para>Messages sent by the user are aligned to the right side of the screen by setting <db:code>anchors.right</db:code> to <db:code>listView.contentItem.right</db:code>.</db:para>
</db:listitem>
<db:listitem>
<db:para>By setting the <db:code>visible</db:code> property of the avatar (which is simply a Rectangle for now) based on <db:code>sentByMe</db:code>, we only show it if the message was sent by a contact.</db:para>
</db:listitem>
<db:listitem>
<db:para>We change the color of the rectangle depending on the author. Since we do not want to display dark text on a dark background, and vice versa, we also set the text color depending on who the author is. In chapter 5, we'll see how styling takes care of matters like this for us.</db:para>
</db:listitem>
</db:itemizedlist>
<db:para>At the bottom of the screen, we place a <db:link xlink:href="qml-qtquick-controls2-textarea.xml">TextArea</db:link> item to allow multi-line text input, and a button to send the message. We use Pane to cover the area under these two items, in the same way that we use <db:link xlink:href="qml-qtquick-controls2-toolbar.xml">ToolBar</db:link> to prevent the contents of the listview from interfering with the page header:</db:para>
<db:programlisting language="cpp">        Pane {
            id: pane
            Layout.fillWidth: true

            RowLayout {
                width: parent.width

                TextArea {
                    id: messageField
                    Layout.fillWidth: true
                    placeholderText: qsTr(&quot;Compose message&quot;)
                    wrapMode: TextArea.Wrap
                }

                Button {
                    id: sendButton
                    text: qsTr(&quot;Send&quot;)
                    enabled: messageField.length &amp;gt; 0
                }
            }
        }
</db:programlisting>
<db:para>The <db:link xlink:href="qml-qtquick-controls2-textarea.xml">TextArea</db:link> should fill the available width of the screen. We assign some placeholder text to provide a visual cue to the user as to where they should begin typing. The text within the input area is wrapped to ensure that it does not go outside of the screen.</db:para>
<db:para>Finally, the button is only enabled when there is actually a message to send.</db:para>
<db:mediaobject>
<db:imageobject>
<db:imagedata fileref="images/qtquickcontrols2-chattutorial-chapter3.gif"/>
</db:imageobject>
</db:mediaobject>
<db:para/>
<db:para/>
</db:section>
</db:section>
<db:section xml:id="chapter-4-models">
<db:title>Chapter 4: Models</db:title>
<db:para>In chapter 4, we'll take you through the process of creating both read-only and read-write SQL models in C++ and exposing them to QML to populate views.</db:para>
<db:section xml:id="qsqlquerymodel">
<db:title>QSqlQueryModel</db:title>
<db:para>In order to keep the tutorial simple, we've chosen to make the list of user contacts non-editable. <db:link xlink:href="qtquickcontrols-chattutorial-example.xml#qsqlquerymodel">QSqlQueryModel</db:link> is the logical choice for this purpose, as it provides a read-only data model for SQL result sets.</db:para>
<db:para>Let's take a look at our <db:code>SqlContactModel</db:code> class that derives from <db:link xlink:href="qsqlquerymodel.xml">QSqlQueryModel</db:link>:</db:para>
<db:programlisting language="cpp">#include &amp;lt;QSqlQueryModel&amp;gt;

class SqlContactModel : public QSqlQueryModel
{
public:
    SqlContactModel(QObject *parent = 0);
};
</db:programlisting>
<db:para>There's not much going on here, so let's move on to the <db:code>.cpp</db:code> file:</db:para>
<db:programlisting language="cpp">#include &quot;sqlcontactmodel.h&quot;

#include &amp;lt;QDebug&amp;gt;
#include &amp;lt;QSqlError&amp;gt;
#include &amp;lt;QSqlQuery&amp;gt;

static void createTable()
{
    if (QSqlDatabase::database().tables().contains(QStringLiteral(&quot;Contacts&quot;))) {
        // The table already exists; we don't need to do anything.
        return;
    }

    QSqlQuery query;
    if (!query.exec(
        &quot;CREATE TABLE IF NOT EXISTS 'Contacts' (&quot;
        &quot;   'name' TEXT NOT NULL,&quot;
        &quot;   PRIMARY KEY(name)&quot;
        &quot;)&quot;)) {
        qFatal(&quot;Failed to query database: %s&quot;, qPrintable(query.lastError().text()));
    }

    query.exec(&quot;INSERT INTO Contacts VALUES('Albert Einstein')&quot;);
    query.exec(&quot;INSERT INTO Contacts VALUES('Ernest Hemingway')&quot;);
    query.exec(&quot;INSERT INTO Contacts VALUES('Hans Gude')&quot;);
}
</db:programlisting>
<db:para>We include the header file of our class and those that we require from Qt. We then define a static function named <db:code>createTable()</db:code> that we'll use to create the SQL table (if it doesn't already exist), and then populate it with some dummy contacts.</db:para>
<db:para>The call to <db:link xlink:href="qsqldatabase.xml#database">database</db:link>() might look a little bit confusing because we have not set up a specific database yet. If no connection name is passed to this function, it will return a <db:emphasis>&quot;default connection&quot;</db:emphasis>, whose creation we will cover soon.</db:para>
<db:programlisting language="cpp">SqlContactModel::SqlContactModel(QObject *parent) :
    QSqlQueryModel(parent)
{
    createTable();

    QSqlQuery query;
    if (!query.exec(&quot;SELECT * FROM Contacts&quot;))
        qFatal(&quot;Contacts SELECT query failed: %s&quot;, qPrintable(query.lastError().text()));

    setQuery(query);
    if (lastError().isValid())
        qFatal(&quot;Cannot set query on SqlContactModel: %s&quot;, qPrintable(lastError().text()));
}
</db:programlisting>
<db:para>In the constructor, we call <db:code>createTable()</db:code>. We then construct a query that will be used to populate the model. In this case, we are simply interested in all rows of the <db:code>Contacts</db:code> table.</db:para>
</db:section>
<db:section xml:id="qsqltablemodel">
<db:title>QSqlTableModel</db:title>
<db:para><db:code>SqlConversationModel</db:code> is more complex:</db:para>
<db:programlisting language="cpp">#include &amp;lt;QSqlTableModel&amp;gt;

class SqlConversationModel : public QSqlTableModel
{
    Q_OBJECT
    Q_PROPERTY(QString recipient READ recipient WRITE setRecipient NOTIFY recipientChanged)

public:
    SqlConversationModel(QObject *parent = 0);

    QString recipient() const;
    void setRecipient(const QString &amp;amp;recipient);

    QVariant data(const QModelIndex &amp;amp;index, int role) const override;
    QHash&amp;lt;int, QByteArray&amp;gt; roleNames() const override;

    Q_INVOKABLE void sendMessage(const QString &amp;amp;recipient, const QString &amp;amp;message);

signals:
    void recipientChanged();

private:
    QString m_recipient;
};
</db:programlisting>
<db:para>We use both the <db:code>Q_PROPERTY</db:code> and <db:code>Q_INVOKABLE</db:code> macros, and therefore we must let <db:link xlink:href="moc.xml">moc</db:link> know by using the <db:code>Q_OBJECT</db:code> macro.</db:para>
<db:para>The <db:code>recipient</db:code> property will be set from QML to let the model know which conversation it should retrieve messages for.</db:para>
<db:para>We override the <db:link xlink:href="qsqltablemodel.xml#data">data</db:link>() and <db:link xlink:href="qabstractitemmodel.xml#roleNames">roleNames</db:link>() functions so that we can use our custom roles in QML.</db:para>
<db:para>We also define the <db:code>sendMessage()</db:code> function that we want to call from QML, hence the <db:code>Q_INVOKABLE</db:code> macro.</db:para>
<db:para>Let's take a look at the <db:code>.cpp</db:code> file:</db:para>
<db:programlisting language="cpp">#include &quot;sqlconversationmodel.h&quot;

#include &amp;lt;QDateTime&amp;gt;
#include &amp;lt;QDebug&amp;gt;
#include &amp;lt;QSqlError&amp;gt;
#include &amp;lt;QSqlRecord&amp;gt;
#include &amp;lt;QSqlQuery&amp;gt;

static const char *conversationsTableName = &quot;Conversations&quot;;

static void createTable()
{
    if (QSqlDatabase::database().tables().contains(conversationsTableName)) {
        // The table already exists; we don't need to do anything.
        return;
    }

    QSqlQuery query;
    if (!query.exec(
        &quot;CREATE TABLE IF NOT EXISTS 'Conversations' (&quot;
        &quot;'author' TEXT NOT NULL,&quot;
        &quot;'recipient' TEXT NOT NULL,&quot;
        &quot;'timestamp' TEXT NOT NULL,&quot;
        &quot;'message' TEXT NOT NULL,&quot;
        &quot;FOREIGN KEY('author') REFERENCES Contacts ( name ),&quot;
        &quot;FOREIGN KEY('recipient') REFERENCES Contacts ( name )&quot;
        &quot;)&quot;)) {
        qFatal(&quot;Failed to query database: %s&quot;, qPrintable(query.lastError().text()));
    }

    query.exec(&quot;INSERT INTO Conversations VALUES('Me', 'Ernest Hemingway', '2016-01-07T14:36:06', 'Hello!')&quot;);
    query.exec(&quot;INSERT INTO Conversations VALUES('Ernest Hemingway', 'Me', '2016-01-07T14:36:16', 'Good afternoon.')&quot;);
    query.exec(&quot;INSERT INTO Conversations VALUES('Me', 'Albert Einstein', '2016-01-01T11:24:53', 'Hi!')&quot;);
    query.exec(&quot;INSERT INTO Conversations VALUES('Albert Einstein', 'Me', '2016-01-07T14:36:16', 'Good morning.')&quot;);
    query.exec(&quot;INSERT INTO Conversations VALUES('Hans Gude', 'Me', '2015-11-20T06:30:02', 'God morgen. Har du fått mitt maleri?')&quot;);
    query.exec(&quot;INSERT INTO Conversations VALUES('Me', 'Hans Gude', '2015-11-20T08:21:03', 'God morgen, Hans. Ja, det er veldig fint. Tusen takk! &quot;
               &quot;Hvor mange timer har du brukt på den?')&quot;);
}
</db:programlisting>
<db:para>This is very similar to <db:code>sqlcontactmodel.cpp</db:code>, with the exception that we are now operating on the <db:code>Conversations</db:code> table. We also define <db:code>conversationsTableName</db:code> as a static const variable, as we use it in a couple of places throughout the file.</db:para>
<db:programlisting language="cpp">SqlConversationModel::SqlConversationModel(QObject *parent) :
    QSqlTableModel(parent)
{
    createTable();
    setTable(conversationsTableName);
    setSort(2, Qt::DescendingOrder);
    // Ensures that the model is sorted correctly after submitting a new row.
    setEditStrategy(QSqlTableModel::OnManualSubmit);
}
</db:programlisting>
<db:para>As with <db:code>SqlContactModel</db:code>, the first thing that we do in the constructor is create the table. We tell <db:link xlink:href="qsqltablemodel.xml">QSqlTableModel</db:link> the name of the table we'll be using via the <db:link xlink:href="qsqltablemodel.xml#setTable">setTable</db:link>() function. To ensure that the latest messages in the conversation are shown first, we sort the query results by the <db:code>timestamp</db:code> field in descending order. This goes hand in hand with setting <db:link xlink:href="qml-qtquick-listview.xml">ListView</db:link>'s <db:link xlink:href="qml-qtquick-listview.xml#verticalLayoutDirection-prop">verticalLayoutDirection</db:link> property to <db:code>ListView.BottomToTop</db:code> (which we covered in chapter 3).</db:para>
<db:programlisting language="cpp">QString SqlConversationModel::recipient() const
{
    return m_recipient;
}

void SqlConversationModel::setRecipient(const QString &amp;amp;recipient)
{
    if (recipient == m_recipient)
        return;

    m_recipient = recipient;

    const QString filterString = QString::fromLatin1(
        &quot;(recipient = '%1' AND author = 'Me') OR (recipient = 'Me' AND author='%1')&quot;).arg(m_recipient);
    setFilter(filterString);
    select();

    emit recipientChanged();
}
</db:programlisting>
<db:para>In <db:code>setRecipient()</db:code>, we set a filter over the results returned from the database.</db:para>
<db:programlisting language="cpp">QVariant SqlConversationModel::data(const QModelIndex &amp;amp;index, int role) const
{
    if (role &amp;lt; Qt::UserRole)
        return QSqlTableModel::data(index, role);

    const QSqlRecord sqlRecord = record(index.row());
    return sqlRecord.value(role - Qt::UserRole);
}
</db:programlisting>
<db:para>The <db:code>data()</db:code> function falls back to <db:link xlink:href="qsqltablemodel.xml">QSqlTableModel</db:link>'s implementation if the role is not a custom user role. If the role is a user role, we can subtract <db:link xlink:href="qt.xml#ItemDataRole-enum">Qt::UserRole</db:link> from it to get the index of that field and then use that to find the value that we need to return.</db:para>
<db:programlisting language="cpp">QHash&amp;lt;int, QByteArray&amp;gt; SqlConversationModel::roleNames() const
{
    QHash&amp;lt;int, QByteArray&amp;gt; names;
    names[Qt::UserRole] = &quot;author&quot;;
    names[Qt::UserRole + 1] = &quot;recipient&quot;;
    names[Qt::UserRole + 2] = &quot;timestamp&quot;;
    names[Qt::UserRole + 3] = &quot;message&quot;;
    return names;
}
</db:programlisting>
<db:para>In <db:code>roleNames()</db:code>, we return a mapping of our custom role values to role names. This enables us to use these roles in QML. It can be useful to declare an enum to hold all of the role values, but since we don't refer to any specific value in code outside of this function, we don't bother.</db:para>
<db:programlisting language="cpp">void SqlConversationModel::sendMessage(const QString &amp;amp;recipient, const QString &amp;amp;message)
{
    const QString timestamp = QDateTime::currentDateTime().toString(Qt::ISODate);

    QSqlRecord newRecord = record();
    newRecord.setValue(&quot;author&quot;, &quot;Me&quot;);
    newRecord.setValue(&quot;recipient&quot;, recipient);
    newRecord.setValue(&quot;timestamp&quot;, timestamp);
    newRecord.setValue(&quot;message&quot;, message);
    if (!insertRecord(rowCount(), newRecord)) {
        qWarning() &amp;lt;&amp;lt; &quot;Failed to send message:&quot; &amp;lt;&amp;lt; lastError().text();
        return;
    }
</db:programlisting>
<db:para>The <db:code>sendMessage()</db:code> function uses the given <db:code>recipient</db:code> and a <db:code>message</db:code> to insert a new record into the database. Due to our usage of <db:link xlink:href="qsqltablemodel.xml#EditStrategy-enum">QSqlTableModel::OnManualSubmit</db:link>, we must manually call <db:link xlink:href="qsqltablemodel.xml#submitAll">submitAll</db:link>().</db:para>
</db:section>
<db:section xml:id="connecting-to-the-database-and-registering-types-with-qml">
<db:title>Connecting to the Database and Registering Types With QML</db:title>
<db:para>Now that we've established the model classes, let's take a look at <db:code>main.cpp</db:code>:</db:para>
<db:programlisting language="cpp">#include &amp;lt;QtCore&amp;gt;
#include &amp;lt;QGuiApplication&amp;gt;
#include &amp;lt;QSqlDatabase&amp;gt;
#include &amp;lt;QSqlError&amp;gt;
#include &amp;lt;QtQml&amp;gt;

#include &quot;sqlcontactmodel.h&quot;
#include &quot;sqlconversationmodel.h&quot;

static void connectToDatabase()
{
    QSqlDatabase database = QSqlDatabase::database();
    if (!database.isValid()) {
        database = QSqlDatabase::addDatabase(&quot;QSQLITE&quot;);
        if (!database.isValid())
            qFatal(&quot;Cannot add database: %s&quot;, qPrintable(database.lastError().text()));
    }

    const QDir writeDir = QStandardPaths::writableLocation(QStandardPaths::AppDataLocation);
    if (!writeDir.mkpath(&quot;.&quot;))
        qFatal(&quot;Failed to create writable directory at %s&quot;, qPrintable(writeDir.absolutePath()));

    // Ensure that we have a writable location on all devices.
    const QString fileName = writeDir.absolutePath() + &quot;/chat-database.sqlite3&quot;;
    // When using the SQLite driver, open() will create the SQLite database if it doesn't exist.
    database.setDatabaseName(fileName);
    if (!database.open()) {
        qFatal(&quot;Cannot open database: %s&quot;, qPrintable(database.lastError().text()));
        QFile::remove(fileName);
    }
}

int main(int argc, char *argv[])
{
    QGuiApplication app(argc, argv);

    qmlRegisterType&amp;lt;SqlContactModel&amp;gt;(&quot;io.qt.examples.chattutorial&quot;, 1, 0, &quot;SqlContactModel&quot;);
    qmlRegisterType&amp;lt;SqlConversationModel&amp;gt;(&quot;io.qt.examples.chattutorial&quot;, 1, 0, &quot;SqlConversationModel&quot;);

    connectToDatabase();

    QQmlApplicationEngine engine;
    engine.load(QUrl(QStringLiteral(&quot;qrc:/main.qml&quot;)));
    if (engine.rootObjects().isEmpty())
        return -1;

    return app.exec();
}
</db:programlisting>
<db:para><db:code>connectToDatabase()</db:code> creates the connection to the SQLite database, creating the actual file if it doesn't already exist.</db:para>
<db:para>Within <db:code>main()</db:code>, we call <db:link xlink:href="qqmlengine.xml#qmlRegisterType-1">qmlRegisterType</db:link>() to register our models as types within QML.</db:para>
</db:section>
<db:section xml:id="using-the-models-in-qml">
<db:title>Using the Models in QML</db:title>
<db:para>Now that we have the models available as QML types, there are some minor changes to be done to <db:code>ContactPage.qml</db:code>. To be able to use the types, we must first import them using the URI we set in <db:code>main.cpp</db:code>:</db:para>
<db:programlisting language="cpp">import io.qt.examples.chattutorial
</db:programlisting>
<db:para>We then replace the dummy model with the proper one:</db:para>
<db:programlisting language="cpp">        model: SqlContactModel {}
</db:programlisting>
<db:para>Within the delegate, we use a different syntax for accessing the model data:</db:para>
<db:programlisting language="cpp">            text: model.display
</db:programlisting>
<db:para>In <db:code>ConversationPage.qml</db:code>, we add the same <db:code>chattutorial</db:code> import, and replace the dummy model:</db:para>
<db:programlisting language="cpp">            model: SqlConversationModel {
                recipient: inConversationWith
            }
</db:programlisting>
<db:para>Within the model, we set the <db:code>recipient</db:code> property to the name of the contact for which the page is being displayed.</db:para>
<db:para>The root delegate item changes from a Row to a Column, to accommodate the timestamp that we want to display below every message:</db:para>
<db:programlisting language="cpp">            delegate: Column {
                anchors.right: sentByMe ? listView.contentItem.right : undefined
                spacing: 6

                readonly property bool sentByMe: model.recipient !== &quot;Me&quot;

                Row {
                    id: messageRow
                    spacing: 6
                    anchors.right: sentByMe ? parent.right : undefined

                    Image {
                        id: avatar
                        source: !sentByMe ? &quot;qrc:/&quot; + model.author.replace(&quot; &quot;, &quot;_&quot;) + &quot;.png&quot; : &quot;&quot;
                    }

                    Rectangle {
                        width: Math.min(messageText.implicitWidth + 24,
                            listView.width - (!sentByMe ? avatar.width + messageRow.spacing : 0))
                        height: messageText.implicitHeight + 24
                        color: sentByMe ? &quot;lightgrey&quot; : &quot;steelblue&quot;

                        Label {
                            id: messageText
                            text: model.message
                            color: sentByMe ? &quot;black&quot; : &quot;white&quot;
                            anchors.fill: parent
                            anchors.margins: 12
                            wrapMode: Label.Wrap
                        }
                    }
                }

                Label {
                    id: timestampText
                    text: Qt.formatDateTime(model.timestamp, &quot;d MMM hh:mm&quot;)
                    color: &quot;lightgrey&quot;
                    anchors.right: sentByMe ? parent.right : undefined
                }
            }
</db:programlisting>
<db:mediaobject>
<db:imageobject>
<db:imagedata fileref="images/qtquickcontrols2-chattutorial-chapter4-message-timestamp.png"/>
</db:imageobject>
</db:mediaobject>
<db:para>Now that we have a proper model, we can use its <db:code>recipient</db:code> role in the expression for the <db:code>sentByMe</db:code> property.</db:para>
<db:para>The Rectangle that was used for the avatar has been converted into an Image. The image has its own implicit size, so we don't need to specify it explicitly. As before, we only show the avatar when the author isn't the user, except this time we set the <db:code>source</db:code> of the image to an empty URL instead of using the <db:code>visible</db:code> property.</db:para>
<db:para>We want each message background to be slightly wider (12 pixels each side) than its text. However, if it's too long, we want to limit its width to the edge of the listview, hence the usage of <db:code>Math.min()</db:code>. When the message wasn't sent by us, an avatar will always come before it, so we account for that by subtracting the width of the avatar and the row spacing.</db:para>
<db:para>For example, in the image above, the implicit width of the message text is the smaller value. However, in the image below, the message text is quite long, so the smaller value (the width of the view) is chosen, ensuring that the text stops at the opposite edge of the screen:</db:para>
<db:mediaobject>
<db:imageobject>
<db:imagedata fileref="images/qtquickcontrols2-chattutorial-chapter4-long-message.png"/>
</db:imageobject>
</db:mediaobject>
<db:para>In order to display the timestamp for each message that we discussed earlier, we use a Label. The date and time are formatted with <db:link xlink:href="qml-qtqml-qt.xml#formatDateTime-method">Qt.formatDateTime</db:link>(), using a custom format.</db:para>
<db:para>The <db:emphasis>&quot;send&quot;</db:emphasis> button must now react to being clicked:</db:para>
<db:programlisting language="cpp">                Button {
                    id: sendButton
                    text: qsTr(&quot;Send&quot;)
                    enabled: messageField.length &amp;gt; 0
                    onClicked: {
                        listView.model.sendMessage(inConversationWith, messageField.text);
                        messageField.text = &quot;&quot;;
                    }
                }
</db:programlisting>
<db:para>First, we call the invokable <db:code>sendMessage()</db:code> function of the model, which inserts a new row into the Conversations database table. Then, we clear the text field to make way for future input.</db:para>
<db:mediaobject>
<db:imageobject>
<db:imagedata fileref="images/qtquickcontrols2-chattutorial-chapter4.gif"/>
</db:imageobject>
</db:mediaobject>
<db:para/>
<db:para/>
</db:section>
</db:section>
<db:section xml:id="chapter-5-styling">
<db:title>Chapter 5: Styling</db:title>
<db:para>Styles in Qt Quick Controls are designed to work on any platform. In this chapter, we'll do some minor visual tweaks to make sure our application looks good when run with the <db:link xlink:href="qtquickcontrols2-basic.xml">Basic</db:link>, <db:link xlink:href="qtquickcontrols2-material.xml">Material</db:link>, and <db:link xlink:href="qtquickcontrols2-universal.xml">Universal</db:link> styles.</db:para>
<db:para>So far, we've just been testing the application with the Basic style. If we run it with the <db:link xlink:href="qtquickcontrols2-material.xml">Material Style</db:link>, for example, we'll immediately see some issues. Here is the Contacts page:</db:para>
<db:mediaobject>
<db:imageobject>
<db:imagedata fileref="images/qtquickcontrols2-chattutorial-chapter5-contacts-material-test.png"/>
</db:imageobject>
</db:mediaobject>
<db:para>The header text is black on a dark blue background, which is very difficult to read. The same thing occurs with the Conversations page:</db:para>
<db:mediaobject>
<db:imageobject>
<db:imagedata fileref="images/qtquickcontrols2-chattutorial-chapter5-conversations-material-test.png"/>
</db:imageobject>
</db:mediaobject>
<db:para>The solution is to tell the toolbar that it should use the <db:emphasis>&quot;Dark&quot;</db:emphasis> theme, so that this information is propagated to its children, allowing them to switch their text color to something lighter. The simplest way of doing so is to import the Material style directly and use the Material attached property:</db:para>
<db:programlisting language="cpp">import QtQuick.Controls.Material 2.12

// ...

header: ToolBar {
    Material.theme: Material.Dark

    // ...
}
</db:programlisting>
<db:para>However, this brings with it a hard dependency to the Material style; the Material style plugin <db:emphasis>must</db:emphasis> be deployed with the application, even if the target device doesn't use it, otherwise the QML engine will fail to find the import.</db:para>
<db:para>Instead, it is better to rely on Qt Quick Controls's built-in support for <db:link xlink:href="qtquickcontrols2-fileselectors.xml">style-based file selectors</db:link>. To do this, we must move the <db:link xlink:href="qml-qtquick-controls2-toolbar.xml">ToolBar</db:link> out into its own file. We'll call it <db:code>ChatToolBar.qml</db:code>. This will be the <db:emphasis>&quot;default&quot;</db:emphasis> version of the file, which means that it will be used when the <db:link xlink:href="qtquickcontrols2-basic.xml">Basic style</db:link> (which is the style that is used when none is specified) is in use. Here's the new file:</db:para>
<db:programlisting language="cpp">import QtQuick.Controls

ToolBar {
}
</db:programlisting>
<db:para>As we only use the <db:link xlink:href="qml-qtquick-controls2-toolbar.xml">ToolBar</db:link> type within this file, we only need the Qt Quick Controls import. The code itself has not changed from how it was in <db:code>ContactPage.qml</db:code>, which is how it should be; for the default version of the file, nothing needs to be different.</db:para>
<db:para>Back in <db:code>ContactPage.qml</db:code>, we update the code to use the new type:</db:para>
<db:programlisting language="cpp">    header: ChatToolBar {
        Label {
            text: qsTr(&quot;Contacts&quot;)
            font.pixelSize: 20
            anchors.centerIn: parent
        }
    }
</db:programlisting>
<db:para>Now we need to add the Material version of the toolbar. File selectors expect variants of a file to be in appropriately named directories that exist alongside the default version of the file. This means that we need to add a folder named &quot;+Material&quot; in the same directory that ChatToolBar.qml is in: the root folder. The &quot;+&quot; is required by <db:link xlink:href="qfileselector.xml">QFileSelector</db:link> as a way of ensuring that the selection feature is not accidentally triggered.</db:para>
<db:para>Here's <db:code>+Material/ChatToolBar.qml</db:code>:</db:para>
<db:programlisting language="cpp">import QtQuick.Controls
import QtQuick.Controls.Material

ToolBar {
    Material.theme: Material.Dark
}
</db:programlisting>
<db:para>We'll make the same changes to <db:code>ConversationPage.qml</db:code>:</db:para>
<db:programlisting language="cpp">    header: ChatToolBar {
        ToolButton {
            text: qsTr(&quot;Back&quot;)
            anchors.left: parent.left
            anchors.leftMargin: 10
            anchors.verticalCenter: parent.verticalCenter
            onClicked: root.StackView.view.pop()
        }

        Label {
            id: pageTitle
            text: inConversationWith
            font.pixelSize: 20
            anchors.centerIn: parent
        }
    }
</db:programlisting>
<db:para>Now both pages look correct:</db:para>
<db:mediaobject>
<db:imageobject>
<db:imagedata fileref="images/qtquickcontrols2-chattutorial-chapter5-contacts-material.png"/>
</db:imageobject>
</db:mediaobject>
<db:mediaobject>
<db:imageobject>
<db:imagedata fileref="images/qtquickcontrols2-chattutorial-chapter5-conversations-material.png"/>
</db:imageobject>
</db:mediaobject>
<db:para>Let's try out the Universal style:</db:para>
<db:mediaobject>
<db:imageobject>
<db:imagedata fileref="images/qtquickcontrols2-chattutorial-chapter5-contacts-universal.png"/>
</db:imageobject>
</db:mediaobject>
<db:mediaobject>
<db:imageobject>
<db:imagedata fileref="images/qtquickcontrols2-chattutorial-chapter5-conversations-universal.png"/>
</db:imageobject>
</db:mediaobject>
<db:para>No issues there. For a relatively simple application such as this one, there should be very few adjustments necessary when switching styles.</db:para>
<db:para>Now let's try each style's dark theme. The Basic style has no dark theme, as it would add a slight overhead to a style that is designed to be as performant as possible. We'll test out the Material style first, so add an entry to <db:code>qtquickcontrols2.conf</db:code> that tells it to use its dark theme:</db:para>
<db:programlisting language="cpp">[Material]
Primary=Indigo
Accent=Indigo
Theme=Dark
</db:programlisting>
<db:para>Once this is done, build and run the application. This is what you should see:</db:para>
<db:mediaobject>
<db:imageobject>
<db:imagedata fileref="images/qtquickcontrols2-chattutorial-chapter5-contacts-material-dark.png"/>
</db:imageobject>
</db:mediaobject>
<db:mediaobject>
<db:imageobject>
<db:imagedata fileref="images/qtquickcontrols2-chattutorial-chapter5-conversations-material-dark.png"/>
</db:imageobject>
</db:mediaobject>
<db:para>Both pages look fine. Now add an entry for the Universal style:</db:para>
<db:programlisting language="cpp">[universal]
Theme=Dark
</db:programlisting>
<db:para>After building and running the application, you should see these results:</db:para>
<db:mediaobject>
<db:imageobject>
<db:imagedata fileref="images/qtquickcontrols2-chattutorial-chapter5-contacts-universal-dark.png"/>
</db:imageobject>
</db:mediaobject>
<db:mediaobject>
<db:imageobject>
<db:imagedata fileref="images/qtquickcontrols2-chattutorial-chapter5-conversations-universal-dark.png"/>
</db:imageobject>
</db:mediaobject>
<db:para/>
<db:para/>
</db:section>
<db:section xml:id="summary">
<db:title>Summary</db:title>
<db:para>In this tutorial, we've taken you through the following steps of writing a basic application using Qt Quick Controls:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para>Creating a new project using Qt Creator.</db:para>
</db:listitem>
<db:listitem>
<db:para>Setting up a basic <db:link xlink:href="qml-qtquick-controls2-applicationwindow.xml">ApplicationWindow</db:link>.</db:para>
</db:listitem>
<db:listitem>
<db:para>Defining headers and footers with Page.</db:para>
</db:listitem>
<db:listitem>
<db:para>Displaying content in a <db:link xlink:href="qml-qtquick-listview.xml">ListView</db:link>.</db:para>
</db:listitem>
<db:listitem>
<db:para>Refactoring components into their own files.</db:para>
</db:listitem>
<db:listitem>
<db:para>Navigating between screens with <db:link xlink:href="qml-qtquick-controls2-stackview.xml">StackView</db:link>.</db:para>
</db:listitem>
<db:listitem>
<db:para>Using layouts to allow an application to resize gracefully.</db:para>
</db:listitem>
<db:listitem>
<db:para>Implementing both custom read-only and writable models that integrate an SQL database into the application.</db:para>
</db:listitem>
<db:listitem>
<db:para>Integrating C++ with QML via <db:link xlink:href="qobject.xml#Q_PROPERTY">Q_PROPERTY</db:link>, <db:link xlink:href="qobject.xml#Q_INVOKABLE">Q_INVOKABLE</db:link>, and <db:link xlink:href="qqmlengine.xml#qmlRegisterType-1">qmlRegisterType</db:link>().</db:para>
</db:listitem>
<db:listitem>
<db:para>Testing and configuring multiple styles.</db:para>
</db:listitem>
</db:itemizedlist>
</db:section>
<db:section>
<db:title>Example project</db:title>
<db:para><db:link xlink:href="https://code.qt.io/cgit/qt/qtquickcontrols2.git/tree/examples/quickcontrols2/chattutorial?h=6.1">Example project @ code.qt.io</db:link></db:para>
</db:section>
</db:article>
