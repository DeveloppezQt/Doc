<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en">
<db:info>
<db:title>QUrl Class</db:title>
<db:productname>QtCore</db:productname>
<db:edition>Qt 6.7.2 Reference Documentation</db:edition>
<db:titleabbrev>Qt Core Reference Documentation</db:titleabbrev>
<db:abstract>
<db:para>The <db:link xlink:href="qurl.xml">QUrl</db:link> class provides a convenient interface for working with URLs.</db:para>
<db:note>
<db:para>All functions in this class are <db:link xlink:href="threads-reentrancy.xml">reentrant</db:link>.</db:para>
</db:note>
</db:abstract>
<db:pubdate>2024-12-27</db:pubdate>
<db:date>2024-12-27</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:variablelist>
<db:varlistentry>
<db:term>Header</db:term>
<db:listitem>
<db:para>QUrl</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>CMake</db:term>
<db:listitem>
<db:para>find_package(Qt6 REQUIRED COMPONENTS Core)</db:para>
<db:para>target_link_libraries(mytarget PRIVATE Qt6::Core)</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>qmake</db:term>
<db:listitem>
<db:para>QT += core</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Group</db:term>
<db:listitem>
<db:para>QUrl is part of <db:simplelist><db:member><db:link xlink:href="io.xml">Input/Output and Networking</db:link></db:member><db:member>network</db:member><db:member><db:link xlink:href="shared.xml">Implicitly Shared Classes</db:link></db:member></db:simplelist></db:para>
</db:listitem>
</db:varlistentry>
</db:variablelist>
<db:section xml:id="details">
<db:title>Detailed Description</db:title>
<db:para>It can parse and construct URLs in both encoded and unencoded form. <db:link xlink:href="qurl.xml">QUrl</db:link> also has support for internationalized domain names (IDNs).</db:para>
<db:para>The most common way to use <db:link xlink:href="qurl.xml">QUrl</db:link> is to initialize it via the constructor by passing a <db:link xlink:href="qstring.xml">QString</db:link> containing a full URL. <db:link xlink:href="qurl.xml">QUrl</db:link> objects can also be created from a <db:link xlink:href="qbytearray.xml">QByteArray</db:link> containing a full URL using <db:link xlink:href="qurl.xml#fromEncoded">QUrl::fromEncoded</db:link>(), or heuristically from incomplete URLs using <db:link xlink:href="qurl.xml#fromUserInput">QUrl::fromUserInput</db:link>(). The URL representation can be obtained from a <db:link xlink:href="qurl.xml">QUrl</db:link> using either <db:link xlink:href="qurl.xml#toString">QUrl::toString</db:link>() or <db:link xlink:href="qurl.xml#toEncoded">QUrl::toEncoded</db:link>().</db:para>
<db:para>URLs can be represented in two forms: encoded or unencoded. The unencoded representation is suitable for showing to users, but the encoded representation is typically what you would send to a web server. For example, the unencoded URL &quot;http://bühler.example.com/List of applicants.xml&quot; would be sent to the server as &quot;http://xn–bhler-kva.example.com/List%20of%20applicants.xml&quot;.</db:para>
<db:para>A URL can also be constructed piece by piece by calling <db:link xlink:href="qurl.xml#setScheme">setScheme</db:link>(), <db:link xlink:href="qurl.xml#setUserName">setUserName</db:link>(), <db:link xlink:href="qurl.xml#setPassword">setPassword</db:link>(), <db:link xlink:href="qurl.xml#setHost">setHost</db:link>(), <db:link xlink:href="qurl.xml#setPort">setPort</db:link>(), <db:link xlink:href="qurl.xml#setPath">setPath</db:link>(), <db:link xlink:href="qurl.xml#setQuery">setQuery</db:link>() and <db:link xlink:href="qurl.xml#setFragment">setFragment</db:link>(). Some convenience functions are also available: <db:link xlink:href="qurl.xml#setAuthority">setAuthority</db:link>() sets the user name, password, host and port. <db:link xlink:href="qurl.xml#setUserInfo">setUserInfo</db:link>() sets the user name and password at once.</db:para>
<db:para>Call <db:link xlink:href="qurl.xml#isValid">isValid</db:link>() to check if the URL is valid. This can be done at any point during the constructing of a URL. If <db:link xlink:href="qurl.xml#isValid">isValid</db:link>() returns false, you should <db:link xlink:href="qurl.xml#clear">clear</db:link>() the URL before proceeding, or start over by parsing a new URL with <db:link xlink:href="qurl.xml#setUrl">setUrl</db:link>().</db:para>
<db:para>Constructing a query is particularly convenient through the use of the <db:link xlink:href="qurlquery.xml">QUrlQuery</db:link> class and its methods <db:link xlink:href="qurlquery.xml#setQueryItems">QUrlQuery::setQueryItems</db:link>(), <db:link xlink:href="qurlquery.xml#addQueryItem">QUrlQuery::addQueryItem</db:link>() and <db:link xlink:href="qurlquery.xml#removeQueryItem">QUrlQuery::removeQueryItem</db:link>(). Use <db:link xlink:href="qurlquery.xml#setQueryDelimiters">QUrlQuery::setQueryDelimiters</db:link>() to customize the delimiters used for generating the query string.</db:para>
<db:para>For the convenience of generating encoded URL strings or query strings, there are two static functions called <db:link xlink:href="qurl.xml#fromPercentEncoding">fromPercentEncoding</db:link>() and <db:link xlink:href="qurl.xml#toPercentEncoding">toPercentEncoding</db:link>() which deal with percent encoding and decoding of <db:link xlink:href="qstring.xml">QString</db:link> objects.</db:para>
<db:para><db:link xlink:href="qurl.xml#fromLocalFile">fromLocalFile</db:link>() constructs a <db:link xlink:href="qurl.xml">QUrl</db:link> by parsing a local file path. <db:link xlink:href="qurl.xml#toLocalFile">toLocalFile</db:link>() converts a URL to a local file path.</db:para>
<db:para>The human readable representation of the URL is fetched with <db:link xlink:href="qurl.xml#toString">toString</db:link>(). This representation is appropriate for displaying a URL to a user in unencoded form. The encoded form however, as returned by <db:link xlink:href="qurl.xml#toEncoded">toEncoded</db:link>(), is for internal use, passing to web servers, mail clients and so on. Both forms are technically correct and represent the same URL unambiguously – in fact, passing either form to <db:link xlink:href="qurl.xml">QUrl</db:link>'s constructor or to <db:link xlink:href="qurl.xml#setUrl">setUrl</db:link>() will yield the same <db:link xlink:href="qurl.xml">QUrl</db:link> object.</db:para>
<db:para><db:link xlink:href="qurl.xml">QUrl</db:link> conforms to the URI specification from <db:link xlink:href="https://datatracker.ietf.org/doc/html/rfc3986">RFC 3986</db:link> (Uniform Resource Identifier: Generic Syntax), and includes scheme extensions from <db:link xlink:href="https://datatracker.ietf.org/doc/html/rfc1738">RFC 1738</db:link> (Uniform Resource Locators). Case folding rules in <db:link xlink:href="qurl.xml">QUrl</db:link> conform to <db:link xlink:href="https://datatracker.ietf.org/doc/html/rfc3491">RFC 3491</db:link> (Nameprep: A Stringprep Profile for Internationalized Domain Names (IDN)). It is also compatible with the <db:link xlink:href="http://freedesktop.org/wiki/Specifications/file-uri-spec/">file URI specification</db:link> from freedesktop.org, provided that the locale encodes file names using UTF-8 (required by IDN).</db:para>
<db:section xml:id="relative-urls-vs-relative-paths">
<db:title>Relative URLs vs Relative Paths</db:title>
<db:para>Calling <db:link xlink:href="qurl.xml#isRelative">isRelative</db:link>() will return whether or not the URL is relative. A relative URL has no <db:link xlink:href="qurl.xml#scheme">scheme</db:link>. For example:</db:para>
<db:programlisting language="cpp">    qDebug() &amp;lt;&amp;lt; QUrl(&quot;main.qml&quot;).isRelative();          // true: no scheme
    qDebug() &amp;lt;&amp;lt; QUrl(&quot;qml/main.qml&quot;).isRelative();      // true: no scheme
    qDebug() &amp;lt;&amp;lt; QUrl(&quot;file:main.qml&quot;).isRelative();     // false: has &quot;file&quot; scheme
    qDebug() &amp;lt;&amp;lt; QUrl(&quot;file:qml/main.qml&quot;).isRelative(); // false: has &quot;file&quot; scheme
</db:programlisting>
<db:para>Notice that a URL can be absolute while containing a relative path, and vice versa:</db:para>
<db:programlisting language="cpp">    // Absolute URL, relative path
    QUrl url(&quot;file:file.txt&quot;);
    qDebug() &amp;lt;&amp;lt; url.isRelative();                 // false: has &quot;file&quot; scheme
    qDebug() &amp;lt;&amp;lt; QDir::isAbsolutePath(url.path()); // false: relative path

    // Relative URL, absolute path
    url = QUrl(&quot;/home/user/file.txt&quot;);
    qDebug() &amp;lt;&amp;lt; url.isRelative();                 // true: has no scheme
    qDebug() &amp;lt;&amp;lt; QDir::isAbsolutePath(url.path()); // true: absolute path
</db:programlisting>
<db:para>A relative URL can be resolved by passing it as an argument to <db:link xlink:href="qurl.xml#resolved">resolved</db:link>(), which returns an absolute URL. <db:link xlink:href="qurl.xml#isParentOf">isParentOf</db:link>() is used for determining whether one URL is a parent of another.</db:para>
</db:section>
<db:section xml:id="error-checking">
<db:title>Error checking</db:title>
<db:para><db:link xlink:href="qurl.xml">QUrl</db:link> is capable of detecting many errors in URLs while parsing it or when components of the URL are set with individual setter methods (like <db:link xlink:href="qurl.xml#setScheme">setScheme</db:link>(), <db:link xlink:href="qurl.xml#setHost">setHost</db:link>() or <db:link xlink:href="qurl.xml#setPath">setPath</db:link>()). If the parsing or setter function is successful, any previously recorded error conditions will be discarded.</db:para>
<db:para>By default, <db:link xlink:href="qurl.xml">QUrl</db:link> setter methods operate in <db:link xlink:href="qurl.xml#ParsingMode-enum">QUrl::TolerantMode</db:link>, which means they accept some common mistakes and mis-representation of data. An alternate method of parsing is <db:link xlink:href="qurl.xml#ParsingMode-enum">QUrl::StrictMode</db:link>, which applies further checks. See <db:link xlink:href="qurl.xml#ParsingMode-enum">QUrl::ParsingMode</db:link> for a description of the difference of the parsing modes.</db:para>
<db:para><db:link xlink:href="qurl.xml">QUrl</db:link> only checks for conformance with the URL specification. It does not try to verify that high-level protocol URLs are in the format they are expected to be by handlers elsewhere. For example, the following URIs are all considered valid by <db:link xlink:href="qurl.xml">QUrl</db:link>, even if they do not make sense when used:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para>&quot;http:/filename.html&quot;</db:para>
</db:listitem>
<db:listitem>
<db:para>&quot;mailto://example.com&quot;</db:para>
</db:listitem>
</db:itemizedlist>
<db:para>When the parser encounters an error, it signals the event by making <db:link xlink:href="qurl.xml#isValid">isValid</db:link>() return false and <db:link xlink:href="qurl.xml#toString">toString</db:link>() / <db:link xlink:href="qurl.xml#toEncoded">toEncoded</db:link>() return an empty string. If it is necessary to show the user the reason why the URL failed to parse, the error condition can be obtained from <db:link xlink:href="qurl.xml">QUrl</db:link> by calling <db:link xlink:href="qurl.xml#errorString">errorString</db:link>(). Note that this message is highly technical and may not make sense to end-users.</db:para>
<db:para><db:link xlink:href="qurl.xml">QUrl</db:link> is capable of recording only one error condition. If more than one error is found, it is undefined which error is reported.</db:para>
</db:section>
<db:section xml:id="character-conversions">
<db:title>Character Conversions</db:title>
<db:para>Follow these rules to avoid erroneous character conversion when dealing with URLs and strings:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para>When creating a <db:link xlink:href="qstring.xml">QString</db:link> to contain a URL from a <db:link xlink:href="qbytearray.xml">QByteArray</db:link> or a char*, always use <db:link xlink:href="qstring.xml#fromUtf8">QString::fromUtf8</db:link>().</db:para>
</db:listitem>
</db:itemizedlist>
</db:section>
</db:section>
<db:section xml:id="member-type-documentation">
<db:title>Member Type Documentation</db:title>
<db:section xml:id="AceProcessingOption-enum">
<db:title>[since 6.3] enum QUrl::AceProcessingOption</db:title>
<db:bridgehead renderas="sect2">flags QUrl::AceProcessingOptions</db:bridgehead>
<db:enumsynopsis>
<db:enumname>AceProcessingOption</db:enumname>
<db:enumitem>
<db:enumidentifier>IgnoreIDNWhitelist</db:enumidentifier>
<db:enumvalue>0x1</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>AceTransitionalProcessing</db:enumidentifier>
<db:enumvalue>0x2</db:enumvalue>
</db:enumitem>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:enumsynopsis>
<db:typedefsynopsis>
<db:typedefname>QUrl::AceProcessingOptions</db:typedefname>
</db:typedefsynopsis>
<db:para>The ACE processing options control the way URLs are transformed to and from ASCII-Compatible Encoding.</db:para>
<db:informaltable>
<db:thead>
<db:tr>
<db:th>Constant</db:th>
<db:th>Value</db:th>
<db:th>Description</db:th>
</db:tr>
</db:thead>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qurl.xml">QUrl</db:link></db:emphasis>::IgnoreIDNWhitelist</db:code></db:para>
</db:td>
<db:td><db:code>0x1</db:code></db:td>
<db:td>
<db:para>Ignore the IDN whitelist when converting URLs to Unicode.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qurl.xml">QUrl</db:link></db:emphasis>::AceTransitionalProcessing</db:code></db:para>
</db:td>
<db:td><db:code>0x2</db:code></db:td>
<db:td>
<db:para>Use transitional processing described in UTS #46. This allows better compatibility with IDNA 2003 specification.</db:para>
</db:td>
</db:tr>
</db:informaltable>
<db:para>The default is to use nontransitional processing and to allow non-ASCII characters only inside URLs whose top-level domains are listed in the IDN whitelist.</db:para>
<db:para>This enum was introduced or modified in Qt 6.3.</db:para>
<db:para>The <db:code>AceProcessingOptions</db:code> type is a typedef for <db:code><db:link xlink:href="qflags.xml">QFlags</db:link>&lt;AceProcessingOption&gt;. </db:code>It stores an OR combination of <db:code>AceProcessingOption</db:code> values.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qurl.xml#toAce">toAce</db:link>()</db:member>
<db:member><db:link xlink:href="qurl.xml#fromAce">fromAce</db:link>()</db:member>
<db:member><db:link xlink:href="qurl.xml#idnWhitelist">idnWhitelist</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="ComponentFormattingOption-enum">
<db:title>enum QUrl::ComponentFormattingOption</db:title>
<db:bridgehead renderas="sect2">flags QUrl::ComponentFormattingOptions</db:bridgehead>
<db:enumsynopsis>
<db:enumname>ComponentFormattingOption</db:enumname>
<db:enumitem>
<db:enumidentifier>PrettyDecoded</db:enumidentifier>
<db:enumvalue>0x000000</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>EncodeSpaces</db:enumidentifier>
<db:enumvalue>0x100000</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>EncodeUnicode</db:enumidentifier>
<db:enumvalue>0x200000</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>EncodeDelimiters</db:enumidentifier>
<db:enumvalue>0x400000 | 0x800000</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>EncodeReserved</db:enumidentifier>
<db:enumvalue>0x1000000</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>DecodeReserved</db:enumidentifier>
<db:enumvalue>0x2000000</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>FullyEncoded</db:enumidentifier>
<db:enumvalue>EncodeSpaces | EncodeUnicode | EncodeDelimiters | EncodeReserved</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>FullyDecoded</db:enumidentifier>
<db:enumvalue>FullyEncoded | DecodeReserved | 0x4000000</db:enumvalue>
</db:enumitem>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:enumsynopsis>
<db:typedefsynopsis>
<db:typedefname>QUrl::ComponentFormattingOptions</db:typedefname>
</db:typedefsynopsis>
<db:para>The component formatting options define how the components of an URL will be formatted when written out as text. They can be combined with the options from <db:link xlink:href="qurl.xml#UrlFormattingOption-enum">QUrl::FormattingOptions</db:link> when used in <db:link xlink:href="qurl.xml#toString">toString</db:link>() and <db:link xlink:href="qurl.xml#toEncoded">toEncoded</db:link>().</db:para>
<db:informaltable>
<db:thead>
<db:tr>
<db:th>Constant</db:th>
<db:th>Value</db:th>
<db:th>Description</db:th>
</db:tr>
</db:thead>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qurl.xml">QUrl</db:link></db:emphasis>::PrettyDecoded</db:code></db:para>
</db:td>
<db:td><db:code>0x000000</db:code></db:td>
<db:td>
<db:para>The component is returned in a &quot;pretty form&quot;, with most percent-encoded characters decoded. The exact behavior of PrettyDecoded varies from component to component and may also change from Qt release to Qt release. This is the default.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qurl.xml">QUrl</db:link></db:emphasis>::EncodeSpaces</db:code></db:para>
</db:td>
<db:td><db:code>0x100000</db:code></db:td>
<db:td>
<db:para>Leave space characters in their encoded form (&quot;%20&quot;).</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qurl.xml">QUrl</db:link></db:emphasis>::EncodeUnicode</db:code></db:para>
</db:td>
<db:td><db:code>0x200000</db:code></db:td>
<db:td>
<db:para>Leave non-US-ASCII characters encoded in their UTF-8 percent-encoded form (e.g., &quot;%C3%A9&quot; for the U+00E9 codepoint, LATIN SMALL LETTER E WITH ACUTE).</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qurl.xml">QUrl</db:link></db:emphasis>::EncodeDelimiters</db:code></db:para>
</db:td>
<db:td><db:code>0x400000 | 0x800000</db:code></db:td>
<db:td>
<db:para>Leave certain delimiters in their encoded form, as would appear in the URL when the full URL is represented as text. The delimiters are affected by this option change from component to component. This flag has no effect in <db:link xlink:href="qurl.xml#toString">toString</db:link>() or <db:link xlink:href="qurl.xml#toEncoded">toEncoded</db:link>().</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qurl.xml">QUrl</db:link></db:emphasis>::EncodeReserved</db:code></db:para>
</db:td>
<db:td><db:code>0x1000000</db:code></db:td>
<db:td>
<db:para>Leave US-ASCII characters not permitted in the URL by the specification in their encoded form. This is the default on <db:link xlink:href="qurl.xml#toString">toString</db:link>() and <db:link xlink:href="qurl.xml#toEncoded">toEncoded</db:link>().</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qurl.xml">QUrl</db:link></db:emphasis>::DecodeReserved</db:code></db:para>
</db:td>
<db:td><db:code>0x2000000</db:code></db:td>
<db:td>
<db:para>Decode the US-ASCII characters that the URL specification does not allow to appear in the URL. This is the default on the getters of individual components.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qurl.xml">QUrl</db:link></db:emphasis>::FullyEncoded</db:code></db:para>
</db:td>
<db:td><db:code>EncodeSpaces | EncodeUnicode | EncodeDelimiters | EncodeReserved</db:code></db:td>
<db:td>
<db:para>Leave all characters in their properly-encoded form, as this component would appear as part of a URL. When used with <db:link xlink:href="qurl.xml#toString">toString</db:link>(), this produces a fully-compliant URL in <db:link xlink:href="qstring.xml">QString</db:link> form, exactly equal to the result of <db:link xlink:href="qurl.xml#toEncoded">toEncoded</db:link>()</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qurl.xml">QUrl</db:link></db:emphasis>::FullyDecoded</db:code></db:para>
</db:td>
<db:td><db:code>FullyEncoded | DecodeReserved | 0x4000000</db:code></db:td>
<db:td>
<db:para>Attempt to decode as much as possible. For individual components of the URL, this decodes every percent encoding sequence, including control characters (U+0000 to U+001F) and UTF-8 sequences found in percent-encoded form. Use of this mode may cause data loss, see below for more information.</db:para>
</db:td>
</db:tr>
</db:informaltable>
<db:para>The values of EncodeReserved and DecodeReserved should not be used together in one call. The behavior is undefined if that happens. They are provided as separate values because the behavior of the &quot;pretty mode&quot; with regards to reserved characters is different on certain components and specially on the full URL.</db:para>
<db:section xml:id="full-decoding">
<db:title>Full decoding</db:title>
<db:para>The FullyDecoded mode is similar to the behavior of the functions returning <db:link xlink:href="qstring.xml">QString</db:link> in Qt 4.x, in that every character represents itself and never has any special meaning. This is true even for the percent character ('%'), which should be interpreted to mean a literal percent, not the beginning of a percent-encoded sequence. The same actual character, in all other decoding modes, is represented by the sequence &quot;%25&quot;.</db:para>
<db:para>Whenever re-applying data obtained with QUrl::FullyDecoded into a <db:link xlink:href="qurl.xml">QUrl</db:link>, care must be taken to use the <db:link xlink:href="qurl.xml#ParsingMode-enum">QUrl::DecodedMode</db:link> parameter to the setters (like <db:link xlink:href="qurl.xml#setPath">setPath</db:link>() and <db:link xlink:href="qurl.xml#setUserName">setUserName</db:link>()). Failure to do so may cause re-interpretation of the percent character ('%') as the beginning of a percent-encoded sequence.</db:para>
<db:para>This mode is quite useful when portions of a URL are used in a non-URL context. For example, to extract the username, password or file paths in an FTP client application, the FullyDecoded mode should be used.</db:para>
<db:para>This mode should be used with care, since there are two conditions that cannot be reliably represented in the returned <db:link xlink:href="qstring.xml">QString</db:link>. They are:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:emphasis role="bold">Non-UTF-8 sequences:</db:emphasis> URLs may contain sequences of percent-encoded characters that do not form valid UTF-8 sequences. Since URLs need to be decoded using UTF-8, any decoder failure will result in the <db:link xlink:href="qstring.xml">QString</db:link> containing one or more replacement characters where the sequence existed.</db:para>
</db:listitem>
<db:listitem>
<db:para><db:emphasis role="bold">Encoded delimiters:</db:emphasis> URLs are also allowed to make a distinction between a delimiter found in its literal form and its equivalent in percent-encoded form. This is most commonly found in the query, but is permitted in most parts of the URL.</db:para>
</db:listitem>
</db:itemizedlist>
<db:para>The following example illustrates the problem:</db:para>
<db:programlisting language="cpp">    QUrl original(&quot;http://example.com/?q=a%2B%3Db%26c&quot;);
    QUrl copy(original);
    copy.setQuery(copy.query(QUrl::FullyDecoded), QUrl::DecodedMode);

    qDebug() &amp;lt;&amp;lt; original.toString();   // prints: http://example.com/?q=a%2B%3Db%26c
    qDebug() &amp;lt;&amp;lt; copy.toString();       // prints: http://example.com/?q=a+=b&amp;amp;c
</db:programlisting>
<db:para>If the two URLs were used via HTTP GET, the interpretation by the web server would probably be different. In the first case, it would interpret as one parameter, with a key of &quot;q&quot; and value &quot;a+=b&amp;c&quot;. In the second case, it would probably interpret as two parameters, one with a key of &quot;q&quot; and value &quot;a =b&quot;, and the second with a key &quot;c&quot; and no value.</db:para>
</db:section>
<db:section>
<db:title>Notes</db:title>
<db:para>The <db:code>ComponentFormattingOptions</db:code> type is a typedef for <db:code><db:link xlink:href="qflags.xml">QFlags</db:link>&lt;ComponentFormattingOption&gt;. </db:code>It stores an OR combination of <db:code>ComponentFormattingOption</db:code> values.</db:para>
</db:section>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qurl.xml#UrlFormattingOption-enum">QUrl::FormattingOptions</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="ParsingMode-enum">
<db:title>enum QUrl::ParsingMode</db:title>
<db:enumsynopsis>
<db:enumname>ParsingMode</db:enumname>
<db:enumitem>
<db:enumidentifier>TolerantMode</db:enumidentifier>
<db:enumvalue>0</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>StrictMode</db:enumidentifier>
<db:enumvalue>1</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>DecodedMode</db:enumidentifier>
<db:enumvalue>2</db:enumvalue>
</db:enumitem>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:enumsynopsis>
<db:para>The parsing mode controls the way <db:link xlink:href="qurl.xml">QUrl</db:link> parses strings.</db:para>
<db:informaltable>
<db:thead>
<db:tr>
<db:th>Constant</db:th>
<db:th>Value</db:th>
<db:th>Description</db:th>
</db:tr>
</db:thead>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qurl.xml">QUrl</db:link></db:emphasis>::TolerantMode</db:code></db:para>
</db:td>
<db:td><db:code>0</db:code></db:td>
<db:td>
<db:para><db:link xlink:href="qurl.xml">QUrl</db:link> will try to correct some common errors in URLs. This mode is useful for parsing URLs coming from sources not known to be strictly standards-conforming.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qurl.xml">QUrl</db:link></db:emphasis>::StrictMode</db:code></db:para>
</db:td>
<db:td><db:code>1</db:code></db:td>
<db:td>
<db:para>Only valid URLs are accepted. This mode is useful for general URL validation.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qurl.xml">QUrl</db:link></db:emphasis>::DecodedMode</db:code></db:para>
</db:td>
<db:td><db:code>2</db:code></db:td>
<db:td>
<db:para><db:link xlink:href="qurl.xml">QUrl</db:link> will interpret the URL component in the fully-decoded form, where percent characters stand for themselves, not as the beginning of a percent-encoded sequence. This mode is only valid for the setters setting components of a URL; it is not permitted in the <db:link xlink:href="qurl.xml">QUrl</db:link> constructor, in <db:link xlink:href="qurl.xml#fromEncoded">fromEncoded</db:link>() or in <db:link xlink:href="qurl.xml#setUrl">setUrl</db:link>(). For more information on this mode, see the documentation for <db:link xlink:href="qurl.xml#ComponentFormattingOption-enum">QUrl::FullyDecoded</db:link>.</db:para>
</db:td>
</db:tr>
</db:informaltable>
<db:para>In TolerantMode, the parser has the following behaviour:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para>Spaces and &quot;%20&quot;: unencoded space characters will be accepted and will be treated as equivalent to &quot;%20&quot;.</db:para>
</db:listitem>
<db:listitem>
<db:para>Single &quot;%&quot; characters: Any occurrences of a percent character &quot;%&quot; not followed by exactly two hexadecimal characters (e.g., &quot;13% coverage.html&quot;) will be replaced by &quot;%25&quot;. Note that one lone &quot;%&quot; character will trigger the correction mode for all percent characters.</db:para>
</db:listitem>
<db:listitem>
<db:para>Reserved and unreserved characters: An encoded URL should only contain a few characters as literals; all other characters should be percent-encoded. In TolerantMode, these characters will be accepted if they are found in the URL: space / double-quote / &quot;&lt;&quot; / &quot;&gt;&quot; / &quot;&quot; / &quot;^&quot; / &quot;`&quot; / &quot;{&quot; / &quot;|&quot; / &quot;}&quot; Those same characters can be decoded again by passing <db:link xlink:href="qurl.xml#ComponentFormattingOption-enum">QUrl::DecodeReserved</db:link> to <db:link xlink:href="qurl.xml#toString">toString</db:link>() or <db:link xlink:href="qurl.xml#toEncoded">toEncoded</db:link>(). In the getters of individual components, those characters are often returned in decoded form.</db:para>
</db:listitem>
</db:itemizedlist>
<db:para>When in StrictMode, if a parsing error is found, <db:link xlink:href="qurl.xml#isValid">isValid</db:link>() will return false and <db:link xlink:href="qurl.xml#errorString">errorString</db:link>() will return a message describing the error. If more than one error is detected, it is undefined which error gets reported.</db:para>
<db:para>Note that TolerantMode is not usually enough for parsing user input, which often contains more errors and expectations than the parser can deal with. When dealing with data coming directly from the user – as opposed to data coming from data-transfer sources, such as other programs – it is recommended to use <db:link xlink:href="qurl.xml#fromUserInput">fromUserInput</db:link>().</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qurl.xml#fromUserInput">fromUserInput</db:link>()</db:member>
<db:member><db:link xlink:href="qurl.xml#setUrl">setUrl</db:link>()</db:member>
<db:member><db:link xlink:href="qurl.xml#toString">toString</db:link>()</db:member>
<db:member><db:link xlink:href="qurl.xml#toEncoded">toEncoded</db:link>()</db:member>
<db:member><db:link xlink:href="qurl.xml#UrlFormattingOption-enum">QUrl::FormattingOptions</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="UrlFormattingOption-enum">
<db:title>enum QUrl::UrlFormattingOption</db:title>
<db:bridgehead renderas="sect2">flags QUrl::FormattingOptions</db:bridgehead>
<db:enumsynopsis>
<db:enumname>UrlFormattingOption</db:enumname>
<db:enumitem>
<db:enumidentifier>None</db:enumidentifier>
<db:enumvalue>0x0</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>RemoveScheme</db:enumidentifier>
<db:enumvalue>0x1</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>RemovePassword</db:enumidentifier>
<db:enumvalue>0x2</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>RemoveUserInfo</db:enumidentifier>
<db:enumvalue>RemovePassword | 0x4</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>RemovePort</db:enumidentifier>
<db:enumvalue>0x8</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>RemoveAuthority</db:enumidentifier>
<db:enumvalue>RemoveUserInfo | RemovePort | 0x10</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>RemovePath</db:enumidentifier>
<db:enumvalue>0x20</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>RemoveQuery</db:enumidentifier>
<db:enumvalue>0x40</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>RemoveFragment</db:enumidentifier>
<db:enumvalue>0x80</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>PreferLocalFile</db:enumidentifier>
<db:enumvalue>0x200</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>StripTrailingSlash</db:enumidentifier>
<db:enumvalue>0x400</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>RemoveFilename</db:enumidentifier>
<db:enumvalue>0x800</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>NormalizePathSegments</db:enumidentifier>
<db:enumvalue>0x1000</db:enumvalue>
</db:enumitem>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:enumsynopsis>
<db:typedefsynopsis>
<db:typedefname>QUrl::FormattingOptions</db:typedefname>
</db:typedefsynopsis>
<db:para>The formatting options define how the URL is formatted when written out as text.</db:para>
<db:informaltable>
<db:thead>
<db:tr>
<db:th>Constant</db:th>
<db:th>Value</db:th>
<db:th>Description</db:th>
</db:tr>
</db:thead>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qurl.xml">QUrl</db:link></db:emphasis>::None</db:code></db:para>
</db:td>
<db:td><db:code>0x0</db:code></db:td>
<db:td>
<db:para>The format of the URL is unchanged.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qurl.xml">QUrl</db:link></db:emphasis>::RemoveScheme</db:code></db:para>
</db:td>
<db:td><db:code>0x1</db:code></db:td>
<db:td>
<db:para>The scheme is removed from the URL.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qurl.xml">QUrl</db:link></db:emphasis>::RemovePassword</db:code></db:para>
</db:td>
<db:td><db:code>0x2</db:code></db:td>
<db:td>
<db:para>Any password in the URL is removed.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qurl.xml">QUrl</db:link></db:emphasis>::RemoveUserInfo</db:code></db:para>
</db:td>
<db:td><db:code>RemovePassword | 0x4</db:code></db:td>
<db:td>
<db:para>Any user information in the URL is removed.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qurl.xml">QUrl</db:link></db:emphasis>::RemovePort</db:code></db:para>
</db:td>
<db:td><db:code>0x8</db:code></db:td>
<db:td>
<db:para>Any specified port is removed from the URL.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qurl.xml">QUrl</db:link></db:emphasis>::RemoveAuthority</db:code></db:para>
</db:td>
<db:td><db:code>RemoveUserInfo | RemovePort | 0x10</db:code></db:td>
<db:td/>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qurl.xml">QUrl</db:link></db:emphasis>::RemovePath</db:code></db:para>
</db:td>
<db:td><db:code>0x20</db:code></db:td>
<db:td>
<db:para>The URL's path is removed, leaving only the scheme, host address, and port (if present).</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qurl.xml">QUrl</db:link></db:emphasis>::RemoveQuery</db:code></db:para>
</db:td>
<db:td><db:code>0x40</db:code></db:td>
<db:td>
<db:para>The query part of the URL (following a '?' character) is removed.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qurl.xml">QUrl</db:link></db:emphasis>::RemoveFragment</db:code></db:para>
</db:td>
<db:td><db:code>0x80</db:code></db:td>
<db:td/>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qurl.xml">QUrl</db:link></db:emphasis>::RemoveFilename</db:code></db:para>
</db:td>
<db:td><db:code>0x800</db:code></db:td>
<db:td>
<db:para>The filename (i.e. everything after the last '/' in the path) is removed. The trailing '/' is kept, unless StripTrailingSlash is set. Only valid if RemovePath is not set.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qurl.xml">QUrl</db:link></db:emphasis>::PreferLocalFile</db:code></db:para>
</db:td>
<db:td><db:code>0x200</db:code></db:td>
<db:td>
<db:para>If the URL is a local file according to <db:link xlink:href="qurl.xml#isLocalFile">isLocalFile</db:link>() and contains no query or fragment, a local file path is returned.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qurl.xml">QUrl</db:link></db:emphasis>::StripTrailingSlash</db:code></db:para>
</db:td>
<db:td><db:code>0x400</db:code></db:td>
<db:td>
<db:para>The trailing slash is removed from the path, if one is present.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qurl.xml">QUrl</db:link></db:emphasis>::NormalizePathSegments</db:code></db:para>
</db:td>
<db:td><db:code>0x1000</db:code></db:td>
<db:td>
<db:para>Modifies the path to remove redundant directory separators, and to resolve &quot;.&quot;s and &quot;..&quot;s (as far as possible). For non-local paths, adjacent slashes are preserved.</db:para>
</db:td>
</db:tr>
</db:informaltable>
<db:para>Note that the case folding rules in <db:link xlink:href="https://datatracker.ietf.org/doc/html/rfc3491">Nameprep</db:link>, which <db:link xlink:href="qurl.xml">QUrl</db:link> conforms to, require host names to always be converted to lower case, regardless of the Qt::FormattingOptions used.</db:para>
<db:para>The options from <db:link xlink:href="qurl.xml#ComponentFormattingOption-enum">QUrl::ComponentFormattingOptions</db:link> are also possible.</db:para>
<db:para>The <db:code>FormattingOptions</db:code> type is a typedef for <db:code><db:link xlink:href="qflags.xml">QFlags</db:link>&lt;UrlFormattingOption&gt;. </db:code>It stores an OR combination of <db:code>UrlFormattingOption</db:code> values.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qurl.xml#ComponentFormattingOption-enum">QUrl::ComponentFormattingOptions</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="UserInputResolutionOption-enum">
<db:title>enum QUrl::UserInputResolutionOption</db:title>
<db:bridgehead renderas="sect2">flags QUrl::UserInputResolutionOptions</db:bridgehead>
<db:enumsynopsis>
<db:enumname>UserInputResolutionOption</db:enumname>
<db:enumitem>
<db:enumidentifier>DefaultResolution</db:enumidentifier>
<db:enumvalue>0</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>AssumeLocalFile</db:enumidentifier>
<db:enumvalue>1</db:enumvalue>
</db:enumitem>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:enumsynopsis>
<db:typedefsynopsis>
<db:typedefname>QUrl::UserInputResolutionOptions</db:typedefname>
</db:typedefsynopsis>
<db:para>The user input resolution options define how <db:link xlink:href="qurl.xml#fromUserInput">fromUserInput</db:link>() should interpret strings that could either be a relative path or the short form of a HTTP URL. For instance file.pl can be either a local file or the URL http://file.pl.</db:para>
<db:informaltable>
<db:thead>
<db:tr>
<db:th>Constant</db:th>
<db:th>Value</db:th>
<db:th>Description</db:th>
</db:tr>
</db:thead>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qurl.xml">QUrl</db:link></db:emphasis>::DefaultResolution</db:code></db:para>
</db:td>
<db:td><db:code>0</db:code></db:td>
<db:td>
<db:para>The default resolution mechanism is to check whether a local file exists, in the working directory given to <db:link xlink:href="qurl.xml#fromUserInput">fromUserInput</db:link>, and only return a local path in that case. Otherwise a URL is assumed.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qurl.xml">QUrl</db:link></db:emphasis>::AssumeLocalFile</db:code></db:para>
</db:td>
<db:td><db:code>1</db:code></db:td>
<db:td>
<db:para>This option makes <db:link xlink:href="qurl.xml#fromUserInput">fromUserInput</db:link>() always return a local path unless the input contains a scheme, such as http://file.pl. This is useful for applications such as text editors, which are able to create the file if it doesn't exist.</db:para>
</db:td>
</db:tr>
</db:informaltable>
<db:para>The <db:code>UserInputResolutionOptions</db:code> type is a typedef for <db:code><db:link xlink:href="qflags.xml">QFlags</db:link>&lt;UserInputResolutionOption&gt;. </db:code>It stores an OR combination of <db:code>UserInputResolutionOption</db:code> values.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qurl.xml#fromUserInput">fromUserInput</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
</db:section>
<db:section xml:id="member-function-documentation">
<db:title>Member Function Documentation</db:title>
<db:section xml:id="QUrl">
<db:title>QUrl::QUrl()</db:title>
<db:constructorsynopsis>
<db:methodname>QUrl</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">constructor</db:synopsisinfo>
<db:synopsisinfo role="signature">QUrl()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:constructorsynopsis>
<db:para>Constructs an empty <db:link xlink:href="qurl.xml">QUrl</db:link> object.</db:para>
</db:section>
<db:section xml:id="QUrl-2">
<db:title>QUrl::QUrl(const QString &amp;<db:emphasis>url</db:emphasis>, QUrl::ParsingMode <db:emphasis>parsingMode</db:emphasis> = TolerantMode)</db:title>
<db:constructorsynopsis>
<db:methodname>QUrl</db:methodname>
<db:methodparam>
<db:type>const QString &amp;</db:type>
<db:parameter>url</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>QUrl::ParsingMode</db:type>
<db:parameter>parsingMode</db:parameter>
<db:initializer>TolerantMode</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">constructor</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">2</db:synopsisinfo>
<db:synopsisinfo role="signature">QUrl(const QString &amp;url, QUrl::ParsingMode parsingMode)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:constructorsynopsis>
<db:para>Constructs a URL by parsing <db:code role="parameter">url</db:code>. Note this constructor expects a proper URL or URL-Reference and will not attempt to guess intent. For example, the following declaration:</db:para>
<db:programlisting language="cpp">QUrl url(&quot;example.com&quot;);
</db:programlisting>
<db:para>Will construct a valid URL but it may not be what one expects, as the <db:link xlink:href="qurl.xml#scheme">scheme</db:link>() part of the input is missing. For a string like the above, applications may want to use <db:link xlink:href="qurl.xml#fromUserInput">fromUserInput</db:link>(). For this constructor or <db:link xlink:href="qurl.xml#setUrl">setUrl</db:link>(), the following is probably what was intended:</db:para>
<db:programlisting language="cpp">QUrl url(&quot;https://example.com&quot;);
</db:programlisting>
<db:para><db:link xlink:href="qurl.xml">QUrl</db:link> will automatically percent encode all characters that are not allowed in a URL and decode the percent-encoded sequences that represent an unreserved character (letters, digits, hyphens, underscores, dots and tildes). All other characters are left in their original forms.</db:para>
<db:para>Parses the <db:code role="parameter">url</db:code> using the parser mode <db:code role="parameter">parsingMode</db:code>. In <db:link xlink:href="qurl.xml#ParsingMode-enum">TolerantMode</db:link> (the default), <db:link xlink:href="qurl.xml">QUrl</db:link> will correct certain mistakes, notably the presence of a percent character ('%') not followed by two hexadecimal digits, and it will accept any character in any position. In <db:link xlink:href="qurl.xml#ParsingMode-enum">StrictMode</db:link>, encoding mistakes will not be tolerated and <db:link xlink:href="qurl.xml">QUrl</db:link> will also check that certain forbidden characters are not present in unencoded form. If an error is detected in <db:link xlink:href="qurl.xml#ParsingMode-enum">StrictMode</db:link>, <db:link xlink:href="qurl.xml#isValid">isValid</db:link>() will return false. The parsing mode <db:link xlink:href="qurl.xml#ParsingMode-enum">DecodedMode</db:link> is not permitted in this context.</db:para>
<db:para>Example:</db:para>
<db:programlisting language="cpp">QUrl url(&quot;http://www.example.com/List of holidays.xml&quot;);
// url.toEncoded() == &quot;http://www.example.com/List%20of%20holidays.xml&quot;
</db:programlisting>
<db:para>To construct a URL from an encoded string, you can also use <db:link xlink:href="qurl.xml#fromEncoded">fromEncoded</db:link>():</db:para>
<db:programlisting language="cpp">QUrl url = QUrl::fromEncoded(&quot;http://qt-project.org/List%20of%20holidays.xml&quot;);
</db:programlisting>
<db:para>Both functions are equivalent and, in Qt 5, both functions accept encoded data. Usually, the choice of the <db:link xlink:href="qurl.xml">QUrl</db:link> constructor or <db:link xlink:href="qurl.xml#setUrl">setUrl</db:link>() versus <db:link xlink:href="qurl.xml#fromEncoded">fromEncoded</db:link>() will depend on the source data: the constructor and <db:link xlink:href="qurl.xml#setUrl">setUrl</db:link>() take a <db:link xlink:href="qstring.xml">QString</db:link>, whereas <db:link xlink:href="qurl.xml#fromEncoded">fromEncoded</db:link> takes a <db:link xlink:href="qbytearray.xml">QByteArray</db:link>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qurl.xml#setUrl">setUrl</db:link>()</db:member>
<db:member><db:link xlink:href="qurl.xml#fromEncoded">fromEncoded</db:link>()</db:member>
<db:member><db:link xlink:href="qurl.xml#ParsingMode-enum">TolerantMode</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="QUrl-1">
<db:title>QUrl::QUrl(const QUrl &amp;<db:emphasis>other</db:emphasis>)</db:title>
<db:constructorsynopsis>
<db:methodname>QUrl</db:methodname>
<db:methodparam>
<db:type>const QUrl &amp;</db:type>
<db:parameter>other</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">copy-constructor</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">QUrl(const QUrl &amp;other)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:constructorsynopsis>
<db:para>Constructs a copy of <db:code role="parameter">other</db:code>.</db:para>
</db:section>
<db:section xml:id="QUrl-3">
<db:title>QUrl::QUrl(QUrl &amp;&amp;<db:emphasis>other</db:emphasis>)</db:title>
<db:constructorsynopsis>
<db:methodname>QUrl</db:methodname>
<db:methodparam>
<db:type>QUrl &amp;&amp;</db:type>
<db:parameter>other</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">move-constructor</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">3</db:synopsisinfo>
<db:synopsisinfo role="signature">QUrl(QUrl &amp;&amp;other)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:constructorsynopsis>
<db:para>Move-constructs a <db:link xlink:href="qurl.xml">QUrl</db:link> instance, making it point at the same object that <db:code role="parameter">other</db:code> was pointing to.</db:para>
</db:section>
<db:section xml:id="dtor.QUrl">
<db:title>QUrl::~QUrl()</db:title>
<db:destructorsynopsis>
<db:methodname>~QUrl</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">destructor</db:synopsisinfo>
<db:synopsisinfo role="signature">~QUrl()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:destructorsynopsis>
<db:para>Destructor; called immediately before the object is deleted.</db:para>
</db:section>
<db:section xml:id="adjusted">
<db:title>QUrl QUrl::adjusted(QUrl::FormattingOptions <db:emphasis>options</db:emphasis>) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QUrl</db:type>
<db:methodname>adjusted</db:methodname>
<db:methodparam>
<db:type>QUrl::FormattingOptions</db:type>
<db:parameter>options</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QUrl adjusted(QUrl::FormattingOptions options) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns an adjusted version of the URL. The output can be customized by passing flags with <db:code role="parameter">options</db:code>.</db:para>
<db:para>The encoding options from <db:link xlink:href="qurl.xml#ComponentFormattingOption-enum">QUrl::ComponentFormattingOption</db:link> don't make much sense for this method, nor does <db:link xlink:href="qurl.xml#UrlFormattingOption-enum">QUrl::PreferLocalFile</db:link>.</db:para>
<db:para>This is always equivalent to <db:link xlink:href="qurl.xml">QUrl</db:link>(url.<db:link xlink:href="qurl.xml#toString">toString</db:link>(options)).</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qurl.xml#UrlFormattingOption-enum">FormattingOptions</db:link></db:member>
<db:member><db:link xlink:href="qurl.xml#toEncoded">toEncoded</db:link>()</db:member>
<db:member><db:link xlink:href="qurl.xml#toString">toString</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="authority">
<db:title>QString QUrl::authority(QUrl::ComponentFormattingOptions <db:emphasis>options</db:emphasis> = PrettyDecoded) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QString</db:type>
<db:methodname>authority</db:methodname>
<db:methodparam>
<db:type>QUrl::ComponentFormattingOptions</db:type>
<db:parameter>options</db:parameter>
<db:initializer>PrettyDecoded</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QString authority(QUrl::ComponentFormattingOptions options) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the authority of the URL if it is defined; otherwise an empty string is returned.</db:para>
<db:para>This function returns an unambiguous value, which may contain that characters still percent-encoded, plus some control sequences not representable in decoded form in <db:link xlink:href="qstring.xml">QString</db:link>.</db:para>
<db:para>The <db:code role="parameter">options</db:code> argument controls how to format the user info component. The value of <db:link xlink:href="qurl.xml#ComponentFormattingOption-enum">QUrl::FullyDecoded</db:link> is not permitted in this function. If you need to obtain fully decoded data, call <db:link xlink:href="qurl.xml#userName">userName</db:link>(), <db:link xlink:href="qurl.xml#password">password</db:link>(), <db:link xlink:href="qurl.xml#host">host</db:link>() and <db:link xlink:href="qurl.xml#port">port</db:link>() individually.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qurl.xml#setAuthority">setAuthority</db:link>()</db:member>
<db:member><db:link xlink:href="qurl.xml#userInfo">userInfo</db:link>()</db:member>
<db:member><db:link xlink:href="qurl.xml#userName">userName</db:link>()</db:member>
<db:member><db:link xlink:href="qurl.xml#password">password</db:link>()</db:member>
<db:member><db:link xlink:href="qurl.xml#host">host</db:link>()</db:member>
<db:member><db:link xlink:href="qurl.xml#port">port</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="clear">
<db:title>void QUrl::clear()</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>clear</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void clear()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Resets the content of the <db:link xlink:href="qurl.xml">QUrl</db:link>. After calling this function, the <db:link xlink:href="qurl.xml">QUrl</db:link> is equal to one that has been constructed with the default empty constructor.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qurl.xml#isEmpty">isEmpty</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="errorString">
<db:title>QString QUrl::errorString() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QString</db:type>
<db:methodname>errorString</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QString errorString() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns an error message if the last operation that modified this <db:link xlink:href="qurl.xml">QUrl</db:link> object ran into a parsing error. If no error was detected, this function returns an empty string and <db:link xlink:href="qurl.xml#isValid">isValid</db:link>() returns true.</db:para>
<db:para>The error message returned by this function is technical in nature and may not be understood by end users. It is mostly useful to developers trying to understand why <db:link xlink:href="qurl.xml">QUrl</db:link> will not accept some input.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qurl.xml#ParsingMode-enum">QUrl::ParsingMode</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="fileName">
<db:title>QString QUrl::fileName(QUrl::ComponentFormattingOptions <db:emphasis>options</db:emphasis> = FullyDecoded) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QString</db:type>
<db:methodname>fileName</db:methodname>
<db:methodparam>
<db:type>QUrl::ComponentFormattingOptions</db:type>
<db:parameter>options</db:parameter>
<db:initializer>FullyDecoded</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QString fileName(QUrl::ComponentFormattingOptions options) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the name of the file, excluding the directory path.</db:para>
<db:para>Note that, if this <db:link xlink:href="qurl.xml">QUrl</db:link> object is given a path ending in a slash, the name of the file is considered empty.</db:para>
<db:para>If the path doesn't contain any slash, it is fully returned as the fileName.</db:para>
<db:para>Example:</db:para>
<db:programlisting language="cpp">QUrl url(&quot;http://qt-project.org/support/file.html&quot;);
// url.adjusted(RemoveFilename) == &quot;http://qt-project.org/support/&quot;
// url.fileName() == &quot;file.html&quot;
</db:programlisting>
<db:para>The <db:code role="parameter">options</db:code> argument controls how to format the file name component. All values produce an unambiguous result. With <db:link xlink:href="qurl.xml#ComponentFormattingOption-enum">QUrl::FullyDecoded</db:link>, all percent-encoded sequences are decoded; otherwise, the returned value may contain some percent-encoded sequences for some control sequences not representable in decoded form in <db:link xlink:href="qstring.xml">QString</db:link>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qurl.xml#path">path</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="fragment">
<db:title>QString QUrl::fragment(QUrl::ComponentFormattingOptions <db:emphasis>options</db:emphasis> = PrettyDecoded) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QString</db:type>
<db:methodname>fragment</db:methodname>
<db:methodparam>
<db:type>QUrl::ComponentFormattingOptions</db:type>
<db:parameter>options</db:parameter>
<db:initializer>PrettyDecoded</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QString fragment(QUrl::ComponentFormattingOptions options) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the fragment of the URL. To determine if the parsed URL contained a fragment, use <db:link xlink:href="qurl.xml#hasFragment">hasFragment</db:link>().</db:para>
<db:para>The <db:code role="parameter">options</db:code> argument controls how to format the fragment component. All values produce an unambiguous result. With <db:link xlink:href="qurl.xml#ComponentFormattingOption-enum">QUrl::FullyDecoded</db:link>, all percent-encoded sequences are decoded; otherwise, the returned value may contain some percent-encoded sequences for some control sequences not representable in decoded form in <db:link xlink:href="qstring.xml">QString</db:link>.</db:para>
<db:para>Note that <db:link xlink:href="qurl.xml#ComponentFormattingOption-enum">QUrl::FullyDecoded</db:link> may cause data loss if those non-representable sequences are present. It is recommended to use that value when the result will be used in a non-URL context.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qurl.xml#setFragment">setFragment</db:link>()</db:member>
<db:member><db:link xlink:href="qurl.xml#hasFragment">hasFragment</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="fromAce">
<db:title>[static, since 6.3] QString QUrl::fromAce(const QByteArray &amp;<db:emphasis>domain</db:emphasis>, QUrl::AceProcessingOptions <db:emphasis>options</db:emphasis> = {})</db:title>
<db:methodsynopsis>
<db:modifier>static</db:modifier>
<db:type>QString</db:type>
<db:methodname>fromAce</db:methodname>
<db:methodparam>
<db:type>const QByteArray &amp;</db:type>
<db:parameter>domain</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>QUrl::AceProcessingOptions</db:type>
<db:parameter>options</db:parameter>
<db:initializer>{}</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QString fromAce(const QByteArray &amp;domain, QUrl::AceProcessingOptions options)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the Unicode form of the given domain name <db:code role="parameter">domain</db:code>, which is encoded in the ASCII Compatible Encoding (ACE). The output can be customized by passing flags with <db:code role="parameter">options</db:code>. The result of this function is considered equivalent to <db:code role="parameter">domain</db:code>.</db:para>
<db:para>If the value in <db:code role="parameter">domain</db:code> cannot be encoded, it will be converted to <db:link xlink:href="qstring.xml">QString</db:link> and returned.</db:para>
<db:para>The ASCII-Compatible Encoding (ACE) is defined by RFC 3490, RFC 3491 and RFC 3492 and updated by the Unicode Technical Standard #46. It is part of the Internationalizing Domain Names in Applications (IDNA) specification, which allows for domain names (like &quot;example.com&quot;) to be written using non-US-ASCII characters.</db:para>
<db:para>This function was introduced in Qt 6.3.</db:para>
</db:section>
<db:section xml:id="fromCFURL">
<db:title>[static] QUrl QUrl::fromCFURL(CFURLRef <db:emphasis>url</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:modifier>static</db:modifier>
<db:type>QUrl</db:type>
<db:methodname>fromCFURL</db:methodname>
<db:methodparam>
<db:type>CFURLRef</db:type>
<db:parameter>url</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QUrl fromCFURL(CFURLRef url)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Constructs a <db:link xlink:href="qurl.xml">QUrl</db:link> containing a copy of the CFURL <db:code role="parameter">url</db:code>.</db:para>
</db:section>
<db:section xml:id="fromEncoded">
<db:title>[static] QUrl QUrl::fromEncoded(QByteArrayView <db:emphasis>input</db:emphasis>, QUrl::ParsingMode <db:emphasis>mode</db:emphasis> = TolerantMode)</db:title>
<db:methodsynopsis>
<db:modifier>static</db:modifier>
<db:type>QUrl</db:type>
<db:methodname>fromEncoded</db:methodname>
<db:methodparam>
<db:type>QByteArrayView</db:type>
<db:parameter>input</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>QUrl::ParsingMode</db:type>
<db:parameter>mode</db:parameter>
<db:initializer>TolerantMode</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QUrl fromEncoded(QByteArrayView input, QUrl::ParsingMode mode)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Parses <db:code role="parameter">input</db:code> and returns the corresponding <db:link xlink:href="qurl.xml">QUrl</db:link>. <db:code role="parameter">input</db:code> is assumed to be in encoded form, containing only ASCII characters.</db:para>
<db:para>Parses the URL using <db:code role="parameter">mode</db:code>. See <db:link xlink:href="qurl.xml#setUrl">setUrl</db:link>() for more information on this parameter. <db:link xlink:href="qurl.xml#ParsingMode-enum">QUrl::DecodedMode</db:link> is not permitted in this context.</db:para>
<db:note>
<db:para>In Qt versions prior to 6.7, this function took a <db:link xlink:href="qbytearray.xml">QByteArray</db:link>, not <db:link xlink:href="qbytearrayview.xml">QByteArrayView</db:link>. If you experience compile errors, it's because your code is passing objects that are implicitly convertible to <db:link xlink:href="qbytearray.xml">QByteArray</db:link>, but not <db:link xlink:href="qbytearrayview.xml">QByteArrayView</db:link>. Wrap the corresponding argument in QByteArray{~~~} to make the cast explicit. This is backwards-compatible with old Qt versions.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qurl.xml#toEncoded">toEncoded</db:link>()</db:member>
<db:member><db:link xlink:href="qurl.xml#setUrl">setUrl</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="fromLocalFile">
<db:title>[static] QUrl QUrl::fromLocalFile(const QString &amp;<db:emphasis>localFile</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:modifier>static</db:modifier>
<db:type>QUrl</db:type>
<db:methodname>fromLocalFile</db:methodname>
<db:methodparam>
<db:type>const QString &amp;</db:type>
<db:parameter>localFile</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QUrl fromLocalFile(const QString &amp;localFile)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns a <db:link xlink:href="qurl.xml">QUrl</db:link> representation of <db:code role="parameter">localFile</db:code>, interpreted as a local file. This function accepts paths separated by slashes as well as the native separator for this platform.</db:para>
<db:para>This function also accepts paths with a doubled leading slash (or backslash) to indicate a remote file, as in &quot;//servername/path/to/file.txt&quot;. Note that only certain platforms can actually open this file using <db:link xlink:href="qfile.xml#open">QFile::open</db:link>().</db:para>
<db:para>An empty <db:code role="parameter">localFile</db:code> leads to an empty URL (since Qt 5.4).</db:para>
<db:programlisting language="cpp">    qDebug() &amp;lt;&amp;lt; QUrl::fromLocalFile(&quot;file.txt&quot;);            // QUrl(&quot;file:file.txt&quot;)
    qDebug() &amp;lt;&amp;lt; QUrl::fromLocalFile(&quot;/home/user/file.txt&quot;); // QUrl(&quot;file:///home/user/file.txt&quot;)
    qDebug() &amp;lt;&amp;lt; QUrl::fromLocalFile(&quot;file:file.txt&quot;);       // doesn't make sense; expects path, not url with scheme
</db:programlisting>
<db:para>In the first line in snippet above, a file URL is constructed from a local, relative path. A file URL with a relative path only makes sense if there is a base URL to resolve it against. For example:</db:para>
<db:programlisting language="cpp">    QUrl url = QUrl::fromLocalFile(&quot;file.txt&quot;);
    QUrl baseUrl = QUrl(&quot;file:/home/user/&quot;);
    // wrong: prints QUrl(&quot;file:file.txt&quot;), as url already has a scheme
    qDebug() &amp;lt;&amp;lt; baseUrl.resolved(url);
</db:programlisting>
<db:para>To resolve such a URL, it's necessary to remove the scheme beforehand:</db:para>
<db:programlisting language="cpp">    // correct: prints QUrl(&quot;file:///home/user/file.txt&quot;)
    url.setScheme(QString());
    qDebug() &amp;lt;&amp;lt; baseUrl.resolved(url);
</db:programlisting>
<db:para>For this reason, it is better to use a relative URL (that is, no scheme) for relative file paths:</db:para>
<db:programlisting language="cpp">    QUrl url = QUrl(&quot;file.txt&quot;);
    QUrl baseUrl = QUrl(&quot;file:/home/user/&quot;);
    // prints QUrl(&quot;file:///home/user/file.txt&quot;)
    qDebug() &amp;lt;&amp;lt; baseUrl.resolved(url);
</db:programlisting>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qurl.xml#toLocalFile">toLocalFile</db:link>()</db:member>
<db:member><db:link xlink:href="qurl.xml#isLocalFile">isLocalFile</db:link>()</db:member>
<db:member><db:link xlink:href="qdir.xml#toNativeSeparators">QDir::toNativeSeparators</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="fromNSURL">
<db:title>[static] QUrl QUrl::fromNSURL(const NSURL *<db:emphasis>url</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:modifier>static</db:modifier>
<db:type>QUrl</db:type>
<db:methodname>fromNSURL</db:methodname>
<db:methodparam>
<db:type>const NSURL *</db:type>
<db:parameter>url</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QUrl fromNSURL(const NSURL *url)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Constructs a <db:link xlink:href="qurl.xml">QUrl</db:link> containing a copy of the NSURL <db:code role="parameter">url</db:code>.</db:para>
</db:section>
<db:section xml:id="fromPercentEncoding">
<db:title>[static] QString QUrl::fromPercentEncoding(const QByteArray &amp;<db:emphasis>input</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:modifier>static</db:modifier>
<db:type>QString</db:type>
<db:methodname>fromPercentEncoding</db:methodname>
<db:methodparam>
<db:type>const QByteArray &amp;</db:type>
<db:parameter>input</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QString fromPercentEncoding(const QByteArray &amp;input)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns a decoded copy of <db:code role="parameter">input</db:code>. <db:code role="parameter">input</db:code> is first decoded from percent encoding, then converted from UTF-8 to unicode.</db:para>
<db:note>
<db:para>Given invalid input (such as a string containing the sequence &quot;%G5&quot;, which is not a valid hexadecimal number) the output will be invalid as well. As an example: the sequence &quot;%G5&quot; could be decoded to 'W'.</db:para>
</db:note>
</db:section>
<db:section xml:id="fromStringList">
<db:title>[static] QList&lt;QUrl&gt; QUrl::fromStringList(const QStringList &amp;<db:emphasis>urls</db:emphasis>, QUrl::ParsingMode <db:emphasis>mode</db:emphasis> = TolerantMode)</db:title>
<db:methodsynopsis>
<db:modifier>static</db:modifier>
<db:type>QList&lt;QUrl&gt;</db:type>
<db:methodname>fromStringList</db:methodname>
<db:methodparam>
<db:type>const QStringList &amp;</db:type>
<db:parameter>urls</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>QUrl::ParsingMode</db:type>
<db:parameter>mode</db:parameter>
<db:initializer>TolerantMode</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QList&lt;QUrl&gt; fromStringList(const QStringList &amp;urls, QUrl::ParsingMode mode)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Converts a list of strings representing <db:code role="parameter">urls</db:code> into a list of urls, using <db:link xlink:href="qurl.xml">QUrl</db:link>(str, <db:code role="parameter">mode</db:code>). Note that this means all strings must be urls, not for instance local paths.</db:para>
</db:section>
<db:section xml:id="fromUserInput">
<db:title>[static] QUrl QUrl::fromUserInput(const QString &amp;<db:emphasis>userInput</db:emphasis>, const QString &amp;<db:emphasis>workingDirectory</db:emphasis> = QString(), QUrl::UserInputResolutionOptions <db:emphasis>options</db:emphasis> = DefaultResolution)</db:title>
<db:methodsynopsis>
<db:modifier>static</db:modifier>
<db:type>QUrl</db:type>
<db:methodname>fromUserInput</db:methodname>
<db:methodparam>
<db:type>const QString &amp;</db:type>
<db:parameter>userInput</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const QString &amp;</db:type>
<db:parameter>workingDirectory</db:parameter>
<db:initializer>QString()</db:initializer>
</db:methodparam>
<db:methodparam>
<db:type>QUrl::UserInputResolutionOptions</db:type>
<db:parameter>options</db:parameter>
<db:initializer>DefaultResolution</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QUrl fromUserInput(const QString &amp;userInput, const QString &amp;workingDirectory, QUrl::UserInputResolutionOptions options)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns a valid URL from a user supplied <db:code role="parameter">userInput</db:code> string if one can be deduced. In the case that is not possible, an invalid <db:link xlink:href="qurl.xml#QUrl">QUrl</db:link>() is returned.</db:para>
<db:para>This allows the user to input a URL or a local file path in the form of a plain string. This string can be manually typed into a location bar, obtained from the clipboard, or passed in via command line arguments.</db:para>
<db:para>When the string is not already a valid URL, a best guess is performed, making various assumptions.</db:para>
<db:para>In the case the string corresponds to a valid file path on the system, a file:// URL is constructed, using <db:link xlink:href="qurl.xml#fromLocalFile">QUrl::fromLocalFile</db:link>().</db:para>
<db:para>If that is not the case, an attempt is made to turn the string into a http:// or ftp:// URL. The latter in the case the string starts with 'ftp'. The result is then passed through <db:link xlink:href="qurl.xml">QUrl</db:link>'s tolerant parser, and in the case or success, a valid <db:link xlink:href="qurl.xml">QUrl</db:link> is returned, or else a <db:link xlink:href="qurl.xml#QUrl">QUrl</db:link>().</db:para>
<db:section xml:id="examples">
<db:title>Examples:</db:title>
<db:itemizedlist>
<db:listitem>
<db:para>qt-project.org becomes http://qt-project.org</db:para>
</db:listitem>
<db:listitem>
<db:para>ftp.qt-project.org becomes ftp://ftp.qt-project.org</db:para>
</db:listitem>
<db:listitem>
<db:para>hostname becomes http://hostname</db:para>
</db:listitem>
<db:listitem>
<db:para>/home/user/test.html becomes file:///home/user/test.html</db:para>
</db:listitem>
</db:itemizedlist>
<db:para>In order to be able to handle relative paths, this method takes an optional <db:code role="parameter">workingDirectory</db:code> path. This is especially useful when handling command line arguments. If <db:code role="parameter">workingDirectory</db:code> is empty, no handling of relative paths will be done.</db:para>
<db:para>By default, an input string that looks like a relative path will only be treated as such if the file actually exists in the given working directory. If the application can handle files that don't exist yet, it should pass the flag <db:link xlink:href="qurl.xml#UserInputResolutionOption-enum">AssumeLocalFile</db:link> in <db:code role="parameter">options</db:code>.</db:para>
</db:section>
<db:section>
<db:title>Notes</db:title>
</db:section>
</db:section>
<db:section xml:id="hasFragment">
<db:title>bool QUrl::hasFragment() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>bool</db:type>
<db:methodname>hasFragment</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool hasFragment() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns true if this URL contains a fragment (i.e., if # was seen on it).</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qurl.xml#fragment">fragment</db:link>()</db:member>
<db:member><db:link xlink:href="qurl.xml#setFragment">setFragment</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="hasQuery">
<db:title>bool QUrl::hasQuery() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>bool</db:type>
<db:methodname>hasQuery</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool hasQuery() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns true if this URL contains a Query (i.e., if ? was seen on it).</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qurl.xml#setQuery">setQuery</db:link>()</db:member>
<db:member><db:link xlink:href="qurl.xml#query">query</db:link>()</db:member>
<db:member><db:link xlink:href="qurl.xml#hasFragment">hasFragment</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="host">
<db:title>QString QUrl::host(QUrl::ComponentFormattingOptions <db:emphasis>options</db:emphasis> = FullyDecoded) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QString</db:type>
<db:methodname>host</db:methodname>
<db:methodparam>
<db:type>QUrl::ComponentFormattingOptions</db:type>
<db:parameter>options</db:parameter>
<db:initializer>FullyDecoded</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QString host(QUrl::ComponentFormattingOptions options) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the host of the URL if it is defined; otherwise an empty string is returned.</db:para>
<db:para>The <db:code role="parameter">options</db:code> argument controls how the hostname will be formatted. The <db:link xlink:href="qurl.xml#ComponentFormattingOption-enum">QUrl::EncodeUnicode</db:link> option will cause this function to return the hostname in the ASCII-Compatible Encoding (ACE) form, which is suitable for use in channels that are not 8-bit clean or that require the legacy hostname (such as DNS requests or in HTTP request headers). If that flag is not present, this function returns the International Domain Name (IDN) in Unicode form, according to the list of permissible top-level domains (see <db:link xlink:href="qurl.xml#idnWhitelist">idnWhitelist</db:link>()).</db:para>
<db:para>All other flags are ignored. Host names cannot contain control or percent characters, so the returned value can be considered fully decoded.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qurl.xml#setHost">setHost</db:link>()</db:member>
<db:member><db:link xlink:href="qurl.xml#idnWhitelist">idnWhitelist</db:link>()</db:member>
<db:member><db:link xlink:href="qurl.xml#setIdnWhitelist">setIdnWhitelist</db:link>()</db:member>
<db:member><db:link xlink:href="qurl.xml#authority">authority</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="idnWhitelist">
<db:title>[static] QStringList QUrl::idnWhitelist()</db:title>
<db:methodsynopsis>
<db:modifier>static</db:modifier>
<db:type>QStringList</db:type>
<db:methodname>idnWhitelist</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QStringList idnWhitelist()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the current whitelist of top-level domains that are allowed to have non-ASCII characters in their compositions.</db:para>
<db:para>See <db:link xlink:href="qurl.xml#setIdnWhitelist">setIdnWhitelist</db:link>() for the rationale of this list.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qurl.xml#setIdnWhitelist">setIdnWhitelist</db:link>()</db:member>
<db:member><db:link xlink:href="qurl.xml#AceProcessingOption-enum">AceProcessingOption</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="isEmpty">
<db:title>bool QUrl::isEmpty() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>bool</db:type>
<db:methodname>isEmpty</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool isEmpty() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns true if the URL has no data; otherwise returns false.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qurl.xml#clear">clear</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="isLocalFile">
<db:title>bool QUrl::isLocalFile() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>bool</db:type>
<db:methodname>isLocalFile</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool isLocalFile() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns true if this URL is pointing to a local file path. A URL is a local file path if the scheme is &quot;file&quot;.</db:para>
<db:para>Note that this function considers URLs with hostnames to be local file paths, even if the eventual file path cannot be opened with <db:link xlink:href="qfile.xml#open">QFile::open</db:link>().</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qurl.xml#fromLocalFile">fromLocalFile</db:link>()</db:member>
<db:member><db:link xlink:href="qurl.xml#toLocalFile">toLocalFile</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="isParentOf">
<db:title>bool QUrl::isParentOf(const QUrl &amp;<db:emphasis>childUrl</db:emphasis>) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>bool</db:type>
<db:methodname>isParentOf</db:methodname>
<db:methodparam>
<db:type>const QUrl &amp;</db:type>
<db:parameter>childUrl</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool isParentOf(const QUrl &amp;childUrl) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns true if this URL is a parent of <db:code role="parameter">childUrl</db:code>. <db:code role="parameter">childUrl</db:code> is a child of this URL if the two URLs share the same scheme and authority, and this URL's path is a parent of the path of <db:code role="parameter">childUrl</db:code>.</db:para>
</db:section>
<db:section xml:id="isRelative">
<db:title>bool QUrl::isRelative() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>bool</db:type>
<db:methodname>isRelative</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool isRelative() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns true if the URL is relative; otherwise returns false. A URL is relative reference if its scheme is undefined; this function is therefore equivalent to calling <db:link xlink:href="qurl.xml#scheme">scheme</db:link>().<db:link xlink:href="qurl.xml#isEmpty">isEmpty</db:link>().</db:para>
<db:para>Relative references are defined in RFC 3986 section 4.2.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qurl.xml#relative-urls-vs-relative-paths">Relative URLs vs Relative Paths</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="isValid">
<db:title>bool QUrl::isValid() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>bool</db:type>
<db:methodname>isValid</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool isValid() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns true if the URL is non-empty and valid; otherwise returns false.</db:para>
<db:para>The URL is run through a conformance test. Every part of the URL must conform to the standard encoding rules of the URI standard for the URL to be reported as valid.</db:para>
<db:programlisting language="cpp">bool checkUrl(const QUrl &amp;amp;url) {
    if (!url.isValid()) {
        qDebug(&quot;Invalid URL: %s&quot;, qUtf8Printable(url.toString()));
        return false;
    }

    return true;
}
</db:programlisting>
</db:section>
<db:section xml:id="matches">
<db:title>bool QUrl::matches(const QUrl &amp;<db:emphasis>url</db:emphasis>, QUrl::FormattingOptions <db:emphasis>options</db:emphasis>) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>bool</db:type>
<db:methodname>matches</db:methodname>
<db:methodparam>
<db:type>const QUrl &amp;</db:type>
<db:parameter>url</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>QUrl::FormattingOptions</db:type>
<db:parameter>options</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool matches(const QUrl &amp;url, QUrl::FormattingOptions options) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns true if this URL and the given <db:code role="parameter">url</db:code> are equal after applying <db:code role="parameter">options</db:code> to both; otherwise returns false.</db:para>
<db:para>This is equivalent to calling adjusted(options) on both URLs and comparing the resulting urls, but faster.</db:para>
</db:section>
<db:section xml:id="password">
<db:title>QString QUrl::password(QUrl::ComponentFormattingOptions <db:emphasis>options</db:emphasis> = FullyDecoded) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QString</db:type>
<db:methodname>password</db:methodname>
<db:methodparam>
<db:type>QUrl::ComponentFormattingOptions</db:type>
<db:parameter>options</db:parameter>
<db:initializer>FullyDecoded</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QString password(QUrl::ComponentFormattingOptions options) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the password of the URL if it is defined; otherwise an empty string is returned.</db:para>
<db:para>The <db:code role="parameter">options</db:code> argument controls how to format the user name component. All values produce an unambiguous result. With <db:link xlink:href="qurl.xml#ComponentFormattingOption-enum">QUrl::FullyDecoded</db:link>, all percent-encoded sequences are decoded; otherwise, the returned value may contain some percent-encoded sequences for some control sequences not representable in decoded form in <db:link xlink:href="qstring.xml">QString</db:link>.</db:para>
<db:para>Note that <db:link xlink:href="qurl.xml#ComponentFormattingOption-enum">QUrl::FullyDecoded</db:link> may cause data loss if those non-representable sequences are present. It is recommended to use that value when the result will be used in a non-URL context, such as setting in <db:link xlink:href="qauthenticator.xml">QAuthenticator</db:link> or negotiating a login.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qurl.xml#setPassword">setPassword</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="path">
<db:title>QString QUrl::path(QUrl::ComponentFormattingOptions <db:emphasis>options</db:emphasis> = FullyDecoded) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QString</db:type>
<db:methodname>path</db:methodname>
<db:methodparam>
<db:type>QUrl::ComponentFormattingOptions</db:type>
<db:parameter>options</db:parameter>
<db:initializer>FullyDecoded</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QString path(QUrl::ComponentFormattingOptions options) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the path of the URL.</db:para>
<db:programlisting language="cpp">    qDebug() &amp;lt;&amp;lt; QUrl(&quot;file:file.txt&quot;).path();                   // &quot;file.txt&quot;
    qDebug() &amp;lt;&amp;lt; QUrl(&quot;/home/user/file.txt&quot;).path();             // &quot;/home/user/file.txt&quot;
    qDebug() &amp;lt;&amp;lt; QUrl(&quot;http://www.example.com/test/123&quot;).path(); // &quot;/test/123&quot;
</db:programlisting>
<db:para>The <db:code role="parameter">options</db:code> argument controls how to format the path component. All values produce an unambiguous result. With <db:link xlink:href="qurl.xml#ComponentFormattingOption-enum">QUrl::FullyDecoded</db:link>, all percent-encoded sequences are decoded; otherwise, the returned value may contain some percent-encoded sequences for some control sequences not representable in decoded form in <db:link xlink:href="qstring.xml">QString</db:link>.</db:para>
<db:para>Note that <db:link xlink:href="qurl.xml#ComponentFormattingOption-enum">QUrl::FullyDecoded</db:link> may cause data loss if those non-representable sequences are present. It is recommended to use that value when the result will be used in a non-URL context, such as sending to an FTP server.</db:para>
<db:para>An example of data loss is when you have non-Unicode percent-encoded sequences and use <db:link xlink:href="qurl.xml#ComponentFormattingOption-enum">FullyDecoded</db:link> (the default):</db:para>
<db:programlisting language="cpp">    qDebug() &amp;lt;&amp;lt; QUrl(&quot;/foo%FFbar&quot;).path();
</db:programlisting>
<db:para>In this example, there will be some level of data loss because the %FF cannot be converted.</db:para>
<db:para>Data loss can also occur when the path contains sub-delimiters (such as +):</db:para>
<db:programlisting language="cpp">    qDebug() &amp;lt;&amp;lt; QUrl(&quot;/foo+bar%2B&quot;).path(); // &quot;/foo+bar+&quot;
</db:programlisting>
<db:para>Other decoding examples:</db:para>
<db:programlisting language="cpp">    const QUrl url(&quot;/tmp/Mambo %235%3F.mp3&quot;);
    qDebug() &amp;lt;&amp;lt; url.path(QUrl::FullyDecoded);  // &quot;/tmp/Mambo #5?.mp3&quot;
    qDebug() &amp;lt;&amp;lt; url.path(QUrl::PrettyDecoded); // &quot;/tmp/Mambo #5?.mp3&quot;
    qDebug() &amp;lt;&amp;lt; url.path(QUrl::FullyEncoded);  // &quot;/tmp/Mambo%20%235%3F.mp3&quot;
</db:programlisting>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qurl.xml#setPath">setPath</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="port">
<db:title>int QUrl::port(int <db:emphasis>defaultPort</db:emphasis> = -1) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>int</db:type>
<db:methodname>port</db:methodname>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>defaultPort</db:parameter>
<db:initializer>-1</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">int port(int defaultPort) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the port of the URL, or <db:code role="parameter">defaultPort</db:code> if the port is unspecified.</db:para>
<db:para>Example:</db:para>
<db:programlisting language="cpp">QTcpSocket sock;
sock.connectToHost(url.host(), url.port(80));
</db:programlisting>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qurl.xml#setPort">setPort</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="query">
<db:title>QString QUrl::query(QUrl::ComponentFormattingOptions <db:emphasis>options</db:emphasis> = PrettyDecoded) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QString</db:type>
<db:methodname>query</db:methodname>
<db:methodparam>
<db:type>QUrl::ComponentFormattingOptions</db:type>
<db:parameter>options</db:parameter>
<db:initializer>PrettyDecoded</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QString query(QUrl::ComponentFormattingOptions options) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the query string of the URL if there's a query string, or an empty result if not. To determine if the parsed URL contained a query string, use <db:link xlink:href="qurl.xml#hasQuery">hasQuery</db:link>().</db:para>
<db:para>The <db:code role="parameter">options</db:code> argument controls how to format the query component. All values produce an unambiguous result. With <db:link xlink:href="qurl.xml#ComponentFormattingOption-enum">QUrl::FullyDecoded</db:link>, all percent-encoded sequences are decoded; otherwise, the returned value may contain some percent-encoded sequences for some control sequences not representable in decoded form in <db:link xlink:href="qstring.xml">QString</db:link>.</db:para>
<db:para>Note that use of <db:link xlink:href="qurl.xml#ComponentFormattingOption-enum">QUrl::FullyDecoded</db:link> in queries is discouraged, as queries often contain data that is supposed to remain percent-encoded, including the use of the &quot;%2B&quot; sequence to represent a plus character ('+').</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qurl.xml#setQuery">setQuery</db:link>()</db:member>
<db:member><db:link xlink:href="qurl.xml#hasQuery">hasQuery</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="resolved">
<db:title>QUrl QUrl::resolved(const QUrl &amp;<db:emphasis>relative</db:emphasis>) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QUrl</db:type>
<db:methodname>resolved</db:methodname>
<db:methodparam>
<db:type>const QUrl &amp;</db:type>
<db:parameter>relative</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QUrl resolved(const QUrl &amp;relative) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the result of the merge of this URL with <db:code role="parameter">relative</db:code>. This URL is used as a base to convert <db:code role="parameter">relative</db:code> to an absolute URL.</db:para>
<db:para>If <db:code role="parameter">relative</db:code> is not a relative URL, this function will return <db:code role="parameter">relative</db:code> directly. Otherwise, the paths of the two URLs are merged, and the new URL returned has the scheme and authority of the base URL, but with the merged path, as in the following example:</db:para>
<db:programlisting language="cpp">QUrl baseUrl(&quot;http://qt.digia.com/Support/&quot;);
QUrl relativeUrl(&quot;../Product/Library/&quot;);
qDebug(baseUrl.resolved(relativeUrl).toString());
// prints &quot;http://qt.digia.com/Product/Library/&quot;
</db:programlisting>
<db:para>Calling resolved() with &quot;..&quot; returns a <db:link xlink:href="qurl.xml">QUrl</db:link> whose directory is one level higher than the original. Similarly, calling resolved() with &quot;../..&quot; removes two levels from the path. If <db:code role="parameter">relative</db:code> is &quot;/&quot;, the path becomes &quot;/&quot;.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qurl.xml#isRelative">isRelative</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="scheme">
<db:title>QString QUrl::scheme() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QString</db:type>
<db:methodname>scheme</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QString scheme() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the scheme of the URL. If an empty string is returned, this means the scheme is undefined and the URL is then relative.</db:para>
<db:para>The scheme can only contain US-ASCII letters or digits, which means it cannot contain any character that would otherwise require encoding. Additionally, schemes are always returned in lowercase form.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qurl.xml#setScheme">setScheme</db:link>()</db:member>
<db:member><db:link xlink:href="qurl.xml#isRelative">isRelative</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setAuthority">
<db:title>void QUrl::setAuthority(const QString &amp;<db:emphasis>authority</db:emphasis>, QUrl::ParsingMode <db:emphasis>mode</db:emphasis> = TolerantMode)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>setAuthority</db:methodname>
<db:methodparam>
<db:type>const QString &amp;</db:type>
<db:parameter>authority</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>QUrl::ParsingMode</db:type>
<db:parameter>mode</db:parameter>
<db:initializer>TolerantMode</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void setAuthority(const QString &amp;authority, QUrl::ParsingMode mode)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Sets the authority of the URL to <db:code role="parameter">authority</db:code>.</db:para>
<db:para>The authority of a URL is the combination of user info, a host name and a port. All of these elements are optional; an empty authority is therefore valid.</db:para>
<db:para>The user info and host are separated by a '@', and the host and port are separated by a ':'. If the user info is empty, the '@' must be omitted; although a stray ':' is permitted if the port is empty.</db:para>
<db:para>The following example shows a valid authority string:</db:para>
<db:mediaobject>
<db:imageobject>
<db:imagedata fileref="images/qurl-authority.png"/>
</db:imageobject>
</db:mediaobject>
<db:para>The <db:code role="parameter">authority</db:code> data is interpreted according to <db:code role="parameter">mode</db:code>: in <db:link xlink:href="qurl.xml#ParsingMode-enum">StrictMode</db:link>, any '%' characters must be followed by exactly two hexadecimal characters and some characters (including space) are not allowed in undecoded form. In <db:link xlink:href="qurl.xml#ParsingMode-enum">TolerantMode</db:link> (the default), all characters are accepted in undecoded form and the tolerant parser will correct stray '%' not followed by two hex characters.</db:para>
<db:para>This function does not allow <db:code role="parameter">mode</db:code> to be <db:link xlink:href="qurl.xml#ParsingMode-enum">QUrl::DecodedMode</db:link>. To set fully decoded data, call <db:link xlink:href="qurl.xml#setUserName">setUserName</db:link>(), <db:link xlink:href="qurl.xml#setPassword">setPassword</db:link>(), <db:link xlink:href="qurl.xml#setHost">setHost</db:link>() and <db:link xlink:href="qurl.xml#setPort">setPort</db:link>() individually.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qurl.xml#authority">authority</db:link>()</db:member>
<db:member><db:link xlink:href="qurl.xml#setUserInfo">setUserInfo</db:link>()</db:member>
<db:member><db:link xlink:href="qurl.xml#setHost">setHost</db:link>()</db:member>
<db:member><db:link xlink:href="qurl.xml#setPort">setPort</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setFragment">
<db:title>void QUrl::setFragment(const QString &amp;<db:emphasis>fragment</db:emphasis>, QUrl::ParsingMode <db:emphasis>mode</db:emphasis> = TolerantMode)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>setFragment</db:methodname>
<db:methodparam>
<db:type>const QString &amp;</db:type>
<db:parameter>fragment</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>QUrl::ParsingMode</db:type>
<db:parameter>mode</db:parameter>
<db:initializer>TolerantMode</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void setFragment(const QString &amp;fragment, QUrl::ParsingMode mode)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Sets the fragment of the URL to <db:code role="parameter">fragment</db:code>. The fragment is the last part of the URL, represented by a '#' followed by a string of characters. It is typically used in HTTP for referring to a certain link or point on a page:</db:para>
<db:mediaobject>
<db:imageobject>
<db:imagedata fileref="images/qurl-fragment.png"/>
</db:imageobject>
</db:mediaobject>
<db:para>The fragment is sometimes also referred to as the URL &quot;reference&quot;.</db:para>
<db:para>Passing an argument of QString() (a null <db:link xlink:href="qstring.xml">QString</db:link>) will unset the fragment. Passing an argument of <db:link xlink:href="qstring.xml">QString</db:link>(&quot;&quot;) (an empty but not null <db:link xlink:href="qstring.xml">QString</db:link>) will set the fragment to an empty string (as if the original URL had a lone &quot;#&quot;).</db:para>
<db:para>The <db:code role="parameter">fragment</db:code> data is interpreted according to <db:code role="parameter">mode</db:code>: in <db:link xlink:href="qurl.xml#ParsingMode-enum">StrictMode</db:link>, any '%' characters must be followed by exactly two hexadecimal characters and some characters (including space) are not allowed in undecoded form. In <db:link xlink:href="qurl.xml#ParsingMode-enum">TolerantMode</db:link>, all characters are accepted in undecoded form and the tolerant parser will correct stray '%' not followed by two hex characters. In <db:link xlink:href="qurl.xml#ParsingMode-enum">DecodedMode</db:link>, '%' stand for themselves and encoded characters are not possible.</db:para>
<db:para><db:link xlink:href="qurl.xml#ParsingMode-enum">QUrl::DecodedMode</db:link> should be used when setting the fragment from a data source which is not a URL or with a fragment obtained by calling <db:link xlink:href="qurl.xml#fragment">fragment</db:link>() with the <db:link xlink:href="qurl.xml#ComponentFormattingOption-enum">QUrl::FullyDecoded</db:link> formatting option.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qurl.xml#fragment">fragment</db:link>()</db:member>
<db:member><db:link xlink:href="qurl.xml#hasFragment">hasFragment</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setHost">
<db:title>void QUrl::setHost(const QString &amp;<db:emphasis>host</db:emphasis>, QUrl::ParsingMode <db:emphasis>mode</db:emphasis> = DecodedMode)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>setHost</db:methodname>
<db:methodparam>
<db:type>const QString &amp;</db:type>
<db:parameter>host</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>QUrl::ParsingMode</db:type>
<db:parameter>mode</db:parameter>
<db:initializer>DecodedMode</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void setHost(const QString &amp;host, QUrl::ParsingMode mode)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Sets the host of the URL to <db:code role="parameter">host</db:code>. The host is part of the authority.</db:para>
<db:para>The <db:code role="parameter">host</db:code> data is interpreted according to <db:code role="parameter">mode</db:code>: in <db:link xlink:href="qurl.xml#ParsingMode-enum">StrictMode</db:link>, any '%' characters must be followed by exactly two hexadecimal characters and some characters (including space) are not allowed in undecoded form. In <db:link xlink:href="qurl.xml#ParsingMode-enum">TolerantMode</db:link>, all characters are accepted in undecoded form and the tolerant parser will correct stray '%' not followed by two hex characters. In <db:link xlink:href="qurl.xml#ParsingMode-enum">DecodedMode</db:link>, '%' stand for themselves and encoded characters are not possible.</db:para>
<db:para>Note that, in all cases, the result of the parsing must be a valid hostname according to STD 3 rules, as modified by the Internationalized Resource Identifiers specification (RFC 3987). Invalid hostnames are not permitted and will cause <db:link xlink:href="qurl.xml#isValid">isValid</db:link>() to become false.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qurl.xml#host">host</db:link>()</db:member>
<db:member><db:link xlink:href="qurl.xml#setAuthority">setAuthority</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setIdnWhitelist">
<db:title>[static] void QUrl::setIdnWhitelist(const QStringList &amp;<db:emphasis>list</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:modifier>static</db:modifier>
<db:void/>
<db:methodname>setIdnWhitelist</db:methodname>
<db:methodparam>
<db:type>const QStringList &amp;</db:type>
<db:parameter>list</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void setIdnWhitelist(const QStringList &amp;list)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Sets the whitelist of Top-Level Domains (TLDs) that are allowed to have non-ASCII characters in domains to the value of <db:code role="parameter">list</db:code>.</db:para>
<db:para>Note that if you call this function, you need to do so <db:emphasis>before</db:emphasis> you start any threads that might access <db:link xlink:href="qurl.xml#idnWhitelist">idnWhitelist</db:link>().</db:para>
<db:para>Qt comes with a default list that contains the Internet top-level domains that have published support for Internationalized Domain Names (IDNs) and rules to guarantee that no deception can happen between similarly-looking characters (such as the Latin lowercase letter 'a' and the Cyrillic equivalent, which in most fonts are visually identical).</db:para>
<db:para>This list is periodically maintained, as registrars publish new rules.</db:para>
<db:para>This function is provided for those who need to manipulate the list, in order to add or remove a TLD. It is not recommended to change its value for purposes other than testing, as it may expose users to security risks.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qurl.xml#idnWhitelist">idnWhitelist</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setPassword">
<db:title>void QUrl::setPassword(const QString &amp;<db:emphasis>password</db:emphasis>, QUrl::ParsingMode <db:emphasis>mode</db:emphasis> = DecodedMode)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>setPassword</db:methodname>
<db:methodparam>
<db:type>const QString &amp;</db:type>
<db:parameter>password</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>QUrl::ParsingMode</db:type>
<db:parameter>mode</db:parameter>
<db:initializer>DecodedMode</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void setPassword(const QString &amp;password, QUrl::ParsingMode mode)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Sets the URL's password to <db:code role="parameter">password</db:code>. The <db:code role="parameter">password</db:code> is part of the user info element in the authority of the URL, as described in <db:link xlink:href="qurl.xml#setUserInfo">setUserInfo</db:link>().</db:para>
<db:para>The <db:code role="parameter">password</db:code> data is interpreted according to <db:code role="parameter">mode</db:code>: in <db:link xlink:href="qurl.xml#ParsingMode-enum">StrictMode</db:link>, any '%' characters must be followed by exactly two hexadecimal characters and some characters (including space) are not allowed in undecoded form. In <db:link xlink:href="qurl.xml#ParsingMode-enum">TolerantMode</db:link>, all characters are accepted in undecoded form and the tolerant parser will correct stray '%' not followed by two hex characters. In <db:link xlink:href="qurl.xml#ParsingMode-enum">DecodedMode</db:link>, '%' stand for themselves and encoded characters are not possible.</db:para>
<db:para><db:link xlink:href="qurl.xml#ParsingMode-enum">QUrl::DecodedMode</db:link> should be used when setting the password from a data source which is not a URL, such as a password dialog shown to the user or with a password obtained by calling <db:link xlink:href="qurl.xml#password">password</db:link>() with the <db:link xlink:href="qurl.xml#ComponentFormattingOption-enum">QUrl::FullyDecoded</db:link> formatting option.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qurl.xml#password">password</db:link>()</db:member>
<db:member><db:link xlink:href="qurl.xml#setUserInfo">setUserInfo</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setPath">
<db:title>void QUrl::setPath(const QString &amp;<db:emphasis>path</db:emphasis>, QUrl::ParsingMode <db:emphasis>mode</db:emphasis> = DecodedMode)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>setPath</db:methodname>
<db:methodparam>
<db:type>const QString &amp;</db:type>
<db:parameter>path</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>QUrl::ParsingMode</db:type>
<db:parameter>mode</db:parameter>
<db:initializer>DecodedMode</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void setPath(const QString &amp;path, QUrl::ParsingMode mode)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Sets the path of the URL to <db:code role="parameter">path</db:code>. The path is the part of the URL that comes after the authority but before the query string.</db:para>
<db:mediaobject>
<db:imageobject>
<db:imagedata fileref="images/qurl-ftppath.png"/>
</db:imageobject>
</db:mediaobject>
<db:para>For non-hierarchical schemes, the path will be everything following the scheme declaration, as in the following example:</db:para>
<db:mediaobject>
<db:imageobject>
<db:imagedata fileref="images/qurl-mailtopath.png"/>
</db:imageobject>
</db:mediaobject>
<db:para>The <db:code role="parameter">path</db:code> data is interpreted according to <db:code role="parameter">mode</db:code>: in <db:link xlink:href="qurl.xml#ParsingMode-enum">StrictMode</db:link>, any '%' characters must be followed by exactly two hexadecimal characters and some characters (including space) are not allowed in undecoded form. In <db:link xlink:href="qurl.xml#ParsingMode-enum">TolerantMode</db:link>, all characters are accepted in undecoded form and the tolerant parser will correct stray '%' not followed by two hex characters. In <db:link xlink:href="qurl.xml#ParsingMode-enum">DecodedMode</db:link>, '%' stand for themselves and encoded characters are not possible.</db:para>
<db:para><db:link xlink:href="qurl.xml#ParsingMode-enum">QUrl::DecodedMode</db:link> should be used when setting the path from a data source which is not a URL, such as a dialog shown to the user or with a path obtained by calling <db:link xlink:href="qurl.xml#path">path</db:link>() with the <db:link xlink:href="qurl.xml#ComponentFormattingOption-enum">QUrl::FullyDecoded</db:link> formatting option.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qurl.xml#path">path</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setPort">
<db:title>void QUrl::setPort(int <db:emphasis>port</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>setPort</db:methodname>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>port</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void setPort(int port)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Sets the port of the URL to <db:code role="parameter">port</db:code>. The port is part of the authority of the URL, as described in <db:link xlink:href="qurl.xml#setAuthority">setAuthority</db:link>().</db:para>
<db:para><db:code role="parameter">port</db:code> must be between 0 and 65535 inclusive. Setting the port to -1 indicates that the port is unspecified.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qurl.xml#port">port</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setQuery">
<db:title>void QUrl::setQuery(const QString &amp;<db:emphasis>query</db:emphasis>, QUrl::ParsingMode <db:emphasis>mode</db:emphasis> = TolerantMode)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>setQuery</db:methodname>
<db:methodparam>
<db:type>const QString &amp;</db:type>
<db:parameter>query</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>QUrl::ParsingMode</db:type>
<db:parameter>mode</db:parameter>
<db:initializer>TolerantMode</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void setQuery(const QString &amp;query, QUrl::ParsingMode mode)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Sets the query string of the URL to <db:code role="parameter">query</db:code>.</db:para>
<db:para>This function is useful if you need to pass a query string that does not fit into the key-value pattern, or that uses a different scheme for encoding special characters than what is suggested by <db:link xlink:href="qurl.xml">QUrl</db:link>.</db:para>
<db:para>Passing a value of QString() to <db:code role="parameter">query</db:code> (a null <db:link xlink:href="qstring.xml">QString</db:link>) unsets the query completely. However, passing a value of <db:link xlink:href="qstring.xml">QString</db:link>(&quot;&quot;) will set the query to an empty value, as if the original URL had a lone &quot;?&quot;.</db:para>
<db:para>The <db:code role="parameter">query</db:code> data is interpreted according to <db:code role="parameter">mode</db:code>: in <db:link xlink:href="qurl.xml#ParsingMode-enum">StrictMode</db:link>, any '%' characters must be followed by exactly two hexadecimal characters and some characters (including space) are not allowed in undecoded form. In <db:link xlink:href="qurl.xml#ParsingMode-enum">TolerantMode</db:link>, all characters are accepted in undecoded form and the tolerant parser will correct stray '%' not followed by two hex characters. In <db:link xlink:href="qurl.xml#ParsingMode-enum">DecodedMode</db:link>, '%' stand for themselves and encoded characters are not possible.</db:para>
<db:para>Query strings often contain percent-encoded sequences, so use of <db:link xlink:href="qurl.xml#ParsingMode-enum">DecodedMode</db:link> is discouraged. One special sequence to be aware of is that of the plus character ('+'). <db:link xlink:href="qurl.xml">QUrl</db:link> does not convert spaces to plus characters, even though HTML forms posted by web browsers do. In order to represent an actual plus character in a query, the sequence &quot;%2B&quot; is usually used. This function will leave &quot;%2B&quot; sequences untouched in <db:link xlink:href="qurl.xml#ParsingMode-enum">TolerantMode</db:link> or <db:link xlink:href="qurl.xml#ParsingMode-enum">StrictMode</db:link>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qurl.xml#query">query</db:link>()</db:member>
<db:member><db:link xlink:href="qurl.xml#hasQuery">hasQuery</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setQuery-1">
<db:title>void QUrl::setQuery(const QUrlQuery &amp;<db:emphasis>query</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>setQuery</db:methodname>
<db:methodparam>
<db:type>const QUrlQuery &amp;</db:type>
<db:parameter>query</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">void setQuery(const QUrlQuery &amp;query)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>Sets the query string of the URL to <db:code role="parameter">query</db:code>.</db:para>
<db:para>This function reconstructs the query string from the <db:link xlink:href="qurlquery.xml">QUrlQuery</db:link> object and sets on this <db:link xlink:href="qurl.xml">QUrl</db:link> object. This function does not have parsing parameters because the <db:link xlink:href="qurlquery.xml">QUrlQuery</db:link> contains data that is already parsed.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qurl.xml#query">query</db:link>()</db:member>
<db:member><db:link xlink:href="qurl.xml#hasQuery">hasQuery</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setScheme">
<db:title>void QUrl::setScheme(const QString &amp;<db:emphasis>scheme</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>setScheme</db:methodname>
<db:methodparam>
<db:type>const QString &amp;</db:type>
<db:parameter>scheme</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void setScheme(const QString &amp;scheme)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Sets the scheme of the URL to <db:code role="parameter">scheme</db:code>. As a scheme can only contain ASCII characters, no conversion or decoding is done on the input. It must also start with an ASCII letter.</db:para>
<db:para>The scheme describes the type (or protocol) of the URL. It's represented by one or more ASCII characters at the start the URL.</db:para>
<db:para>A scheme is strictly <db:link xlink:href="https://datatracker.ietf.org/doc/html/rfc3986">RFC 3986</db:link>-compliant: <db:code>scheme = ALPHA *( ALPHA / DIGIT / &quot;+&quot; / &quot;-&quot; / &quot;.&quot; )</db:code></db:para>
<db:para>The following example shows a URL where the scheme is &quot;ftp&quot;:</db:para>
<db:mediaobject>
<db:imageobject>
<db:imagedata fileref="images/qurl-authority2.png"/>
</db:imageobject>
</db:mediaobject>
<db:para>To set the scheme, the following call is used:</db:para>
<db:programlisting language="cpp">    QUrl url;
    url.setScheme(&quot;ftp&quot;);
</db:programlisting>
<db:para>The scheme can also be empty, in which case the URL is interpreted as relative.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qurl.xml#scheme">scheme</db:link>()</db:member>
<db:member><db:link xlink:href="qurl.xml#isRelative">isRelative</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setUrl">
<db:title>void QUrl::setUrl(const QString &amp;<db:emphasis>url</db:emphasis>, QUrl::ParsingMode <db:emphasis>parsingMode</db:emphasis> = TolerantMode)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>setUrl</db:methodname>
<db:methodparam>
<db:type>const QString &amp;</db:type>
<db:parameter>url</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>QUrl::ParsingMode</db:type>
<db:parameter>parsingMode</db:parameter>
<db:initializer>TolerantMode</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void setUrl(const QString &amp;url, QUrl::ParsingMode parsingMode)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Parses <db:code role="parameter">url</db:code> and sets this object to that value. <db:link xlink:href="qurl.xml">QUrl</db:link> will automatically percent encode all characters that are not allowed in a URL and decode the percent-encoded sequences that represent an unreserved character (letters, digits, hyphens, underscores, dots and tildes). All other characters are left in their original forms.</db:para>
<db:para>Parses the <db:code role="parameter">url</db:code> using the parser mode <db:code role="parameter">parsingMode</db:code>. In <db:link xlink:href="qurl.xml#ParsingMode-enum">TolerantMode</db:link> (the default), <db:link xlink:href="qurl.xml">QUrl</db:link> will correct certain mistakes, notably the presence of a percent character ('%') not followed by two hexadecimal digits, and it will accept any character in any position. In <db:link xlink:href="qurl.xml#ParsingMode-enum">StrictMode</db:link>, encoding mistakes will not be tolerated and <db:link xlink:href="qurl.xml">QUrl</db:link> will also check that certain forbidden characters are not present in unencoded form. If an error is detected in <db:link xlink:href="qurl.xml#ParsingMode-enum">StrictMode</db:link>, <db:link xlink:href="qurl.xml#isValid">isValid</db:link>() will return false. The parsing mode <db:link xlink:href="qurl.xml#ParsingMode-enum">DecodedMode</db:link> is not permitted in this context and will produce a run-time warning.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qurl.xml#url">url</db:link>()</db:member>
<db:member><db:link xlink:href="qurl.xml#toString">toString</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setUserInfo">
<db:title>void QUrl::setUserInfo(const QString &amp;<db:emphasis>userInfo</db:emphasis>, QUrl::ParsingMode <db:emphasis>mode</db:emphasis> = TolerantMode)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>setUserInfo</db:methodname>
<db:methodparam>
<db:type>const QString &amp;</db:type>
<db:parameter>userInfo</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>QUrl::ParsingMode</db:type>
<db:parameter>mode</db:parameter>
<db:initializer>TolerantMode</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void setUserInfo(const QString &amp;userInfo, QUrl::ParsingMode mode)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Sets the user info of the URL to <db:code role="parameter">userInfo</db:code>. The user info is an optional part of the authority of the URL, as described in <db:link xlink:href="qurl.xml#setAuthority">setAuthority</db:link>().</db:para>
<db:para>The user info consists of a user name and optionally a password, separated by a ':'. If the password is empty, the colon must be omitted. The following example shows a valid user info string:</db:para>
<db:mediaobject>
<db:imageobject>
<db:imagedata fileref="images/qurl-authority3.png"/>
</db:imageobject>
</db:mediaobject>
<db:para>The <db:code role="parameter">userInfo</db:code> data is interpreted according to <db:code role="parameter">mode</db:code>: in <db:link xlink:href="qurl.xml#ParsingMode-enum">StrictMode</db:link>, any '%' characters must be followed by exactly two hexadecimal characters and some characters (including space) are not allowed in undecoded form. In <db:link xlink:href="qurl.xml#ParsingMode-enum">TolerantMode</db:link> (the default), all characters are accepted in undecoded form and the tolerant parser will correct stray '%' not followed by two hex characters.</db:para>
<db:para>This function does not allow <db:code role="parameter">mode</db:code> to be <db:link xlink:href="qurl.xml#ParsingMode-enum">QUrl::DecodedMode</db:link>. To set fully decoded data, call <db:link xlink:href="qurl.xml#setUserName">setUserName</db:link>() and <db:link xlink:href="qurl.xml#setPassword">setPassword</db:link>() individually.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qurl.xml#userInfo">userInfo</db:link>()</db:member>
<db:member><db:link xlink:href="qurl.xml#setUserName">setUserName</db:link>()</db:member>
<db:member><db:link xlink:href="qurl.xml#setPassword">setPassword</db:link>()</db:member>
<db:member><db:link xlink:href="qurl.xml#setAuthority">setAuthority</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setUserName">
<db:title>void QUrl::setUserName(const QString &amp;<db:emphasis>userName</db:emphasis>, QUrl::ParsingMode <db:emphasis>mode</db:emphasis> = DecodedMode)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>setUserName</db:methodname>
<db:methodparam>
<db:type>const QString &amp;</db:type>
<db:parameter>userName</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>QUrl::ParsingMode</db:type>
<db:parameter>mode</db:parameter>
<db:initializer>DecodedMode</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void setUserName(const QString &amp;userName, QUrl::ParsingMode mode)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Sets the URL's user name to <db:code role="parameter">userName</db:code>. The <db:code role="parameter">userName</db:code> is part of the user info element in the authority of the URL, as described in <db:link xlink:href="qurl.xml#setUserInfo">setUserInfo</db:link>().</db:para>
<db:para>The <db:code role="parameter">userName</db:code> data is interpreted according to <db:code role="parameter">mode</db:code>: in <db:link xlink:href="qurl.xml#ParsingMode-enum">StrictMode</db:link>, any '%' characters must be followed by exactly two hexadecimal characters and some characters (including space) are not allowed in undecoded form. In <db:link xlink:href="qurl.xml#ParsingMode-enum">TolerantMode</db:link> (the default), all characters are accepted in undecoded form and the tolerant parser will correct stray '%' not followed by two hex characters. In <db:link xlink:href="qurl.xml#ParsingMode-enum">DecodedMode</db:link>, '%' stand for themselves and encoded characters are not possible.</db:para>
<db:para><db:link xlink:href="qurl.xml#ParsingMode-enum">QUrl::DecodedMode</db:link> should be used when setting the user name from a data source which is not a URL, such as a password dialog shown to the user or with a user name obtained by calling <db:link xlink:href="qurl.xml#userName">userName</db:link>() with the <db:link xlink:href="qurl.xml#ComponentFormattingOption-enum">QUrl::FullyDecoded</db:link> formatting option.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qurl.xml#userName">userName</db:link>()</db:member>
<db:member><db:link xlink:href="qurl.xml#setUserInfo">setUserInfo</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="swap">
<db:title>void QUrl::swap(QUrl &amp;<db:emphasis>other</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>swap</db:methodname>
<db:methodparam>
<db:type>QUrl &amp;</db:type>
<db:parameter>other</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void swap(QUrl &amp;other)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Swaps URL <db:code role="parameter">other</db:code> with this URL. This operation is very fast and never fails.</db:para>
</db:section>
<db:section xml:id="toAce">
<db:title>[static, since 6.3] QByteArray QUrl::toAce(const QString &amp;<db:emphasis>domain</db:emphasis>, QUrl::AceProcessingOptions <db:emphasis>options</db:emphasis> = {})</db:title>
<db:methodsynopsis>
<db:modifier>static</db:modifier>
<db:type>QByteArray</db:type>
<db:methodname>toAce</db:methodname>
<db:methodparam>
<db:type>const QString &amp;</db:type>
<db:parameter>domain</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>QUrl::AceProcessingOptions</db:type>
<db:parameter>options</db:parameter>
<db:initializer>{}</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QByteArray toAce(const QString &amp;domain, QUrl::AceProcessingOptions options)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the ASCII Compatible Encoding of the given domain name <db:code role="parameter">domain</db:code>. The output can be customized by passing flags with <db:code role="parameter">options</db:code>. The result of this function is considered equivalent to <db:code role="parameter">domain</db:code>.</db:para>
<db:para>The ASCII-Compatible Encoding (ACE) is defined by RFC 3490, RFC 3491 and RFC 3492 and updated by the Unicode Technical Standard #46. It is part of the Internationalizing Domain Names in Applications (IDNA) specification, which allows for domain names (like &quot;example.com&quot;) to be written using non-US-ASCII characters.</db:para>
<db:para>This function returns an empty <db:link xlink:href="qbytearray.xml">QByteArray</db:link> if <db:code role="parameter">domain</db:code> is not a valid hostname. Note, in particular, that IPv6 literals are not valid domain names.</db:para>
<db:para>This function was introduced in Qt 6.3.</db:para>
</db:section>
<db:section xml:id="toCFURL">
<db:title>CFURLRef QUrl::toCFURL() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>CFURLRef</db:type>
<db:methodname>toCFURL</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">CFURLRef toCFURL() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Creates a CFURL from a <db:link xlink:href="qurl.xml">QUrl</db:link>.</db:para>
<db:para>The caller owns the CFURL and is responsible for releasing it.</db:para>
</db:section>
<db:section xml:id="toDisplayString">
<db:title>QString QUrl::toDisplayString(QUrl::FormattingOptions <db:emphasis>options</db:emphasis> = FormattingOptions(PrettyDecoded)) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QString</db:type>
<db:methodname>toDisplayString</db:methodname>
<db:methodparam>
<db:type>QUrl::FormattingOptions</db:type>
<db:parameter>options</db:parameter>
<db:initializer>FormattingOptions(PrettyDecoded)</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QString toDisplayString(QUrl::FormattingOptions options) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns a human-displayable string representation of the URL. The output can be customized by passing flags with <db:code role="parameter">options</db:code>. The option <db:link xlink:href="qurl.xml#UrlFormattingOption-enum">RemovePassword</db:link> is always enabled, since passwords should never be shown back to users.</db:para>
<db:para>With the default options, the resulting <db:link xlink:href="qstring.xml">QString</db:link> can be passed back to a <db:link xlink:href="qurl.xml">QUrl</db:link> later on, but any password that was present initially will be lost.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qurl.xml#UrlFormattingOption-enum">FormattingOptions</db:link></db:member>
<db:member><db:link xlink:href="qurl.xml#toEncoded">toEncoded</db:link>()</db:member>
<db:member><db:link xlink:href="qurl.xml#toString">toString</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="toEncoded">
<db:title>QByteArray QUrl::toEncoded(QUrl::FormattingOptions <db:emphasis>options</db:emphasis> = FullyEncoded) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QByteArray</db:type>
<db:methodname>toEncoded</db:methodname>
<db:methodparam>
<db:type>QUrl::FormattingOptions</db:type>
<db:parameter>options</db:parameter>
<db:initializer>FullyEncoded</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QByteArray toEncoded(QUrl::FormattingOptions options) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the encoded representation of the URL if it's valid; otherwise an empty <db:link xlink:href="qbytearray.xml">QByteArray</db:link> is returned. The output can be customized by passing flags with <db:code role="parameter">options</db:code>.</db:para>
<db:para>The user info, path and fragment are all converted to UTF-8, and all non-ASCII characters are then percent encoded. The host name is encoded using Punycode.</db:para>
</db:section>
<db:section xml:id="toLocalFile">
<db:title>QString QUrl::toLocalFile() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QString</db:type>
<db:methodname>toLocalFile</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QString toLocalFile() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the path of this URL formatted as a local file path. The path returned will use forward slashes, even if it was originally created from one with backslashes.</db:para>
<db:para>If this URL contains a non-empty hostname, it will be encoded in the returned value in the form found on SMB networks (for example, &quot;//servername/path/to/file.txt&quot;).</db:para>
<db:programlisting language="cpp">    qDebug() &amp;lt;&amp;lt; QUrl(&quot;file:file.txt&quot;).toLocalFile();            // &quot;file.txt&quot;
    qDebug() &amp;lt;&amp;lt; QUrl(&quot;file:/home/user/file.txt&quot;).toLocalFile(); // &quot;/home/user/file.txt&quot;
    qDebug() &amp;lt;&amp;lt; QUrl(&quot;file.txt&quot;).toLocalFile();                 // &quot;&quot;; wasn't a local file as it had no scheme
</db:programlisting>
<db:para>Note: if the path component of this URL contains a non-UTF-8 binary sequence (such as %80), the behaviour of this function is undefined.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qurl.xml#fromLocalFile">fromLocalFile</db:link>()</db:member>
<db:member><db:link xlink:href="qurl.xml#isLocalFile">isLocalFile</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="toNSURL">
<db:title>NSURL *QUrl::toNSURL() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>NSURL *</db:type>
<db:methodname>toNSURL</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">NSURL * toNSURL() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Creates a NSURL from a <db:link xlink:href="qurl.xml">QUrl</db:link>.</db:para>
<db:para>The NSURL is autoreleased.</db:para>
</db:section>
<db:section xml:id="toPercentEncoding">
<db:title>[static] QByteArray QUrl::toPercentEncoding(const QString &amp;<db:emphasis>input</db:emphasis>, const QByteArray &amp;<db:emphasis>exclude</db:emphasis> = QByteArray(), const QByteArray &amp;<db:emphasis>include</db:emphasis> = QByteArray())</db:title>
<db:methodsynopsis>
<db:modifier>static</db:modifier>
<db:type>QByteArray</db:type>
<db:methodname>toPercentEncoding</db:methodname>
<db:methodparam>
<db:type>const QString &amp;</db:type>
<db:parameter>input</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const QByteArray &amp;</db:type>
<db:parameter>exclude</db:parameter>
<db:initializer>QByteArray()</db:initializer>
</db:methodparam>
<db:methodparam>
<db:type>const QByteArray &amp;</db:type>
<db:parameter>include</db:parameter>
<db:initializer>QByteArray()</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QByteArray toPercentEncoding(const QString &amp;input, const QByteArray &amp;exclude, const QByteArray &amp;include)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns an encoded copy of <db:code role="parameter">input</db:code>. <db:code role="parameter">input</db:code> is first converted to UTF-8, and all ASCII-characters that are not in the unreserved group are percent encoded. To prevent characters from being percent encoded pass them to <db:code role="parameter">exclude</db:code>. To force characters to be percent encoded pass them to <db:code role="parameter">include</db:code>.</db:para>
<db:para>Unreserved is defined as: <db:code>ALPHA / DIGIT / &quot;-&quot; / &quot;.&quot; / &quot;_&quot; / &quot;~&quot;</db:code></db:para>
<db:programlisting language="cpp">QByteArray ba = QUrl::toPercentEncoding(&quot;{a fishy string?}&quot;, &quot;{}&quot;, &quot;s&quot;);
qDebug(ba.constData());
// prints &quot;{a fi%73hy %73tring%3F}&quot;
</db:programlisting>
</db:section>
<db:section xml:id="toString">
<db:title>QString QUrl::toString(QUrl::FormattingOptions <db:emphasis>options</db:emphasis> = FormattingOptions(PrettyDecoded)) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QString</db:type>
<db:methodname>toString</db:methodname>
<db:methodparam>
<db:type>QUrl::FormattingOptions</db:type>
<db:parameter>options</db:parameter>
<db:initializer>FormattingOptions(PrettyDecoded)</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QString toString(QUrl::FormattingOptions options) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns a string representation of the URL. The output can be customized by passing flags with <db:code role="parameter">options</db:code>. The option <db:link xlink:href="qurl.xml#ComponentFormattingOption-enum">QUrl::FullyDecoded</db:link> is not permitted in this function since it would generate ambiguous data.</db:para>
<db:para>The default formatting option is <db:link xlink:href="qurl.xml#UrlFormattingOption-enum">PrettyDecoded</db:link>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qurl.xml#UrlFormattingOption-enum">FormattingOptions</db:link></db:member>
<db:member><db:link xlink:href="qurl.xml#url">url</db:link>()</db:member>
<db:member><db:link xlink:href="qurl.xml#setUrl">setUrl</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="toStringList">
<db:title>[static] QStringList QUrl::toStringList(const QList&lt;QUrl&gt; &amp;<db:emphasis>urls</db:emphasis>, QUrl::FormattingOptions <db:emphasis>options</db:emphasis> = FormattingOptions(PrettyDecoded))</db:title>
<db:methodsynopsis>
<db:modifier>static</db:modifier>
<db:type>QStringList</db:type>
<db:methodname>toStringList</db:methodname>
<db:methodparam>
<db:type>const QList&lt;QUrl&gt; &amp;</db:type>
<db:parameter>urls</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>QUrl::FormattingOptions</db:type>
<db:parameter>options</db:parameter>
<db:initializer>FormattingOptions(PrettyDecoded)</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QStringList toStringList(const QList&lt;QUrl&gt; &amp;urls, QUrl::FormattingOptions options)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Converts a list of <db:code role="parameter">urls</db:code> into a list of <db:link xlink:href="qstring.xml">QString</db:link> objects, using <db:link xlink:href="qurl.xml#toString">toString</db:link>(<db:code role="parameter">options</db:code>).</db:para>
</db:section>
<db:section xml:id="url">
<db:title>QString QUrl::url(QUrl::FormattingOptions <db:emphasis>options</db:emphasis> = FormattingOptions(PrettyDecoded)) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QString</db:type>
<db:methodname>url</db:methodname>
<db:methodparam>
<db:type>QUrl::FormattingOptions</db:type>
<db:parameter>options</db:parameter>
<db:initializer>FormattingOptions(PrettyDecoded)</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QString url(QUrl::FormattingOptions options) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns a string representation of the URL. The output can be customized by passing flags with <db:code role="parameter">options</db:code>. The option <db:link xlink:href="qurl.xml#ComponentFormattingOption-enum">QUrl::FullyDecoded</db:link> is not permitted in this function since it would generate ambiguous data.</db:para>
<db:para>The resulting <db:link xlink:href="qstring.xml">QString</db:link> can be passed back to a <db:link xlink:href="qurl.xml">QUrl</db:link> later on.</db:para>
<db:para>Synonym for <db:link xlink:href="qurl.xml#toString">toString</db:link>(options).</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qurl.xml#setUrl">setUrl</db:link>()</db:member>
<db:member><db:link xlink:href="qurl.xml#UrlFormattingOption-enum">FormattingOptions</db:link></db:member>
<db:member><db:link xlink:href="qurl.xml#toEncoded">toEncoded</db:link>()</db:member>
<db:member><db:link xlink:href="qurl.xml#toString">toString</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="userInfo">
<db:title>QString QUrl::userInfo(QUrl::ComponentFormattingOptions <db:emphasis>options</db:emphasis> = PrettyDecoded) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QString</db:type>
<db:methodname>userInfo</db:methodname>
<db:methodparam>
<db:type>QUrl::ComponentFormattingOptions</db:type>
<db:parameter>options</db:parameter>
<db:initializer>PrettyDecoded</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QString userInfo(QUrl::ComponentFormattingOptions options) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the user info of the URL, or an empty string if the user info is undefined.</db:para>
<db:para>This function returns an unambiguous value, which may contain that characters still percent-encoded, plus some control sequences not representable in decoded form in <db:link xlink:href="qstring.xml">QString</db:link>.</db:para>
<db:para>The <db:code role="parameter">options</db:code> argument controls how to format the user info component. The value of <db:link xlink:href="qurl.xml#ComponentFormattingOption-enum">QUrl::FullyDecoded</db:link> is not permitted in this function. If you need to obtain fully decoded data, call <db:link xlink:href="qurl.xml#userName">userName</db:link>() and <db:link xlink:href="qurl.xml#password">password</db:link>() individually.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qurl.xml#setUserInfo">setUserInfo</db:link>()</db:member>
<db:member><db:link xlink:href="qurl.xml#userName">userName</db:link>()</db:member>
<db:member><db:link xlink:href="qurl.xml#password">password</db:link>()</db:member>
<db:member><db:link xlink:href="qurl.xml#authority">authority</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="userName">
<db:title>QString QUrl::userName(QUrl::ComponentFormattingOptions <db:emphasis>options</db:emphasis> = FullyDecoded) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QString</db:type>
<db:methodname>userName</db:methodname>
<db:methodparam>
<db:type>QUrl::ComponentFormattingOptions</db:type>
<db:parameter>options</db:parameter>
<db:initializer>FullyDecoded</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QString userName(QUrl::ComponentFormattingOptions options) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the user name of the URL if it is defined; otherwise an empty string is returned.</db:para>
<db:para>The <db:code role="parameter">options</db:code> argument controls how to format the user name component. All values produce an unambiguous result. With <db:link xlink:href="qurl.xml#ComponentFormattingOption-enum">QUrl::FullyDecoded</db:link>, all percent-encoded sequences are decoded; otherwise, the returned value may contain some percent-encoded sequences for some control sequences not representable in decoded form in <db:link xlink:href="qstring.xml">QString</db:link>.</db:para>
<db:para>Note that <db:link xlink:href="qurl.xml#ComponentFormattingOption-enum">QUrl::FullyDecoded</db:link> may cause data loss if those non-representable sequences are present. It is recommended to use that value when the result will be used in a non-URL context, such as setting in <db:link xlink:href="qauthenticator.xml">QAuthenticator</db:link> or negotiating a login.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qurl.xml#setUserName">setUserName</db:link>()</db:member>
<db:member><db:link xlink:href="qurl.xml#userInfo">userInfo</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="operator-not-eq">
<db:title>bool QUrl::operator!=(const QUrl &amp;<db:emphasis>url</db:emphasis>) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>bool</db:type>
<db:methodname>operator!=</db:methodname>
<db:methodparam>
<db:type>const QUrl &amp;</db:type>
<db:parameter>url</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool operator!=(const QUrl &amp;url) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns true if this URL and the given <db:code role="parameter">url</db:code> are not equal; otherwise returns false.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qurl.xml#matches">matches</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="operator-eq">
<db:title>QUrl &amp;QUrl::operator=(const QUrl &amp;<db:emphasis>url</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>QUrl &amp;</db:type>
<db:methodname>operator=</db:methodname>
<db:methodparam>
<db:type>const QUrl &amp;</db:type>
<db:parameter>url</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">copy-assign</db:synopsisinfo>
<db:synopsisinfo role="signature">QUrl &amp; operator=(const QUrl &amp;url)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Assigns the specified <db:code role="parameter">url</db:code> to this object.</db:para>
</db:section>
<db:section xml:id="operator-eq-1">
<db:title>QUrl &amp;QUrl::operator=(const QString &amp;<db:emphasis>url</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>QUrl &amp;</db:type>
<db:methodname>operator=</db:methodname>
<db:methodparam>
<db:type>const QString &amp;</db:type>
<db:parameter>url</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">copy-assign</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">QUrl &amp; operator=(const QString &amp;url)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Assigns the specified <db:code role="parameter">url</db:code> to this object.</db:para>
</db:section>
<db:section xml:id="operator-eq-2">
<db:title>QUrl &amp;QUrl::operator=(QUrl &amp;&amp;<db:emphasis>other</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>QUrl &amp;</db:type>
<db:methodname>operator=</db:methodname>
<db:methodparam>
<db:type>QUrl &amp;&amp;</db:type>
<db:parameter>other</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">move-assign</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">2</db:synopsisinfo>
<db:synopsisinfo role="signature">QUrl &amp; operator=(QUrl &amp;&amp;other)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Move-assigns <db:code role="parameter">other</db:code> to this <db:link xlink:href="qurl.xml">QUrl</db:link> instance.</db:para>
</db:section>
<db:section xml:id="operator-eq-eq">
<db:title>bool QUrl::operator==(const QUrl &amp;<db:emphasis>url</db:emphasis>) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>bool</db:type>
<db:methodname>operator==</db:methodname>
<db:methodparam>
<db:type>const QUrl &amp;</db:type>
<db:parameter>url</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool operator==(const QUrl &amp;url) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns true if this URL and the given <db:code role="parameter">url</db:code> are equal; otherwise returns false.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qurl.xml#matches">matches</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
</db:section>
<db:section xml:id="related-non-members">
<db:title>Related Non-Members</db:title>
<db:section xml:id="operator-lt-lt">
<db:title>QDataStream &amp;operator&lt;&lt;(QDataStream &amp;<db:emphasis>out</db:emphasis>, const QUrl &amp;<db:emphasis>url</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>QDataStream &amp;</db:type>
<db:methodname>operator&lt;&lt;</db:methodname>
<db:methodparam>
<db:type>QDataStream &amp;</db:type>
<db:parameter>out</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const QUrl &amp;</db:type>
<db:parameter>url</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QDataStream &amp; operator&lt;&lt;(QDataStream &amp;out, const QUrl &amp;url)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Writes url <db:code role="parameter">url</db:code> to the stream <db:code role="parameter">out</db:code> and returns a reference to the stream.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="datastreamformat.xml">Format of the QDataStream operators</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="operator-gt-gt">
<db:title>QDataStream &amp;operator&gt;&gt;(QDataStream &amp;<db:emphasis>in</db:emphasis>, QUrl &amp;<db:emphasis>url</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>QDataStream &amp;</db:type>
<db:methodname>operator&gt;&gt;</db:methodname>
<db:methodparam>
<db:type>QDataStream &amp;</db:type>
<db:parameter>in</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>QUrl &amp;</db:type>
<db:parameter>url</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QDataStream &amp; operator&gt;&gt;(QDataStream &amp;in, QUrl &amp;url)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Reads a url into <db:code role="parameter">url</db:code> from the stream <db:code role="parameter">in</db:code> and returns a reference to the stream.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="datastreamformat.xml">Format of the QDataStream operators</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
</db:section>
<db:section xml:id="macro-documentation">
<db:title>Macro Documentation</db:title>
<db:section xml:id="QT_NO_URL_CAST_FROM_STRING">
<db:title>QT_NO_URL_CAST_FROM_STRING</db:title>
<db:methodsynopsis>
<db:methodname>QT_NO_URL_CAST_FROM_STRING</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">macrowithoutparams</db:synopsisinfo>
<db:synopsisinfo role="signature">QT_NO_URL_CAST_FROM_STRING</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Disables automatic conversions from <db:link xlink:href="qstring.xml">QString</db:link> (or char *) to <db:link xlink:href="qurl.xml">QUrl</db:link>.</db:para>
<db:para>Compiling your code with this define is useful when you have a lot of code that uses <db:link xlink:href="qstring.xml">QString</db:link> for file names and you wish to convert it to use <db:link xlink:href="qurl.xml">QUrl</db:link> for network transparency. In any code that uses <db:link xlink:href="qurl.xml">QUrl</db:link>, it can help avoid missing <db:link xlink:href="qurl.xml#resolved">QUrl::resolved</db:link>() calls, and other misuses of <db:link xlink:href="qstring.xml">QString</db:link> to <db:link xlink:href="qurl.xml">QUrl</db:link> conversions.</db:para>
<db:para>For example, if you have code like</db:para>
<db:programlisting language="cpp">url = filename; // probably not what you want
</db:programlisting>
<db:para>you can rewrite it as</db:para>
<db:programlisting language="cpp">url = QUrl::fromLocalFile(filename);
url = baseurl.resolved(QUrl(filename));
</db:programlisting>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qstring.xml#QT_NO_CAST_FROM_ASCII">QT_NO_CAST_FROM_ASCII</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
</db:section>
</db:article>
