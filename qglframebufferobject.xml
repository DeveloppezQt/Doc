<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en_US">
<db:info>
<db:title>QGLFramebufferObject Class</db:title>
<db:productname>qtopengl</db:productname>
<db:titleabbrev>qtopengl Reference Documentation</db:titleabbrev>
<db:abstract>
<db:para>The <db:link xlink:href="qglframebufferobject.xml">QGLFramebufferObject</db:link> class encapsulates an OpenGL framebuffer object.</db:para>
<db:para><db:emphasis role="bold">This class is deprecated. We strongly advise against using it in new code.</db:emphasis></db:para>
<db:para>This class was introduced in Qt 4.2.</db:para>
</db:abstract>
<db:pubdate>2025-06-29</db:pubdate>
<db:date>2025-06-29</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:variablelist>
<db:varlistentry>
<db:term>Header</db:term>
<db:listitem>
<db:para>QGLFramebufferObject</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Since</db:term>
<db:listitem>
<db:para>Qt 4.2</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Inherits</db:term>
<db:listitem>
<db:para><db:link xlink:href="qpaintdevice.xml" xlink:role="class">QPaintDevice</db:link></db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Group</db:term>
<db:listitem>
<db:para>QGLFramebufferObject is part of <db:simplelist><db:member>painting-3D</db:member></db:simplelist>
</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Status</db:term>
<db:listitem>
<db:para>Deprecated</db:para>
</db:listitem>
</db:varlistentry>
</db:variablelist>
<db:para><db:emphasis role="bold">This class is deprecated. We strongly advise against using it in new code.</db:emphasis></db:para>
<db:section xml:id="details">
<db:title>Detailed Description</db:title>
<db:para>The <db:link xlink:href="qglframebufferobject.xml">QGLFramebufferObject</db:link> class encapsulates an OpenGL framebuffer object, defined by the <db:code>GL_EXT_framebuffer_object</db:code> extension. In addition it provides a rendering surface that can be painted on with a <db:link xlink:href="qpainter.xml">QPainter</db:link>, rendered to using native GL calls, or both. This surface can be bound and used as a regular texture in your own GL drawing code. By default, the <db:link xlink:href="qglframebufferobject.xml">QGLFramebufferObject</db:link> class generates a 2D GL texture (using the <db:code>GL_TEXTURE_2D</db:code> target), which is used as the internal rendering target.</db:para>
<db:para><db:emphasis role="bold">It is important to have a current GL context when creating a <db:link xlink:href="qglframebufferobject.xml">QGLFramebufferObject</db:link>, otherwise initialization will fail.</db:emphasis></db:para>
<db:para>OpenGL framebuffer objects and pbuffers (see <db:link xlink:href="qglpixelbuffer.xml">QGLPixelBuffer</db:link>) can both be used to render to offscreen surfaces, but there are a number of advantages with using framebuffer objects instead of pbuffers:</db:para>
<db:orderedlist numeration="arabic">
<db:listitem>
<db:para>A framebuffer object does not require a separate rendering context, so no context switching will occur when switching rendering targets. There is an overhead involved in switching targets, but in general it is cheaper than a context switch to a pbuffer.</db:para>
</db:listitem>
<db:listitem>
<db:para>Rendering to dynamic textures (i.e. render-to-texture functionality) works on all platforms. No need to do explicit copy calls from a render buffer into a texture, as was necessary on systems that did not support the <db:code>render_texture</db:code> extension.</db:para>
</db:listitem>
<db:listitem>
<db:para>It is possible to attach several rendering buffers (or texture objects) to the same framebuffer object, and render to all of them without doing a context switch.</db:para>
</db:listitem>
<db:listitem>
<db:para>The OpenGL framebuffer extension is a pure GL extension with no system dependant WGL, CGL, or GLX parts. This makes using framebuffer objects more portable.</db:para>
</db:listitem>
</db:orderedlist>
<db:para>When using a <db:link xlink:href="qpainter.xml">QPainter</db:link> to paint to a <db:link xlink:href="qglframebufferobject.xml">QGLFramebufferObject</db:link> you should take care that the <db:link xlink:href="qglframebufferobject.xml">QGLFramebufferObject</db:link> is created with the <db:link xlink:href="qglframebufferobject.xml#Attachment-enum">CombinedDepthStencil</db:link> attachment for <db:link xlink:href="qpainter.xml">QPainter</db:link> to be able to render correctly. Note that you need to create a <db:link xlink:href="qglframebufferobject.xml">QGLFramebufferObject</db:link> with more than one sample per pixel for primitives to be antialiased when drawing using a <db:link xlink:href="qpainter.xml">QPainter</db:link>. To create a multisample framebuffer object you should use one of the constructors that take a <db:link xlink:href="qglframebufferobjectformat.xml">QGLFramebufferObjectFormat</db:link> parameter, and set the <db:link xlink:href="qglframebufferobjectformat.xml#samples">QGLFramebufferObjectFormat::samples</db:link>() property to a non-zero value.</db:para>
<db:para>When painting to a <db:link xlink:href="qglframebufferobject.xml">QGLFramebufferObject</db:link> using <db:link xlink:href="qpainter.xml">QPainter</db:link>, the state of the current GL context will be altered by the paint engine to reflect its needs. Applications should not rely upon the GL state being reset to its original conditions, particularly the current shader program, GL viewport, texture units, and drawing modes.</db:para>
<db:para>For multisample framebuffer objects a color render buffer is created, otherwise a texture with the specified texture target is created. The color render buffer or texture will have the specified internal format, and will be bound to the <db:code>GL_COLOR_ATTACHMENT0</db:code> attachment in the framebuffer object.</db:para>
<db:para>If you want to use a framebuffer object with multisampling enabled as a texture, you first need to copy from it to a regular framebuffer object using QGLContext::blitFramebuffer().</db:para>
<db:section xml:id="threading">
<db:title>Threading</db:title>
<db:para>As of Qt 4.8, it's possible to draw into a <db:link xlink:href="qglframebufferobject.xml">QGLFramebufferObject</db:link> using a <db:link xlink:href="qpainter.xml">QPainter</db:link> in a separate thread. Note that OpenGL 2.0 or OpenGL ES 2.0 is required for this to work.</db:para>
<db:note>
<db:para>This class has been deprecated in favor of <db:link xlink:href="qopenglframebufferobject.xml">QOpenGLFramebufferObject</db:link>.</db:para>
</db:note>
</db:section>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="">Framebuffer Object Example</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="member-type-documentation">
<db:title>Member Type Documentation</db:title>
<db:section xml:id="Attachment-enum">
<db:title>[since 4.3] enum QGLFramebufferObject::Attachment</db:title>
<db:para>This enum type is used to configure the depth and stencil buffers attached to the framebuffer object when it is created.</db:para>
<db:informaltable>
<db:thead>
<db:tr>
<db:th>Constant</db:th>
<db:th>Value</db:th>
<db:th>Description</db:th>
</db:tr>
</db:thead>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qglframebufferobject.xml">QGLFramebufferObject</db:link></db:emphasis>::NoAttachment</db:code></db:para>
</db:td>
<db:td><db:code>0</db:code></db:td>
<db:td>
<db:para>No attachment is added to the framebuffer object. Note that the OpenGL depth and stencil tests won't work when rendering to a framebuffer object without any depth or stencil buffers. This is the default value.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qglframebufferobject.xml">QGLFramebufferObject</db:link></db:emphasis>::CombinedDepthStencil</db:code></db:para>
</db:td>
<db:td><db:code>1</db:code></db:td>
<db:td>
<db:para>If the <db:code>GL_EXT_packed_depth_stencil</db:code> extension is present, a combined depth and stencil buffer is attached. If the extension is not present, only a depth buffer is attached.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qglframebufferobject.xml">QGLFramebufferObject</db:link></db:emphasis>::Depth</db:code></db:para>
</db:td>
<db:td><db:code>2</db:code></db:td>
<db:td>
<db:para>A depth buffer is attached to the framebuffer object.</db:para>
</db:td>
</db:tr>
</db:informaltable>
<db:para>This enum was introduced in Qt 4.3.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qglframebufferobject.xml#attachment">attachment</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
</db:section>
<db:section xml:id="member-function-documentation">
<db:title>Member Function Documentation</db:title>
<db:section xml:id="QGLFramebufferObject-2">
<db:title>QGLFramebufferObject::QGLFramebufferObject(const QSize &amp;<db:emphasis>size</db:emphasis>, const QGLFramebufferObjectFormat &amp;<db:emphasis>format</db:emphasis>)</db:title>
<db:para>This is an overloaded function.</db:para>
<db:para>Constructs an OpenGL framebuffer object of the given <db:code role="parameter">size</db:code> based on the supplied <db:code role="parameter">format</db:code>.</db:para>
</db:section>
<db:section xml:id="QGLFramebufferObject-3">
<db:title>QGLFramebufferObject::QGLFramebufferObject(int <db:emphasis>width</db:emphasis>, int <db:emphasis>height</db:emphasis>, GLenum <db:emphasis>target</db:emphasis> = GL_TEXTURE_2D)</db:title>
<db:para>This is an overloaded function.</db:para>
<db:para>Constructs an OpenGL framebuffer object and binds a 2D GL texture to the buffer of the given <db:code role="parameter">width</db:code> and <db:code role="parameter">height</db:code>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="">size()</db:link></db:member>
<db:member><db:link xlink:href="">texture()</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="QGLFramebufferObject-4">
<db:title>QGLFramebufferObject::QGLFramebufferObject(int <db:emphasis>width</db:emphasis>, int <db:emphasis>height</db:emphasis>, const QGLFramebufferObjectFormat &amp;<db:emphasis>format</db:emphasis>)</db:title>
<db:para>This is an overloaded function.</db:para>
<db:para>Constructs an OpenGL framebuffer object of the given <db:code role="parameter">width</db:code> and <db:code role="parameter">height</db:code> based on the supplied <db:code role="parameter">format</db:code>.</db:para>
</db:section>
<db:section xml:id="QGLFramebufferObject-5">
<db:title>QGLFramebufferObject::QGLFramebufferObject(const QSize &amp;<db:emphasis>size</db:emphasis>, QGLFramebufferObject::Attachment <db:emphasis>attachment</db:emphasis>, GLenum <db:emphasis>target</db:emphasis> = GL_TEXTURE_2D, GLenum <db:emphasis>internal_format</db:emphasis>)</db:title>
<db:para>This is an overloaded function.</db:para>
<db:para>Constructs an OpenGL framebuffer object and binds a texture to the buffer of the given <db:code role="parameter">size</db:code>.</db:para>
<db:para>The <db:code role="parameter">attachment</db:code> parameter describes the depth/stencil buffer configuration, <db:code role="parameter">target</db:code> the texture target and <db:code role="parameter">internal_format</db:code> the internal texture format. The default texture target is <db:code>GL_TEXTURE_2D</db:code>, while the default internal format is <db:code>GL_RGBA8</db:code> for desktop OpenGL and <db:code>GL_RGBA</db:code> for OpenGL/ES.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="">size()</db:link></db:member>
<db:member><db:link xlink:href="">texture()</db:link></db:member>
<db:member><db:link xlink:href="qglframebufferobject.xml#attachment">attachment</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="QGLFramebufferObject-6">
<db:title>QGLFramebufferObject::QGLFramebufferObject(int <db:emphasis>width</db:emphasis>, int <db:emphasis>height</db:emphasis>, QGLFramebufferObject::Attachment <db:emphasis>attachment</db:emphasis>, GLenum <db:emphasis>target</db:emphasis> = GL_TEXTURE_2D, GLenum <db:emphasis>internal_format</db:emphasis>)</db:title>
<db:para>This is an overloaded function.</db:para>
<db:para>Constructs an OpenGL framebuffer object and binds a texture to the buffer of the given <db:code role="parameter">width</db:code> and <db:code role="parameter">height</db:code>.</db:para>
<db:para>The <db:code role="parameter">attachment</db:code> parameter describes the depth/stencil buffer configuration, <db:code role="parameter">target</db:code> the texture target and <db:code role="parameter">internal_format</db:code> the internal texture format. The default texture target is <db:code>GL_TEXTURE_2D</db:code>, while the default internal format is <db:code>GL_RGBA8</db:code> for desktop OpenGL and <db:code>GL_RGBA</db:code> for OpenGL/ES.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="">size()</db:link></db:member>
<db:member><db:link xlink:href="">texture()</db:link></db:member>
<db:member><db:link xlink:href="qglframebufferobject.xml#attachment">attachment</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="attachment">
<db:title>QGLFramebufferObject::Attachment QGLFramebufferObject::attachment() const</db:title>
<db:para>Returns the status of the depth and stencil buffers attached to this framebuffer object.</db:para>
</db:section>
<db:section xml:id="blitFramebuffer">
<db:title>[static, since 4.6] void QGLFramebufferObject::blitFramebuffer(QGLFramebufferObject *<db:emphasis>target</db:emphasis>, const QRect &amp;<db:emphasis>targetRect</db:emphasis>, QGLFramebufferObject *<db:emphasis>source</db:emphasis>, const QRect &amp;<db:emphasis>sourceRect</db:emphasis>, GLbitfield <db:emphasis>buffers</db:emphasis> = GL_COLOR_BUFFER_BIT, GLenum <db:emphasis>filter</db:emphasis> = GL_NEAREST)</db:title>
<db:para>Blits from the <db:code role="parameter">sourceRect</db:code> rectangle in the <db:code role="parameter">source</db:code> framebuffer object to the <db:code role="parameter">targetRect</db:code> rectangle in the <db:code role="parameter">target</db:code> framebuffer object.</db:para>
<db:para>If <db:code role="parameter">source</db:code> or <db:code role="parameter">target</db:code> is 0, the default framebuffer will be used instead of a framebuffer object as source or target respectively.</db:para>
<db:para>The <db:code role="parameter">buffers</db:code> parameter should be a mask consisting of any combination of <db:code>GL_COLOR_BUFFER_BIT</db:code>, <db:code>GL_DEPTH_BUFFER_BIT</db:code>, and <db:code>GL_STENCIL_BUFFER_BIT</db:code>. Any buffer type that is not present both in the source and target buffers is ignored.</db:para>
<db:para>The <db:code role="parameter">sourceRect</db:code> and <db:code role="parameter">targetRect</db:code> rectangles may have different sizes; in this case <db:code role="parameter">buffers</db:code> should not contain <db:code>GL_DEPTH_BUFFER_BIT</db:code> or <db:code>GL_STENCIL_BUFFER_BIT</db:code>. The <db:code role="parameter">filter</db:code> parameter should be set to <db:code>GL_LINEAR</db:code> or <db:code>GL_NEAREST</db:code>, and specifies whether linear or nearest interpolation should be used when scaling is performed.</db:para>
<db:para>If <db:code role="parameter">source</db:code> equals <db:code role="parameter">target</db:code> a copy is performed within the same buffer. Results are undefined if the source and target rectangles overlap and have different sizes. The sizes must also be the same if any of the framebuffer objects are multisample framebuffers.</db:para>
<db:para>Note that the scissor test will restrict the blit area if enabled.</db:para>
<db:para>This function will have no effect unless hasOpenGLFramebufferBlit() returns true.</db:para>
<db:para>This function was introduced in Qt 4.6.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="">hasOpenGLFramebufferBlit()</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="drawTexture">
<db:title>[since 4.4] void QGLFramebufferObject::drawTexture(const QPointF &amp;<db:emphasis>point</db:emphasis>, GLuint <db:emphasis>textureId</db:emphasis>, GLenum <db:emphasis>textureTarget</db:emphasis> = GL_TEXTURE_2D)</db:title>
<db:para>Draws the given texture, <db:code role="parameter">textureId</db:code>, at the given <db:code role="parameter">point</db:code> in OpenGL model space. The <db:code role="parameter">textureTarget</db:code> should be a 2D texture target.</db:para>
<db:para>The framebuffer object should be bound when calling this function.</db:para>
<db:para>Equivalent to the corresponding <db:link xlink:href="qglcontext.xml#drawTexture">QGLContext::drawTexture</db:link>().</db:para>
<db:para>This function was introduced in Qt 4.4.</db:para>
</db:section>
<db:section xml:id="drawTexture-1">
<db:title>[since 4.4] void QGLFramebufferObject::drawTexture(const QRectF &amp;<db:emphasis>target</db:emphasis>, GLuint <db:emphasis>textureId</db:emphasis>, GLenum <db:emphasis>textureTarget</db:emphasis> = GL_TEXTURE_2D)</db:title>
<db:para>Draws the given texture, <db:code role="parameter">textureId</db:code>, to the given target rectangle, <db:code role="parameter">target</db:code>, in OpenGL model space. The <db:code role="parameter">textureTarget</db:code> should be a 2D texture target.</db:para>
<db:para>The framebuffer object should be bound when calling this function.</db:para>
<db:para>Equivalent to the corresponding <db:link xlink:href="qglcontext.xml#drawTexture">QGLContext::drawTexture</db:link>().</db:para>
<db:para>This function was introduced in Qt 4.4.</db:para>
</db:section>
<db:section xml:id="format">
<db:title>QGLFramebufferObjectFormat QGLFramebufferObject::format() const</db:title>
<db:para>Returns the format of this framebuffer object.</db:para>
</db:section>
<db:section xml:id="isBound">
<db:title>[since 4.5] bool QGLFramebufferObject::isBound() const</db:title>
<db:para>Returns true if the framebuffer object is currently bound to a context, otherwise false is returned.</db:para>
<db:para>This function was introduced in Qt 4.5.</db:para>
</db:section>
<db:section xml:id="metric">
<db:title>[override virtual protected] int QGLFramebufferObject::metric(QPaintDevice::PaintDeviceMetric <db:emphasis>metric</db:emphasis>) const</db:title>
<db:para>Reimplements: <db:link xlink:href="qpaintdevice.xml#metric" role="function">QPaintDevice::metric(QPaintDevice::PaintDeviceMetric metric) const</db:link>.</db:para>
</db:section>
<db:section xml:id="paintEngine">
<db:title>[override virtual] QPaintEngine *QGLFramebufferObject::paintEngine() const</db:title>
<db:para>Reimplements: <db:link xlink:href="qpaintdevice.xml#paintEngine" role="function">QPaintDevice::paintEngine() const</db:link>.</db:para>
</db:section>
</db:section>
</db:article>
