<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en">
<db:info>
<db:title>Qt Script</db:title>
<db:productname>QtScript</db:productname>
<db:edition>Qt 5.6.3 Reference Documentation</db:edition>
<db:titleabbrev>QtScript Reference Documentation</db:titleabbrev>
<db:abstract>
<db:para>QtScript Reference Documentation.</db:para></db:abstract>
<db:pubdate>2025-06-29</db:pubdate>
<db:date>2025-06-29</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:para>Qt provides support for application scripting with ECMAScript. The following guides and references cover aspects of programming with ECMAScript and Qt.</db:para>
<db:section xml:id="scripting-classes">
<db:title>Scripting Classes</db:title>
<db:para>The following classes add scripting capabilities to Qt applications.</db:para>
<db:variablelist role="script">
<db:varlistentry>
<db:term><db:link xlink:href="qscriptclass.xml" xlink:role="class">QScriptClass</db:link></db:term>
<db:listitem>
<db:para>The QScriptClass class provides an interface for defining custom behavior of (a class of) Qt Script objects.</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term><db:link xlink:href="qscriptclasspropertyiterator.xml" xlink:role="class">QScriptClassPropertyIterator</db:link></db:term>
<db:listitem>
<db:para>The QScriptClassPropertyIterator class provides an iterator interface for custom Qt Script objects.</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term><db:link xlink:href="qscriptcontext.xml" xlink:role="class">QScriptContext</db:link></db:term>
<db:listitem>
<db:para>The QScriptContext class represents a Qt Script function invocation.</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term><db:link xlink:href="qscriptcontextinfo.xml" xlink:role="class">QScriptContextInfo</db:link></db:term>
<db:listitem>
<db:para>The QScriptContextInfo class provides additional information about a QScriptContext.</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term><db:link xlink:href="qscriptengine.xml" xlink:role="class">QScriptEngine</db:link></db:term>
<db:listitem>
<db:para>The QScriptEngine class provides an environment for evaluating Qt Script code.</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term><db:link xlink:href="qscriptengineagent.xml" xlink:role="class">QScriptEngineAgent</db:link></db:term>
<db:listitem>
<db:para>The QScriptEngineAgent class provides an interface to report events pertaining to QScriptEngine execution.</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term><db:link xlink:href="qscriptprogram.xml" xlink:role="class">QScriptProgram</db:link></db:term>
<db:listitem>
<db:para>The QScriptProgram class encapsulates a Qt Script program.</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term><db:link xlink:href="qscriptstring.xml" xlink:role="class">QScriptString</db:link></db:term>
<db:listitem>
<db:para>The QScriptString class acts as a handle to &quot;interned&quot; strings in a QScriptEngine.</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term><db:link xlink:href="qscriptsyntaxcheckresult.xml" xlink:role="class">QScriptSyntaxCheckResult</db:link></db:term>
<db:listitem>
<db:para>The QScriptSyntaxCheckResult class provides the result of a script syntax check.</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term><db:link xlink:href="qscriptvalue.xml" xlink:role="class">QScriptValue</db:link></db:term>
<db:listitem>
<db:para>The QScriptValue class acts as a container for the Qt Script data types.</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term><db:link xlink:href="qscriptvalueiterator.xml" xlink:role="class">QScriptValueIterator</db:link></db:term>
<db:listitem>
<db:para>The QScriptValueIterator class provides a Java-style iterator for QScriptValue.</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term><db:link xlink:href="qscriptable.xml" xlink:role="class">QScriptable</db:link></db:term>
<db:listitem>
<db:para>The QScriptable class provides access to the Qt Script environment from Qt C++ member functions.</db:para>
</db:listitem>
</db:varlistentry>
</db:variablelist>
</db:section>
<db:section xml:id="language-overview">
<db:title>Language Overview</db:title>
<db:para>Qt Script is based on the ECMAScript scripting language, as defined in standard <db:link xlink:href="http://www.ecma-international.org/publications/standards/Ecma-262.htm">ECMA-262</db:link>. Microsoft's JScript, and Netscape's JavaScript are also based on the ECMAScript standard. For an overview of ECMAScript, see the <db:link xlink:href="ecmascript.xml">ECMAScript reference</db:link>. If you are not familiar with the ECMAScript language, there are several existing tutorials and books that cover this subject, such as <db:link xlink:href="http://shop.oreilly.com/product/9780596805531.do">JavaScript: The Definitive Guide</db:link>.</db:para>
</db:section>
<db:section xml:id="basic-usage">
<db:title>Basic Usage</db:title>
<db:para>To evaluate script code, you create a <db:link xlink:href="qscriptengine.xml">QScriptEngine</db:link> and call its evaluate() function, passing the script code (text) to evaluate as argument.</db:para>
<db:programlisting language="cpp">QScriptEngine engine;
qDebug() &lt;&lt; &quot;the magic number is:&quot; &lt;&lt; engine.evaluate(&quot;1 + 2&quot;).toNumber();
</db:programlisting>
<db:para>The return value will be the result of the evaluation (represented as a <db:link xlink:href="qscriptvalue.xml">QScriptValue</db:link> object); this can be converted to standard C++ and Qt types.</db:para>
<db:para>Custom properties can be made available to scripts by registering them with the script engine. This is most easily done by setting properties of the script engine's <db:emphasis>Global Object</db:emphasis>:</db:para>
<db:programlisting language="cpp">engine.globalObject().setProperty(&quot;foo&quot;, 123);
qDebug() &lt;&lt; &quot;foo times two is:&quot; &lt;&lt; engine.evaluate(&quot;foo * 2&quot;).toNumber();
</db:programlisting>
<db:para>This places the properties in the script environment, thus making them available to script code.</db:para>
</db:section>
<db:section xml:id="making-a-qobject-available-to-the-script-engine">
<db:title>Making a QObject Available to the Script Engine</db:title>
<db:para>Any <db:link xlink:href="qobject.xml">QObject</db:link>-based instance can be made available for use with scripts.</db:para>
<db:para>When a <db:link xlink:href="qobject.xml">QObject</db:link> is passed to the <db:link xlink:href="qscriptengine.xml#newQObject">QScriptEngine::newQObject</db:link>() function, a Qt Script wrapper object is created that can be used to make the <db:link xlink:href="qobject.xml">QObject</db:link>'s signals, slots, properties, and child objects available to scripts.</db:para>
<db:para>Here's an example of making an instance of a <db:link xlink:href="qobject.xml">QObject</db:link> subclass available to script code under the name <db:code>&quot;myObject&quot;</db:code>:</db:para>
<db:programlisting language="cpp">QScriptEngine engine;
QObject *someObject = new MyObject;
QScriptValue objectValue = engine.newQObject(someObject);
engine.globalObject().setProperty(&quot;myObject&quot;, objectValue);
</db:programlisting>
<db:para>This will create a global variable called <db:code>myObject</db:code> in the script environment. The variable serves as a proxy to the underlying C++ object. Note that the name of the script variable can be anything; i.e., it is not dependent upon <db:link xlink:href="qobject.xml#objectName-prop">QObject::objectName</db:link>().</db:para>
<db:para>The <db:link xlink:href="qscriptengine.xml#newQObject">newQObject</db:link>() function accepts two additional optional arguments: one is the ownership mode, and the other is a collection of options that allow you to control certain aspects of how the <db:link xlink:href="qscriptvalue.xml">QScriptValue</db:link> that wraps the <db:link xlink:href="qobject.xml">QObject</db:link> should behave. We will come back to the usage of these arguments later.</db:para>
<db:section xml:id="using-signals-and-slots">
<db:title>Using Signals and Slots</db:title>
<db:para>Qt Script adapts Qt's central <db:link xlink:href="signalsandslots.xml">Signals and Slots</db:link> feature for scripting. There are three principal ways to use signals and slots with Qt Script:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:emphasis role="bold">Hybrid C++/script</db:emphasis>: C++ application code connects a signal to a script function. The script function can, for example, be a function that the user has typed in, or one that you have read from a file. This approach is useful if you have a <db:link xlink:href="qobject.xml">QObject</db:link> but don't want to expose the object itself to the scripting environment; you just want a script to be able to define how a signal should be reacted to, and leave it up to the C++ side of your application to establish the connection.</db:para>
</db:listitem>
<db:listitem>
<db:para><db:emphasis role="bold">Hybrid script/C++</db:emphasis>: A script can connect signals and slots to establish connections between pre-defined objects that the application exposes to the scripting environment. In this scenario, the slots themselves are still written in C++, but the definition of the connections is fully dynamic (script-defined).</db:para>
</db:listitem>
<db:listitem>
<db:para><db:emphasis role="bold">Purely script-defined</db:emphasis>: A script can both define signal handler functions (effectively &quot;slots written in Qt Script&quot;), <db:emphasis>and</db:emphasis> set up the connections that utilize those handlers. For example, a script can define a function that will handle the <db:link xlink:href="qlineedit.xml#returnPressed">QLineEdit::returnPressed</db:link>() signal, and then connect that signal to the script function.</db:para>
</db:listitem>
</db:itemizedlist>
<db:para>Use the <db:link xlink:href="qscriptengine.xml#qScriptConnect">qScriptConnect</db:link>() function to connect a C++ signal to a script function. In the following example a script signal handler is defined that will handle the <db:link xlink:href="qlineedit.xml#textChanged">QLineEdit::textChanged</db:link>() signal:</db:para>
<db:programlisting language="cpp">QScriptEngine eng;
QLineEdit *edit = new QLineEdit(...);
QScriptValue handler = eng.evaluate(&quot;(function(text) { print('text was changed to', text); })&quot;);
qScriptConnect(edit, SIGNAL(textChanged(const QString &amp;)), QScriptValue(), handler);
</db:programlisting>
<db:para>The first two arguments to <db:link xlink:href="qscriptengine.xml#qScriptConnect">qScriptConnect</db:link>() are the same as you would pass to <db:link xlink:href="qobject.xml#connect">QObject::connect</db:link>() to establish a normal C++ connection. The third argument is the script object that will act as the <db:code>this</db:code> object when the signal handler is invoked; in the above example we pass an invalid script value, so the <db:code>this</db:code> object will be the Global Object. The fourth argument is the script function (&quot;slot&quot;) itself. The following example shows how the <db:code>this</db:code> argument can be put to use:</db:para>
<db:programlisting language="cpp">QLineEdit *edit1 = new QLineEdit(...);
QLineEdit *edit2 = new QLineEdit(...);

QScriptValue handler = eng.evaluate(&quot;(function() { print('I am', this.name); })&quot;);
QScriptValue obj1 = eng.newObject();
obj1.setProperty(&quot;name&quot;, &quot;the walrus&quot;);
QScriptValue obj2 = eng.newObject();
obj2.setProperty(&quot;name&quot;, &quot;Sam&quot;);

qScriptConnect(edit1, SIGNAL(returnPressed()), obj1, handler);
qScriptConnect(edit2, SIGNAL(returnPressed()), obj2, handler);
</db:programlisting>
<db:para>We create two <db:link xlink:href="qlineedit.xml">QLineEdit</db:link> objects and define a single signal handler function. The connections use the same handler function, but the function will be invoked with a different <db:code>this</db:code> object depending on which object's signal was triggered, so the output of the print() statement will be different for each.</db:para>
<db:para>In script code, Qt Script uses a different syntax for connecting to and disconnecting from signals than the familiar C++ syntax; i.e., <db:link xlink:href="qobject.xml#connect">QObject::connect</db:link>(). To connect to a signal, you reference the relevant signal as a property of the sender object, and invoke its <db:code>connect()</db:code> function. There are three overloads of <db:code>connect()</db:code>, each with a corresponding <db:code>disconnect()</db:code> overload. The following subsections describe these three forms.</db:para>
<db:section xml:id="signal-to-function-connections">
<db:title>Signal to Function Connections</db:title>
<db:para><db:code>connect(function)</db:code></db:para>
<db:para>In this form of connection, the argument to <db:code>connect()</db:code> is the function to connect to the signal.</db:para>
<db:programlisting language="cpp">function myInterestingScriptFunction() {
    // ...
}
// ...
myQObject.somethingChanged.connect(myInterestingScriptFunction);
</db:programlisting>
<db:para>The argument can be a Qt Script function, as in the above example, or it can be a <db:link xlink:href="qobject.xml">QObject</db:link> slot, as in the following example:</db:para>
<db:programlisting language="cpp">myQObject.somethingChanged.connect(myOtherQObject.doSomething);
</db:programlisting>
<db:para>When the argument is a <db:link xlink:href="qobject.xml">QObject</db:link> slot, the argument types of the signal and slot do not necessarily have to be compatible; Qt Script will, if necessary, perform conversion of the signal arguments to match the argument types of the slot.</db:para>
<db:para>To disconnect from a signal, you invoke the signal's <db:code>disconnect()</db:code> function, passing the function to disconnect as argument:</db:para>
<db:programlisting language="cpp">myQObject.somethingChanged.disconnect(myInterestingFunction);
myQObject.somethingChanged.disconnect(myOtherQObject.doSomething);
</db:programlisting>
<db:para>When a script function is invoked in response to a signal, the <db:code>this</db:code> object will be the Global Object.</db:para>
</db:section>
<db:section xml:id="signal-to-member-function-connections">
<db:title>Signal to Member Function Connections</db:title>
<db:para><db:code>connect(thisObject, function)</db:code></db:para>
<db:para>In this form of the <db:code>connect()</db:code> function, the first argument is the object that will be bound to the variable, <db:code>this</db:code>, when the function specified using the second argument is invoked.</db:para>
<db:para>If you have a push button in a form, you typically want to do something involving the form in response to the button's <db:code>clicked</db:code> signal; passing the form as the <db:code>this</db:code> object makes sense in such a case.</db:para>
<db:programlisting language="cpp">var obj = { x: 123 };
var fun = function() { print(this.x); };
myQObject.somethingChanged.connect(obj, fun);
</db:programlisting>
<db:para>To disconnect from the signal, pass the same arguments to <db:code>disconnect()</db:code>:</db:para>
<db:programlisting language="cpp">myQObject.somethingChanged.disconnect(obj, fun);
</db:programlisting>
</db:section>
<db:section xml:id="signal-to-named-member-function-connections">
<db:title>Signal to Named Member Function Connections</db:title>
<db:para><db:code>connect(thisObject, functionName)</db:code></db:para>
<db:para>In this form of the <db:code>connect()</db:code> function, the first argument is the object that will be bound to the variable, <db:code>this</db:code>, when a function is invoked in response to the signal. The second argument specifies the name of a function that is connected to the signal, and this refers to a member function of the object passed as the first argument (<db:code>thisObject</db:code> in the above scheme).</db:para>
<db:para>Note that the function is resolved when the connection is made, not when the signal is emitted.</db:para>
<db:programlisting language="cpp">var obj = { x: 123, fun: function() { print(this.x); } };
myQObject.somethingChanged.connect(obj, &quot;fun&quot;);
</db:programlisting>
<db:para>To disconnect from the signal, pass the same arguments to <db:code>disconnect()</db:code>:</db:para>
<db:programlisting language="cpp">myQObject.somethingChanged.disconnect(obj, &quot;fun&quot;);
</db:programlisting>
</db:section>
<db:section xml:id="error-handling">
<db:title>Error Handling</db:title>
<db:para>When <db:code>connect()</db:code> or <db:code>disconnect()</db:code> succeeds, the function will return <db:code>undefined</db:code>; otherwise, it will throw a script exception. You can obtain an error message from the resulting <db:code>Error</db:code> object. Example:</db:para>
<db:programlisting language="cpp">try {
    myQObject.somethingChanged.connect(myQObject, &quot;slotThatDoesntExist&quot;);
} catch (e) {
    print(e);
}
</db:programlisting>
</db:section>
<db:section xml:id="emitting-signals-from-scripts">
<db:title>Emitting Signals from Scripts</db:title>
<db:para>To emit a signal from script code, you simply invoke the signal function, passing the relevant arguments:</db:para>
<db:programlisting language="cpp">myQObject.somethingChanged(&quot;hello&quot;);
</db:programlisting>
<db:para>It is currently not possible to define a new signal in a script; i.e., all signals must be defined by C++ classes.</db:para>
</db:section>
<db:section xml:id="overloaded-signals-and-slots">
<db:title>Overloaded Signals and Slots</db:title>
<db:para>When a signal or slot is overloaded, Qt Script will attempt to pick the right overload based on the actual types of the <db:link xlink:href="qscriptvalue.xml">QScriptValue</db:link> arguments involved in the function invocation. For example, if your class has slots <db:code>myOverloadedSlot(int)</db:code> and <db:code>myOverloadedSlot(QString)</db:code>, the following script code will behave reasonably:</db:para>
<db:programlisting language="cpp">myQObject.myOverloadedSlot(10);   // will call the int overload
myQObject.myOverloadedSlot(&quot;10&quot;); // will call the QString overload
</db:programlisting>
<db:para>You can specify a particular overload by using array-style property access with the <db:link xlink:href="qmetaobject.xml#normalizedSignature">normalized signature</db:link> of the C++ function as the property name:</db:para>
<db:programlisting language="cpp">myQObject['myOverloadedSlot(int)'](&quot;10&quot;);   // call int overload; the argument is converted to an int
myQObject['myOverloadedSlot(QString)'](10); // call QString overload; the argument is converted to a string
</db:programlisting>
<db:para>If the overloads have different number of arguments, Qt Script will pick the overload with the argument count that best matches the actual number of arguments passed to the slot.</db:para>
<db:para>For overloaded signals, Qt Script will throw an error if you try to connect to the signal by name; you have to refer to the signal with the full normalized signature of the particular overload you want to connect to.</db:para>
</db:section>
</db:section>
<db:section xml:id="accessing-properties">
<db:title>Accessing Properties</db:title>
<db:para>The properties of the <db:link xlink:href="qobject.xml">QObject</db:link> are available as properties of the corresponding Qt Script object. When you manipulate a property in script code, the C++ get/set method for that property will automatically be invoked. For example, if your C++ class has a property declared as follows:</db:para>
<db:programlisting language="cpp">Q_PROPERTY(bool enabled READ enabled WRITE setEnabled)
</db:programlisting>
<db:para>then script code can do things like the following:</db:para>
<db:programlisting language="cpp">myQObject.enabled = true;

// ...

myQObject.enabled = !myQObject.enabled;
</db:programlisting>
</db:section>
<db:section xml:id="accessing-child-qobjects">
<db:title>Accessing Child QObjects</db:title>
<db:para>Every named child of the <db:link xlink:href="qobject.xml">QObject</db:link> (that is, for which <db:link xlink:href="qobject.xml#objectName-prop">QObject::objectName</db:link>() is not an empty string) is by default available as a property of the Qt Script wrapper object. For example, if you have a <db:link xlink:href="qdialog.xml">QDialog</db:link> with a child widget whose <db:code>objectName</db:code> property is <db:code>&quot;okButton&quot;</db:code>, you can access this object in script code through the expression</db:para>
<db:programlisting language="cpp">myDialog.okButton
</db:programlisting>
<db:para>Since <db:code>objectName</db:code> is itself a <db:link xlink:href="qobject.xml#Q_PROPERTY">Q_PROPERTY</db:link>, you can manipulate the name in script code to, for example, rename an object:</db:para>
<db:programlisting language="cpp">myDialog.okButton.objectName = &quot;cancelButton&quot;;
// from now on, myDialog.cancelButton references the button
</db:programlisting>
<db:para>You can also use the functions <db:code>findChild()</db:code> and <db:code>findChildren()</db:code> to find children. These two functions behave identically to QObject::findChild() and QObject::findChildren(), respectively.</db:para>
<db:para>For example, we can use these functions to find objects using strings and regular expressions:</db:para>
<db:programlisting language="cpp">var okButton = myDialog.findChild(&quot;okButton&quot;);
if (okButton != null) {
   // do something with the OK button
}

var buttons = myDialog.findChildren(RegExp(&quot;button[0-9]+&quot;));
for (var i = 0; i &lt; buttons.length; ++i) {
   // do something with buttons[i]
}
</db:programlisting>
<db:para>You typically want to use <db:code>findChild()</db:code> when manipulating a form that uses nested layouts; that way the script is isolated from the details about which particular layout a widget is located in.</db:para>
</db:section>
<db:section xml:id="controlling-qobject-ownership">
<db:title>Controlling QObject Ownership</db:title>
<db:para>Qt Script uses garbage collection to reclaim memory used by script objects when they are no longer needed; an object's memory can be automatically reclaimed when it is no longer referenced anywhere in the scripting environment. Qt Script lets you control what happens to the underlying C++ <db:link xlink:href="qobject.xml">QObject</db:link> when the wrapper object is reclaimed (i.e., whether the <db:link xlink:href="qobject.xml">QObject</db:link> is deleted or not); you do this when you create an object by passing an ownership mode as the second argument to <db:link xlink:href="qscriptengine.xml#newQObject">QScriptEngine::newQObject</db:link>().</db:para>
<db:para>Knowing how Qt Script deals with ownership is important, since it can help you avoid situations where a C++ object isn't deleted when it should be (causing memory leaks), or where a C++ object <db:emphasis>is</db:emphasis> deleted when it shouldn't be (typically causing a crash if C++ code later tries to access that object).</db:para>
<db:section xml:id="qt-ownership">
<db:title>Qt Ownership</db:title>
<db:para>By default, the script engine does not take ownership of the <db:link xlink:href="qobject.xml">QObject</db:link> that is passed to <db:link xlink:href="qscriptengine.xml#newQObject">QScriptEngine::newQObject</db:link>(); the object is managed according to Qt's object ownership (see <db:link xlink:href="objecttrees.xml">Object Trees &amp; Ownership</db:link>). This mode is appropriate when, for example, you are wrapping C++ objects that are part of your application's core; that is, they should persist regardless of what happens in the scripting environment. Another way of stating this is that the C++ objects should outlive the script engine.</db:para>
</db:section>
<db:section xml:id="script-ownership">
<db:title>Script Ownership</db:title>
<db:para>Specifying <db:link xlink:href="qscriptengine.xml#ValueOwnership-enum">QScriptEngine::ScriptOwnership</db:link> as the ownership mode will cause the script engine to take full ownership of the <db:link xlink:href="qobject.xml">QObject</db:link> and delete it when it determines that it is safe to do so (i.e., when there are no more references to it in script code). This ownership mode is appropriate if the <db:link xlink:href="qobject.xml">QObject</db:link> does not have a parent object, and/or the <db:link xlink:href="qobject.xml">QObject</db:link> is created in the context of the script engine and is not intended to outlive the script engine.</db:para>
<db:para>For example, a constructor function that constructs QObjects only to be used in the script environment is a good candidate:</db:para>
<db:programlisting language="cpp">QScriptValue myQObjectConstructor(QScriptContext *context, QScriptEngine *engine)
{
  // let the engine manage the new object's lifetime.
  return engine-&gt;newQObject(new MyQObject(), QScriptEngine::ScriptOwnership);
}
</db:programlisting>
</db:section>
<db:section xml:id="auto-ownership">
<db:title>Auto-Ownership</db:title>
<db:para>With <db:link xlink:href="qscriptengine.xml#ValueOwnership-enum">QScriptEngine::AutoOwnership</db:link> the ownership is based on whether the <db:link xlink:href="qobject.xml">QObject</db:link> has a parent or not. If the Qt Script garbage collector finds that the <db:link xlink:href="qobject.xml">QObject</db:link> is no longer referenced within the script environment, the <db:link xlink:href="qobject.xml">QObject</db:link> will be deleted <db:emphasis>only</db:emphasis> if it does not have a parent.</db:para>
</db:section>
<db:section xml:id="what-happens-when-someone-else-deletes-the-qobject">
<db:title>What Happens When Someone Else Deletes the QObject?</db:title>
<db:para>It is possible that a wrapped <db:link xlink:href="qobject.xml">QObject</db:link> is deleted outside of Qt Script's control; i.e., without regard to the ownership mode specified. In this case, the wrapper object will still be an object (unlike the C++ pointer it wraps, the script object won't become null). Any attempt to access properties of the script object will, however, result in a script exception being thrown.</db:para>
<db:para>Note that <db:link xlink:href="qscriptvalue.xml#isQObject">QScriptValue::isQObject</db:link>() will still return true for a deleted <db:link xlink:href="qobject.xml">QObject</db:link>, since it tests the type of the script object, not whether the internal pointer is non-null. In other words, if <db:link xlink:href="qscriptvalue.xml#isQObject">QScriptValue::isQObject</db:link>() returns true but <db:link xlink:href="qscriptvalue.xml#toQObject">QScriptValue::toQObject</db:link>() returns a null pointer, this indicates that the <db:link xlink:href="qobject.xml">QObject</db:link> has been deleted outside of Qt Script (perhaps accidentally).</db:para>
</db:section>
</db:section>
<db:section xml:id="customizing-access-to-the-qobject">
<db:title>Customizing Access to the QObject</db:title>
<db:para><db:link xlink:href="qscriptengine.xml#newQObject">QScriptEngine::newQObject</db:link>() can take a third argument which allows you to control various aspects of the access to the <db:link xlink:href="qobject.xml">QObject</db:link> through the Qt Script wrapper object it returns.</db:para>
<db:para><db:link xlink:href="qscriptengine.xml#QObjectWrapOption-enum">QScriptEngine::ExcludeChildObjects</db:link> specifies that child objects of the <db:link xlink:href="qobject.xml">QObject</db:link> should not appear as properties of the wrapper object.</db:para>
<db:para><db:link xlink:href="qscriptengine.xml#QObjectWrapOption-enum">QScriptEngine::ExcludeSuperClassProperties</db:link> and <db:link xlink:href="qscriptengine.xml#QObjectWrapOption-enum">QScriptEngine::ExcludeSuperClassMethods</db:link> can be used to avoid exposing members that are inherited from the <db:link xlink:href="qobject.xml">QObject</db:link>'s superclass. This is useful for defining a &quot;pure&quot; interface where inherited members don't make sense from a scripting perspective; e.g., you don't want script authors to be able to change the <db:code>objectName</db:code> property of the object or invoke the <db:code>deleteLater()</db:code> slot.</db:para>
<db:para><db:link xlink:href="qscriptengine.xml#QObjectWrapOption-enum">QScriptEngine::AutoCreateDynamicProperties</db:link> specifies that properties that don't already exist in the <db:link xlink:href="qobject.xml">QObject</db:link> should be created as dynamic properties of the <db:link xlink:href="qobject.xml">QObject</db:link>, rather than as properties of the Qt Script wrapper object. If you want new properties to truly become persistent properties of the <db:link xlink:href="qobject.xml">QObject</db:link>, rather than properties that are destroyed along with the wrapper object (and that aren't shared if the <db:link xlink:href="qobject.xml">QObject</db:link> is wrapped multiple times with <db:link xlink:href="qscriptengine.xml#newQObject">QScriptEngine::newQObject</db:link>()), you should use this option.</db:para>
<db:para><db:link xlink:href="qscriptengine.xml#QObjectWrapOption-enum">QScriptEngine::SkipMethodsInEnumeration</db:link> specifies that signals and slots should be skipped when enumerating the properties of the <db:link xlink:href="qobject.xml">QObject</db:link> wrapper in a for-in script statement. This is useful when defining prototype objects, since by convention function properties of prototypes should not be enumerable.</db:para>
</db:section>
<db:section xml:id="making-a-qobject-based-class-new-able-from-a-script">
<db:title>Making a QObject-based Class New-able from a Script</db:title>
<db:para>The <db:link xlink:href="qscriptengine.xml#newQObject">QScriptEngine::newQObject</db:link>() function is used to wrap an existing <db:link xlink:href="qobject.xml">QObject</db:link> instance, so that it can be made available to scripts. A different scenario is that you want scripts to be able to construct new objects, not just access existing ones.</db:para>
<db:para>The Qt meta-type system currently does not provide dynamic binding of constructors for <db:link xlink:href="qobject.xml">QObject</db:link>-based classes. If you want to make such a class new-able from scripts, Qt Script can generate a reasonable script constructor for you; see QScriptEngine::scriptValueFromQMetaObject().</db:para>
<db:para>You can also use <db:link xlink:href="qscriptengine.xml#newFunction">QScriptEngine::newFunction</db:link>() to wrap your own factory function, and add it to the script environment; see <db:link xlink:href="qscriptengine.xml#newQMetaObject">QScriptEngine::newQMetaObject</db:link>() for an example.</db:para>
</db:section>
<db:section xml:id="enum-values">
<db:title>Enum Values</db:title>
<db:para>Values for enums declared with Q_ENUMS are not available as properties of individual wrapper objects; rather, they are properties of the <db:link xlink:href="qmetaobject.xml">QMetaObject</db:link> wrapper object that can be created with <db:link xlink:href="qscriptengine.xml#newQMetaObject">QScriptEngine::newQMetaObject</db:link>().</db:para>
</db:section>
</db:section>
<db:section xml:id="conversion-between-qt-script-and-c-types">
<db:title>Conversion Between Qt Script and C++ Types</db:title>
<db:para>Qt Script will perform type conversion when a value needs to be converted from the script side to the C++ side or vice versa; for instance, when a C++ signal triggers a script function, when you access a <db:link xlink:href="qobject.xml">QObject</db:link> property in script code, or when you call QScriptEngine::toScriptValue() or QScriptEngine::fromScriptValue() in C++. Qt Script provides default conversion operations for many of the built-in Qt types. You can change the conversion operation for a type (including your custom C++ types) by registering your own conversion functions with qScriptRegisterMetaType().</db:para>
<db:section xml:id="default-conversion-from-qt-script-to-c">
<db:title>Default Conversion from Qt Script to C++</db:title>
<db:para>The following table describes the default conversion from a <db:link xlink:href="qscriptvalue.xml">QScriptValue</db:link> to a C++ type.</db:para>
<db:informaltable style="generic" width="80%">
<db:thead>
<db:tr>
<db:th>
<db:para>C++ Type</db:para>
</db:th>
<db:th>
<db:para>Default Conversion</db:para>
</db:th>
</db:tr>
</db:thead>
<db:tr valign="top">
<db:td>
<db:para>bool</db:para>
</db:td>
<db:td>
<db:para><db:link xlink:href="qscriptvalue.xml#toBool">QScriptValue::toBool</db:link>()</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>int</db:para>
</db:td>
<db:td>
<db:para><db:link xlink:href="qscriptvalue.xml#toInt32">QScriptValue::toInt32</db:link>()</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>uint</db:para>
</db:td>
<db:td>
<db:para><db:link xlink:href="qscriptvalue.xml#toUInt32">QScriptValue::toUInt32</db:link>()</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>float</db:para>
</db:td>
<db:td>
<db:para>float(<db:link xlink:href="qscriptvalue.xml#toNumber">QScriptValue::toNumber</db:link>())</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>double</db:para>
</db:td>
<db:td>
<db:para><db:link xlink:href="qscriptvalue.xml#toNumber">QScriptValue::toNumber</db:link>()</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>short</db:para>
</db:td>
<db:td>
<db:para>short(<db:link xlink:href="qscriptvalue.xml#toInt32">QScriptValue::toInt32</db:link>())</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>ushort</db:para>
</db:td>
<db:td>
<db:para><db:link xlink:href="qscriptvalue.xml#toUInt16">QScriptValue::toUInt16</db:link>()</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>char</db:para>
</db:td>
<db:td>
<db:para>char(<db:link xlink:href="qscriptvalue.xml#toInt32">QScriptValue::toInt32</db:link>())</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>uchar</db:para>
</db:td>
<db:td>
<db:para>unsigned char(<db:link xlink:href="qscriptvalue.xml#toInt32">QScriptValue::toInt32</db:link>())</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>long</db:para>
</db:td>
<db:td>
<db:para>long(<db:link xlink:href="qscriptvalue.xml#toInteger">QScriptValue::toInteger</db:link>())</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>ulong</db:para>
</db:td>
<db:td>
<db:para>ulong(<db:link xlink:href="qscriptvalue.xml#toInteger">QScriptValue::toInteger</db:link>())</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>qlonglong</db:para>
</db:td>
<db:td>
<db:para>qlonglong(<db:link xlink:href="qscriptvalue.xml#toInteger">QScriptValue::toInteger</db:link>())</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>qulonglong</db:para>
</db:td>
<db:td>
<db:para>qulonglong(<db:link xlink:href="qscriptvalue.xml#toInteger">QScriptValue::toInteger</db:link>())</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para><db:link xlink:href="qstring.xml">QString</db:link></db:para>
</db:td>
<db:td>
<db:para>An empty string if the <db:link xlink:href="qscriptvalue.xml">QScriptValue</db:link> is null or undefined; <db:link xlink:href="qscriptvalue.xml#toString">QScriptValue::toString</db:link>() otherwise.</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para><db:link xlink:href="qdatetime.xml">QDateTime</db:link></db:para>
</db:td>
<db:td>
<db:para><db:link xlink:href="qscriptvalue.xml#toDateTime">QScriptValue::toDateTime</db:link>()</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para><db:link xlink:href="qdate.xml">QDate</db:link></db:para>
</db:td>
<db:td>
<db:para><db:link xlink:href="qscriptvalue.xml#toDateTime">QScriptValue::toDateTime</db:link>().date()</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para><db:link xlink:href="qregexp.xml">QRegExp</db:link></db:para>
</db:td>
<db:td>
<db:para><db:link xlink:href="qscriptvalue.xml#toRegExp">QScriptValue::toRegExp</db:link>()</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para><db:link xlink:href="qobject.xml">QObject</db:link>*</db:para>
</db:td>
<db:td>
<db:para><db:link xlink:href="qscriptvalue.xml#toQObject">QScriptValue::toQObject</db:link>()</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para><db:link xlink:href="qwidget.xml">QWidget</db:link>*</db:para>
</db:td>
<db:td>
<db:para><db:link xlink:href="qscriptvalue.xml#toQObject">QScriptValue::toQObject</db:link>()</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para><db:link xlink:href="qvariant.xml">QVariant</db:link></db:para>
</db:td>
<db:td>
<db:para><db:link xlink:href="qscriptvalue.xml#toVariant">QScriptValue::toVariant</db:link>()</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para><db:link xlink:href="qchar.xml">QChar</db:link></db:para>
</db:td>
<db:td>
<db:para>If the <db:link xlink:href="qscriptvalue.xml">QScriptValue</db:link> is a string, the result is the first character of the string, or a null <db:link xlink:href="qchar.xml">QChar</db:link> if the string is empty; otherwise, the result is a <db:link xlink:href="qchar.xml">QChar</db:link> constructed from the unicode obtained by converting the <db:link xlink:href="qscriptvalue.xml">QScriptValue</db:link> to a <db:code>ushort</db:code>.</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para><db:link xlink:href="qstringlist.xml">QStringList</db:link></db:para>
</db:td>
<db:td>
<db:para>If the <db:link xlink:href="qscriptvalue.xml">QScriptValue</db:link> is an array, the result is a <db:link xlink:href="qstringlist.xml">QStringList</db:link> constructed from the result of <db:link xlink:href="qscriptvalue.xml#toString">QScriptValue::toString</db:link>() for each array element; otherwise, the result is an empty <db:link xlink:href="qstringlist.xml">QStringList</db:link>.</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para><db:link xlink:href="qvariant.xml#QVariantList-typedef">QVariantList</db:link></db:para>
</db:td>
<db:td>
<db:para>If the <db:link xlink:href="qscriptvalue.xml">QScriptValue</db:link> is an array, the result is a <db:link xlink:href="qvariant.xml#QVariantList-typedef">QVariantList</db:link> constructed from the result of <db:link xlink:href="qscriptvalue.xml#toVariant">QScriptValue::toVariant</db:link>() for each array element; otherwise, the result is an empty <db:link xlink:href="qvariant.xml#QVariantList-typedef">QVariantList</db:link>.</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para><db:link xlink:href="qvariant.xml#QVariantMap-typedef">QVariantMap</db:link></db:para>
</db:td>
<db:td>
<db:para>If the <db:link xlink:href="qscriptvalue.xml">QScriptValue</db:link> is an object, the result is a <db:link xlink:href="qvariant.xml#QVariantMap-typedef">QVariantMap</db:link> with a (key, value) pair of the form (propertyName, propertyValue.toVariant()) for each property, using <db:link xlink:href="qscriptvalueiterator.xml">QScriptValueIterator</db:link> to iterate over the object's properties.</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para><db:link xlink:href="qobject.xml#QObjectList-typedef">QObjectList</db:link></db:para>
</db:td>
<db:td>
<db:para>If the <db:link xlink:href="qscriptvalue.xml">QScriptValue</db:link> is an array, the result is a <db:link xlink:href="qobject.xml#QObjectList-typedef">QObjectList</db:link> constructed from the result of <db:link xlink:href="qscriptvalue.xml#toQObject">QScriptValue::toQObject</db:link>() for each array element; otherwise, the result is an empty <db:link xlink:href="qobject.xml#QObjectList-typedef">QObjectList</db:link>.</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para><db:link xlink:href="qlist.xml">QList</db:link>&lt;int&gt;</db:para>
</db:td>
<db:td>
<db:para>If the <db:link xlink:href="qscriptvalue.xml">QScriptValue</db:link> is an array, the result is a <db:link xlink:href="qlist.xml">QList</db:link>&lt;int&gt; constructed from the result of <db:link xlink:href="qscriptvalue.xml#toInt32">QScriptValue::toInt32</db:link>() for each array element; otherwise, the result is an empty <db:link xlink:href="qlist.xml">QList</db:link>&lt;int&gt;.</db:para>
</db:td>
</db:tr>
</db:informaltable>
<db:para>Additionally, Qt Script will handle the following cases:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para>If the <db:link xlink:href="qscriptvalue.xml">QScriptValue</db:link> is a <db:link xlink:href="qobject.xml">QObject</db:link> and the target type name ends with <db:code>*</db:code> (i.e., it is a pointer), the <db:link xlink:href="qobject.xml">QObject</db:link> pointer will be cast to the target type with qobject_cast().</db:para>
</db:listitem>
<db:listitem>
<db:para>If the <db:link xlink:href="qscriptvalue.xml">QScriptValue</db:link> is a <db:link xlink:href="qvariant.xml">QVariant</db:link> and the target type name ends with <db:code>*</db:code> (i.e., it is a pointer), and the <db:link xlink:href="qvariant.xml#userType">userType</db:link>() of the <db:link xlink:href="qvariant.xml">QVariant</db:link> is the type that the target type points to, the result is a pointer to the <db:link xlink:href="qvariant.xml">QVariant</db:link>'s data.</db:para>
</db:listitem>
<db:listitem>
<db:para>If the <db:link xlink:href="qscriptvalue.xml">QScriptValue</db:link> is a <db:link xlink:href="qvariant.xml">QVariant</db:link> and it can be converted to the target type (according to <db:link xlink:href="qvariant.xml#canConvert">QVariant::canConvert</db:link>()), the <db:link xlink:href="qvariant.xml">QVariant</db:link> will be cast to the target type with <db:link xlink:href="qvariant.xml#qvariant_cast">qvariant_cast</db:link>().</db:para>
</db:listitem>
</db:itemizedlist>
</db:section>
<db:section xml:id="default-conversion-from-c-to-qt-script">
<db:title>Default Conversion from C++ to Qt Script</db:title>
<db:para>The following table describes the default behavior when a <db:link xlink:href="qscriptvalue.xml">QScriptValue</db:link> is constructed from a C++ type:</db:para>
<db:informaltable style="generic" width="80%">
<db:thead>
<db:tr>
<db:th>
<db:para>C++ Type</db:para>
</db:th>
<db:th>
<db:para>Default Construction</db:para>
</db:th>
</db:tr>
</db:thead>
<db:tr valign="top">
<db:td>
<db:para>void</db:para>
</db:td>
<db:td>
<db:para><db:link xlink:href="qscriptengine.xml#undefinedValue">QScriptEngine::undefinedValue</db:link>()</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>bool</db:para>
</db:td>
<db:td>
<db:para><db:link xlink:href="qscriptvalue.xml">QScriptValue</db:link>(engine, value)</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>int</db:para>
</db:td>
<db:td>
<db:para><db:link xlink:href="qscriptvalue.xml">QScriptValue</db:link>(engine, value)</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>uint</db:para>
</db:td>
<db:td>
<db:para><db:link xlink:href="qscriptvalue.xml">QScriptValue</db:link>(engine, value)</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>float</db:para>
</db:td>
<db:td>
<db:para><db:link xlink:href="qscriptvalue.xml">QScriptValue</db:link>(engine, value)</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>double</db:para>
</db:td>
<db:td>
<db:para><db:link xlink:href="qscriptvalue.xml">QScriptValue</db:link>(engine, value)</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>short</db:para>
</db:td>
<db:td>
<db:para><db:link xlink:href="qscriptvalue.xml">QScriptValue</db:link>(engine, value)</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>ushort</db:para>
</db:td>
<db:td>
<db:para><db:link xlink:href="qscriptvalue.xml">QScriptValue</db:link>(engine, value)</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>char</db:para>
</db:td>
<db:td>
<db:para><db:link xlink:href="qscriptvalue.xml">QScriptValue</db:link>(engine, value)</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>uchar</db:para>
</db:td>
<db:td>
<db:para><db:link xlink:href="qscriptvalue.xml">QScriptValue</db:link>(engine, value)</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para><db:link xlink:href="qstring.xml">QString</db:link></db:para>
</db:td>
<db:td>
<db:para><db:link xlink:href="qscriptvalue.xml">QScriptValue</db:link>(engine, value)</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>long</db:para>
</db:td>
<db:td>
<db:para>If the input fits in an int, <db:link xlink:href="qscriptvalue.xml">QScriptValue</db:link>(engine, int(value)); otherwise, <db:link xlink:href="qscriptvalue.xml">QScriptValue</db:link>(engine, double(value)). Note that the latter conversion can be lossy.</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>ulong</db:para>
</db:td>
<db:td>
<db:para>If the input fits in a uint, <db:link xlink:href="qscriptvalue.xml">QScriptValue</db:link>(engine, uint(value)); otherwise, <db:link xlink:href="qscriptvalue.xml">QScriptValue</db:link>(engine, double(value)). Note that the latter conversion can be lossy.</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>qlonglong</db:para>
</db:td>
<db:td>
<db:para><db:link xlink:href="qscriptvalue.xml">QScriptValue</db:link>(engine, qsreal(value)). Note that the conversion may lead to loss of precision, since not all 64-bit integers can be represented using the qsreal type.</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>qulonglong</db:para>
</db:td>
<db:td>
<db:para><db:link xlink:href="qscriptvalue.xml">QScriptValue</db:link>(engine, qsreal(value)). Note that the conversion may lead to loss of precision, since not all 64-bit unsigned integers can be represented using the qsreal type.</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para><db:link xlink:href="qchar.xml">QChar</db:link></db:para>
</db:td>
<db:td>
<db:para><db:link xlink:href="qscriptvalue.xml">QScriptValue</db:link>(this, value.unicode())</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para><db:link xlink:href="qdatetime.xml">QDateTime</db:link></db:para>
</db:td>
<db:td>
<db:para><db:link xlink:href="qscriptengine.xml#newDate">QScriptEngine::newDate</db:link>(value)</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para><db:link xlink:href="qdate.xml">QDate</db:link></db:para>
</db:td>
<db:td>
<db:para><db:link xlink:href="qscriptengine.xml#newDate">QScriptEngine::newDate</db:link>(value)</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para><db:link xlink:href="qregexp.xml">QRegExp</db:link></db:para>
</db:td>
<db:td>
<db:para><db:link xlink:href="qscriptengine.xml#newRegExp">QScriptEngine::newRegExp</db:link>(value)</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para><db:link xlink:href="qobject.xml">QObject</db:link>*</db:para>
</db:td>
<db:td>
<db:para><db:link xlink:href="qscriptengine.xml#newQObject">QScriptEngine::newQObject</db:link>(value)</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para><db:link xlink:href="qwidget.xml">QWidget</db:link>*</db:para>
</db:td>
<db:td>
<db:para><db:link xlink:href="qscriptengine.xml#newQObject">QScriptEngine::newQObject</db:link>(value)</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para><db:link xlink:href="qvariant.xml">QVariant</db:link></db:para>
</db:td>
<db:td>
<db:para><db:link xlink:href="qscriptengine.xml#newVariant">QScriptEngine::newVariant</db:link>(value)</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para><db:link xlink:href="qstringlist.xml">QStringList</db:link></db:para>
</db:td>
<db:td>
<db:para>A new script array (created with <db:link xlink:href="qscriptengine.xml#newArray">QScriptEngine::newArray</db:link>()), whose elements are created using the <db:link xlink:href="qscriptvalue.xml">QScriptValue</db:link>(<db:link xlink:href="qscriptengine.xml">QScriptEngine</db:link> *, <db:link xlink:href="qstring.xml">QString</db:link>) constructor for each element of the list.</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para><db:link xlink:href="qvariant.xml#QVariantList-typedef">QVariantList</db:link></db:para>
</db:td>
<db:td>
<db:para>A new script array (created with <db:link xlink:href="qscriptengine.xml#newArray">QScriptEngine::newArray</db:link>()), whose elements are created using <db:link xlink:href="qscriptengine.xml#newVariant">QScriptEngine::newVariant</db:link>() for each element of the list.</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para><db:link xlink:href="qvariant.xml#QVariantMap-typedef">QVariantMap</db:link></db:para>
</db:td>
<db:td>
<db:para>A new script object (created with <db:link xlink:href="qscriptengine.xml#newObject">QScriptEngine::newObject</db:link>()), whose properties are initialized according to the (key, value) pairs of the map.</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para><db:link xlink:href="qobject.xml#QObjectList-typedef">QObjectList</db:link></db:para>
</db:td>
<db:td>
<db:para>A new script array (created with <db:link xlink:href="qscriptengine.xml#newArray">QScriptEngine::newArray</db:link>()), whose elements are created using <db:link xlink:href="qscriptengine.xml#newQObject">QScriptEngine::newQObject</db:link>() for each element of the list.</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para><db:link xlink:href="qlist.xml">QList</db:link>&lt;int&gt;</db:para>
</db:td>
<db:td>
<db:para>A new script array (created with <db:link xlink:href="qscriptengine.xml#newArray">QScriptEngine::newArray</db:link>()), whose elements are created using the <db:link xlink:href="qscriptvalue.xml">QScriptValue</db:link>(<db:link xlink:href="qscriptengine.xml">QScriptEngine</db:link> *, int) constructor for each element of the list.</db:para>
</db:td>
</db:tr>
</db:informaltable>
<db:para>Other types (including custom types) will be wrapped using <db:link xlink:href="qscriptengine.xml#newVariant">QScriptEngine::newVariant</db:link>(). For null pointers of any type, the result is <db:link xlink:href="qscriptengine.xml#nullValue">QScriptEngine::nullValue</db:link>().</db:para>
</db:section>
</db:section>
<db:section xml:id="how-to-design-and-implement-application-objects">
<db:title>How to Design and Implement Application Objects</db:title>
<db:para>This section explains how to implement application objects and provides the necessary technical background material.</db:para>
<db:section xml:id="making-a-c-object-available-to-scripts-written-in-qt-script">
<db:title>Making a C++ object available to Scripts Written in Qt Script</db:title>
<db:para>Making C++ classes and objects available to a scripting language is not trivial because scripting languages tend to be more dynamic than C++, and it must be possible to introspect objects (query information such as function names, function signatures, properties, etc., at run-time). Standard C++ does not provide features for this.</db:para>
<db:para>We can achieve the functionality we want by extending C++, using C++'s own facilities so our code is still standard C++. The Qt meta-object system provides the necessary additional functionality. It allows us to write using an extended C++ syntax, but converts this into standard C++ using a small utility program called <db:link xlink:href="moc.xml">moc</db:link> (Meta-Object Compiler). Classes that wish to take advantage of the meta-object facilities are either subclasses of <db:link xlink:href="qobject.xml">QObject</db:link>, or use the <db:code>Q_OBJECT</db:code> macro. Qt has used this approach for many years and it has proven to be solid and reliable. Qt Script uses this meta-object technology to provide scripters with dynamic access to C++ classes and objects.</db:para>
<db:para>To completely understand how to make C++ objects available to Qt Script, some basic knowledge of the Qt meta-object system is very helpful. We recommend that you read about the Qt <db:link xlink:href="object.xml">Object Model</db:link> and <db:link xlink:href="metaobjects.xml">The Meta-Object System</db:link>, which are useful for understanding how to implement application objects.</db:para>
<db:para>However, this knowledge is not essential in the simplest cases. To make an object available in Qt Script, it must derive from <db:link xlink:href="qobject.xml">QObject</db:link>. All classes which derive from <db:link xlink:href="qobject.xml">QObject</db:link> can be introspected and can provide the information needed by the scripting engine at run-time; e.g., class name, functions, signatures. Because we obtain the information we need about classes dynamically at run-time, there is no need to write wrappers for <db:link xlink:href="qobject.xml">QObject</db:link> derived classes.</db:para>
</db:section>
<db:section xml:id="making-c-class-member-functions-available-in-qt-script">
<db:title>Making C++ Class Member Functions Available in Qt Script</db:title>
<db:para>The meta-object system also makes information about signals and slots dynamically available at run-time. By default, for <db:link xlink:href="qobject.xml">QObject</db:link> subclasses, only the signals and slots are automatically made available to scripts. This is very convenient because, in practice, we normally only want to make specially chosen functions available to scripters. When you create a <db:link xlink:href="qobject.xml">QObject</db:link> subclass, make sure that the functions you want to expose to Qt Script are public slots.</db:para>
<db:para>For example, the following class definition enables scripting only for certain functions:</db:para>
<db:programlisting language="cpp">class MyObject : public QObject
{
    Q_OBJECT

public:
    MyObject( ... );

    void aNonScriptableFunction();

public slots: // these functions (slots) will be available in Qt Script
    void calculate( ... );
    void setEnabled( bool enabled );
    bool isEnabled() const;

private:
   ....

};
</db:programlisting>
<db:para>In the example above, aNonScriptableFunction() is not declared as a slot, so it will not be available in Qt Script. The other three functions will automatically be made available in Qt Script because they are declared in the <db:code>public slots</db:code> section of the class definition.</db:para>
<db:para>It is possible to make any function script-invokable by specifying the <db:code>Q_INVOKABLE</db:code> modifier when declaring the function:</db:para>
<db:programlisting language="cpp">class MyObject : public QObject
{
    Q_OBJECT

    public:
    Q_INVOKABLE void thisMethodIsInvokableInQtScript();
    void thisMethodIsNotInvokableInQtScript();

    ...
};
</db:programlisting>
<db:para>Once declared with <db:code>Q_INVOKABLE</db:code>, the method can be invoked from Qt Script code just as if it were a slot. Although such a method is not a slot, you can still specify it as the target function in a call to <db:code>connect()</db:code> in script code; <db:code>connect()</db:code> accepts both native and non-native functions as targets.</db:para>
<db:para>As discussed in <db:link xlink:href="qtscript-index.xml#default-conversion-from-qt-script-to-c">Default Conversion from Qt Script to C++</db:link>, Qt Script handles conversion for many C++ types. If your function takes arguments for which Qt Script does not handle conversion, you need to supply conversion functions. This is done using the qScriptRegisterMetaType() function.</db:para>
</db:section>
<db:section xml:id="making-c-class-properties-available-in-qt-script">
<db:title>Making C++ Class Properties Available in Qt Script</db:title>
<db:para>In the previous example, if we wanted to get or set a property using Qt Script we would have to write code like the following:</db:para>
<db:programlisting language="cpp">var obj = new MyObject;
obj.setEnabled( true );
print( &quot;obj is enabled: &quot; + obj.isEnabled() );
</db:programlisting>
<db:para>Scripting languages often provide a property syntax to modify and retrieve properties (in our case the enabled state) of an object. Many script programmers would want to write the above code like this:</db:para>
<db:programlisting language="cpp">var obj = new MyObject;
obj.enabled = true;
print( &quot;obj is enabled: &quot; + obj.enabled );
</db:programlisting>
<db:para>To make this possible, you must define properties in the C++ <db:link xlink:href="qobject.xml">QObject</db:link> subclass. For example, the following <db:code>MyObject</db:code> class declaration declares a boolean property called <db:code>enabled</db:code>, which uses the function <db:code>setEnabled(bool)</db:code> as its setter function and <db:code>isEnabled()</db:code> as its getter function:</db:para>
<db:programlisting language="cpp">class MyObject : public QObject
{
    Q_OBJECT
    // define the enabled property
    Q_PROPERTY( bool enabled WRITE setEnabled READ isEnabled )

public:
    MyObject( ... );

    void aNonScriptableFunction();

public slots: // these functions (slots) will be available in Qt Script
    void calculate( ... );
    void setEnabled( bool enabled );
    bool isEnabled() const;

private:
   ....

};
</db:programlisting>
<db:para>The only difference from the original code is the use of the macro <db:code>Q_PROPERTY</db:code>, which takes the type and name of the property, and the names of the setter and getter functions as arguments.</db:para>
<db:para>If you don't want a property of your class to be accessible in Qt Script, you set the <db:code>SCRIPTABLE</db:code> attribute to <db:code>false</db:code> when declaring the property; by default, the <db:code>SCRIPTABLE</db:code> attribute is <db:code>true</db:code>. For example:</db:para>
<db:programlisting language="cpp">Q_PROPERTY(int nonScriptableProperty READ foo WRITE bar SCRIPTABLE false)
</db:programlisting>
</db:section>
<db:section xml:id="reacting-to-c-objects-signals-in-scripts">
<db:title>Reacting to C++ Objects Signals in Scripts</db:title>
<db:para>In the Qt object model, signals are used as a notification mechanism between QObjects. This means one object can connect a signal to another object's slot and, every time the signal is emitted, the slot is called. This connection is established using the <db:link xlink:href="qobject.xml#connect">QObject::connect</db:link>() function.</db:para>
<db:para>The signals and slots mechanism is also available to Qt Script programmers. The code to declare a signal in C++ is the same, regardless of whether the signal will be connected to a slot in C++ or in Qt Script.</db:para>
<db:programlisting language="cpp">class MyObject : public QObject
{
    Q_OBJECT
    // define the enabled property
    Q_PROPERTY( bool enabled WRITE setEnabled READ isEnabled )

public:
    MyObject( ... );

    void aNonScriptableFunction();

public slots: // these functions (slots) will be available in Qt Script
    void calculate( ... );
    void setEnabled( bool enabled );
    bool isEnabled() const;

signals: // the signals
    void enabledChanged( bool newState );

private:
   ....

};
</db:programlisting>
<db:para>The only change we have made to the code in the previous section is to declare a signals section with the relevant signal. Now, the script writer can define a function and connect to the object like this:</db:para>
<db:programlisting language="cpp">function enabledChangedHandler( b )
{
    print( &quot;state changed to: &quot; + b );
}

function init()
{
    var obj = new MyObject();
    // connect a script function to the signal
    obj[&quot;enabledChanged(bool)&quot;].connect(enabledChangedHandler);
    obj.enabled = true;
    print( &quot;obj is enabled: &quot; + obj.enabled );
}
</db:programlisting>
</db:section>
<db:section xml:id="design-of-application-objects">
<db:title>Design of Application Objects</db:title>
<db:para>The previous section described how to implement C++ objects which can be used in Qt Script. Application objects are the same kind of objects, and they make your application's functionality available to Qt Script scripters. Since the C++ application is already written in Qt, many objects are already QObjects. The easiest approach would be to simply add all these QObjects as application objects to the scripting engine. For small applications this might be sufficient, but for larger applications this is probably not the right approach. The problem is that this method reveals too much of the internal API and gives script programmers access to application internals which should not be exposed.</db:para>
<db:para>Generally, the best way of making application functionality available to scripters is to code some QObjects which define the applications public API using signals, slots, and properties. This gives you complete control of the functionality made available by the application. The implementations of these objects simply call the functions in the application which do the real work. So, instead of making all your QObjects available to the scripting engine, just add the wrapper QObjects.</db:para>
<db:section xml:id="returning-qobject-pointers">
<db:title>Returning QObject Pointers</db:title>
<db:para>If you have a slot that returns a <db:link xlink:href="qobject.xml">QObject</db:link> pointer, you should note that, by default, Qt Script only handles conversion of the types <db:link xlink:href="qobject.xml">QObject</db:link>* and <db:link xlink:href="qwidget.xml">QWidget</db:link>*. This means that if your slot is declared with a signature like &quot;MyObject* getMyObject()&quot;, Qt Script doesn't automatically know that MyObject* should be handled in the same way as <db:link xlink:href="qobject.xml">QObject</db:link>* and <db:link xlink:href="qwidget.xml">QWidget</db:link>*. The simplest way to solve this is to only use <db:link xlink:href="qobject.xml">QObject</db:link>* and <db:link xlink:href="qwidget.xml">QWidget</db:link>* in the method signatures of your scripting interface.</db:para>
<db:para>Alternatively, you can register conversion functions for your custom type with the qScriptRegisterMetaType() function. In this way, you can preserve the precise typing in your C++ declarations, while still allowing pointers to your custom objects to flow seamlessly between C++ and scripts. Example:</db:para>
<db:programlisting language="cpp">class MyObject : public QObject
{
    Q_OBJECT
    ...
};

Q_DECLARE_METATYPE(MyObject*)

QScriptValue myObjectToScriptValue(QScriptEngine *engine, MyObject* const &amp;in)
{ return engine-&gt;newQObject(in); }

void myObjectFromScriptValue(const QScriptValue &amp;object, MyObject* &amp;out)
{ out = qobject_cast&lt;MyObject*&gt;(object.toQObject()); }

...

qScriptRegisterMetaType(&amp;engine, myObjectToScriptValue, myObjectFromScriptValue);
</db:programlisting>
</db:section>
</db:section>
</db:section>
<db:section xml:id="function-objects-and-native-functions">
<db:title>Function Objects and Native Functions</db:title>
<db:para>In Qt Script, functions are first-class values; they are objects that can have properties of their own, just like any other type of object. They can be stored in variables and passed as arguments to other functions. Knowing how function calls in Qt Script behave is useful when you want to define and use your own script functions. This section discusses this matter, and also explains how you can implement native functions; that is, Qt Script functions written in C++, as opposed to functions written in the scripting language itself. Even if you will be relying mostly on the dynamic <db:link xlink:href="qobject.xml">QObject</db:link> binding that Qt Script provides, knowing about these powerful concepts and techniques is important to understand what's actually going on when script functions are executed.</db:para>
<db:section xml:id="calling-a-qt-script-function-from-c">
<db:title>Calling a Qt Script Function from C++</db:title>
<db:para>Calling a Qt Script function from C++ is achieved with the <db:link xlink:href="qscriptvalue.xml#call">QScriptValue::call</db:link>() function. A typical scenario is that you evaluate a script that defines a function, and at some point you want to call that function from C++, perhaps passing it some arguments, and then handle the result. The following script defines a Qt Script object that has a toKelvin() function:</db:para>
<db:programlisting language="cpp">({ unitName: &quot;Celsius&quot;,
   toKelvin: function(x) { return x + 273; }
 })
</db:programlisting>
<db:para>The toKelvin() function takes a temperature in Kelvin as argument, and returns the temperature converted to Celsius. The following snippet shows how the toKelvin() function might be obtained and called from C++:</db:para>
<db:programlisting language="cpp">QScriptValue object = engine.evaluate(&quot;({ unitName: 'Celsius', toKelvin: function(x) { return x + 273; } })&quot;);
QScriptValue toKelvin = object.property(&quot;toKelvin&quot;);
QScriptValue result = toKelvin.call(object, QScriptValueList() &lt;&lt; 100);
qDebug() &lt;&lt; result.toNumber(); // 373
</db:programlisting>
<db:para>If a script defines a global function, you can access the function as a property of <db:link xlink:href="qscriptengine.xml#globalObject">QScriptEngine::globalObject</db:link>(). For example, the following script defines a global function add():</db:para>
<db:programlisting language="cpp">function add(a, b) {
    return a + b;
}
</db:programlisting>
<db:para>C++ code might call the add() function as follows:</db:para>
<db:programlisting language="cpp">QScriptValue add = engine.globalObject().property(&quot;add&quot;);
qDebug() &lt;&lt; add.call(QScriptValue(), QScriptValueList() &lt;&lt; 1 &lt;&lt; 2).toNumber(); // 3
</db:programlisting>
<db:para>As already mentioned, functions are just values in Qt Script; a function by itself is not &quot;tied to&quot; a particular object. This is why you have to specify a <db:code>this</db:code> object (the first argument to <db:link xlink:href="qscriptvalue.xml#call">QScriptValue::call</db:link>()) that the function should be applied to.</db:para>
<db:para>If the function is supposed to act as a method (i.e. it can only be applied to a certain class of objects), it is up to the function itself to check that it is being called with a compatible <db:code>this</db:code> object.</db:para>
<db:para>Passing an invalid <db:link xlink:href="qscriptvalue.xml">QScriptValue</db:link> as the <db:code>this</db:code> argument to <db:link xlink:href="qscriptvalue.xml#call">QScriptValue::call</db:link>() indicates that the Global Object should be used as the <db:code>this</db:code> object; in other words, that the function should be invoked as a global function.</db:para>
</db:section>
<db:section xml:id="the-keyword-this-keyword-object">
<db:title>The <db:code>this</db:code> Object</db:title>
<db:para>When a Qt Script function is invoked from a script, the <db:emphasis>way</db:emphasis> in which it is invoked determines the <db:code>this</db:code> object when the function body is executed, as the following script example illustrates:</db:para>
<db:programlisting language="cpp">var getProperty = function(name) { return this[name]; };

name = &quot;Global Object&quot;; // creates a global variable
print(getProperty(&quot;name&quot;)); // &quot;Global Object&quot;

var myObject = { name: 'My Object' };
print(getProperty.call(myObject, &quot;name&quot;)); // &quot;My Object&quot;

myObject.getProperty = getProperty;
print(myObject.getProperty(&quot;name&quot;)); // &quot;My Object&quot;

getProperty.name = &quot;The getProperty() function&quot;;
getProperty.getProperty = getProperty;
getProperty.getProperty(&quot;name&quot;); // &quot;The getProperty() function&quot;
</db:programlisting>
<db:para>An important thing to note is that in Qt Script, unlike C++ and Java, the <db:code>this</db:code> object is not part of the execution scope. This means that member functions (i.e., functions that operate on <db:code>this</db:code>) must always use the <db:code>this</db:code> keyword to access the object's properties. For example, the following script probably doesn't do what you want:</db:para>
<db:programlisting language="cpp">var o = { a: 1, b: 2, sum: function() { return a + b; } };
print(o.sum()); // reference error, or sum of global variables a and b!!
</db:programlisting>
<db:para>You will get a reference error saying that 'a is not defined' or, worse, two totally unrelated global variables <db:code>a</db:code> and <db:code>b</db:code> will be used to perform the computation, if they exist. Instead, the script should look like this:</db:para>
<db:programlisting language="cpp">var o = { a: 1, b: 2, sum: function() { return this.a + this.b; } };
print(o.sum()); // 3
</db:programlisting>
<db:para>Accidentally omitting the <db:code>this</db:code> keyword is a typical source of error for programmers who are used to the scoping rules of C++ and Java.</db:para>
</db:section>
<db:section xml:id="wrapping-a-native-function">
<db:title>Wrapping a Native Function</db:title>
<db:para>Qt Script provides <db:link xlink:href="qscriptengine.xml#newFunction">QScriptEngine::newFunction</db:link>() as a way of wrapping a C++ function pointer; this enables you to implement a function in C++ and add it to the script environment, so that scripts can invoke your function as if it were a &quot;normal&quot; script function. Here is how the previous <db:code>getProperty()</db:code> function can be written in C++:</db:para>
<db:programlisting language="cpp">QScriptValue getProperty(QScriptContext *ctx, QScriptEngine *eng)
{
    QString name = ctx-&gt;argument(0).toString();
    return ctx-&gt;thisObject().property(name);
}
</db:programlisting>
<db:para>Call <db:link xlink:href="qscriptengine.xml#newFunction">QScriptEngine::newFunction</db:link>() to wrap the function. This will produce a special type of function object that carries a pointer to the C++ function internally. Once the resulting wrapper has been added to the scripting environment (e.g., by setting it as a property of the Global Object), scripts can call the function without having to know nor care that it is, in fact, a native function.</db:para>
<db:para>Note that the name of the C++ function doesn't matter in the scripting sense; the name by which the function is invoked by scripts depends only on what you call the script object property in which you store the function wrapper.</db:para>
<db:para>It is currently not possible to wrap member functions; i.e., methods of a C++ class that require a <db:code>this</db:code> object.</db:para>
</db:section>
<db:section xml:id="the-qscriptcontext-object">
<db:title>The QScriptContext Object</db:title>
<db:para>A <db:link xlink:href="qscriptcontext.xml">QScriptContext</db:link> holds all the state associated with a particular invocation of your function. Through the <db:link xlink:href="qscriptcontext.xml">QScriptContext</db:link>, you can:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para>Get the arguments that were passed to the function.</db:para>
</db:listitem>
<db:listitem>
<db:para>Get the <db:code>this</db:code> object.</db:para>
</db:listitem>
<db:listitem>
<db:para>Find out whether the function was called with the <db:code>new</db:code> operator (the significance of this will be explained later).</db:para>
</db:listitem>
<db:listitem>
<db:para>Throw a script error.</db:para>
</db:listitem>
<db:listitem>
<db:para>Get the function object that's being invoked.</db:para>
</db:listitem>
<db:listitem>
<db:para>Get the activation object (the object used to hold local variables).</db:para>
</db:listitem>
</db:itemizedlist>
<db:para>The following sections explain how to make use of this functionality.</db:para>
</db:section>
<db:section xml:id="processing-function-arguments">
<db:title>Processing Function Arguments</db:title>
<db:para>Two things are worth noting about function arguments:</db:para>
<db:orderedlist numeration="arabic">
<db:listitem>
<db:para>Any script function  including native functions  can be invoked with any number of arguments. This means that it is up to the function itself to check the argument count if necessary, and act accordingly (e.g., throw an error if the number of arguments is too large, or prepare a default value if the number is too small).</db:para>
</db:listitem>
<db:listitem>
<db:para>A value of any type can be supplied as an argument to any function. This means that it is up to you to check the type of the arguments if necessary, and act accordingly (e.g., throw an error if an argument is not an object of a certain type).</db:para>
</db:listitem>
</db:orderedlist>
<db:para>In summary: Qt Script does not automatically enforce any constraints on the number or type of arguments involved in a function call.</db:para>
<db:section xml:id="formal-parameters-and-the-arguments-object">
<db:title>Formal Parameters and the Arguments Object</db:title>
<db:para>A native Qt Script function is analogous to a script function that defines no formal parameters and only uses the built-in <db:code>arguments</db:code> variable to process its arguments. To see this, let's first consider how a script would normally define an <db:code>add()</db:code> function that takes two arguments, adds them together and returns the result:</db:para>
<db:programlisting language="cpp">function add(a, b) {
    return a + b;
}
</db:programlisting>
<db:para>When a script function is defined with formal parameters, their names can be viewed as mere aliases of properties of the <db:code>arguments</db:code> object; for example, in the <db:code>add(a, b)</db:code> definition's function body, <db:code>a</db:code> and <db:code>arguments[0]</db:code> refer to the same variable. This means that the <db:code>add()</db:code> function can equivalently be written like this:</db:para>
<db:programlisting language="cpp">function add() {
    return arguments[0] + arguments[1];
}
</db:programlisting>
<db:para>This latter form closely matches what a native implementation typically looks like:</db:para>
<db:programlisting language="cpp">QScriptValue add(QScriptContext *ctx, QScriptEngine *eng)
{
    double a = ctx-&gt;argument(0).toNumber();
    double b = ctx-&gt;argument(1).toNumber();
    return a + b;
}
</db:programlisting>
</db:section>
<db:section xml:id="checking-the-number-of-arguments">
<db:title>Checking the Number of Arguments</db:title>
<db:para>Again, remember that the presence (or lack) of formal parameter names in a function definition does not affect how the function may be invoked; <db:code>add(1, 2, 3)</db:code> is allowed by the engine, as is <db:code>add(42)</db:code>. In the case of the <db:code>add()</db:code> function, the function really needs two arguments in order to do something useful. This can be expressed by the script definition as follows:</db:para>
<db:programlisting language="cpp">function add() {
    if (arguments.length != 2)
        throw Error(&quot;add() takes exactly two arguments&quot;);
    return arguments[0] + arguments[1];
}
</db:programlisting>
<db:para>This would result in an error being thrown if a script invokes <db:code>add()</db:code> with anything other than two arguments. The native function can be modified to perform the same check:</db:para>
<db:programlisting language="cpp">QScriptValue add(QScriptContext *ctx, QScriptEngine *eng)
{
    if (ctx-&gt;argumentCount() != 2)
        return ctx-&gt;throwError(&quot;add() takes exactly two arguments&quot;);
    double a = ctx-&gt;argument(0).toNumber();
    double b = ctx-&gt;argument(1).toNumber();
    return a + b;
}
</db:programlisting>
</db:section>
<db:section xml:id="checking-the-types-of-arguments">
<db:title>Checking the Types of Arguments</db:title>
<db:para>In addition to expecting a certain number of arguments, a function might expect that those arguments are of certain types (e.g., that the first argument is a number and that the second is a string). Such a function should explicitly check the type of arguments and/or perform a conversion, or throw an error if the type of an argument is incompatible.</db:para>
<db:para>As it is, the native implementation of <db:code>add()</db:code> shown above doesn't have the exact same semantics as the script counterpart; this is because the behavior of the Qt Script <db:code>+</db:code> operator depends on the types of its operands (for example, if one of the operands is a string, string concatenation is performed). To give the script function stricter semantics (namely, that it should only add numeric operands), the argument types can be tested:</db:para>
<db:programlisting language="cpp">function add() {
    if (arguments.length != 2)
        throw Error(&quot;add() takes exactly two arguments&quot;);
    if (typeof arguments[0] != &quot;number&quot;)
        throw TypeError(&quot;add(): first argument is not a number&quot;);
    if (typeof arguments[1] != &quot;number&quot;)
        throw TypeError(&quot;add(): second argument is not a number&quot;);
    return arguments[0] + arguments[1];
}
</db:programlisting>
<db:para>Then an invocation like <db:code>add(&quot;foo&quot;, new Array())</db:code> will cause an error to be thrown.</db:para>
<db:para>The C++ version can call <db:link xlink:href="qscriptvalue.xml#isNumber">QScriptValue::isNumber</db:link>() to perform similar tests:</db:para>
<db:programlisting language="cpp">QScriptValue add(QScriptContext *ctx, QScriptEngine *eng)
{
    if (ctx-&gt;argumentCount() != 2)
        return ctx-&gt;throwError(&quot;add() takes exactly two arguments&quot;);
    if (!ctx-&gt;argument(0).isNumber())
        return ctx-&gt;throwError(QScriptContext::TypeError, &quot;add(): first argument is not a number&quot;);
    if (!ctx-&gt;argument(1).isNumber())
        return ctx-&gt;throwError(QScriptContext::TypeError, &quot;add(): second argument is not a number&quot;);
    double a = ctx-&gt;argument(0).toNumber();
    double b = ctx-&gt;argument(1).toNumber();
    return a + b;
}
</db:programlisting>
<db:para>A less strict script implementation might settle for performing an explicit to-number conversion before applying the <db:code>+</db:code> operator:</db:para>
<db:programlisting language="cpp">function add() {
    if (arguments.length != 2)
        throw Error(&quot;add() takes exactly two arguments&quot;);
    return Number(arguments[0]) + Number(arguments[1]);
}
</db:programlisting>
<db:para>In a native implementation, this is equivalent to calling <db:link xlink:href="qscriptvalue.xml#toNumber">QScriptValue::toNumber</db:link>() without performing any type test first, since <db:link xlink:href="qscriptvalue.xml#toNumber">QScriptValue::toNumber</db:link>() will automatically perform a type conversion if necessary.</db:para>
<db:para>To check if an argument is of a certain object type (class), scripts can use the <db:code>instanceof</db:code> operator (e.g., <db:code>&quot;arguments[0] instanceof Array&quot;</db:code> evaluates to true if the first argument is an Array object); native functions can call <db:link xlink:href="qscriptvalue.xml#instanceOf">QScriptValue::instanceOf</db:link>().</db:para>
<db:para>To check if an argument is of a custom C++ type, you typically use <db:link xlink:href="qscriptvalue.xml#qscriptvalue_cast">qscriptvalue_cast</db:link>() and check if the result is valid. For object types, this means casting to a pointer and checking if it is non-zero; for value types, the class should have an <db:code>isNull()</db:code>, <db:code>isValid()</db:code> or similar method. Alternatively, since most custom types are transported in <db:link xlink:href="qvariant.xml">QVariant</db:link>s, you can check if the script value is a <db:link xlink:href="qvariant.xml">QVariant</db:link> using <db:link xlink:href="qscriptvalue.xml#isVariant">QScriptValue::isVariant</db:link>(), and then check if the <db:link xlink:href="qvariant.xml">QVariant</db:link> can be converted to your type using <db:link xlink:href="qvariant.xml#canConvert">QVariant::canConvert</db:link>().</db:para>
</db:section>
<db:section xml:id="functions-with-variable-numbers-of-arguments">
<db:title>Functions with Variable Numbers of Arguments</db:title>
<db:para>Because of the presence of the built-in <db:code>arguments</db:code> object, implementing functions that take a variable number of arguments is simple. In fact, as we have seen, in the technical sense <db:emphasis>all</db:emphasis> Qt Script functions can be seen as variable-argument functions. As an example, consider a concat() function that takes an arbitrary number of arguments, converts the arguments to their string representation and concatenates the results; for example, <db:code>concat(&quot;Qt&quot;, &quot; &quot;, &quot;Script &quot;, 101)</db:code> would return &quot;Qt Script 101&quot;. A script definition of <db:code>concat()</db:code> might look like this:</db:para>
<db:programlisting language="cpp">function concat() {
    var result = &quot;&quot;;
    for (var i = 0; i &lt; arguments.length; ++i)
        result += String(arguments[i]);
    return result;
}
</db:programlisting>
<db:para>Here is an equivalent native implementation:</db:para>
<db:programlisting language="cpp">QScriptValue concat(QScriptContext *ctx, QScriptEngine *eng)
{
    QString result = &quot;&quot;;
    for (int i = 0; i &lt; ctx-&gt;argumentCount(); ++i)
        result += ctx-&gt;argument(i).toString();
    return result;
}
</db:programlisting>
<db:para>A second use case for a variable number of arguments is to implement optional arguments. Here's how a script definition typically does it:</db:para>
<db:programlisting language="cpp">function sort(comparefn) {
    if (comparefn == undefined)
        comparefn = fn; /* replace fn with the built-in comparison function */
    else if (typeof comparefn != &quot;function&quot;)
        throw TypeError(&quot;sort(): argument must be a function&quot;);
    // ...
}
</db:programlisting>
<db:para>And here's the native equivalent:</db:para>
<db:programlisting language="cpp">QScriptValue sort(QScriptContext *ctx, QScriptEngine *eng)
{
    QScriptValue comparefn = ctx-&gt;argument(0);
    if (comparefn.isUndefined())
        comparefn = /* the built-in comparison function */;
    else if (!comparefn.isFunction())
        return ctx-&gt;throwError(QScriptContext::TypeError, &quot;sort(): argument is not a function&quot;);
    ...
}
</db:programlisting>
<db:para>A third use case for a variable number of arguments is to simulate C++ overloads. This involves checking the number of arguments and/or their type at the beginning of the function body (as already shown), and acting accordingly. It might be worth thinking twice before doing this, and instead favor unique function names; e.g., having separate <db:code>processNumber(number)</db:code> and <db:code>processString(string)</db:code> functions rather than a generic <db:code>process(anything)</db:code> function. On the caller side, this makes it harder for scripts to accidentally call the wrong overload (since they don't know or don't comprehend your custom sophisticated overloading resolution rules), and on the callee side, you avoid the need for potentially complex (read: error-prone) checks to resolve ambiguity.</db:para>
</db:section>
<db:section xml:id="accessing-the-arguments-object">
<db:title>Accessing the Arguments Object</db:title>
<db:para>Most native functions use the <db:link xlink:href="qscriptcontext.xml#argument">QScriptContext::argument</db:link>() function to access function arguments. However, it is also possible to access the built-in <db:code>arguments</db:code> object itself (the one referred to by the <db:code>arguments</db:code> variable in script code), by calling the <db:link xlink:href="qscriptcontext.xml#argumentsObject">QScriptContext::argumentsObject</db:link>() function. This has three principal applications:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para>The <db:code>arguments</db:code> object can be used to easily forward a function call to another function. In script code, this is what it typically looks like:</db:para>
<db:programlisting language="cpp">function foo() {
    // Let bar() take care of this.
    print(&quot;calling bar() with &quot; + arguments.length + &quot;arguments&quot;);
    var result = bar.apply(this, arguments);
    print(&quot;bar() returned&quot; + result);
    return result;
}
</db:programlisting>
<db:para>For example, <db:code>foo(10, 20, 30)</db:code> would result in the <db:code>foo()</db:code> function executing the equivalent of <db:code>bar(10, 20, 30)</db:code>. This is useful if you want to perform some special pre- or post-processing when calling a function (e.g., to log the call to <db:code>bar()</db:code> without having to modify the <db:code>bar()</db:code> function itself, like the above example), or if you want to call a &quot;base implementation&quot; from a prototype function that has the exact same &quot;signature&quot;. In C++, the forwarding function might look like this:</db:para>
<db:programlisting language="cpp">QScriptValue foo(QScriptContext *ctx, QScriptEngine *eng)
{
    QScriptValue bar = eng-&gt;globalObject().property(&quot;bar&quot;);
    QScriptValue arguments = ctx-&gt;argumentsObject();
    qDebug() &lt;&lt; &quot;calling bar() with&quot; &lt;&lt; arguments.property(&quot;length&quot;).toInt32() &lt;&lt; &quot;arguments&quot;;
    QScriptValue result = bar.apply(ctx-&gt;thisObject(), arguments);
    qDebug() &lt;&lt; &quot;bar() returned&quot; &lt;&lt; result.toString();
    return result;
}
</db:programlisting>
</db:listitem>
<db:listitem>
<db:para>The arguments object can serve as input to a <db:link xlink:href="qscriptvalueiterator.xml">QScriptValueIterator</db:link>, providing a generic way to iterate over the arguments. A debugger might use this to display the arguments object in a general purpose &quot;Qt Script Object Explorer&quot;, for example.</db:para>
</db:listitem>
<db:listitem>
<db:para>The arguments object can be serialized (e.g., with JSON) and transferred to another entity (e.g., a script engine running in another thread), where the object can be deserialized and passed as argument to another script function.</db:para>
</db:listitem>
</db:itemizedlist>
</db:section>
</db:section>
<db:section xml:id="constructor-functions">
<db:title>Constructor Functions</db:title>
<db:para>Some script functions are constructors; they are expected to initialize new objects. The following snippet is a small example:</db:para>
<db:programlisting language="cpp">function Book(isbn) {
    this.isbn = isbn;
}

var coolBook1 = new Book(&quot;978-0131872493&quot;);
var coolBook2 = new Book(&quot;978-1593271473&quot;);
</db:programlisting>
<db:para>There is nothing special about constructor functions. In fact, any script function can act as a constructor function (i.e., any function can serve as the operand to <db:code>new</db:code>). Some functions behave differently depending on whether they are called as part of a <db:code>new</db:code> expression or not; for example, the expression <db:code>new Number(1)</db:code> will create a Number object, whereas <db:code>Number(&quot;123&quot;)</db:code> will perform a type conversion. Other functions, like <db:code>Array()</db:code>, will always create and initialize a new object (e.g., <db:code>new Array()</db:code> and <db:code>Array()</db:code> have the same effect).</db:para>
<db:para>A native Qt Script function can call the <db:link xlink:href="qscriptcontext.xml#isCalledAsConstructor">QScriptContext::isCalledAsConstructor</db:link>() function to determine if it is being called as a constructor or as a regular function. When a function is called as a constructor (i.e., it is the operand in a <db:code>new</db:code> expression), this has two important implications:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para>The <db:code>this</db:code> object, <db:link xlink:href="qscriptcontext.xml#thisObject">QScriptContext::thisObject</db:link>(), contains the new object to be initialized; the engine creates this new object automatically before invoking your function. This means that your native constructor function normally doesn't have to (and shouldn't) create a new object when it is called as a constructor, since the engine has already prepared a new object. Instead your function should operate on the supplied <db:code>this</db:code> object.</db:para>
</db:listitem>
<db:listitem>
<db:para>The constructor function should return an undefined value, <db:link xlink:href="qscriptengine.xml#undefinedValue">QScriptEngine::undefinedValue</db:link>(), to tell the engine that the <db:code>this</db:code> object should be the final result of the <db:code>new</db:code> operator. Alternatively, the function can return the <db:code>this</db:code> object itself.</db:para>
</db:listitem>
</db:itemizedlist>
<db:para>When <db:link xlink:href="qscriptcontext.xml#isCalledAsConstructor">QScriptContext::isCalledAsConstructor</db:link>() returns false, how your constructor handles this case depends on what behavior you desire. If, like the built-in <db:code>Number()</db:code> function, a plain function call should perform a type conversion of its argument, then you perform the conversion and return the result. If, on the other hand, you want your constructor to behave <db:emphasis>as if it was called as a constructor</db:emphasis> (with <db:code>new</db:code>), you have to explicitly create a new object (that is, ignore the <db:code>this</db:code> object), initialize that object, and return it.</db:para>
<db:para>The following example implements a constructor function that always creates and initializes a new object:</db:para>
<db:programlisting language="cpp">QScriptValue Person_ctor(QScriptContext *ctx, QScriptEngine *eng)
{
    QScriptValue object;
    if (ctx-&gt;isCalledAsConstructor()) {
        object = ctx-&gt;thisObject();
    } else {
        object = eng-&gt;newObject();
        object.setPrototype(ctx-&gt;callee().property(&quot;prototype&quot;));
    }
    object.setProperty(&quot;name&quot;, ctx-&gt;argument(0));
    return object;
}
</db:programlisting>
<db:para>Given this constructor, scripts would be able to use either the expression <db:code>new Person(&quot;Bob&quot;)</db:code> or <db:code>Person(&quot;Bob&quot;)</db:code> to create a new <db:code>Person</db:code> object; both behave in the same way.</db:para>
<db:para>There is no equivalent way for a function defined in script code to determine whether or not it was invoked as a constructor.</db:para>
<db:para>Note that, even though it is not considered good practice, there is nothing that stops you from choosing to ignore the default constructed (<db:code>this</db:code>) object when your function is called as a constructor and creating your own object anyway; simply have the constructor return that object. The object will &quot;override&quot; the default object that the engine constructed (i.e., the default object will simply be discarded internally).</db:para>
</db:section>
<db:section xml:id="associating-data-with-a-function">
<db:title>Associating Data with a Function</db:title>
<db:para>Even if a function is global  i.e., not associated with any particular (type of) object  you might still want to associate some data with it, so that it becomes self-contained; for example, the function could have a pointer to some C++ resource that it needs to access. If your application only uses a single script engine, or the same C++ resource can/should be shared among all script engines, you can simply use a static C++ variable and access it from within the native Qt Script function.</db:para>
<db:para>In the case where a static C++ variable or singleton class is not appropriate, you can call <db:link xlink:href="qscriptvalue.xml#setProperty">QScriptValue::setProperty</db:link>() on the function object, but be aware that those properties will also be accessible to script code. The alternative is to use <db:link xlink:href="qscriptvalue.xml#setData">QScriptValue::setData</db:link>(); this data is not script-accessible. The implementation can access this internal data through the <db:link xlink:href="qscriptcontext.xml#callee">QScriptContext::callee</db:link>() function, which returns the function object being invoked. The following example shows how this might be used:</db:para>
<db:programlisting language="cpp">QScriptValue rectifier(QScriptContext *ctx, QScriptEngine *eng)
{
    QRectF magicRect = qscriptvalue_cast&lt;QRectF&gt;(ctx-&gt;callee().data());
    QRectF sourceRect = qscriptvalue_cast&lt;QRectF&gt;(ctx-&gt;argument(0));
    return eng-&gt;toScriptValue(sourceRect.intersected(magicRect));
}

...

QScriptValue fun = eng.newFunction(rectifier);
QRectF magicRect = QRectF(10, 20, 30, 40);
fun.setData(eng.toScriptValue(magicRect));
eng.globalObject().setProperty(&quot;rectifier&quot;, fun);
</db:programlisting>
</db:section>
<db:section xml:id="native-functions-as-arguments-to-functions">
<db:title>Native Functions as Arguments to Functions</db:title>
<db:para>As previously mentioned, a function object can be passed as argument to another function; this is also true for native functions, naturally. As an example, here's a native comparison function that compares its two arguments numerically:</db:para>
<db:programlisting language="cpp">QScriptValue myCompare(QScriptContext *ctx, QScriptEngine *eng)
{
    double first = ctx-&gt;argument(0).toNumber();
    double second = ctx-&gt;argument(1).toNumber();
    int result;
    if (first == second)
        result = 0;
    else if (first &lt; second)
        result = -1;
    else
        result = 1;
    return result;
}
</db:programlisting>
<db:para>The above function can be passed as argument to the standard <db:code>Array.prototype.sort</db:code> function to sort an array numerically, as the following C++ code illustrates:</db:para>
<db:programlisting language="cpp">QScriptEngine eng;
QScriptValue comparefn = eng.newFunction(myCompare);
QScriptValue array = eng.evaluate(&quot;new Array(10, 5, 20, 15, 30)&quot;);
array.property(&quot;sort&quot;).call(array, QScriptValueList() &lt;&lt; comparefn);

// prints &quot;5,10,15,20,30&quot;
qDebug() &lt;&lt; array.toString();
</db:programlisting>
<db:para>Note that, in this case, we are truly treating the native function object as a value  i.e., we don't store it as a property of the scripting environment  we simply pass it on as an &quot;anonymous&quot; argument to another script function and then forget about it.</db:para>
</db:section>
<db:section xml:id="the-activation-object">
<db:title>The Activation Object</db:title>
<db:para>Every Qt Script function invocation has an <db:emphasis>activation object</db:emphasis> associated with it; this object is accessible through the <db:link xlink:href="qscriptcontext.xml#activationObject">QScriptContext::activationObject</db:link>() function. The activation object is a script object whose properties are the local variables associated with the invocation (including the arguments for which the script function has a corresponding formal parameter name). Thus, getting, modifying, creating and deleting local variables from C++ is done using the regular <db:link xlink:href="qscriptvalue.xml#property">QScriptValue::property</db:link>() and <db:link xlink:href="qscriptvalue.xml#setProperty">QScriptValue::setProperty</db:link>() functions. The activation object itself is not directly accessible from script code (but it is implicitly accessed whenever a local variable is read from or written to).</db:para>
<db:para>For C++ code, there are two principal applications of the activation object:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para>The activation object provides a standard way to traverse the variables associated with a function call, by using it as the input to <db:link xlink:href="qscriptvalueiterator.xml">QScriptValueIterator</db:link>. This is useful for debugging purposes.</db:para>
</db:listitem>
<db:listitem>
<db:para>The activation object can be used to prepare local variables that should be available when a script is evaluated inline; this can be viewed as a way of passing arguments to the script itself. This technique is typically used in conjunction with <db:link xlink:href="qscriptengine.xml#pushContext">QScriptEngine::pushContext</db:link>(), as in the following example:</db:para>
<db:programlisting language="cpp">QScriptContext *ctx = eng.pushContext();
QScriptValue act = ctx-&gt;activationObject();
act.setProperty(&quot;digit&quot;, 7);

qDebug() &lt;&lt; eng.evaluate(&quot;digit + 1&quot;).toNumber(); // 8

eng.popContext();
</db:programlisting>
<db:para>We create a temporary execution context, create a local variable for it, evaluate the script, and finally restore the old context.</db:para>
</db:listitem>
</db:itemizedlist>
</db:section>
<db:section xml:id="property-getters-and-setters">
<db:title>Property Getters and Setters</db:title>
<db:para>A script object property can be defined in terms of a getter/setter function, similar to how a Qt C++ property has read and write functions associated with it. This makes it possible for a script to use expressions like <db:code>object.x</db:code> instead of <db:code>object.getX()</db:code>; the getter/setter function for <db:code>x</db:code> will implicitly be invoked whenever the property is accessed. To scripts, the property looks and behaves just like a regular object property.</db:para>
<db:para>A single Qt Script function can act as both getter and setter for a property. When it is called as a getter, the argument count is 0. When it is called as a setter, the argument count is 1; the argument is the new value of the property. In the following example, we define a native combined getter/setter that transforms the value slightly:</db:para>
<db:programlisting language="cpp">QScriptValue getSet(QScriptContext *ctx, QScriptEngine *eng)
{
    QScriptValue obj = ctx-&gt;thisObject();
    QScriptValue data = obj.data();
    if (!data.isValid()) {
        data = eng-&gt;newObject();
        obj.setData(data);
    }
    QScriptValue result;
    if (ctx-&gt;argumentCount() == 1) {
        QString str = ctx-&gt;argument(0).toString();
        str.replace(&quot;Roberta&quot;, &quot;Ken&quot;);
        result = str;
        data.setProperty(&quot;x&quot;, result);
    } else {
        result = data.property(&quot;x&quot;);
    }
    return result;
}
</db:programlisting>
<db:para>The example uses the internal data of the object to store and retrieve the transformed value. Alternatively, the property could be stored in another, &quot;hidden&quot; property of the object itself (e.g., <db:code>__x__</db:code>). A native function is free to implement whatever storage scheme it wants, as long as the external behavior of the property itself is consistent (e.g., that scripts should not be able to distinguish it from a regular property).</db:para>
<db:para>The following C++ code shows how an object property can be defined in terms of the native getter/setter:</db:para>
<db:programlisting language="cpp">QScriptEngine eng;
QScriptValue obj = eng.newObject();
obj.setProperty(&quot;x&quot;, eng.newFunction(getSet),
                QScriptValue::PropertyGetter|QScriptValue::PropertySetter);
</db:programlisting>
<db:para>When the property is accessed, like in the following script, the getter/setter does its job behind the scenes:</db:para>
<db:programlisting language="cpp">obj.x = &quot;Roberta sent me&quot;;
print(obj.x); // &quot;Ken sent me&quot;
obj.x = &quot;I sent the bill to Roberta&quot;;
print(obj.x); // &quot;I sent the bill to Ken&quot;
</db:programlisting>
<db:note>
<db:para>It is important that the setter function, not just the getter, returns the value of the property; i.e., the setter should <db:emphasis>not</db:emphasis> return <db:link xlink:href="qscriptvalue.xml#SpecialValue-enum">QScriptValue::UndefinedValue</db:link>. This is because the result of the property assignment is the value returned by the setter, and not the right-hand side expression. Also note that you normally should not attempt to read the same property that the getter modifies within the getter itself, since this will cause the getter to be called recursively.</db:para>
</db:note>
<db:para>You can remove a property getter/setter by calling <db:link xlink:href="qscriptvalue.xml#setProperty">QScriptValue::setProperty</db:link>(), passing an invalid <db:link xlink:href="qscriptvalue.xml">QScriptValue</db:link> as the getter/setter. Remember to specify the <db:link xlink:href="qscriptvalue.xml#PropertyFlag-enum">QScriptValue::PropertyGetter</db:link>/<db:link xlink:href="qscriptvalue.xml#PropertyFlag-enum">QScriptValue::PropertySetter</db:link> flag(s), otherwise the only thing that will happen is that the setter will be invoked with an invalid <db:link xlink:href="qscriptvalue.xml">QScriptValue</db:link> as its argument!</db:para>
<db:para>Property getters and setters can be defined and installed by script code as well, as in the following example:</db:para>
<db:programlisting language="cpp">obj = {};
obj.__defineGetter__(&quot;x&quot;, function() { return this._x; });
obj.__defineSetter__(&quot;x&quot;, function(v) { print(&quot;setting x to&quot;, v); this._x = v; });
obj.x = 123;
</db:programlisting>
<db:para>Getters and setters can only be used to implement &quot;a priori properties&quot;; i.e., the technique can't be used to react to an access to a property that the object doesn't already have. To gain total control of property access in this way, you need to subclass <db:link xlink:href="qscriptclass.xml">QScriptClass</db:link>.</db:para>
</db:section>
</db:section>
<db:section xml:id="making-use-of-prototype-based-inheritance">
<db:title>Making Use of Prototype-Based Inheritance</db:title>
<db:para>In ECMAScript, inheritance is based on the concept of <db:emphasis>shared prototype objects</db:emphasis>; this is quite different from the class-based inheritance familiar to C++ programmers. With Qt Script, you can associate a custom prototype object with a C++ type using <db:link xlink:href="qscriptengine.xml#setDefaultPrototype">QScriptEngine::setDefaultPrototype</db:link>(); this is the key to providing a script interface to that type. Since the Qt Script module is built on top of Qt's meta-type system, this can be done for any C++ type.</db:para>
<db:para>You might be wondering when exactly you would need to use this functionality in your application; isn't the automatic binding provided by <db:link xlink:href="qscriptengine.xml#newQObject">QScriptEngine::newQObject</db:link>() enough? No, not under all circumstances. Firstly, not every C++ type is derived from <db:link xlink:href="qobject.xml">QObject</db:link>; types that are not QObjects cannot be introspected through Qt's meta-object system (they do not have properties, signals and slots). Secondly, even if a type is <db:link xlink:href="qobject.xml">QObject</db:link>-derived, the functionality you want to expose to scripts might not all be available, since it is unusual to define every function to be a slot (and it's not always possible/desirable to change the C++ API to make it so).</db:para>
<db:para>It is perfectly possible to solve this problem by using &quot;conventional&quot; C++ techniques. For instance, the <db:link xlink:href="qrect.xml">QRect</db:link> class could effectively be made scriptable by creating a <db:link xlink:href="qobject.xml">QObject</db:link>-based C++ wrapper class with <db:code>x</db:code>, <db:code>y</db:code>, <db:code>width</db:code> properties and so on, which forwarded property access and function calls to the wrapped value. However, as we shall see, by taking advantage of the ECMAScript object model and combining it with Qt's meta-object system, we can arrive at a solution that is more elegant, consistent and lightweight, supported by a small API.</db:para>
<db:para>This section explains the underlying concepts of prototype-based inheritance. Once these concepts are understood, the associated practices can be applied throughout the Qt Script API in order to create well-behaved, consistent bindings to C++ that will fit nicely into the ECMAScript universe.</db:para>
<db:para>When experimenting with Qt Script objects and inheritance, it can be helpful to use the interactive interpreter included with the Qt Script examples, located in <db:code>examples/script</db:code>.</db:para>
<db:section xml:id="prototype-objects-and-shared-properties">
<db:title>Prototype Objects and Shared Properties</db:title>
<db:para>The purpose of a Qt Script <db:emphasis>prototype object</db:emphasis> is to define behavior that should be shared by a set of other Qt Script objects. We say that objects which share the same prototype object belong to the same <db:emphasis>class</db:emphasis> (again, on the technical side this should not to be confused with the class constructs of languages like C++ and Java; ECMAScript has no such construct).</db:para>
<db:para>The basic prototype-based inheritance mechanism works as follows: Each Qt Script object has an internal link to another object, its <db:emphasis>prototype</db:emphasis>. When a property is looked up in an object, and the object itself does not have the property, the property is looked up in the prototype object instead; if the prototype has the property, then that property is returned. Otherwise, the property is looked up in the prototype of the prototype object, and so on; this chain of objects constitutes a <db:emphasis>prototype chain</db:emphasis>. The chain of prototype objects is followed until the property is found or the end of the chain is reached.</db:para>
<db:para>For example, when you create a new object by the expression <db:code>new Object()</db:code>, the resulting object will have as its prototype the standard <db:code>Object</db:code> prototype, <db:code>Object.prototype</db:code>; through this prototype relation, the new object inherits a set of properties, including the <db:code>hasOwnProperty()</db:code> function and <db:code>toString()</db:code> function:</db:para>
<db:programlisting language="cpp">var o = new Object();
o.foo = 123;
print(o.hasOwnProperty('foo')); // true
print(o.hasOwnProperty('bar')); // false
print(o); // calls o.toString(), which returns &quot;[object Object]&quot;
</db:programlisting>
<db:para>The <db:code>toString()</db:code> function itself is not defined in <db:code>o</db:code> (since we did not assign anything to <db:code>o.toString</db:code>), so instead the <db:code>toString()</db:code> function in the standard <db:code>Object</db:code> prototype is called, which returns a highly generic string representation of <db:code>o</db:code> (&quot;[object Object]&quot;).</db:para>
<db:para>Note that the properties of the prototype object are not <db:emphasis>copied</db:emphasis> to the new object; only a <db:emphasis>link</db:emphasis> from the new object to the prototype object is maintained. This means that changes done to the prototype object will immediately be reflected in the behavior of all objects that have the modified object as their prototype.</db:para>
</db:section>
<db:section xml:id="defining-classes-in-a-prototype-based-universe">
<db:title>Defining Classes in a Prototype-Based Universe</db:title>
<db:para>In Qt Script, a class is not defined explicitly; there is no <db:code>class</db:code> keyword. Instead, you define a new class in two steps:</db:para>
<db:orderedlist numeration="arabic">
<db:listitem>
<db:para>Define a <db:emphasis>constructor function</db:emphasis> that will initialize new objects.</db:para>
</db:listitem>
<db:listitem>
<db:para>Set up a <db:emphasis>prototype object</db:emphasis> that defines the class interface, and assign this object to the public <db:code>prototype</db:code> property of the constructor function.</db:para>
</db:listitem>
</db:orderedlist>
<db:para>With this arrangement, the constructor's public <db:code>prototype</db:code> property will automatically be set as the prototype of objects created by applying the <db:code>new</db:code> operator to your constructor function; e.g., the prototype of an object created by <db:code>new Foo()</db:code> will be the value of <db:code>Foo.prototype</db:code>.</db:para>
<db:para>Functions that don't operate on the <db:code>this</db:code> object (&quot;static&quot; methods) are typically stored as properties of the constructor function, not as properties of the prototype object. The same is true for constants, such as enum values.</db:para>
<db:para>The following code defines a simple constructor function for a class called <db:code>Person</db:code>:</db:para>
<db:programlisting language="cpp">function Person(name)
{
  this.name = name;
}
</db:programlisting>
<db:para>Next, you want to set up <db:code>Person.prototype</db:code> as your prototype object; i.e., define the interface that should be common to all <db:code>Person</db:code> objects. Qt Script automatically creates a default prototype object (by the expression <db:code>new Object()</db:code>) for every script function; you can add properties to this object, or you can assign your own custom object. (Generally speaking, any Qt Script object can act as prototype for any other object.)</db:para>
<db:para>Here's an example of how you might want to override the <db:code>toString()</db:code> function that <db:code>Person.prototype</db:code> inherits from <db:code>Object.prototype</db:code>, to give your <db:code>Person</db:code> objects a more appropriate string representation:</db:para>
<db:programlisting language="cpp">Person.prototype.toString = function() { return &quot;Person(name: &quot; + this.name + &quot;)&quot;; }
</db:programlisting>
<db:para>This resembles the process of reimplementing a virtual function in C++. Henceforth, when the property named <db:code>toString</db:code> is looked up in a <db:code>Person</db:code> object, it will be resolved in <db:code>Person.prototype</db:code>, not in <db:code>Object.prototype</db:code> as before:</db:para>
<db:programlisting language="cpp">var p1 = new Person(&quot;John Doe&quot;);
var p2 = new Person(&quot;G.I. Jane&quot;);
print(p1); // &quot;Person(name: John Doe)&quot;
print(p2); // &quot;Person(name: G.I. Jane)&quot;
</db:programlisting>
<db:para>There are also some other interesting things we can learn about a <db:code>Person</db:code> object:</db:para>
<db:programlisting language="cpp">print(p1.hasOwnProperty('name')); // 'name' is an instance variable, so this returns true
print(p1.hasOwnProperty('toString')); // returns false; inherited from prototype
print(p1 instanceof Person); // true
print(p1 instanceof Object); // true
</db:programlisting>
<db:para>The <db:code>hasOwnProperty()</db:code> function is not inherited from <db:code>Person.prototype</db:code>, but rather from <db:code>Object.prototype</db:code>, which is the prototype of <db:code>Person.prototype</db:code> itself; i.e., the prototype chain of <db:code>Person</db:code> objects is <db:code>Person.prototype</db:code> followed by <db:code>Object.prototype</db:code>. This prototype chain establishes a <db:emphasis>class hierarchy</db:emphasis>, as demonstrated by applying the <db:code>instanceof</db:code> operator; <db:code>instanceof</db:code> checks if the value of the public <db:code>prototype</db:code> property of the constructor function on the right-hand side is reached by following the prototype chain of the object on the left-hand side.</db:para>
<db:para>When defining subclasses, there's a general pattern you can use. The following example shows how one can create a subclass of <db:code>Person</db:code> called <db:code>Employee</db:code>:</db:para>
<db:programlisting language="cpp">function Employee(name, salary)
{
  Person.call(this, name); // call base constructor

  this.salary = salary;
}

// set the prototype to be an instance of the base class
Employee.prototype = new Person();

// initialize prototype
Employee.prototype.toString = function() {
    // ...
}
</db:programlisting>
<db:para>Again, you can use the <db:code>instanceof</db:code> to verify that the class relationship between <db:code>Employee</db:code> and <db:code>Person</db:code> has been correctly established:</db:para>
<db:programlisting language="cpp">var e = new Employee(&quot;Johnny Bravo&quot;, 5000000);
print(e instanceof Employee); // true
print(e instanceof Person);   // true
print(e instanceof Object);   // true
print(e instanceof Array);    // false
</db:programlisting>
<db:para>This shows that the prototype chain of <db:code>Employee</db:code> objects is the same as that of <db:code>Person</db:code> objects, but with <db:code>Employee.prototype</db:code> added to the front of the chain.</db:para>
</db:section>
<db:section xml:id="prototype-based-programming-with-the-qt-script-c-api">
<db:title>Prototype-Based Programming with the Qt Script C++ API</db:title>
<db:para>You can use <db:link xlink:href="qscriptengine.xml#newFunction">QScriptEngine::newFunction</db:link>() to wrap native functions. When implementing a constructor function, you also pass the prototype object as an argument to <db:link xlink:href="qscriptengine.xml#newFunction">QScriptEngine::newFunction</db:link>(). You can call <db:link xlink:href="qscriptvalue.xml#construct">QScriptValue::construct</db:link>() to call a constructor function, and you can use <db:link xlink:href="qscriptvalue.xml#call">QScriptValue::call</db:link>() from within a native constructor function if you need to call a base class constructor.</db:para>
<db:para>The <db:link xlink:href="qscriptable.xml">QScriptable</db:link> class provides a convenient way to implement a prototype object in terms of C++ slots and properties. Take a look at the <db:link xlink:href="qtscript-script-defaultprototypes-example.xml">Default Prototypes Example</db:link> to see how this is done. Alternatively, the prototype functionality can be implemented in terms of standalone native functions that you wrap with <db:link xlink:href="qscriptengine.xml#newFunction">QScriptEngine::newFunction</db:link>() and set as properties of your prototype object by calling <db:link xlink:href="qscriptvalue.xml#setProperty">QScriptValue::setProperty</db:link>().</db:para>
<db:para>In the implementation of your prototype functions, you use <db:link xlink:href="qscriptable.xml#thisObject">QScriptable::thisObject</db:link>() (or <db:link xlink:href="qscriptcontext.xml#thisObject">QScriptContext::thisObject</db:link>()) to obtain a reference to the <db:link xlink:href="qscriptvalue.xml">QScriptValue</db:link> being operated upon; then you call <db:link xlink:href="qscriptvalue.xml#qscriptvalue_cast">qscriptvalue_cast</db:link>() to cast it to your C++ type, and perform the relevant operations using the usual C++ API for the type.</db:para>
<db:para>You associate a prototype object with a C++ type by calling <db:link xlink:href="qscriptengine.xml#setDefaultPrototype">QScriptEngine::setDefaultPrototype</db:link>(). Once this mapping is established, Qt Script will automatically assign the correct prototype when a value of such a type is wrapped in a <db:link xlink:href="qscriptvalue.xml">QScriptValue</db:link>; either when you explicitly call QScriptEngine::toScriptValue(), or when a value of such a type is returned from a C++ slot and internally passed back to script code by the engine. This means you <db:emphasis>don't</db:emphasis> have to implement wrapper classes if you use this approach.</db:para>
<db:para>As an example, let's consider how the <db:code>Person</db:code> class from the preceding section can be implemented in terms of the Qt Script API. We begin with the native constructor function:</db:para>
<db:programlisting language="cpp">QScriptValue Person_ctor(QScriptContext *context, QScriptEngine *engine)
{
  QString name = context-&gt;argument(0).toString();
  context-&gt;thisObject().setProperty(&quot;name&quot;, name);
  return engine-&gt;undefinedValue();
}
</db:programlisting>
<db:para>Here's the native equivalent of the <db:code>Person.prototype.toString</db:code> function we saw before:</db:para>
<db:programlisting language="cpp">QScriptValue Person_prototype_toString(QScriptContext *context, QScriptEngine *engine)
{
  QString name = context-&gt;thisObject().property(&quot;name&quot;).toString();
  QString result = QString::fromLatin1(&quot;Person(name: %0)&quot;).arg(name);
  return result;
}
</db:programlisting>
<db:para>The <db:code>Person</db:code> class can then be initialized as follows:</db:para>
<db:programlisting language="cpp">QScriptEngine engine;
QScriptValue ctor = engine.newFunction(Person_ctor);
ctor.property(&quot;prototype&quot;).setProperty(&quot;toString&quot;, engine.newFunction(Person_prototype_toString));
QScriptValue global = engine.globalObject();
global.setProperty(&quot;Person&quot;, ctor);
</db:programlisting>
<db:para>The implementation of the <db:code>Employee</db:code> subclass is similar. We use <db:link xlink:href="qscriptvalue.xml#call">QScriptValue::call</db:link>() to call the super-class (Person) constructor:</db:para>
<db:programlisting language="cpp">QScriptValue Employee_ctor(QScriptContext *context, QScriptEngine *engine)
{
  QScriptValue super = context-&gt;callee().property(&quot;prototype&quot;).property(&quot;constructor&quot;);
  super.call(context-&gt;thisObject(), QScriptValueList() &lt;&lt; context-&gt;argument(0));
  context-&gt;thisObject().setProperty(&quot;salary&quot;, context-&gt;argument(1));
  return engine-&gt;undefinedValue();
}
</db:programlisting>
<db:para>The <db:code>Employee</db:code> class can then be initialized as follows:</db:para>
<db:programlisting language="cpp">QScriptValue empCtor = engine.newFunction(Employee_ctor);
empCtor.setProperty(&quot;prototype&quot;, global.property(&quot;Person&quot;).construct());
global.setProperty(&quot;Employee&quot;, empCtor);
</db:programlisting>
<db:para>When implementing the prototype object of a class, you may want to use the <db:link xlink:href="qscriptable.xml">QScriptable</db:link> class, as it enables you to define the API of your script class in terms of Qt properties, signals and slots, and automatically handles value conversion between the Qt Script and C++ side.</db:para>
</db:section>
<db:section xml:id="implementing-prototype-objects-for-value-based-types">
<db:title>Implementing Prototype Objects for Value-based Types</db:title>
<db:para>When implementing a prototype object for a value-based type  e.g. <db:link xlink:href="qpointf.xml">QPointF</db:link>  the same general technique applies; you populate a prototype object with functionality that should be shared among instances. You then associate the prototype object with the type by calling <db:link xlink:href="qscriptengine.xml#setDefaultPrototype">QScriptEngine::setDefaultPrototype</db:link>(). This ensures that when e.g. a value of the relevant type is returned from a slot back to the script, the prototype link of the script value will be initialized correctly.</db:para>
<db:para>When values of the custom type are stored in QVariants  which Qt Script does by default , <db:link xlink:href="qscriptvalue.xml#qscriptvalue_cast">qscriptvalue_cast</db:link>() enables you to safely cast the script value to a pointer to the C++ type. This makes it easy to do type-checking, and, for prototype functions that should modify the underlying C++ value, lets you modify the actual value contained in the script value (and not a copy of it).</db:para>
<db:programlisting language="cpp">Q_DECLARE_METATYPE(QPointF)
Q_DECLARE_METATYPE(QPointF*)

QScriptValue QPointF_prototype_x(QScriptContext *context, QScriptEngine *engine)
{
  // Since the point is not to be modified, it's OK to cast to a value here
    QPointF point = qscriptvalue_cast&lt;QPointF&gt;(context-&gt;thisObject());
    return point.x();
}

QScriptValue QPointF_prototype_setX(QScriptContext *context, QScriptEngine *engine)
{
    // Cast to a pointer to be able to modify the underlying C++ value
    QPointF *point = qscriptvalue_cast&lt;QPointF*&gt;(context-&gt;thisObject());
    if (!point)
        return context-&gt;throwError(QScriptContext::TypeError, &quot;QPointF.prototype.setX: this object is not a QPointF&quot;);
    point-&gt;setX(context-&gt;argument(0).toNumber());
    return engine-&gt;undefinedValue();
}
</db:programlisting>
</db:section>
<db:section xml:id="implementing-constructors-for-value-based-types">
<db:title>Implementing Constructors for Value-based Types</db:title>
<db:para>You can implement a constructor function for a value-based type by wrapping a native factory function. For example, the following function implements a simple constructor for <db:link xlink:href="qpoint.xml">QPoint</db:link>:</db:para>
<db:programlisting language="cpp">QScriptValue QPoint_ctor(QScriptContext *context, QScriptEngine *engine)
{
    int x = context-&gt;argument(0).toInt32();
    int y = context-&gt;argument(1).toInt32();
    return engine-&gt;toScriptValue(QPoint(x, y));
}

...

engine.globalObject().setProperty(&quot;QPoint&quot;, engine.newFunction(QPoint_ctor));
</db:programlisting>
<db:para>In the above code we simplified things a bit, e.g. we didn't check the argument count to decide which <db:link xlink:href="qpoint.xml">QPoint</db:link> C++ constructor to use. In your own constructors you have to do this type of resolution yourself, i.e. by checking the number of arguments passed to the native function, and/or by checking the type of the arguments and converting the arguments to the desired type. If you detect a problem with the arguments you may want to signal this by throwing a script exception; see <db:link xlink:href="qscriptcontext.xml#throwError">QScriptContext::throwError</db:link>().</db:para>
</db:section>
<db:section xml:id="managing-non-qobject-based-objects">
<db:title>Managing Non-QObject-based Objects</db:title>
<db:para>For value-based types (e.g. <db:link xlink:href="qpoint.xml">QPoint</db:link>), the C++ object will be destroyed when the Qt Script object is garbage-collected, so managing the memory of the C++ object is not an issue. For QObjects, Qt Script provides several alternatives for managing the underlying C++ object's lifetime; see the <db:link xlink:href="qtscript-index.xml#controlling-qobject-ownership">Controlling QObject Ownership</db:link> section. However, for polymorphic types that don't inherit from <db:link xlink:href="qobject.xml">QObject</db:link>, and when you can't (or won't) wrap the type in a <db:link xlink:href="qobject.xml">QObject</db:link>, you have to manage the lifetime of the C++ object yourself.</db:para>
<db:para>A behavior that's often reasonable when a Qt Script object wraps a C++ object, is that the C++ object is deleted when the Qt Script object is garbage-collected; this is typically the case when the objects can be constructed by scripts, as opposed to the application providing the scripts with pre-made &quot;environment&quot; objects. A way of making the lifetime of the C++ object follow the lifetime of the Qt Script object is by using a shared pointer class, such as <db:link xlink:href="qsharedpointer.xml">QSharedPointer</db:link>, to hold a pointer to your object; when the Qt Script object containing the <db:link xlink:href="qsharedpointer.xml">QSharedPointer</db:link> is garbage-collected, the underlying C++ object will be deleted if there are no other references to the object.</db:para>
<db:para>The following snippet shows a constructor function that constructs <db:link xlink:href="qxmlstreamreader.xml">QXmlStreamReader</db:link> objects that are stored using <db:link xlink:href="qsharedpointer.xml">QSharedPointer</db:link>:</db:para>
<db:programlisting language="cpp">typedef QSharedPointer&lt;QXmlStreamReader&gt; XmlStreamReaderPointer;

Q_DECLARE_METATYPE(XmlStreamReaderPointer)

QScriptValue constructXmlStreamReader(QScriptContext *context, QScriptEngine *engine)
{
    if (!context-&gt;isCalledAsConstructor())
        return context-&gt;throwError(QScriptContext::SyntaxError, &quot;please use the 'new' operator&quot;);

    QIODevice *device = qobject_cast&lt;QIODevice*&gt;(context-&gt;argument(0).toQObject());
    if (!device)
        return context-&gt;throwError(QScriptContext::TypeError, &quot;please supply a QIODevice as first argument&quot;);

    // Create the C++ object
    QXmlStreamReader *reader = new QXmlStreamReader(device);

    XmlStreamReaderPointer pointer(reader);

    // store the shared pointer in the script object that we are constructing
    return engine-&gt;newVariant(context-&gt;thisObject(), QVariant::fromValue(pointer));
}
</db:programlisting>
<db:para>Prototype functions can use <db:link xlink:href="qscriptvalue.xml#qscriptvalue_cast">qscriptvalue_cast</db:link>() to cast the <db:code>this</db:code> object to the proper type:</db:para>
<db:programlisting language="cpp">QScriptValue xmlStreamReader_atEnd(QScriptContext *context, QScriptEngine *)
{
    XmlStreamReaderPointer reader = qscriptvalue_cast&lt;XmlStreamReaderPointer&gt;(context-&gt;thisObject());
    if (!reader)
        return context-&gt;throwError(QScriptContext::TypeError, &quot;this object is not an XmlStreamReader&quot;);
    return reader-&gt;atEnd();
}
</db:programlisting>
<db:para>The prototype and constructor objects are set up in the usual way:</db:para>
<db:programlisting language="cpp">    QScriptEngine engine;
    QScriptValue xmlStreamReaderProto = engine.newObject();
    xmlStreamReaderProto.setProperty(&quot;atEnd&quot;, engine.newFunction(xmlStreamReader_atEnd));

    QScriptValue xmlStreamReaderCtor = engine.newFunction(constructXmlStreamReader, xmlStreamReaderProto);
    engine.globalObject().setProperty(&quot;XmlStreamReader&quot;, xmlStreamReaderCtor);
</db:programlisting>
<db:para>Scripts can now construct <db:link xlink:href="qxmlstreamreader.xml">QXmlStreamReader</db:link> objects by calling the <db:code>XmlStreamReader</db:code> constructor, and when the Qt Script object is garbage-collected (or the script engine is destroyed), the <db:link xlink:href="qxmlstreamreader.xml">QXmlStreamReader</db:link> object is destroyed as well.</db:para>
</db:section>
</db:section>
<db:section xml:id="defining-custom-script-classes-with-qscriptclass">
<db:title>Defining Custom Script Classes with QScriptClass</db:title>
<db:para>There are cases where neither the dynamic <db:link xlink:href="qobject.xml">QObject</db:link> binding provided by <db:link xlink:href="qscriptengine.xml#newQObject">QScriptEngine::newQObject</db:link>() or the manual binding provided by <db:link xlink:href="qscriptengine.xml#newFunction">QScriptEngine::newFunction</db:link>() is sufficient. For example, you might want to implement a dynamic script proxy to an underlying object; or you might want to implement an array-like class (i.e. that gives special treatment to properties that are valid array indexes, and to the property &quot;length&quot;). In such cases, you can subclass <db:link xlink:href="qscriptclass.xml">QScriptClass</db:link> to achieve the desired behavior.</db:para>
<db:para><db:link xlink:href="qscriptclass.xml">QScriptClass</db:link> allows you to handle all property access for a (class of) script object through virtual get/set property functions. Iteration of custom properties is also supported through the <db:link xlink:href="qscriptclasspropertyiterator.xml">QScriptClassPropertyIterator</db:link> class; this means you can advertise properties to be reported by for-in script statements and <db:link xlink:href="qscriptvalueiterator.xml">QScriptValueIterator</db:link>.</db:para>
</db:section>
<db:section xml:id="error-handling-and-debugging-facilities">
<db:title>Error Handling and Debugging Facilities</db:title>
<db:para>Syntax errors in scripts will be reported as soon as a script is evaluated; <db:link xlink:href="qscriptengine.xml#evaluate">QScriptEngine::evaluate</db:link>() will return a SyntaxError object that you can convert to a string to get a description of the error.</db:para>
<db:para>The <db:link xlink:href="qscriptengine.xml#uncaughtExceptionBacktrace">QScriptEngine::uncaughtExceptionBacktrace</db:link>() function gives you a human-readable backtrace of the last uncaught exception. In order to get useful filename information in backtraces, you should pass proper filenames to <db:link xlink:href="qscriptengine.xml#evaluate">QScriptEngine::evaluate</db:link>() when evaluating your scripts.</db:para>
<db:para>Often an exception doesn't happen at the time the script is evaluated, but at a later time when a function defined by the script is actually executed. For C++ signal handlers, this is tricky; consider the case where the clicked() signal of a button is connected to a script function, and that script function causes a script exception when it is handling the signal. Where is that script exception propagated to?</db:para>
<db:para>The solution is to connect to the <db:link xlink:href="qscriptengine.xml#signalHandlerException">QScriptEngine::signalHandlerException</db:link>() signal; this will give you notification when a signal handler causes an exception, so that you can find out what happened and/or recover from it.</db:para>
<db:para>In Qt 4.4 the <db:link xlink:href="qscriptengineagent.xml">QScriptEngineAgent</db:link> class was introduced. <db:link xlink:href="qscriptengineagent.xml">QScriptEngineAgent</db:link> provides an interface for reporting low-level &quot;events&quot; in a script engine, such as when a function is entered or when a new script statement is reached. By subclassing <db:link xlink:href="qscriptengineagent.xml">QScriptEngineAgent</db:link> you can be notified of these events and perform some action, if you want. <db:link xlink:href="qscriptengineagent.xml">QScriptEngineAgent</db:link> itself doesn't provide any debugging-specific functionality (e.g. setting breakpoints), but it is the basis of tools that do.</db:para>
<db:para>The <db:link xlink:href="qtscripttools-index.xml">Qt Script Tools</db:link> module provides a <db:link xlink:href="qtscriptdebugger-manual.xml">Qt Script debugger</db:link> that can be embedded into your application.</db:para>
<db:section xml:id="redefining-print">
<db:title>Redefining print()</db:title>
<db:para>Qt Script provides a built-in print() function that can be useful for simple debugging purposes. The built-in print() function writes to standard output. You can redefine the print() function (or add your own function, e.g. debug() or log()) that redirects the text to somewhere else. The following code shows a custom print() that adds text to a <db:link xlink:href="qplaintextedit.xml">QPlainTextEdit</db:link>.</db:para>
<db:programlisting language="cpp">QScriptValue myPrintFunction(QScriptContext *context, QScriptEngine *engine)
{
    QString result;
    for (int i = 0; i &lt; context-&gt;argumentCount(); ++i) {
        if (i &gt; 0)
            result.append(&quot; &quot;);
        result.append(context-&gt;argument(i).toString());
    }

    QScriptValue calleeData = context-&gt;callee().data();
    QPlainTextEdit *edit = qobject_cast&lt;QPlainTextEdit*&gt;(calleeData.toQObject());
    edit-&gt;appendPlainText(result);

    return engine-&gt;undefinedValue();
}
</db:programlisting>
<db:para>The following code shows how the custom print() function may be initialized and used.</db:para>
<db:programlisting language="cpp">int main(int argc, char **argv)
{
    QApplication app(argc, argv);

    QScriptEngine eng;
    QPlainTextEdit edit;

    QScriptValue fun = eng.newFunction(myPrintFunction);
    fun.setData(eng.newQObject(&amp;edit));
    eng.globalObject().setProperty(&quot;print&quot;, fun);

    eng.evaluate(&quot;print('hello', 'world')&quot;);

    edit.show();
    return app.exec();
}
</db:programlisting>
<db:para>A pointer to the <db:link xlink:href="qplaintextedit.xml">QPlainTextEdit</db:link> is stored as an internal property of the script function itself, so that it can be retrieved when the function is called.</db:para>
</db:section>
</db:section>
<db:section xml:id="using-qt-script-extensions">
<db:title>Using Qt Script Extensions</db:title>
<db:para>The <db:link xlink:href="qscriptengine.xml#importExtension">QScriptEngine::importExtension</db:link>() function can be used to load plugins into a script engine. Plugins typically add some extra functionality to the engine; for example, a plugin might add full bindings for the Qt Arthur painting API, so that those classes may be used from Qt Script scripts. There are currently no script plugins shipped with Qt.</db:para>
<db:para>If you are implementing some Qt Script functionality that you want other Qt application developers to be able to use, <db:link xlink:href="qtscriptextensions.xml">developing an extension</db:link> (e.g. by subclassing <db:link xlink:href="qscriptextensionplugin.xml">QScriptExtensionPlugin</db:link>) is worth looking into.</db:para>
</db:section>
<db:section xml:id="internationalization">
<db:title>Internationalization</db:title>
<db:para>Since Qt 4.5, Qt Script supports internationalization of scripts by building on the C++ internationalization functionality (see <db:link xlink:href="internationalization.xml">Internationalization with Qt</db:link>).</db:para>
<db:section xml:id="use-qstr-for-all-literal-text">
<db:title>Use qsTr() for All Literal Text</db:title>
<db:para>Wherever your script uses &quot;quoted text&quot; for text that will be presented to the user, ensure that it is processed by the <db:link xlink:href="qcoreapplication.xml#translate">QCoreApplication::translate</db:link>() function. Essentially all that is necessary to achieve this is to use the qsTr() script function. Example:</db:para>
<db:programlisting language="cpp">myButton.text = qsTr(&quot;Hello world!&quot;);
</db:programlisting>
<db:para>This accounts for 99% of the user-visible strings you're likely to write.</db:para>
<db:para>The qsTr() function uses the basename of the script's filename (see <db:link xlink:href="qfileinfo.xml#baseName">QFileInfo::baseName</db:link>()) as the translation context; if the filename is not unique in your project, you should use the qsTranslate() function and pass a suitable context as the first argument. Example:</db:para>
<db:programlisting language="cpp">myButton.text = qsTranslate(&quot;MyAwesomeScript&quot;, &quot;Hello world!&quot;);
</db:programlisting>
<db:para>If you need to have translatable text completely outside a function, there are two functions to help: <db:link xlink:href="qtglobal.xml#QT_TR_NOOP">QT_TR_NOOP</db:link>() and <db:link xlink:href="qtglobal.xml#QT_TRANSLATE_NOOP">QT_TRANSLATE_NOOP</db:link>(). They merely mark the text for extraction by the <db:code>lupdate</db:code> utility described below. At runtime, these functions simply return the text to translate unmodified.</db:para>
<db:para>Example of <db:link xlink:href="qtglobal.xml#QT_TR_NOOP">QT_TR_NOOP</db:link>():</db:para>
<db:programlisting language="cpp">FriendlyConversation.prototype.greeting = function(type)
{
    if (FriendlyConversation['greeting_strings'] == undefined) {
        FriendlyConversation['greeting_strings'] = [
            QT_TR_NOOP(&quot;Hello&quot;),
            QT_TR_NOOP(&quot;Goodbye&quot;)
        ];
    }
    return qsTr(FriendlyConversation.greeting_strings[type]);
}
</db:programlisting>
<db:para>Example of <db:link xlink:href="qtglobal.xml#QT_TRANSLATE_NOOP">QT_TRANSLATE_NOOP</db:link>():</db:para>
<db:programlisting language="cpp">FriendlyConversation.prototype.greeting = function(type)
{
    if (FriendlyConversation['greeting_strings'] == undefined) {
        FriendlyConversation['greeting_strings'] = [
            QT_TRANSLATE_NOOP(&quot;FriendlyConversation&quot;, &quot;Hello&quot;),
            QT_TRANSLATE_NOOP(&quot;FriendlyConversation&quot;, &quot;Goodbye&quot;)
        ];
    }
    return qsTranslate(&quot;FriendlyConversation&quot;, FriendlyConversation.greeting_strings[type]);
}
</db:programlisting>
</db:section>
<db:section xml:id="use-string-prototype-arg-for-dynamic-text">
<db:title>Use String.prototype.arg() for Dynamic Text</db:title>
<db:para>The String.prototype.arg() function (which is modeled after <db:link xlink:href="qstring.xml#arg">QString::arg</db:link>()) offers a simple means for substituting arguments:</db:para>
<db:programlisting language="cpp">FileCopier.prototype.showProgress = function(done, total, currentFileName)
{
    this.label.text = qsTr(&quot;%1 of %2 files copied.\nCopying: %3&quot;)
                      .arg(done)
                      .arg(total)
                      .arg(currentFileName);
}
</db:programlisting>
</db:section>
<db:section xml:id="produce-translations">
<db:title>Produce Translations</db:title>
<db:para>Once you are using qsTr() and/or qsTranslate() throughout your scripts, you can start producing translations of the user-visible text in your program.</db:para>
<db:para>The <db:link xlink:href="qtlinguist-index.xml">Qt Linguist Manual</db:link> provides further information about Qt's translation tools, <db:emphasis>Qt Linguist</db:emphasis>, <db:code>lupdate</db:code> and <db:code>lrelease</db:code>.</db:para>
<db:para>Translation of Qt Script scripts is a three-step process:</db:para>
<db:orderedlist numeration="arabic">
<db:listitem>
<db:para>Run <db:code>lupdate</db:code> to extract translatable text from the script source code of the Qt application, resulting in a message file for translators (a TS file). The utility recognizes qsTr(), qsTranslate() and the <db:code>QT_TR*_NOOP()</db:code> functions described above and produces TS files (usually one per language).</db:para>
</db:listitem>
<db:listitem>
<db:para>Provide translations for the source texts in the TS file, using <db:emphasis>Qt Linguist</db:emphasis>. Since TS files are in XML format, you can also edit them by hand.</db:para>
</db:listitem>
<db:listitem>
<db:para>Run <db:code>lrelease</db:code> to obtain a light-weight message file (a QM file) from the TS file, suitable only for end use. Think of the TS files as &quot;source files&quot;, and QM files as &quot;object files&quot;. The translator edits the TS files, but the users of your application only need the QM files. Both kinds of files are platform and locale independent.</db:para>
</db:listitem>
</db:orderedlist>
<db:para>Typically, you will repeat these steps for every release of your application. The <db:code>lupdate</db:code> utility does its best to reuse the translations from previous releases.</db:para>
<db:para>When running <db:code>lupdate</db:code>, you must specify the location of the script(s), and the name of the TS file to produce. Examples:</db:para>
<db:programlisting language="cpp">lupdate myscript.qs -ts myscript_la.ts
</db:programlisting>
<db:para>will extract translatable text from <db:code>myscript.qs</db:code> and create the translation file <db:code>myscript_la.qs</db:code>.</db:para>
<db:programlisting language="cpp">lupdate -extensions qs scripts/ -ts scripts_la.ts
</db:programlisting>
<db:para>will extract translatable text from all files ending with <db:code>.qs</db:code> in the <db:code>scripts</db:code> folder and create the translation file <db:code>scripts_la.qs</db:code>.</db:para>
<db:para>Alternatively, you can create a separate qmake project file that sets up the <db:code>SOURCES</db:code> and <db:code>TRANSLATIONS</db:code> variables appropriately; then run <db:code>lupdate</db:code> with the project file as input.</db:para>
<db:programlisting language="cpp">lrelease myscript_la.ts
</db:programlisting>
<db:para>When running <db:code>lrelease</db:code>, you must specify the name of the TS input file; or, if you are using a qmake project file to manage script translations, you specify the name of that file. <db:code>lrelease</db:code> will create <db:code>myscript_la.qm</db:code>, the binary representation of the translation.</db:para>
</db:section>
<db:section xml:id="apply-translations">
<db:title>Apply Translations</db:title>
<db:para>In your application, you must use <db:link xlink:href="qtranslator.xml#load">QTranslator::load</db:link>() to load the translation files appropriate for the user's language, and install them using <db:link xlink:href="qcoreapplication.xml#installTranslator">QCoreApplication::installTranslator</db:link>(). Finally, you must call <db:link xlink:href="qscriptengine.xml#installTranslatorFunctions">QScriptEngine::installTranslatorFunctions</db:link>() to make the script translation functions (qsTr(), qsTranslate() and <db:code>QT_TR*_NOOP()</db:code>) available to scripts that are subsequently evaluated by <db:link xlink:href="qscriptengine.xml#evaluate">QScriptEngine::evaluate</db:link>(). For scripts that are using the qsTr() function, the proper filename must be passed as second argument to <db:link xlink:href="qscriptengine.xml#evaluate">QScriptEngine::evaluate</db:link>().</db:para>
<db:para><db:code>linguist</db:code>, <db:code>lupdate</db:code> and <db:code>lrelease</db:code> are installed in the <db:code>bin</db:code> subdirectory of the base directory Qt is installed into. Click Help|Manual in <db:emphasis>Qt Linguist</db:emphasis> to access the user's manual; it contains a tutorial to get you started.</db:para>
<db:para>See also the <db:link xlink:href="qtscript-script-helloscript-example.xml">Hello Script Example</db:link>.</db:para>
</db:section>
</db:section>
<db:section xml:id="ecmascript-compatibility">
<db:title>ECMAScript Compatibility</db:title>
<db:para>Qt Script implements all the built-in objects and properties defined in the <db:link xlink:href="http://www.ecma-international.org/publications/standards/Ecma-262.htm">ECMA-262</db:link> standard; see the <db:link xlink:href="ecmascript.xml">ECMAScript reference</db:link> for an overview.</db:para>
</db:section>
<db:section xml:id="qt-script-extensions-to-ecmascript">
<db:title>Qt Script Extensions to ECMAScript</db:title>
<db:itemizedlist>
<db:listitem>
<db:para><db:code>__proto__</db:code>  The prototype of an object (<db:link xlink:href="qscriptvalue.xml#prototype">QScriptValue::prototype</db:link>()) can be accessed through its <db:code>__proto__</db:code> property in script code. This property has the <db:link xlink:href="qscriptvalue.xml#PropertyFlag-enum">QScriptValue::Undeletable</db:link> flag set. For example:</db:para>
<db:programlisting language="cpp">var o = new Object();
(o.__proto__ === Object.prototype); // this evaluates to true
</db:programlisting>
</db:listitem>
<db:listitem>
<db:para><db:code>Object.prototype.__defineGetter__</db:code>  This function installs a getter function for a property of an object. The first argument is the property name, and the second is the function to call to get the value of that property. When the function is invoked, the <db:code>this</db:code> object will be the object whose property is accessed. For example:</db:para>
<db:programlisting language="cpp">var o = new Object();
o.__defineGetter__(&quot;x&quot;, function() { return 123; });
var y = o.x; // 123
</db:programlisting>
</db:listitem>
<db:listitem>
<db:para><db:code>Object.prototype.__defineSetter__</db:code>  This function installs a setter function for a property of an object. The first argument is the property name, and the second is the function to call to set the value of that property. When the function is invoked, the <db:code>this</db:code> object will be the object whose property is accessed. For example:</db:para>
<db:programlisting language="cpp">var o = new Object();
o.__defineSetter__(&quot;x&quot;, function(v) { print(&quot;and the value is:&quot;, v); });
o.x = 123; // will print &quot;and the value is: 123&quot;
</db:programlisting>
</db:listitem>
<db:listitem>
<db:para><db:code>Function.prototype.connect</db:code>  This function connects a signal to a slot. Usage of this function is described in the section <db:link xlink:href="qtscript-index.xml#using-signals-and-slots">Using Signals and Slots</db:link>.</db:para>
</db:listitem>
<db:listitem>
<db:para><db:code>Function.prototype.disconnect</db:code>  This function disconnects a signal from a slot. Usage of this function is described in the section <db:link xlink:href="qtscript-index.xml#using-signals-and-slots">Using Signals and Slots</db:link>.</db:para>
</db:listitem>
<db:listitem>
<db:para><db:code>QObject.prototype.findChild</db:code>  This function is semantically equivalent to QObject::findChild().</db:para>
</db:listitem>
<db:listitem>
<db:para><db:code>QObject.prototype.findChildren</db:code>  This function is semantically equivalent to QObject::findChildren().</db:para>
</db:listitem>
<db:listitem>
<db:para><db:code>QObject.prototype.toString</db:code>  This function returns a default string representation of a <db:link xlink:href="qobject.xml">QObject</db:link>.</db:para>
</db:listitem>
<db:listitem>
<db:para><db:code>gc</db:code>  This function invokes the garbage collector.</db:para>
</db:listitem>
<db:listitem>
<db:para><db:code>Error.prototype.backtrace</db:code>  This function returns a human-readable backtrace, in the form of an array of strings.</db:para>
</db:listitem>
<db:listitem>
<db:para>Error objects have the following additional properties:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:code>lineNumber</db:code>: The line number where the error occurred.</db:para>
</db:listitem>
<db:listitem>
<db:para><db:code>fileName</db:code>: The file name where the error occurred (if a file name was passed to <db:link xlink:href="qscriptengine.xml#evaluate">QScriptEngine::evaluate</db:link>()).</db:para>
</db:listitem>
</db:itemizedlist>
</db:listitem>
</db:itemizedlist>
</db:section>
</db:article>
