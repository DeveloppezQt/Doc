<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en">
<db:info>
<db:title>QLatin1StringView Class</db:title>
<db:productname>QtCore</db:productname>
<db:edition>Qt 6.8.3 Reference Documentation</db:edition>
<db:titleabbrev>Qt Core Reference Documentation</db:titleabbrev>
<db:abstract>
<db:para>The <db:link xlink:href="qlatin1stringview.xml">QLatin1StringView</db:link> class provides a thin wrapper around a US-ASCII/Latin-1 encoded string literal.</db:para>
<db:note>
<db:para>All functions in this class are reentrant.</db:para>
</db:note>
<db:para>This class is <db:emphasis>strongly comparable</db:emphasis>.</db:para>
<db:para>This class is <db:emphasis role="bold">strongly comparable</db:emphasis> with char16_t, <db:link xlink:href="qchar.xml">QChar</db:link>, <db:link xlink:href="qstringview.xml">QStringView</db:link>, <db:link xlink:href="qutf8stringview.xml">QUtf8StringView</db:link>, <db:link xlink:href="qstring.xml">QString</db:link>, and const char16_t *.</db:para>
<db:para>This class is <db:emphasis role="bold">strongly comparable</db:emphasis> with const char *, <db:link xlink:href="qbytearray.xml">QByteArray</db:link>, and <db:link xlink:href="qbytearrayview.xml">QByteArrayView</db:link>.</db:para>
<db:para>The byte array data is interpreted as UTF-8.</db:para>
</db:abstract>
<db:pubdate>2025-06-29</db:pubdate>
<db:date>2025-06-29</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:variablelist>
<db:varlistentry>
<db:term>Header</db:term>
<db:listitem>
<db:para>QLatin1StringView</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>CMake</db:term>
<db:listitem>
<db:para>find_package(Qt6 REQUIRED COMPONENTS Core)</db:para>
<db:para>target_link_libraries(mytarget PRIVATE Qt6::Core)</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>qmake</db:term>
<db:listitem>
<db:para>QT += core</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Group</db:term>
<db:listitem>
<db:para>QLatin1StringView is part of <db:simplelist><db:member>string-processing</db:member></db:simplelist>
</db:para>
</db:listitem>
</db:varlistentry>
</db:variablelist>
<db:section xml:id="details">
<db:title>Detailed Description</db:title>
<db:para>Many of <db:link xlink:href="qstring.xml">QString</db:link>'s member functions are overloaded to accept <db:code>const char *</db:code> instead of <db:link xlink:href="qstring.xml">QString</db:link>. This includes the copy constructor, the assignment operator, the comparison operators, and various other functions such as <db:link xlink:href="qstring.xml#insert">insert</db:link>(), <db:link xlink:href="qstring.xml#append">append</db:link>(), and <db:link xlink:href="qstring.xml#prepend">prepend</db:link>(). Some of these functions are optimized to avoid constructing a <db:link xlink:href="qstring.xml">QString</db:link> object for the <db:code>const char *</db:code> data. For example, assuming <db:code>str</db:code> is a <db:link xlink:href="qstring.xml">QString</db:link>,</db:para>
<db:programlisting language="cpp">if (str == &quot;auto&quot; || str == &quot;extern&quot;
        || str == &quot;static&quot; || str == &quot;register&quot;) {
    ...
}
</db:programlisting>
<db:para>is much faster than</db:para>
<db:programlisting language="cpp">if (str == QString(&quot;auto&quot;) || str == QString(&quot;extern&quot;)
        || str == QString(&quot;static&quot;) || str == QString(&quot;register&quot;)) {
    ...
}
</db:programlisting>
<db:para>because it doesn't construct four temporary <db:link xlink:href="qstring.xml">QString</db:link> objects and make a deep copy of the character data.</db:para>
<db:para>However, that is not true for all <db:link xlink:href="qstring.xml">QString</db:link> member functions that take <db:code>const char *</db:code> and therefore applications should assume a temporary will be created, such as in</db:para>
<db:programlisting language="cpp">str.append(&quot;Hello &quot;).append(&quot;World&quot;);
</db:programlisting>
<db:para>Applications that define <db:link xlink:href="qstring.xml#QT_NO_CAST_FROM_ASCII">QT_NO_CAST_FROM_ASCII</db:link> (as explained in the <db:link xlink:href="qstring.xml">QString</db:link> documentation) don't have access to <db:link xlink:href="qstring.xml">QString</db:link>'s <db:code>const char *</db:code> API. To provide an efficient way of specifying constant Latin-1 strings, Qt provides the <db:link xlink:href="qlatin1stringview.xml">QLatin1StringView</db:link>, which is just a very thin wrapper around a <db:code>const char *</db:code>. Using <db:link xlink:href="qlatin1stringview.xml">QLatin1StringView</db:link>, the example code above becomes</db:para>
<db:programlisting language="cpp">if (str == &quot;auto&quot;_L1
        || str == &quot;extern&quot;_L1
        || str == &quot;static&quot;_L1
        || str == &quot;register&quot;_L1 {
    ...
}
</db:programlisting>
<db:para>This is a bit longer to type, but it provides exactly the same benefits as the first version of the code, and is faster than converting the Latin-1 strings using <db:link xlink:href="qstring.xml#fromLatin1">QString::fromLatin1</db:link>().</db:para>
<db:para>Thanks to the <db:link xlink:href="qstring.xml">QString</db:link>(<db:link xlink:href="qlatin1stringview.xml">QLatin1StringView</db:link>) constructor, <db:link xlink:href="qlatin1stringview.xml">QLatin1StringView</db:link> can be used everywhere a <db:link xlink:href="qstring.xml">QString</db:link> is expected. For example:</db:para>
<db:programlisting language="cpp">QLabel *label = new QLabel(&quot;MOD&quot;_L1, this);
</db:programlisting>
<db:note>
<db:para>If the function you're calling with a <db:link xlink:href="qlatin1stringview.xml">QLatin1StringView</db:link> argument isn't actually overloaded to take <db:link xlink:href="qlatin1stringview.xml">QLatin1StringView</db:link>, the implicit conversion to <db:link xlink:href="qstring.xml">QString</db:link> will trigger a memory allocation, which is usually what you want to avoid by using <db:link xlink:href="qlatin1stringview.xml">QLatin1StringView</db:link> in the first place. In those cases, using <db:link xlink:href="qstring.xml#QStringLiteral">QStringLiteral</db:link> may be the better option.</db:para>
</db:note>
<db:note>
<db:para>Only US-ASCII literals can be used in <db:link xlink:href="qlatin1stringview.xml">QLatin1StringView</db:link> if the source code file is encoded in UTF-8, as <db:link xlink:href="">Qt requires</db:link>. Non-US-ASCII literals like <db:code>QLatin1StringView(&quot;Ã©&quot;)</db:code> will not be represented correctly. You can use octal or hex notation instead: <db:code>QLatin1StringView(&quot;\351&quot;)</db:code> or <db:code>QLatin1StringView(&quot;\xe9&quot;)</db:code>, respectively.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qstring.xml">QString</db:link></db:member>
<db:member><db:link xlink:href="qlatin1char.xml">QLatin1Char</db:link></db:member>
<db:member><db:link xlink:href="qstring.xml#QStringLiteral">QStringLiteral</db:link></db:member>
<db:member><db:link xlink:href="qstring.xml#QT_NO_CAST_FROM_ASCII">QT_NO_CAST_FROM_ASCII</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="member-type-documentation">
<db:title>Member Type Documentation</db:title>
<db:section xml:id="const_pointer-typedef">
<db:title>[alias, since 6.7] QLatin1StringView::const_pointer</db:title>
<db:bridgehead renderas="sect2" xml:id="pointer-typedef">[alias, since 6.7] QLatin1StringView::pointer</db:bridgehead>
<db:para>Alias for <db:code>value_type *</db:code>. Provided for compatibility with the STL.</db:para>
<db:para>This typedef was introduced in Qt 6.7.</db:para>
</db:section>
<db:section xml:id="const_iterator-typedef">
<db:title>[alias] QLatin1StringView::const_iterator</db:title>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qlatin1stringview.xml#iterator-typedef">iterator</db:link></db:member>
<db:member><db:link xlink:href="qlatin1stringview.xml#const_reverse_iterator-typedef">const_reverse_iterator</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="const_reference-typedef">
<db:title>[alias] QLatin1StringView::const_reference</db:title>
<db:para>Alias for <db:code>reference</db:code>. Provided for compatibility with the STL.</db:para>
</db:section>
<db:section xml:id="const_reverse_iterator-typedef">
<db:title>[alias] QLatin1StringView::const_reverse_iterator</db:title>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qlatin1stringview.xml#reverse_iterator-typedef">reverse_iterator</db:link></db:member>
<db:member><db:link xlink:href="qlatin1stringview.xml#const_iterator-typedef">const_iterator</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="difference_type-typedef">
<db:title>[alias] QLatin1StringView::difference_type</db:title>
<db:para>Alias for <db:code>qsizetype</db:code>. Provided for compatibility with the STL.</db:para>
</db:section>
<db:section xml:id="iterator-typedef">
<db:title>[alias] QLatin1StringView::iterator</db:title>
<db:para><db:link xlink:href="qlatin1stringview.xml">QLatin1StringView</db:link> does not support mutable iterators, so this is the same as <db:link xlink:href="qlatin1stringview.xml#const_iterator-typedef">const_iterator</db:link>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qlatin1stringview.xml#const_iterator-typedef">const_iterator</db:link></db:member>
<db:member><db:link xlink:href="qlatin1stringview.xml#reverse_iterator-typedef">reverse_iterator</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="reference-typedef">
<db:title>[alias] QLatin1StringView::reference</db:title>
<db:para>Alias for <db:code>value_type &amp;</db:code>. Provided for compatibility with the STL.</db:para>
</db:section>
<db:section xml:id="reverse_iterator-typedef">
<db:title>[alias] QLatin1StringView::reverse_iterator</db:title>
<db:para><db:link xlink:href="qlatin1stringview.xml">QLatin1StringView</db:link> does not support mutable reverse iterators, so this is the same as <db:link xlink:href="qlatin1stringview.xml#const_reverse_iterator-typedef">const_reverse_iterator</db:link>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qlatin1stringview.xml#const_reverse_iterator-typedef">const_reverse_iterator</db:link></db:member>
<db:member><db:link xlink:href="qlatin1stringview.xml#iterator-typedef">iterator</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="size_type-typedef">
<db:title>[alias] QLatin1StringView::size_type</db:title>
<db:para>Alias for <db:code>qsizetype</db:code>. Provided for compatibility with the STL.</db:para>
<db:note>
<db:para>In version prior to Qt 6, this was an alias for <db:code>int</db:code>, restricting the amount of data that could be held in a <db:link xlink:href="qlatin1stringview.xml">QLatin1StringView</db:link> on 64-bit architectures.</db:para>
</db:note>
</db:section>
<db:section xml:id="value_type-typedef">
<db:title>[alias] QLatin1StringView::value_type</db:title>
<db:para>Alias for <db:code>const char</db:code>. Provided for compatibility with the STL.</db:para>
</db:section>
</db:section>
<db:section xml:id="member-function-documentation">
<db:title>Member Function Documentation</db:title>
<db:section xml:id="compare">
<db:title>[constexpr noexcept] int QLatin1StringView::compare(QChar <db:emphasis>ch</db:emphasis>) const</db:title>
<db:bridgehead renderas="sect2" xml:id="compare-1">[noexcept] int QLatin1StringView::compare(QChar <db:emphasis>ch</db:emphasis>, Qt::CaseSensitivity <db:emphasis>cs</db:emphasis>) const</db:bridgehead>
<db:bridgehead renderas="sect2" xml:id="compare-2">[noexcept] int QLatin1StringView::compare(QLatin1StringView <db:emphasis>l1</db:emphasis>, Qt::CaseSensitivity <db:emphasis>cs</db:emphasis> = Qt::CaseSensitive) const</db:bridgehead>
<db:bridgehead renderas="sect2" xml:id="compare-3">[noexcept] int QLatin1StringView::compare(QStringView <db:emphasis>str</db:emphasis>, Qt::CaseSensitivity <db:emphasis>cs</db:emphasis> = Qt::CaseSensitive) const</db:bridgehead>
<db:para>Compares this string view with UTF-16 string view <db:code role="parameter">str</db:code>, Latin-1 string view <db:code role="parameter">l1</db:code>, or the character <db:code role="parameter">ch</db:code>, respectively. Returns a negative integer if this string is less than <db:code role="parameter">str</db:code>, <db:code role="parameter">l1</db:code> or <db:code role="parameter">ch</db:code>, returns a positive integer if it is greater than <db:code role="parameter">str</db:code>, <db:code role="parameter">l1</db:code> or <db:code role="parameter">ch</db:code>, and zero if they are equal.</db:para>
<db:para>If <db:code role="parameter">cs</db:code> is <db:link xlink:href="qt.xml#CaseSensitivity-enum">Qt::CaseSensitive</db:link> (the default), the search is case-sensitive; otherwise the search is case-insensitive.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qlatin1stringview.xml#operator-eq-eq">operator==</db:link>()</db:member>
<db:member><db:link xlink:href="qlatin1stringview.xml#operator-lt">operator&lt;</db:link>()</db:member>
<db:member><db:link xlink:href="qlatin1stringview.xml#operator-gt">operator&gt;</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="startsWith">
<db:title>[constexpr noexcept] bool QLatin1StringView::startsWith(QChar <db:emphasis>ch</db:emphasis>) const</db:title>
<db:bridgehead renderas="sect2" xml:id="startsWith-1">[noexcept] bool QLatin1StringView::startsWith(QChar <db:emphasis>ch</db:emphasis>, Qt::CaseSensitivity <db:emphasis>cs</db:emphasis>) const</db:bridgehead>
<db:bridgehead renderas="sect2" xml:id="startsWith-2">[noexcept] bool QLatin1StringView::startsWith(QLatin1StringView <db:emphasis>l1</db:emphasis>, Qt::CaseSensitivity <db:emphasis>cs</db:emphasis> = Qt::CaseSensitive) const</db:bridgehead>
<db:bridgehead renderas="sect2" xml:id="startsWith-3">[noexcept] bool QLatin1StringView::startsWith(QStringView <db:emphasis>str</db:emphasis>, Qt::CaseSensitivity <db:emphasis>cs</db:emphasis> = Qt::CaseSensitive) const</db:bridgehead>
<db:para>Returns <db:code>true</db:code> if this Latin-1 string view starts with the UTF-16 string viewed by <db:code role="parameter">str</db:code>, the Latin-1 string viewed by <db:code role="parameter">l1</db:code>, or the character <db:code role="parameter">ch</db:code>, respectively; otherwise returns <db:code>false</db:code>.</db:para>
<db:para>If <db:code role="parameter">cs</db:code> is <db:link xlink:href="qt.xml#CaseSensitivity-enum">Qt::CaseSensitive</db:link> (the default), the search is case-sensitive; otherwise the search is case-insensitive.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qlatin1stringview.xml#endsWith">endsWith</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="endsWith">
<db:title>[constexpr noexcept] bool QLatin1StringView::endsWith(QChar <db:emphasis>ch</db:emphasis>) const</db:title>
<db:bridgehead renderas="sect2" xml:id="endsWith-1">[noexcept] bool QLatin1StringView::endsWith(QChar <db:emphasis>ch</db:emphasis>, Qt::CaseSensitivity <db:emphasis>cs</db:emphasis>) const</db:bridgehead>
<db:bridgehead renderas="sect2" xml:id="endsWith-2">[noexcept] bool QLatin1StringView::endsWith(QLatin1StringView <db:emphasis>l1</db:emphasis>, Qt::CaseSensitivity <db:emphasis>cs</db:emphasis> = Qt::CaseSensitive) const</db:bridgehead>
<db:bridgehead renderas="sect2" xml:id="endsWith-3">[noexcept] bool QLatin1StringView::endsWith(QStringView <db:emphasis>str</db:emphasis>, Qt::CaseSensitivity <db:emphasis>cs</db:emphasis> = Qt::CaseSensitive) const</db:bridgehead>
<db:para>Returns <db:code>true</db:code> if this Latin-1 string view ends with the UTF-16 string viewed <db:code role="parameter">str</db:code>, the Latin-1 string viewed by <db:code role="parameter">l1</db:code>, or the character <db:code role="parameter">ch</db:code>, respectively; otherwise returns <db:code>false</db:code>.</db:para>
<db:para>If <db:code role="parameter">cs</db:code> is <db:link xlink:href="qt.xml#CaseSensitivity-enum">Qt::CaseSensitive</db:link> (the default), the search is case-sensitive; otherwise the search is case-insensitive.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qlatin1stringview.xml#startsWith">startsWith</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="indexOf">
<db:title>[noexcept] qsizetype QLatin1StringView::indexOf(QChar <db:emphasis>c</db:emphasis>, qsizetype <db:emphasis>from</db:emphasis> = 0, Qt::CaseSensitivity <db:emphasis>cs</db:emphasis> = Qt::CaseSensitive) const</db:title>
<db:bridgehead renderas="sect2" xml:id="indexOf-1">[noexcept] qsizetype QLatin1StringView::indexOf(QLatin1StringView <db:emphasis>l1</db:emphasis>, qsizetype <db:emphasis>from</db:emphasis> = 0, Qt::CaseSensitivity <db:emphasis>cs</db:emphasis> = Qt::CaseSensitive) const</db:bridgehead>
<db:bridgehead renderas="sect2" xml:id="indexOf-2">[noexcept] qsizetype QLatin1StringView::indexOf(QStringView <db:emphasis>str</db:emphasis>, qsizetype <db:emphasis>from</db:emphasis> = 0, Qt::CaseSensitivity <db:emphasis>cs</db:emphasis> = Qt::CaseSensitive) const</db:bridgehead>
<db:para>Returns the index position in this Latin-1 string view of the first occurrence of the UTF-16 string viewed by <db:code role="parameter">str</db:code>, the Latin-1 string viewed by <db:code role="parameter">l1</db:code>, or the character <db:code role="parameter">ch</db:code>, respectively, searching forward from index position <db:code role="parameter">from</db:code>. Returns -1 if <db:code role="parameter">str</db:code>, <db:code role="parameter">l1</db:code> or <db:code role="parameter">c</db:code> is not found, respectively.</db:para>
<db:para>If <db:code role="parameter">cs</db:code> is <db:link xlink:href="qt.xml#CaseSensitivity-enum">Qt::CaseSensitive</db:link> (the default), the search is case-sensitive; otherwise the search is case-insensitive.</db:para>
<db:para>If <db:code role="parameter">from</db:code> is -1, the search starts at the last character; if it is -2, at the next to last character and so on.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qstring.xml#indexOf">QString::indexOf</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="contains">
<db:title>[noexcept] bool QLatin1StringView::contains(QChar <db:emphasis>c</db:emphasis>, Qt::CaseSensitivity <db:emphasis>cs</db:emphasis> = Qt::CaseSensitive) const</db:title>
<db:bridgehead renderas="sect2" xml:id="contains-1">[noexcept] bool QLatin1StringView::contains(QLatin1StringView <db:emphasis>l1</db:emphasis>, Qt::CaseSensitivity <db:emphasis>cs</db:emphasis> = Qt::CaseSensitive) const</db:bridgehead>
<db:bridgehead renderas="sect2" xml:id="contains-2">[noexcept] bool QLatin1StringView::contains(QStringView <db:emphasis>str</db:emphasis>, Qt::CaseSensitivity <db:emphasis>cs</db:emphasis> = Qt::CaseSensitive) const</db:bridgehead>
<db:para>Returns <db:code>true</db:code> if this Latin-1 string view contains an occurrence of the UTF-16 string viewed by <db:code role="parameter">str</db:code>, the Latin-1 string viewed by <db:code role="parameter">l1</db:code>, or the character <db:code role="parameter">ch</db:code>, respectively; otherwise returns <db:code>false</db:code>.</db:para>
<db:para>If <db:code role="parameter">cs</db:code> is <db:link xlink:href="qt.xml#CaseSensitivity-enum">Qt::CaseSensitive</db:link> (the default), the search is case-sensitive; otherwise the search is case-insensitive.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qlatin1stringview.xml#indexOf">indexOf</db:link>()</db:member>
<db:member><db:link xlink:href="qstringview.xml#contains">QStringView::contains</db:link>()</db:member>
<db:member><db:link xlink:href="qstringview.xml#indexOf">QStringView::indexOf</db:link>()</db:member>
<db:member><db:link xlink:href="qstring.xml#indexOf">QString::indexOf</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="lastIndexOf">
<db:title>[noexcept] qsizetype QLatin1StringView::lastIndexOf(QChar <db:emphasis>c</db:emphasis>, qsizetype <db:emphasis>from</db:emphasis>, Qt::CaseSensitivity <db:emphasis>cs</db:emphasis> = Qt::CaseSensitive) const</db:title>
<db:bridgehead renderas="sect2" xml:id="lastIndexOf-1">[noexcept] qsizetype QLatin1StringView::lastIndexOf(QLatin1StringView <db:emphasis>l1</db:emphasis>, qsizetype <db:emphasis>from</db:emphasis>, Qt::CaseSensitivity <db:emphasis>cs</db:emphasis> = Qt::CaseSensitive) const</db:bridgehead>
<db:bridgehead renderas="sect2" xml:id="lastIndexOf-2">[noexcept] qsizetype QLatin1StringView::lastIndexOf(QStringView <db:emphasis>str</db:emphasis>, qsizetype <db:emphasis>from</db:emphasis>, Qt::CaseSensitivity <db:emphasis>cs</db:emphasis> = Qt::CaseSensitive) const</db:bridgehead>
<db:para>Returns the index position in this Latin-1 string view of the last occurrence of the UTF-16 string viewed by <db:code role="parameter">str</db:code>, the Latin-1 string viewed by <db:code role="parameter">l1</db:code>, or the character <db:code role="parameter">ch</db:code>, respectively, searching backward from index position <db:code role="parameter">from</db:code>; returns -1 if <db:code role="parameter">str</db:code>, <db:code role="parameter">l1</db:code> or <db:code role="parameter">ch</db:code> is not found, respectively.</db:para>
<db:para>If <db:code role="parameter">from</db:code> is -1, the search starts at the last character; if it is -2, at the next to last character and so on.</db:para>
<db:para>If <db:code role="parameter">cs</db:code> is <db:link xlink:href="qt.xml#CaseSensitivity-enum">Qt::CaseSensitive</db:link> (the default), the search is case-sensitive; otherwise the search is case-insensitive.</db:para>
<db:note>
<db:para>When searching for a 0-length <db:code role="parameter">str</db:code> or <db:code role="parameter">l1</db:code>, the match at the end of the data is excluded from the search by a negative <db:code role="parameter">from</db:code>, even though <db:code>-1</db:code> is normally thought of as searching from the end of the string: the match at the end is <db:emphasis>after</db:emphasis> the last character, so it is excluded. To include such a final empty match, either give a positive value for <db:code role="parameter">from</db:code> or omit the <db:code role="parameter">from</db:code> parameter entirely.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qlatin1stringview.xml#indexOf">indexOf</db:link>()</db:member>
<db:member><db:link xlink:href="qstringview.xml#lastIndexOf">QStringView::lastIndexOf</db:link>()</db:member>
<db:member><db:link xlink:href="qstringview.xml#indexOf">QStringView::indexOf</db:link>()</db:member>
<db:member><db:link xlink:href="qstring.xml#indexOf">QString::indexOf</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="lastIndexOf-4">
<db:title>[noexcept, since 6.2] qsizetype QLatin1StringView::lastIndexOf(QLatin1StringView <db:emphasis>l1</db:emphasis>, Qt::CaseSensitivity <db:emphasis>cs</db:emphasis> = Qt::CaseSensitive) const</db:title>
<db:bridgehead renderas="sect2" xml:id="lastIndexOf-5">[noexcept, since 6.2] qsizetype QLatin1StringView::lastIndexOf(QStringView <db:emphasis>str</db:emphasis>, Qt::CaseSensitivity <db:emphasis>cs</db:emphasis> = Qt::CaseSensitive) const</db:bridgehead>
<db:para>This function overloads <db:link xlink:href="qlatin1stringview.xml#lastIndexOf">lastIndexOf</db:link>().</db:para>
<db:para>Returns the index position in this Latin-1 string view of the last occurrence of the UTF-16 string viewed by <db:code role="parameter">str</db:code> or the Latin-1 string viewed by <db:code role="parameter">l1</db:code>, respectively. Returns -1 if <db:code role="parameter">str</db:code> or <db:code role="parameter">l1</db:code> is not found, respectively.</db:para>
<db:para>If <db:code role="parameter">cs</db:code> is <db:link xlink:href="qt.xml#CaseSensitivity-enum">Qt::CaseSensitive</db:link> (the default), the search is case-sensitive; otherwise the search is case-insensitive.</db:para>
<db:para>This function was introduced in Qt 6.2.</db:para>
</db:section>
<db:section xml:id="count">
<db:title>[noexcept, since 6.4] qsizetype QLatin1StringView::count(QChar <db:emphasis>ch</db:emphasis>, Qt::CaseSensitivity <db:emphasis>cs</db:emphasis> = Qt::CaseSensitive) const</db:title>
<db:bridgehead renderas="sect2" xml:id="count-1">[since 6.4] qsizetype QLatin1StringView::count(QLatin1StringView <db:emphasis>l1</db:emphasis>, Qt::CaseSensitivity <db:emphasis>cs</db:emphasis> = Qt::CaseSensitive) const</db:bridgehead>
<db:bridgehead renderas="sect2" xml:id="count-2">[since 6.4] qsizetype QLatin1StringView::count(QStringView <db:emphasis>str</db:emphasis>, Qt::CaseSensitivity <db:emphasis>cs</db:emphasis> = Qt::CaseSensitive) const</db:bridgehead>
<db:para>Returns the number of (potentially overlapping) occurrences of the UTF-16 string viewed by <db:code role="parameter">str</db:code>, the Latin-1 string viewed by <db:code role="parameter">l1</db:code>, or the character <db:code role="parameter">ch</db:code>, respectively, in this string view.</db:para>
<db:para>If <db:code role="parameter">cs</db:code> is <db:link xlink:href="qt.xml#CaseSensitivity-enum">Qt::CaseSensitive</db:link> (the default), the search is case-sensitive; otherwise the search is case-insensitive.</db:para>
<db:para>This function was introduced in Qt 6.4.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qlatin1stringview.xml#contains">contains</db:link>()</db:member>
<db:member><db:link xlink:href="qlatin1stringview.xml#indexOf">indexOf</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="toInt">
<db:title>[since 6.4] int QLatin1StringView::toInt(bool *<db:emphasis>ok</db:emphasis> = nullptr, int <db:emphasis>base</db:emphasis> = 10) const</db:title>
<db:bridgehead renderas="sect2" xml:id="toLong">[since 6.4] long QLatin1StringView::toLong(bool *<db:emphasis>ok</db:emphasis> = nullptr, int <db:emphasis>base</db:emphasis> = 10) const</db:bridgehead>
<db:bridgehead renderas="sect2" xml:id="toLongLong">[since 6.4] qlonglong QLatin1StringView::toLongLong(bool *<db:emphasis>ok</db:emphasis> = nullptr, int <db:emphasis>base</db:emphasis> = 10) const</db:bridgehead>
<db:bridgehead renderas="sect2" xml:id="toULongLong">[since 6.4] qulonglong QLatin1StringView::toULongLong(bool *<db:emphasis>ok</db:emphasis> = nullptr, int <db:emphasis>base</db:emphasis> = 10) const</db:bridgehead>
<db:bridgehead renderas="sect2" xml:id="toShort">[since 6.4] short QLatin1StringView::toShort(bool *<db:emphasis>ok</db:emphasis> = nullptr, int <db:emphasis>base</db:emphasis> = 10) const</db:bridgehead>
<db:bridgehead renderas="sect2" xml:id="toUInt">[since 6.4] uint QLatin1StringView::toUInt(bool *<db:emphasis>ok</db:emphasis> = nullptr, int <db:emphasis>base</db:emphasis> = 10) const</db:bridgehead>
<db:bridgehead renderas="sect2" xml:id="toULong">[since 6.4] ulong QLatin1StringView::toULong(bool *<db:emphasis>ok</db:emphasis> = nullptr, int <db:emphasis>base</db:emphasis> = 10) const</db:bridgehead>
<db:bridgehead renderas="sect2" xml:id="toUShort">[since 6.4] ushort QLatin1StringView::toUShort(bool *<db:emphasis>ok</db:emphasis> = nullptr, int <db:emphasis>base</db:emphasis> = 10) const</db:bridgehead>
<db:para>Returns this <db:link xlink:href="qlatin1stringview.xml">QLatin1StringView</db:link> converted to a corresponding numeric value using base <db:code role="parameter">base</db:code>, which is ten by default. Bases 0 and 2 through 36 are supported, using letters for digits beyond 9; A is ten, B is eleven and so on.</db:para>
<db:para>If <db:code role="parameter">base</db:code> is 0, the base is determined automatically using the following rules (in this order), if the Latin-1 string view begins with:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:code>&quot;0x&quot;</db:code>, the rest of it is read as hexadecimal (base 16)</db:para>
</db:listitem>
<db:listitem>
<db:para><db:code>&quot;0b&quot;</db:code>, the rest of it is read as binary (base 2)</db:para>
</db:listitem>
<db:listitem>
<db:para><db:code>&quot;0&quot;</db:code>, the rest of it is read as octal (base 8)</db:para>
</db:listitem>
<db:listitem>
<db:para>otherwise it is read as decimal</db:para>
</db:listitem>
</db:itemizedlist>
<db:para>Returns 0 if the conversion fails.</db:para>
<db:para>If <db:code role="parameter">ok</db:code> is not <db:code>nullptr</db:code>, failure is reported by setting *<db:code role="parameter">ok</db:code> to <db:code>false</db:code>, and success by setting *<db:code role="parameter">ok</db:code> to <db:code>true</db:code>.</db:para>
<db:note>
<db:para>The conversion of the number is performed in the default C locale, regardless of the user's locale. Use <db:link xlink:href="qlocale.xml">QLocale</db:link> to perform locale-aware conversions between numbers and strings.</db:para>
</db:note>
<db:para>This function ignores leading and trailing spacing characters.</db:para>
<db:note>
<db:para>Support for the &quot;0b&quot; prefix was added in Qt 6.4.</db:para>
</db:note>
<db:para>This function was introduced in Qt 6.4.</db:para>
</db:section>
<db:section xml:id="toDouble">
<db:title>[since 6.4] double QLatin1StringView::toDouble(bool *<db:emphasis>ok</db:emphasis> = nullptr) const</db:title>
<db:bridgehead renderas="sect2" xml:id="toFloat">[since 6.4] float QLatin1StringView::toFloat(bool *<db:emphasis>ok</db:emphasis> = nullptr) const</db:bridgehead>
<db:para>Returns this <db:link xlink:href="qlatin1stringview.xml">QLatin1StringView</db:link> converted to a corresponding floating-point value.</db:para>
<db:para>Returns an infinity if the conversion overflows or 0.0 if the conversion fails for other reasons (e.g. underflow).</db:para>
<db:para>If <db:code role="parameter">ok</db:code> is not <db:code>nullptr</db:code>, failure is reported by setting *<db:code role="parameter">ok</db:code> to <db:code>false</db:code>, and success by setting *<db:code role="parameter">ok</db:code> to <db:code>true</db:code>.</db:para>
<db:warning>
<db:para>The <db:link xlink:href="qlatin1stringview.xml">QLatin1StringView</db:link> content may only contain valid numerical characters which includes the plus/minus sign, the character e used in scientific notation, and the decimal point. Including the unit or additional characters leads to a conversion error.</db:para>
</db:warning>
<db:note>
<db:para>The conversion of the number is performed in the default C locale, regardless of the user's locale. Use <db:link xlink:href="qlocale.xml">QLocale</db:link> to perform locale-aware conversions between numbers and strings.</db:para>
</db:note>
<db:para>This function ignores leading and trailing spacing characters.</db:para>
<db:para>This function was introduced in Qt 6.4.</db:para>
</db:section>
<db:section xml:id="arg">
<db:title>QString QLatin1StringView::arg(Args &amp;&amp;... <db:emphasis>args</db:emphasis>) const</db:title>
<db:para>Replaces occurrences of <db:code>%N</db:code> in this string with the corresponding argument from <db:code role="parameter">args</db:code>. The arguments are not positional: the first of the <db:code role="parameter">args</db:code> replaces the <db:code>%N</db:code> with the lowest <db:code>N</db:code> (all of them), the second of the <db:code role="parameter">args</db:code> the <db:code>%N</db:code> with the next-lowest <db:code>N</db:code> etc.</db:para>
<db:para><db:code>Args</db:code> can consist of anything that implicitly converts to <db:link xlink:href="qstring.xml">QString</db:link>, <db:link xlink:href="qstringview.xml">QStringView</db:link> or <db:link xlink:href="qlatin1stringview.xml">QLatin1StringView</db:link>.</db:para>
<db:para>In addition, the following types are also supported: <db:link xlink:href="qchar.xml">QChar</db:link>, <db:link xlink:href="qlatin1char.xml">QLatin1Char</db:link>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qstring.xml#arg">QString::arg</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="tokenize">
<db:title>[constexpr noexcept(...), since 6.0] auto QLatin1StringView::tokenize(Needle &amp;&amp;<db:emphasis>sep</db:emphasis>, Flags... <db:emphasis>flags</db:emphasis>) const</db:title>
<db:para>Splits the string into substring views wherever <db:code role="parameter">sep</db:code> occurs, and returns a lazy sequence of those strings.</db:para>
<db:para>Equivalent to</db:para>
<db:programlisting language="cpp">return QStringTokenizer{std::forward&lt;Needle&gt;(sep), flags...};
</db:programlisting>
<db:para>except it works without C++17 Class Template Argument Deduction (CTAD) enabled in the compiler.</db:para>
<db:para>See <db:link xlink:href="qstringtokenizer.xml">QStringTokenizer</db:link> for how <db:code role="parameter">sep</db:code> and <db:code role="parameter">flags</db:code> interact to form the result.</db:para>
<db:note>
<db:para>While this function returns <db:link xlink:href="qstringtokenizer.xml">QStringTokenizer</db:link>, you should never, ever, name its template arguments explicitly. If you can use C++17 Class Template Argument Deduction (CTAD), you may write</db:para>
</db:note>
<db:programlisting language="cpp">QStringTokenizer result = sv.tokenize(sep);
</db:programlisting>
<db:para>(without template arguments). If you can't use C++17 CTAD, you must store the return value only in <db:code>auto</db:code> variables:</db:para>
<db:programlisting language="cpp">auto result = sv.tokenize(sep);
</db:programlisting>
<db:para>This is because the template arguments of <db:link xlink:href="qstringtokenizer.xml">QStringTokenizer</db:link> have a very subtle dependency on the specific <db:link xlink:href="qlatin1stringview.xml#tokenize">tokenize</db:link>() overload from which they are returned, and they don't usually correspond to the type used for the separator.</db:para>
<db:para>This function was introduced in Qt 6.0.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qstringtokenizer.xml">QStringTokenizer</db:link></db:member>
<db:member><db:link xlink:href="qstringtokenizer.xml#qTokenize">qTokenize</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="QLatin1StringView">
<db:title>[constexpr noexcept] QLatin1StringView::QLatin1StringView()</db:title>
<db:para>Constructs a <db:link xlink:href="qlatin1stringview.xml">QLatin1StringView</db:link> object that stores a <db:code>nullptr</db:code>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qlatin1stringview.xml#data">data</db:link>()</db:member>
<db:member><db:link xlink:href="qlatin1stringview.xml#isEmpty">isEmpty</db:link>()</db:member>
<db:member><db:link xlink:href="qlatin1stringview.xml#isNull">isNull</db:link>()</db:member>
<db:member><db:link xlink:href="qstring.xml#distinction-between-null-and-empty-strings">Distinction Between Null and Empty Strings</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="QLatin1StringView-1">
<db:title>[explicit constexpr noexcept, since 6.3] QLatin1StringView::QLatin1StringView(QByteArrayView <db:emphasis>str</db:emphasis>)</db:title>
<db:para>Constructs a <db:link xlink:href="qlatin1stringview.xml">QLatin1StringView</db:link> object as a view on <db:code role="parameter">str</db:code>.</db:para>
<db:para>The string data is <db:emphasis>not</db:emphasis> copied. The caller must be able to guarantee that the data which <db:code role="parameter">str</db:code> is pointing to will not be deleted or modified as long as the <db:link xlink:href="qlatin1stringview.xml">QLatin1StringView</db:link> object exists. The size is obtained from <db:code role="parameter">str</db:code> as-is, without checking for a null-terminator.</db:para>
<db:note>
<db:para>: any null ('\0') bytes in the byte array will be included in this string, which will be converted to Unicode null characters (U+0000) if this string is used by <db:link xlink:href="qstring.xml">QString</db:link>.</db:para>
</db:note>
<db:para>This function was introduced in Qt 6.3.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qlatin1stringview.xml#latin1">latin1</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="QLatin1StringView-2">
<db:title>[explicit noexcept] QLatin1StringView::QLatin1StringView(const QByteArray &amp;<db:emphasis>str</db:emphasis>)</db:title>
<db:para>Constructs a <db:link xlink:href="qlatin1stringview.xml">QLatin1StringView</db:link> object as a view on <db:code role="parameter">str</db:code>.</db:para>
<db:para>The string data is <db:emphasis>not</db:emphasis> copied. The caller must be able to guarantee that <db:code role="parameter">str</db:code> will not be deleted or modified as long as the <db:link xlink:href="qlatin1stringview.xml">QLatin1StringView</db:link> object exists.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qlatin1stringview.xml#latin1">latin1</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="QLatin1StringView-3">
<db:title>[explicit constexpr noexcept] QLatin1StringView::QLatin1StringView(const char *<db:emphasis>str</db:emphasis>)</db:title>
<db:para>Constructs a <db:link xlink:href="qlatin1stringview.xml">QLatin1StringView</db:link> object that stores <db:code role="parameter">str</db:code>.</db:para>
<db:para>The string data is <db:emphasis>not</db:emphasis> copied. The caller must be able to guarantee that <db:code role="parameter">str</db:code> will not be deleted or modified as long as the <db:link xlink:href="qlatin1stringview.xml">QLatin1StringView</db:link> object exists.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qlatin1stringview.xml#latin1">latin1</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="QLatin1StringView-4">
<db:title>[constexpr noexcept, since 6.4] QLatin1StringView::QLatin1StringView(<db:emphasis>std::nullptr_t</db:emphasis>)</db:title>
<db:para>Constructs a <db:link xlink:href="qlatin1stringview.xml">QLatin1StringView</db:link> object that stores a <db:code>nullptr</db:code>.</db:para>
<db:para>This function was introduced in Qt 6.4.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qlatin1stringview.xml#data">data</db:link>()</db:member>
<db:member><db:link xlink:href="qlatin1stringview.xml#isEmpty">isEmpty</db:link>()</db:member>
<db:member><db:link xlink:href="qlatin1stringview.xml#isNull">isNull</db:link>()</db:member>
<db:member><db:link xlink:href="qstring.xml#distinction-between-null-and-empty-strings">Distinction Between Null and Empty Strings</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="QLatin1StringView-5">
<db:title>[constexpr] QLatin1StringView::QLatin1StringView(const char *<db:emphasis>first</db:emphasis>, const char *<db:emphasis>last</db:emphasis>)</db:title>
<db:para>Constructs a <db:link xlink:href="qlatin1stringview.xml">QLatin1StringView</db:link> object that stores <db:code role="parameter">first</db:code> with length (<db:code role="parameter">last</db:code> - <db:code role="parameter">first</db:code>).</db:para>
<db:para>The range <db:code>[first,last)</db:code> must remain valid for the lifetime of this Latin-1 string object.</db:para>
<db:para>Passing <db:code>nullptr</db:code> as <db:code role="parameter">first</db:code> is safe if <db:code role="parameter">last</db:code> is <db:code>nullptr</db:code>, too, and results in a null Latin-1 string.</db:para>
<db:para>The behavior is undefined if <db:code role="parameter">last</db:code> precedes <db:code role="parameter">first</db:code>, <db:code role="parameter">first</db:code> is <db:code>nullptr</db:code> and <db:code role="parameter">last</db:code> is not, or if <db:code>last - first &gt; INT_MAX</db:code>.</db:para>
</db:section>
<db:section xml:id="QLatin1StringView-6">
<db:title>[constexpr noexcept] QLatin1StringView::QLatin1StringView(const char *<db:emphasis>str</db:emphasis>, qsizetype <db:emphasis>size</db:emphasis>)</db:title>
<db:para>Constructs a <db:link xlink:href="qlatin1stringview.xml">QLatin1StringView</db:link> object that stores <db:code role="parameter">str</db:code> with <db:code role="parameter">size</db:code>.</db:para>
<db:para>The string data is <db:emphasis>not</db:emphasis> copied. The caller must be able to guarantee that <db:code role="parameter">str</db:code> will not be deleted or modified as long as the <db:link xlink:href="qlatin1stringview.xml">QLatin1StringView</db:link> object exists.</db:para>
<db:note>
<db:para>: any null ('\0') bytes in the byte array will be included in this string, which will be converted to Unicode null characters (U+0000) if this string is used by <db:link xlink:href="qstring.xml">QString</db:link>. This behavior is different from Qt 5.x.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qlatin1stringview.xml#latin1">latin1</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="at">
<db:title>[constexpr] QLatin1Char QLatin1StringView::at(qsizetype <db:emphasis>pos</db:emphasis>) const</db:title>
<db:para>Returns the character at position <db:code role="parameter">pos</db:code> in this object.</db:para>
<db:note>
<db:para>This function performs no error checking. The behavior is undefined when <db:code role="parameter">pos</db:code> &lt; 0 or <db:code role="parameter">pos</db:code> &gt;= <db:link xlink:href="qlatin1stringview.xml#size">size</db:link>().</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qlatin1stringview.xml#operator-5b-5d">operator[]</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="back">
<db:title>[constexpr] QLatin1Char QLatin1StringView::back() const</db:title>
<db:para>Returns the last character in the string. Same as <db:code>at(size() - 1)</db:code>.</db:para>
<db:para>This function is provided for STL compatibility.</db:para>
<db:warning>
<db:para>Calling this function on an empty string constitutes undefined behavior.</db:para>
</db:warning>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qlatin1stringview.xml#front">front</db:link>()</db:member>
<db:member><db:link xlink:href="qlatin1stringview.xml#at">at</db:link>()</db:member>
<db:member><db:link xlink:href="qlatin1stringview.xml#operator-5b-5d">operator[]</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="begin">
<db:title>[constexpr noexcept] QLatin1StringView::const_iterator QLatin1StringView::begin() const</db:title>
<db:para>Returns a const <db:link xlink:href="containers.xml#stl-style-iterators">STL-style iterator</db:link> pointing to the first character in the string.</db:para>
<db:para>This function is provided for STL compatibility.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qlatin1stringview.xml#end">end</db:link>()</db:member>
<db:member><db:link xlink:href="qlatin1stringview.xml#cbegin">cbegin</db:link>()</db:member>
<db:member><db:link xlink:href="qlatin1stringview.xml#rbegin">rbegin</db:link>()</db:member>
<db:member><db:link xlink:href="qlatin1stringview.xml#data">data</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="cbegin">
<db:title>[constexpr noexcept] QLatin1StringView::const_iterator QLatin1StringView::cbegin() const</db:title>
<db:para>Same as <db:link xlink:href="qlatin1stringview.xml#begin">begin</db:link>().</db:para>
<db:para>This function is provided for STL compatibility.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qlatin1stringview.xml#cend">cend</db:link>()</db:member>
<db:member><db:link xlink:href="qlatin1stringview.xml#begin">begin</db:link>()</db:member>
<db:member><db:link xlink:href="qlatin1stringview.xml#crbegin">crbegin</db:link>()</db:member>
<db:member><db:link xlink:href="qlatin1stringview.xml#data">data</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="cend">
<db:title>[constexpr noexcept] QLatin1StringView::const_iterator QLatin1StringView::cend() const</db:title>
<db:para>Same as <db:link xlink:href="qlatin1stringview.xml#end">end</db:link>().</db:para>
<db:para>This function is provided for STL compatibility.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qlatin1stringview.xml#cbegin">cbegin</db:link>()</db:member>
<db:member><db:link xlink:href="qlatin1stringview.xml#end">end</db:link>()</db:member>
<db:member><db:link xlink:href="qlatin1stringview.xml#crend">crend</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="chop">
<db:title>[constexpr] void QLatin1StringView::chop(qsizetype <db:emphasis>length</db:emphasis>)</db:title>
<db:para>Truncates this string by <db:code role="parameter">length</db:code> characters.</db:para>
<db:para>Same as <db:code>*this = left(size() - length)</db:code>.</db:para>
<db:note>
<db:para>The behavior is undefined when <db:code role="parameter">length</db:code> &lt; 0 or <db:code role="parameter">length</db:code> &gt; <db:link xlink:href="qlatin1stringview.xml#size">size</db:link>().</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qlatin1stringview.xml#sliced">sliced</db:link>()</db:member>
<db:member><db:link xlink:href="qlatin1stringview.xml#first">first</db:link>()</db:member>
<db:member><db:link xlink:href="qlatin1stringview.xml#last">last</db:link>()</db:member>
<db:member><db:link xlink:href="qlatin1stringview.xml#chopped">chopped</db:link>()</db:member>
<db:member><db:link xlink:href="qlatin1stringview.xml#truncate">truncate</db:link>()</db:member>
<db:member><db:link xlink:href="qlatin1stringview.xml#slice">slice</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="chopped">
<db:title>[constexpr] QLatin1StringView QLatin1StringView::chopped(qsizetype <db:emphasis>length</db:emphasis>) const</db:title>
<db:para>Returns the substring of length <db:link xlink:href="qlatin1stringview.xml#size">size</db:link>() - <db:code role="parameter">length</db:code> starting at the beginning of this object.</db:para>
<db:para>Same as <db:code>left(size() - length)</db:code>.</db:para>
<db:note>
<db:para>The behavior is undefined when <db:code role="parameter">length</db:code> &lt; 0 or <db:code role="parameter">length</db:code> &gt; <db:link xlink:href="qlatin1stringview.xml#size">size</db:link>().</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qlatin1stringview.xml#sliced">sliced</db:link>()</db:member>
<db:member><db:link xlink:href="qlatin1stringview.xml#first">first</db:link>()</db:member>
<db:member><db:link xlink:href="qlatin1stringview.xml#last">last</db:link>()</db:member>
<db:member><db:link xlink:href="qlatin1stringview.xml#chop">chop</db:link>()</db:member>
<db:member><db:link xlink:href="qlatin1stringview.xml#truncate">truncate</db:link>()</db:member>
<db:member><db:link xlink:href="qlatin1stringview.xml#slice">slice</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="compare-4">
<db:title>[noexcept, since 6.5] int QLatin1StringView::compare(QUtf8StringView <db:emphasis>str</db:emphasis>, Qt::CaseSensitivity <db:emphasis>cs</db:emphasis> = Qt::CaseSensitive) const</db:title>
<db:para>Compares this string view with <db:code role="parameter">str</db:code> and returns a negative integer if this string view is less than <db:code role="parameter">str</db:code>, a positive integer if it is greater than <db:code role="parameter">str</db:code>, and zero if they are equal.</db:para>
<db:para>If <db:code role="parameter">cs</db:code> is <db:link xlink:href="qt.xml#CaseSensitivity-enum">Qt::CaseSensitive</db:link> (the default), the comparison is case-sensitive; otherwise the comparison is case-insensitive.</db:para>
<db:para>This function was introduced in Qt 6.5.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qlatin1stringview.xml#operator-eq-eq">operator==</db:link>()</db:member>
<db:member><db:link xlink:href="qlatin1stringview.xml#operator-lt">operator&lt;</db:link>()</db:member>
<db:member><db:link xlink:href="qlatin1stringview.xml#operator-gt">operator&gt;</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="constBegin">
<db:title>[constexpr noexcept, since 6.4] const char *QLatin1StringView::constBegin() const</db:title>
<db:para>Same as <db:link xlink:href="qlatin1stringview.xml#begin">begin</db:link>().</db:para>
<db:para>This function is provided for compatibility with other Qt containers.</db:para>
<db:para>This function was introduced in Qt 6.4.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qlatin1stringview.xml#constEnd">constEnd</db:link>()</db:member>
<db:member><db:link xlink:href="qlatin1stringview.xml#begin">begin</db:link>()</db:member>
<db:member><db:link xlink:href="qlatin1stringview.xml#cbegin">cbegin</db:link>()</db:member>
<db:member><db:link xlink:href="qlatin1stringview.xml#data">data</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="constData">
<db:title>[constexpr noexcept, since 6.4] const char *QLatin1StringView::constData() const</db:title>
<db:para>Returns the start of the Latin-1 string referenced by this object.</db:para>
<db:para>This function is provided for compatibility with other Qt containers.</db:para>
<db:para>This function was introduced in Qt 6.4.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qlatin1stringview.xml#data">data</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="constEnd">
<db:title>[constexpr noexcept, since 6.4] const char *QLatin1StringView::constEnd() const</db:title>
<db:para>Same as <db:link xlink:href="qlatin1stringview.xml#end">end</db:link>().</db:para>
<db:para>This function is provided for compatibility with other Qt containers.</db:para>
<db:para>This function was introduced in Qt 6.4.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qlatin1stringview.xml#constBegin">constBegin</db:link>()</db:member>
<db:member><db:link xlink:href="qlatin1stringview.xml#end">end</db:link>()</db:member>
<db:member><db:link xlink:href="qlatin1stringview.xml#cend">cend</db:link>()</db:member>
<db:member><db:link xlink:href="qlatin1stringview.xml#crend">crend</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="crbegin">
<db:title>[noexcept] QLatin1StringView::const_reverse_iterator QLatin1StringView::crbegin() const</db:title>
<db:para>Same as <db:link xlink:href="qlatin1stringview.xml#rbegin">rbegin</db:link>().</db:para>
<db:para>This function is provided for STL compatibility.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qlatin1stringview.xml#crend">crend</db:link>()</db:member>
<db:member><db:link xlink:href="qlatin1stringview.xml#rbegin">rbegin</db:link>()</db:member>
<db:member><db:link xlink:href="qlatin1stringview.xml#cbegin">cbegin</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="crend">
<db:title>[noexcept] QLatin1StringView::const_reverse_iterator QLatin1StringView::crend() const</db:title>
<db:para>Same as <db:link xlink:href="qlatin1stringview.xml#rend">rend</db:link>().</db:para>
<db:para>This function is provided for STL compatibility.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qlatin1stringview.xml#crbegin">crbegin</db:link>()</db:member>
<db:member><db:link xlink:href="qlatin1stringview.xml#rend">rend</db:link>()</db:member>
<db:member><db:link xlink:href="qlatin1stringview.xml#cend">cend</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="data">
<db:title>[constexpr noexcept] const char *QLatin1StringView::data() const</db:title>
<db:para>Returns the start of the Latin-1 string referenced by this object.</db:para>
</db:section>
<db:section xml:id="empty">
<db:title>[constexpr noexcept, since 6.4] bool QLatin1StringView::empty() const</db:title>
<db:para>Returns whether the Latin-1 string referenced by this object is empty (<db:code>size() == 0</db:code>) or not.</db:para>
<db:para>This function is provided for STL compatibility.</db:para>
<db:para>This function was introduced in Qt 6.4.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qlatin1stringview.xml#isEmpty">isEmpty</db:link>()</db:member>
<db:member><db:link xlink:href="qlatin1stringview.xml#isNull">isNull</db:link>()</db:member>
<db:member><db:link xlink:href="qlatin1stringview.xml#size">size</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="end">
<db:title>[constexpr noexcept] QLatin1StringView::const_iterator QLatin1StringView::end() const</db:title>
<db:para>Returns a const <db:link xlink:href="containers.xml#stl-style-iterators">STL-style iterator</db:link> pointing just after the last character in the string.</db:para>
<db:para>This function is provided for STL compatibility.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qlatin1stringview.xml#begin">begin</db:link>()</db:member>
<db:member><db:link xlink:href="qlatin1stringview.xml#cend">cend</db:link>()</db:member>
<db:member><db:link xlink:href="qlatin1stringview.xml#rend">rend</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="first">
<db:title>[constexpr, since 6.4] QLatin1Char QLatin1StringView::first() const</db:title>
<db:para>Returns the first character in the string. Same as <db:code>at(0)</db:code> or <db:link xlink:href="qlatin1stringview.xml#front">front</db:link>().</db:para>
<db:para>This function is provided for compatibility with other Qt containers.</db:para>
<db:warning>
<db:para>Calling this function on an empty string constitutes undefined behavior.</db:para>
</db:warning>
<db:para>This function was introduced in Qt 6.4.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qlatin1stringview.xml#last">last</db:link>()</db:member>
<db:member><db:link xlink:href="qlatin1stringview.xml#front">front</db:link>()</db:member>
<db:member><db:link xlink:href="qlatin1stringview.xml#back">back</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="first-1">
<db:title>[constexpr, since 6.0] QLatin1StringView QLatin1StringView::first(qsizetype <db:emphasis>n</db:emphasis>) const</db:title>
<db:para>Returns a Latin-1 string view that contains the first <db:code role="parameter">n</db:code> characters of this string view.</db:para>
<db:note>
<db:para>The behavior is undefined when <db:code role="parameter">n</db:code> &lt; 0 or <db:code role="parameter">n</db:code> &gt; <db:link xlink:href="qlatin1stringview.xml#size">size</db:link>().</db:para>
</db:note>
<db:para>This function was introduced in Qt 6.0.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qlatin1stringview.xml#last">last</db:link>()</db:member>
<db:member><db:link xlink:href="qlatin1stringview.xml#startsWith">startsWith</db:link>()</db:member>
<db:member><db:link xlink:href="qlatin1stringview.xml#chopped">chopped</db:link>()</db:member>
<db:member><db:link xlink:href="qlatin1stringview.xml#chop">chop</db:link>()</db:member>
<db:member><db:link xlink:href="qlatin1stringview.xml#truncate">truncate</db:link>()</db:member>
<db:member><db:link xlink:href="qlatin1stringview.xml#slice">slice</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="front">
<db:title>[constexpr] QLatin1Char QLatin1StringView::front() const</db:title>
<db:para>Returns the first character in the string. Same as <db:code>at(0)</db:code>.</db:para>
<db:para>This function is provided for STL compatibility.</db:para>
<db:warning>
<db:para>Calling this function on an empty string constitutes undefined behavior.</db:para>
</db:warning>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qlatin1stringview.xml#back">back</db:link>()</db:member>
<db:member><db:link xlink:href="qlatin1stringview.xml#at">at</db:link>()</db:member>
<db:member><db:link xlink:href="qlatin1stringview.xml#operator-5b-5d">operator[]</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="isEmpty">
<db:title>[constexpr noexcept] bool QLatin1StringView::isEmpty() const</db:title>
<db:para>Returns whether the Latin-1 string referenced by this object is empty (<db:code>size() == 0</db:code>) or not.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qlatin1stringview.xml#isNull">isNull</db:link>()</db:member>
<db:member><db:link xlink:href="qlatin1stringview.xml#size">size</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="isNull">
<db:title>[constexpr noexcept] bool QLatin1StringView::isNull() const</db:title>
<db:para>Returns whether the Latin-1 string referenced by this object is null (<db:code>data() == nullptr</db:code>) or not.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qlatin1stringview.xml#isEmpty">isEmpty</db:link>()</db:member>
<db:member><db:link xlink:href="qlatin1stringview.xml#data">data</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="last">
<db:title>[constexpr, since 6.4] QLatin1Char QLatin1StringView::last() const</db:title>
<db:para>Returns the last character in the string. Same as <db:code>at(size() - 1)</db:code> or <db:link xlink:href="qlatin1stringview.xml#back">back</db:link>().</db:para>
<db:para>This function is provided for compatibility with other Qt containers.</db:para>
<db:warning>
<db:para>Calling this function on an empty string constitutes undefined behavior.</db:para>
</db:warning>
<db:para>This function was introduced in Qt 6.4.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qlatin1stringview.xml#first">first</db:link>()</db:member>
<db:member><db:link xlink:href="qlatin1stringview.xml#back">back</db:link>()</db:member>
<db:member><db:link xlink:href="qlatin1stringview.xml#front">front</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="last-1">
<db:title>[constexpr, since 6.0] QLatin1StringView QLatin1StringView::last(qsizetype <db:emphasis>n</db:emphasis>) const</db:title>
<db:para>Returns a Latin-1 string view that contains the last <db:code role="parameter">n</db:code> characters of this string view.</db:para>
<db:note>
<db:para>The behavior is undefined when <db:code role="parameter">n</db:code> &lt; 0 or <db:code role="parameter">n</db:code> &gt; <db:link xlink:href="qlatin1stringview.xml#size">size</db:link>().</db:para>
</db:note>
<db:para>This function was introduced in Qt 6.0.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qlatin1stringview.xml#first">first</db:link>()</db:member>
<db:member><db:link xlink:href="qlatin1stringview.xml#endsWith">endsWith</db:link>()</db:member>
<db:member><db:link xlink:href="qlatin1stringview.xml#chopped">chopped</db:link>()</db:member>
<db:member><db:link xlink:href="qlatin1stringview.xml#chop">chop</db:link>()</db:member>
<db:member><db:link xlink:href="qlatin1stringview.xml#truncate">truncate</db:link>()</db:member>
<db:member><db:link xlink:href="qlatin1stringview.xml#slice">slice</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="lastIndexOf-3">
<db:title>[noexcept, since 6.3] qsizetype QLatin1StringView::lastIndexOf(QChar <db:emphasis>ch</db:emphasis>, Qt::CaseSensitivity <db:emphasis>cs</db:emphasis> = Qt::CaseSensitive) const</db:title>
<db:para>This is an overloaded function.</db:para>
<db:para>This function was introduced in Qt 6.3.</db:para>
</db:section>
<db:section xml:id="latin1">
<db:title>[constexpr noexcept] const char *QLatin1StringView::latin1() const</db:title>
<db:para>Returns the start of the Latin-1 string referenced by this object.</db:para>
</db:section>
<db:section xml:id="left">
<db:title>[constexpr] QLatin1StringView QLatin1StringView::left(qsizetype <db:emphasis>length</db:emphasis>) const</db:title>
<db:para>If you know that <db:code role="parameter">length</db:code> cannot be out of bounds, use <db:link xlink:href="qlatin1stringview.xml#first">first</db:link>() instead in new code, because it is faster.</db:para>
<db:para>Returns the substring of length <db:code role="parameter">length</db:code> starting at position 0 in this Latin-1 string view.</db:para>
<db:para>The entire Latin-1 string view is returned if <db:code role="parameter">length</db:code> is greater than or equal to <db:link xlink:href="qlatin1stringview.xml#size">size</db:link>(), or less than zero.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qlatin1stringview.xml#first">first</db:link>()</db:member>
<db:member><db:link xlink:href="qlatin1stringview.xml#last">last</db:link>()</db:member>
<db:member><db:link xlink:href="qlatin1stringview.xml#sliced">sliced</db:link>()</db:member>
<db:member><db:link xlink:href="qlatin1stringview.xml#startsWith">startsWith</db:link>()</db:member>
<db:member><db:link xlink:href="qlatin1stringview.xml#chopped">chopped</db:link>()</db:member>
<db:member><db:link xlink:href="qlatin1stringview.xml#chop">chop</db:link>()</db:member>
<db:member><db:link xlink:href="qlatin1stringview.xml#truncate">truncate</db:link>()</db:member>
<db:member><db:link xlink:href="qlatin1stringview.xml#slice">slice</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="length">
<db:title>[constexpr noexcept, since 6.4] qsizetype QLatin1StringView::length() const</db:title>
<db:para>Same as <db:link xlink:href="qlatin1stringview.xml#size">size</db:link>().</db:para>
<db:para>This function is provided for compatibility with other Qt containers.</db:para>
<db:para>This function was introduced in Qt 6.4.</db:para>
</db:section>
<db:section xml:id="maxSize">
<db:title>[static constexpr noexcept, since 6.8] qsizetype QLatin1StringView::maxSize()</db:title>
<db:para>It returns the maximum number of elements that the string view can theoretically represent. In practice, the number can be much smaller, limited by the amount of memory available to the system.</db:para>
<db:para>This function was introduced in Qt 6.8.</db:para>
</db:section>
<db:section xml:id="max_size">
<db:title>[constexpr noexcept, since 6.8] qsizetype QLatin1StringView::max_size() const</db:title>
<db:para>This function is provided for STL compatibility.</db:para>
<db:para>Returns <db:link xlink:href="qlatin1stringview.xml#maxSize">maxSize</db:link>().</db:para>
<db:para>This function was introduced in Qt 6.8.</db:para>
</db:section>
<db:section xml:id="mid">
<db:title>[constexpr] QLatin1StringView QLatin1StringView::mid(qsizetype <db:emphasis>start</db:emphasis>, qsizetype <db:emphasis>length</db:emphasis> = -1) const</db:title>
<db:para>Returns the substring of length <db:code role="parameter">length</db:code> starting at position <db:code role="parameter">start</db:code> in this Latin-1 string view.</db:para>
<db:para>If you know that <db:code role="parameter">start</db:code> and <db:code role="parameter">length</db:code> cannot be out of bounds, use <db:link xlink:href="qlatin1stringview.xml#sliced">sliced</db:link>() instead in new code, because it is faster.</db:para>
<db:para>Returns an empty Latin-1 string view if <db:code role="parameter">start</db:code> exceeds the length of this string view. If there are less than <db:code role="parameter">length</db:code> characters available in this string view starting at <db:code role="parameter">start</db:code>, or if <db:code role="parameter">length</db:code> is negative (default), the function returns all characters that are available from <db:code role="parameter">start</db:code>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qlatin1stringview.xml#first">first</db:link>()</db:member>
<db:member><db:link xlink:href="qlatin1stringview.xml#last">last</db:link>()</db:member>
<db:member><db:link xlink:href="qlatin1stringview.xml#sliced">sliced</db:link>()</db:member>
<db:member><db:link xlink:href="qlatin1stringview.xml#chopped">chopped</db:link>()</db:member>
<db:member><db:link xlink:href="qlatin1stringview.xml#chop">chop</db:link>()</db:member>
<db:member><db:link xlink:href="qlatin1stringview.xml#truncate">truncate</db:link>()</db:member>
<db:member><db:link xlink:href="qlatin1stringview.xml#slice">slice</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="rbegin">
<db:title>[noexcept] QLatin1StringView::const_reverse_iterator QLatin1StringView::rbegin() const</db:title>
<db:para>Returns a const <db:link xlink:href="containers.xml#stl-style-iterators">STL-style</db:link> reverse iterator pointing to the first character in the string, in reverse order.</db:para>
<db:para>This function is provided for STL compatibility.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qlatin1stringview.xml#rend">rend</db:link>()</db:member>
<db:member><db:link xlink:href="qlatin1stringview.xml#crbegin">crbegin</db:link>()</db:member>
<db:member><db:link xlink:href="qlatin1stringview.xml#begin">begin</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="rend">
<db:title>[noexcept] QLatin1StringView::const_reverse_iterator QLatin1StringView::rend() const</db:title>
<db:para>Returns a <db:link xlink:href="containers.xml#stl-style-iterators">STL-style</db:link> reverse iterator pointing just after the last character in the string, in reverse order.</db:para>
<db:para>This function is provided for STL compatibility.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qlatin1stringview.xml#rbegin">rbegin</db:link>()</db:member>
<db:member><db:link xlink:href="qlatin1stringview.xml#crend">crend</db:link>()</db:member>
<db:member><db:link xlink:href="qlatin1stringview.xml#end">end</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="right">
<db:title>[constexpr] QLatin1StringView QLatin1StringView::right(qsizetype <db:emphasis>length</db:emphasis>) const</db:title>
<db:para>If you know that <db:code role="parameter">length</db:code> cannot be out of bounds, use <db:link xlink:href="qlatin1stringview.xml#last">last</db:link>() instead in new code, because it is faster.</db:para>
<db:para>Returns the substring of length <db:code role="parameter">length</db:code> starting at position <db:link xlink:href="qlatin1stringview.xml#size">size</db:link>() - <db:code role="parameter">length</db:code> in this Latin-1 string view.</db:para>
<db:para>The entire Latin-1 string view is returned if <db:code role="parameter">length</db:code> is greater than or equal to <db:link xlink:href="qlatin1stringview.xml#size">size</db:link>(), or less than zero.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qlatin1stringview.xml#first">first</db:link>()</db:member>
<db:member><db:link xlink:href="qlatin1stringview.xml#last">last</db:link>()</db:member>
<db:member><db:link xlink:href="qlatin1stringview.xml#sliced">sliced</db:link>()</db:member>
<db:member><db:link xlink:href="qlatin1stringview.xml#endsWith">endsWith</db:link>()</db:member>
<db:member><db:link xlink:href="qlatin1stringview.xml#chopped">chopped</db:link>()</db:member>
<db:member><db:link xlink:href="qlatin1stringview.xml#chop">chop</db:link>()</db:member>
<db:member><db:link xlink:href="qlatin1stringview.xml#truncate">truncate</db:link>()</db:member>
<db:member><db:link xlink:href="qlatin1stringview.xml#slice">slice</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="size">
<db:title>[constexpr noexcept] qsizetype QLatin1StringView::size() const</db:title>
<db:para>Returns the size of the Latin-1 string referenced by this object.</db:para>
<db:note>
<db:para>In version prior to Qt 6, this function returned <db:code>int</db:code>, restricting the amount of data that could be held in a <db:link xlink:href="qlatin1stringview.xml">QLatin1StringView</db:link> on 64-bit architectures.</db:para>
</db:note>
</db:section>
<db:section xml:id="slice">
<db:title>[constexpr, since 6.8] QLatin1StringView &amp;QLatin1StringView::slice(qsizetype <db:emphasis>pos</db:emphasis>)</db:title>
<db:para>Modifies this Latin-1 string view to start at position <db:code role="parameter">pos</db:code>, extending to its end.</db:para>
<db:note>
<db:para>The behavior is undefined when <db:code role="parameter">pos</db:code> &lt; 0 or <db:code role="parameter">pos</db:code> &gt; <db:link xlink:href="qlatin1stringview.xml#size">size</db:link>().</db:para>
</db:note>
<db:para>This function was introduced in Qt 6.8.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qlatin1stringview.xml#sliced">sliced</db:link>()</db:member>
<db:member><db:link xlink:href="qlatin1stringview.xml#first">first</db:link>()</db:member>
<db:member><db:link xlink:href="qlatin1stringview.xml#last">last</db:link>()</db:member>
<db:member><db:link xlink:href="qlatin1stringview.xml#chopped">chopped</db:link>()</db:member>
<db:member><db:link xlink:href="qlatin1stringview.xml#chop">chop</db:link>()</db:member>
<db:member><db:link xlink:href="qlatin1stringview.xml#truncate">truncate</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="slice-1">
<db:title>[constexpr, since 6.8] QLatin1StringView &amp;QLatin1StringView::slice(qsizetype <db:emphasis>pos</db:emphasis>, qsizetype <db:emphasis>n</db:emphasis>)</db:title>
<db:para>This is an overloaded function.</db:para>
<db:para>Modifies this Latin-1 string view to start at position <db:code role="parameter">pos</db:code>, extending for <db:code role="parameter">n</db:code> characters.</db:para>
<db:note>
<db:para>The behavior is undefined when <db:code role="parameter">pos</db:code> &lt; 0, <db:code role="parameter">n</db:code> &lt; 0, or <db:code>pos + n &gt; size()</db:code>.</db:para>
</db:note>
<db:para>This function was introduced in Qt 6.8.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qlatin1stringview.xml#sliced">sliced</db:link>()</db:member>
<db:member><db:link xlink:href="qlatin1stringview.xml#first">first</db:link>()</db:member>
<db:member><db:link xlink:href="qlatin1stringview.xml#last">last</db:link>()</db:member>
<db:member><db:link xlink:href="qlatin1stringview.xml#chopped">chopped</db:link>()</db:member>
<db:member><db:link xlink:href="qlatin1stringview.xml#chop">chop</db:link>()</db:member>
<db:member><db:link xlink:href="qlatin1stringview.xml#truncate">truncate</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="sliced">
<db:title>[constexpr, since 6.0] QLatin1StringView QLatin1StringView::sliced(qsizetype <db:emphasis>pos</db:emphasis>) const</db:title>
<db:para>Returns a Latin-1 string view starting at position <db:code role="parameter">pos</db:code> in this string view, and extending to its end.</db:para>
<db:note>
<db:para>The behavior is undefined when <db:code role="parameter">pos</db:code> &lt; 0 or <db:code role="parameter">pos</db:code> &gt; <db:link xlink:href="qlatin1stringview.xml#size">size</db:link>().</db:para>
</db:note>
<db:para>This function was introduced in Qt 6.0.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qlatin1stringview.xml#first">first</db:link>()</db:member>
<db:member><db:link xlink:href="qlatin1stringview.xml#last">last</db:link>()</db:member>
<db:member><db:link xlink:href="qlatin1stringview.xml#chopped">chopped</db:link>()</db:member>
<db:member><db:link xlink:href="qlatin1stringview.xml#chop">chop</db:link>()</db:member>
<db:member><db:link xlink:href="qlatin1stringview.xml#truncate">truncate</db:link>()</db:member>
<db:member><db:link xlink:href="qlatin1stringview.xml#slice">slice</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="sliced-1">
<db:title>[constexpr, since 6.0] QLatin1StringView QLatin1StringView::sliced(qsizetype <db:emphasis>pos</db:emphasis>, qsizetype <db:emphasis>n</db:emphasis>) const</db:title>
<db:para>Returns a Latin-1 string view that points to <db:code role="parameter">n</db:code> characters of this string view, starting at position <db:code role="parameter">pos</db:code>.</db:para>
<db:note>
<db:para>The behavior is undefined when <db:code role="parameter">pos</db:code> &lt; 0, <db:code role="parameter">n</db:code> &lt; 0, or <db:code>pos + n &gt; size()</db:code>.</db:para>
</db:note>
<db:para>This function was introduced in Qt 6.0.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qlatin1stringview.xml#first">first</db:link>()</db:member>
<db:member><db:link xlink:href="qlatin1stringview.xml#last">last</db:link>()</db:member>
<db:member><db:link xlink:href="qlatin1stringview.xml#chopped">chopped</db:link>()</db:member>
<db:member><db:link xlink:href="qlatin1stringview.xml#chop">chop</db:link>()</db:member>
<db:member><db:link xlink:href="qlatin1stringview.xml#truncate">truncate</db:link>()</db:member>
<db:member><db:link xlink:href="qlatin1stringview.xml#slice">slice</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="toString">
<db:title>[since 6.0] QString QLatin1StringView::toString() const</db:title>
<db:para>Converts this Latin-1 string into a <db:link xlink:href="qstring.xml">QString</db:link>. Equivalent to</db:para>
<db:programlisting language="cpp">return QString(*this);
</db:programlisting>
<db:para>This function was introduced in Qt 6.0.</db:para>
</db:section>
<db:section xml:id="trimmed">
<db:title>[noexcept] QLatin1StringView QLatin1StringView::trimmed() const</db:title>
<db:para>Strips leading and trailing whitespace and returns the result.</db:para>
<db:para>Whitespace means any character for which <db:link xlink:href="qchar.xml#isSpace">QChar::isSpace</db:link>() returns <db:code>true</db:code>. This includes the ASCII characters '\t', '\n', '\v', '\f', '\r', and ' '.</db:para>
</db:section>
<db:section xml:id="truncate">
<db:title>[constexpr] void QLatin1StringView::truncate(qsizetype <db:emphasis>length</db:emphasis>)</db:title>
<db:para>Truncates this string to length <db:code role="parameter">length</db:code>.</db:para>
<db:para>Same as <db:code>*this = left(length)</db:code>.</db:para>
<db:note>
<db:para>The behavior is undefined when <db:code role="parameter">length</db:code> &lt; 0 or <db:code role="parameter">length</db:code> &gt; <db:link xlink:href="qlatin1stringview.xml#size">size</db:link>().</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qlatin1stringview.xml#sliced">sliced</db:link>()</db:member>
<db:member><db:link xlink:href="qlatin1stringview.xml#first">first</db:link>()</db:member>
<db:member><db:link xlink:href="qlatin1stringview.xml#last">last</db:link>()</db:member>
<db:member><db:link xlink:href="qlatin1stringview.xml#chopped">chopped</db:link>()</db:member>
<db:member><db:link xlink:href="qlatin1stringview.xml#chop">chop</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="operator-5b-5d">
<db:title>[constexpr] QLatin1Char QLatin1StringView::operator[](qsizetype <db:emphasis>pos</db:emphasis>) const</db:title>
<db:para>Returns the character at position <db:code role="parameter">pos</db:code> in this object.</db:para>
<db:note>
<db:para>This function performs no error checking. The behavior is undefined when <db:code role="parameter">pos</db:code> &lt; 0 or <db:code role="parameter">pos</db:code> &gt;= <db:link xlink:href="qlatin1stringview.xml#size">size</db:link>().</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qlatin1stringview.xml#at">at</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
</db:section>
<db:section xml:id="related-non-members">
<db:title>Related Non-Members</db:title>
<db:section xml:id="operator-not-eq">
<db:title>[noexcept] bool operator!=(const QChar &amp;<db:emphasis>lhs</db:emphasis>, const QLatin1StringView &amp;<db:emphasis>rhs</db:emphasis>)</db:title>
<db:para>Returns <db:code>true</db:code> if char <db:code role="parameter">lhs</db:code> is lexically not equal to string <db:code role="parameter">rhs</db:code>; otherwise returns <db:code>false</db:code>.</db:para>
</db:section>
<db:section xml:id="operator-not-eq-1">
<db:title>[noexcept] bool operator!=(const QLatin1StringView &amp;<db:emphasis>lhs</db:emphasis>, const QChar &amp;<db:emphasis>rhs</db:emphasis>)</db:title>
<db:para>Returns <db:code>true</db:code> if string <db:code role="parameter">lhs</db:code> is lexically not equal to char <db:code role="parameter">rhs</db:code>; otherwise returns <db:code>false</db:code>.</db:para>
</db:section>
<db:section xml:id="operator-not-eq-2">
<db:title>[noexcept] bool operator!=(const QLatin1StringView &amp;<db:emphasis>lhs</db:emphasis>, const QLatin1StringView &amp;<db:emphasis>rhs</db:emphasis>)</db:title>
<db:para>Returns <db:code>true</db:code> if string <db:code role="parameter">lhs</db:code> is lexically not equal to string <db:code role="parameter">rhs</db:code>; otherwise returns <db:code>false</db:code>.</db:para>
</db:section>
<db:section xml:id="operator-not-eq-3">
<db:title>[noexcept] bool operator!=(const QLatin1StringView &amp;<db:emphasis>lhs</db:emphasis>, const QStringView &amp;<db:emphasis>rhs</db:emphasis>)</db:title>
<db:para>Returns <db:code>true</db:code> if string <db:code role="parameter">lhs</db:code> is lexically not equal to string view <db:code role="parameter">rhs</db:code>; otherwise returns <db:code>false</db:code>.</db:para>
</db:section>
<db:section xml:id="operator-not-eq-4">
<db:title>[noexcept] bool operator!=(const QLatin1StringView &amp;<db:emphasis>lhs</db:emphasis>, const char *const &amp;<db:emphasis>rhs</db:emphasis>)</db:title>
<db:para>Returns <db:code>true</db:code> if the string <db:code role="parameter">lhs</db:code> is not equal to const char pointer <db:code role="parameter">rhs</db:code>; otherwise returns <db:code>false</db:code>.</db:para>
<db:para>The <db:code role="parameter">rhs</db:code> const char pointer is converted to a <db:link xlink:href="qutf8stringview.xml">QUtf8StringView</db:link>.</db:para>
<db:para>You can disable this operator by defining <db:link xlink:href="qstring.xml#QT_NO_CAST_FROM_ASCII">QT_NO_CAST_FROM_ASCII</db:link> when you compile your applications. This can be useful if you want to ensure that all user-visible strings go through <db:link xlink:href="qobject.xml#tr">QObject::tr</db:link>(), for example.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qstring.xml#comparing-strings">Comparing Strings</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="operator-not-eq-5">
<db:title>[noexcept] bool operator!=(const QStringView &amp;<db:emphasis>lhs</db:emphasis>, const QLatin1StringView &amp;<db:emphasis>rhs</db:emphasis>)</db:title>
<db:para>Returns <db:code>true</db:code> if string view <db:code role="parameter">lhs</db:code> is lexically not equal to string <db:code role="parameter">rhs</db:code>; otherwise returns <db:code>false</db:code>.</db:para>
</db:section>
<db:section xml:id="operator-not-eq-6">
<db:title>[noexcept] bool operator!=(const char *const &amp;<db:emphasis>lhs</db:emphasis>, const QLatin1StringView &amp;<db:emphasis>rhs</db:emphasis>)</db:title>
<db:para>Returns <db:code>true</db:code> if const char pointer <db:code role="parameter">lhs</db:code> is lexically not equal to string <db:code role="parameter">rhs</db:code>; otherwise returns <db:code>false</db:code>.</db:para>
</db:section>
<db:section xml:id="operator-not-eq-10">
<db:title>[noexcept] bool operator!=(const QLatin1StringView &amp;<db:emphasis>lhs</db:emphasis>, const QByteArray &amp;<db:emphasis>rhs</db:emphasis>)</db:title>
<db:para>This function overloads <db:link xlink:href="qlatin1stringview.xml#operator-not-eq">operator!=</db:link>().</db:para>
<db:para>The <db:code role="parameter">rhs</db:code> byte array is converted to a <db:link xlink:href="qutf8stringview.xml">QUtf8StringView</db:link>.</db:para>
<db:para>You can disable this operator by defining <db:link xlink:href="qstring.xml#QT_NO_CAST_FROM_ASCII">QT_NO_CAST_FROM_ASCII</db:link> when you compile your applications. This can be useful if you want to ensure that all user-visible strings go through <db:link xlink:href="qobject.xml#tr">QObject::tr</db:link>(), for example.</db:para>
</db:section>
<db:section xml:id="operator-22-22_L1-1">
<db:title>[constexpr noexcept, since 6.4] QLatin1StringView operator&quot;&quot;_L1(const char *<db:emphasis>str</db:emphasis>, size_t <db:emphasis>size</db:emphasis>)</db:title>
<db:para>Literal operator that creates a <db:link xlink:href="qlatin1stringview.xml">QLatin1StringView</db:link> out of the first <db:code role="parameter">size</db:code> characters in the char string literal <db:code role="parameter">str</db:code>.</db:para>
<db:para>The following code creates a <db:link xlink:href="qlatin1stringview.xml">QLatin1StringView</db:link>:</db:para>
<db:programlisting language="cpp">using namespace Qt::Literals::StringLiterals;

auto str = &quot;hello&quot;_L1;
</db:programlisting>
<db:para>This function was introduced in Qt 6.4.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qt-literals-stringliterals.xml">Qt::Literals::StringLiterals</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="operator-lt">
<db:title>[noexcept] bool operator&lt;(const QChar &amp;<db:emphasis>lhs</db:emphasis>, const QLatin1StringView &amp;<db:emphasis>rhs</db:emphasis>)</db:title>
<db:para>Returns <db:code>true</db:code> if char <db:code role="parameter">lhs</db:code> is lexically less than string <db:code role="parameter">rhs</db:code>; otherwise returns <db:code>false</db:code>.</db:para>
</db:section>
<db:section xml:id="operator-lt-1">
<db:title>[noexcept] bool operator&lt;(const QLatin1StringView &amp;<db:emphasis>lhs</db:emphasis>, const QChar &amp;<db:emphasis>rhs</db:emphasis>)</db:title>
<db:para>Returns <db:code>true</db:code> if string <db:code role="parameter">lhs</db:code> is lexically less than char <db:code role="parameter">rhs</db:code>; otherwise returns <db:code>false</db:code>.</db:para>
</db:section>
<db:section xml:id="operator-lt-2">
<db:title>[noexcept] bool operator&lt;(const QLatin1StringView &amp;<db:emphasis>lhs</db:emphasis>, const QLatin1StringView &amp;<db:emphasis>rhs</db:emphasis>)</db:title>
<db:para>Returns <db:code>true</db:code> if string <db:code role="parameter">lhs</db:code> is lexically less than string <db:code role="parameter">rhs</db:code>; otherwise returns <db:code>false</db:code>.</db:para>
</db:section>
<db:section xml:id="operator-lt-3">
<db:title>[noexcept] bool operator&lt;(const QLatin1StringView &amp;<db:emphasis>lhs</db:emphasis>, const QStringView &amp;<db:emphasis>rhs</db:emphasis>)</db:title>
<db:para>Returns <db:code>true</db:code> if string <db:code role="parameter">lhs</db:code> is lexically less than string view <db:code role="parameter">rhs</db:code>; otherwise returns <db:code>false</db:code>.</db:para>
</db:section>
<db:section xml:id="operator-lt-4">
<db:title>[noexcept] bool operator&lt;(const QLatin1StringView &amp;<db:emphasis>lhs</db:emphasis>, const char *const &amp;<db:emphasis>rhs</db:emphasis>)</db:title>
<db:para>Returns <db:code>true</db:code> if the string <db:code role="parameter">lhs</db:code> is lexically less than const char pointer <db:code role="parameter">rhs</db:code>; otherwise returns <db:code>false</db:code>.</db:para>
<db:para>The <db:code role="parameter">rhs</db:code> const char pointer is converted to a <db:link xlink:href="qutf8stringview.xml">QUtf8StringView</db:link>.</db:para>
<db:para>You can disable this operator by defining <db:link xlink:href="qstring.xml#QT_NO_CAST_FROM_ASCII">QT_NO_CAST_FROM_ASCII</db:link> when you compile your applications. This can be useful if you want to ensure that all user-visible strings go through <db:link xlink:href="qobject.xml#tr">QObject::tr</db:link>(), for example.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qstring.xml#comparing-strings">Comparing Strings</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="operator-lt-5">
<db:title>[noexcept] bool operator&lt;(const QStringView &amp;<db:emphasis>lhs</db:emphasis>, const QLatin1StringView &amp;<db:emphasis>rhs</db:emphasis>)</db:title>
<db:para>Returns <db:code>true</db:code> if string view <db:code role="parameter">lhs</db:code> is lexically less than string <db:code role="parameter">rhs</db:code>; otherwise returns <db:code>false</db:code>.</db:para>
</db:section>
<db:section xml:id="operator-lt-6">
<db:title>[noexcept] bool operator&lt;(const char *const &amp;<db:emphasis>lhs</db:emphasis>, const QLatin1StringView &amp;<db:emphasis>rhs</db:emphasis>)</db:title>
<db:para>Returns <db:code>true</db:code> if const char pointer <db:code role="parameter">lhs</db:code> is lexically less than string <db:code role="parameter">rhs</db:code>; otherwise returns <db:code>false</db:code>.</db:para>
</db:section>
<db:section xml:id="operator-lt-10">
<db:title>[noexcept] bool operator&lt;(const QLatin1StringView &amp;<db:emphasis>lhs</db:emphasis>, const QByteArray &amp;<db:emphasis>rhs</db:emphasis>)</db:title>
<db:para>This is an overloaded function.</db:para>
<db:para>The <db:code role="parameter">rhs</db:code> byte array is converted to a <db:link xlink:href="qutf8stringview.xml">QUtf8StringView</db:link>.</db:para>
<db:para>You can disable this operator by defining <db:link xlink:href="qstring.xml#QT_NO_CAST_FROM_ASCII">QT_NO_CAST_FROM_ASCII</db:link> when you compile your applications. This can be useful if you want to ensure that all user-visible strings go through <db:link xlink:href="qobject.xml#tr">QObject::tr</db:link>(), for example.</db:para>
</db:section>
<db:section xml:id="operator-lt-eq">
<db:title>[noexcept] bool operator&lt;=(const QChar &amp;<db:emphasis>lhs</db:emphasis>, const QLatin1StringView &amp;<db:emphasis>rhs</db:emphasis>)</db:title>
<db:para>Returns <db:code>true</db:code> if char <db:code role="parameter">lhs</db:code> is lexically less than or equal to string <db:code role="parameter">rhs</db:code>; otherwise returns <db:code>false</db:code>.</db:para>
</db:section>
<db:section xml:id="operator-lt-eq-1">
<db:title>[noexcept] bool operator&lt;=(const QLatin1StringView &amp;<db:emphasis>lhs</db:emphasis>, const QChar &amp;<db:emphasis>rhs</db:emphasis>)</db:title>
<db:para>Returns <db:code>true</db:code> if string <db:code role="parameter">lhs</db:code> is lexically less than or equal to char <db:code role="parameter">rhs</db:code>; otherwise returns <db:code>false</db:code>.</db:para>
</db:section>
<db:section xml:id="operator-lt-eq-2">
<db:title>[noexcept] bool operator&lt;=(const QLatin1StringView &amp;<db:emphasis>lhs</db:emphasis>, const QLatin1StringView &amp;<db:emphasis>rhs</db:emphasis>)</db:title>
<db:para>Returns <db:code>true</db:code> if string <db:code role="parameter">lhs</db:code> is lexically less than or equal to string <db:code role="parameter">rhs</db:code>; otherwise returns <db:code>false</db:code>.</db:para>
</db:section>
<db:section xml:id="operator-lt-eq-3">
<db:title>[noexcept] bool operator&lt;=(const QLatin1StringView &amp;<db:emphasis>lhs</db:emphasis>, const QStringView &amp;<db:emphasis>rhs</db:emphasis>)</db:title>
<db:para>Returns <db:code>true</db:code> if string <db:code role="parameter">lhs</db:code> is lexically less than or equal to string view <db:code role="parameter">rhs</db:code>; otherwise returns <db:code>false</db:code>.</db:para>
</db:section>
<db:section xml:id="operator-lt-eq-4">
<db:title>[noexcept] bool operator&lt;=(const QLatin1StringView &amp;<db:emphasis>lhs</db:emphasis>, const char *const &amp;<db:emphasis>rhs</db:emphasis>)</db:title>
<db:para>Returns <db:code>true</db:code> if the string <db:code role="parameter">lhs</db:code> is lexically less than or equal to const char pointer <db:code role="parameter">rhs</db:code>; otherwise returns <db:code>false</db:code>.</db:para>
<db:para>The <db:code role="parameter">rhs</db:code> const char pointer is converted to a <db:link xlink:href="qutf8stringview.xml">QUtf8StringView</db:link>.</db:para>
<db:para>You can disable this operator by defining <db:link xlink:href="qstring.xml#QT_NO_CAST_FROM_ASCII">QT_NO_CAST_FROM_ASCII</db:link> when you compile your applications. This can be useful if you want to ensure that all user-visible strings go through <db:link xlink:href="qobject.xml#tr">QObject::tr</db:link>(), for example.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qstring.xml#comparing-strings">Comparing Strings</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="operator-lt-eq-5">
<db:title>[noexcept] bool operator&lt;=(const QStringView &amp;<db:emphasis>lhs</db:emphasis>, const QLatin1StringView &amp;<db:emphasis>rhs</db:emphasis>)</db:title>
<db:para>Returns <db:code>true</db:code> if string view <db:code role="parameter">lhs</db:code> is lexically less than or equal to string <db:code role="parameter">rhs</db:code>; otherwise returns <db:code>false</db:code>.</db:para>
</db:section>
<db:section xml:id="operator-lt-eq-6">
<db:title>[noexcept] bool operator&lt;=(const char *const &amp;<db:emphasis>lhs</db:emphasis>, const QLatin1StringView &amp;<db:emphasis>rhs</db:emphasis>)</db:title>
<db:para>Returns <db:code>true</db:code> if const char pointer <db:code role="parameter">lhs</db:code> is lexically less than or equal to string <db:code role="parameter">rhs</db:code>; otherwise returns <db:code>false</db:code>.</db:para>
</db:section>
<db:section xml:id="operator-lt-eq-10">
<db:title>[noexcept] bool operator&lt;=(const QLatin1StringView &amp;<db:emphasis>lhs</db:emphasis>, const QByteArray &amp;<db:emphasis>rhs</db:emphasis>)</db:title>
<db:para>This is an overloaded function.</db:para>
<db:para>The <db:code role="parameter">rhs</db:code> byte array is converted to a <db:link xlink:href="qutf8stringview.xml">QUtf8StringView</db:link>.</db:para>
<db:para>You can disable this operator by defining <db:link xlink:href="qstring.xml#QT_NO_CAST_FROM_ASCII">QT_NO_CAST_FROM_ASCII</db:link> when you compile your applications. This can be useful if you want to ensure that all user-visible strings go through <db:link xlink:href="qobject.xml#tr">QObject::tr</db:link>(), for example.</db:para>
</db:section>
<db:section xml:id="operator-eq-eq">
<db:title>[noexcept] bool operator==(const QChar &amp;<db:emphasis>lhs</db:emphasis>, const QLatin1StringView &amp;<db:emphasis>rhs</db:emphasis>)</db:title>
<db:para>Returns <db:code>true</db:code> if char <db:code role="parameter">lhs</db:code> is lexically equal to string <db:code role="parameter">rhs</db:code>; otherwise returns <db:code>false</db:code>.</db:para>
</db:section>
<db:section xml:id="operator-eq-eq-1">
<db:title>[noexcept] bool operator==(const QLatin1StringView &amp;<db:emphasis>lhs</db:emphasis>, const QChar &amp;<db:emphasis>rhs</db:emphasis>)</db:title>
<db:para>Returns <db:code>true</db:code> if string <db:code role="parameter">lhs</db:code> is lexically equal to char <db:code role="parameter">rhs</db:code>; otherwise returns <db:code>false</db:code>.</db:para>
</db:section>
<db:section xml:id="operator-eq-eq-2">
<db:title>[noexcept] bool operator==(const QLatin1StringView &amp;<db:emphasis>lhs</db:emphasis>, const QLatin1StringView &amp;<db:emphasis>rhs</db:emphasis>)</db:title>
<db:para>Returns <db:code>true</db:code> if string <db:code role="parameter">lhs</db:code> is lexically equal to string <db:code role="parameter">rhs</db:code>; otherwise returns <db:code>false</db:code>.</db:para>
</db:section>
<db:section xml:id="operator-eq-eq-3">
<db:title>[noexcept] bool operator==(const QLatin1StringView &amp;<db:emphasis>lhs</db:emphasis>, const QStringView &amp;<db:emphasis>rhs</db:emphasis>)</db:title>
<db:para>Returns <db:code>true</db:code> if string <db:code role="parameter">lhs</db:code> is lexically equal to string view <db:code role="parameter">rhs</db:code>; otherwise returns <db:code>false</db:code>.</db:para>
</db:section>
<db:section xml:id="operator-eq-eq-4">
<db:title>[noexcept] bool operator==(const QLatin1StringView &amp;<db:emphasis>lhs</db:emphasis>, const char *const &amp;<db:emphasis>rhs</db:emphasis>)</db:title>
<db:para>Returns <db:code>true</db:code> if the string <db:code role="parameter">lhs</db:code> is equal to const char pointer <db:code role="parameter">rhs</db:code>; otherwise returns <db:code>false</db:code>.</db:para>
<db:para>The <db:code role="parameter">rhs</db:code> const char pointer is converted to a <db:link xlink:href="qutf8stringview.xml">QUtf8StringView</db:link>.</db:para>
<db:para>You can disable this operator by defining <db:link xlink:href="qstring.xml#QT_NO_CAST_FROM_ASCII">QT_NO_CAST_FROM_ASCII</db:link> when you compile your applications. This can be useful if you want to ensure that all user-visible strings go through <db:link xlink:href="qobject.xml#tr">QObject::tr</db:link>(), for example.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qstring.xml#comparing-strings">Comparing Strings</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="operator-eq-eq-5">
<db:title>[noexcept] bool operator==(const QStringView &amp;<db:emphasis>lhs</db:emphasis>, const QLatin1StringView &amp;<db:emphasis>rhs</db:emphasis>)</db:title>
<db:para>Returns <db:code>true</db:code> if string view <db:code role="parameter">lhs</db:code> is lexically equal to string <db:code role="parameter">rhs</db:code>; otherwise returns <db:code>false</db:code>.</db:para>
</db:section>
<db:section xml:id="operator-eq-eq-6">
<db:title>[noexcept] bool operator==(const char *const &amp;<db:emphasis>lhs</db:emphasis>, const QLatin1StringView &amp;<db:emphasis>rhs</db:emphasis>)</db:title>
<db:para>Returns <db:code>true</db:code> if const char pointer <db:code role="parameter">lhs</db:code> is lexically equal to string <db:code role="parameter">rhs</db:code>; otherwise returns <db:code>false</db:code>.</db:para>
</db:section>
<db:section xml:id="operator-eq-eq-10">
<db:title>[noexcept] bool operator==(const QLatin1StringView &amp;<db:emphasis>lhs</db:emphasis>, const QByteArray &amp;<db:emphasis>rhs</db:emphasis>)</db:title>
<db:para>This is an overloaded function.</db:para>
<db:para>The <db:code role="parameter">rhs</db:code> byte array is converted to a <db:link xlink:href="qutf8stringview.xml">QUtf8StringView</db:link>.</db:para>
<db:para>You can disable this operator by defining <db:link xlink:href="qstring.xml#QT_NO_CAST_FROM_ASCII">QT_NO_CAST_FROM_ASCII</db:link> when you compile your applications. This can be useful if you want to ensure that all user-visible strings go through <db:link xlink:href="qobject.xml#tr">QObject::tr</db:link>(), for example.</db:para>
</db:section>
<db:section xml:id="operator-gt">
<db:title>[noexcept] bool operator&gt;(const QChar &amp;<db:emphasis>lhs</db:emphasis>, const QLatin1StringView &amp;<db:emphasis>rhs</db:emphasis>)</db:title>
<db:para>Returns <db:code>true</db:code> if char <db:code role="parameter">lhs</db:code> is lexically greater than string <db:code role="parameter">rhs</db:code>; otherwise returns <db:code>false</db:code>.</db:para>
</db:section>
<db:section xml:id="operator-gt-1">
<db:title>[noexcept] bool operator&gt;(const QLatin1StringView &amp;<db:emphasis>lhs</db:emphasis>, const QChar &amp;<db:emphasis>rhs</db:emphasis>)</db:title>
<db:para>Returns <db:code>true</db:code> if string <db:code role="parameter">lhs</db:code> is lexically greater than char <db:code role="parameter">rhs</db:code>; otherwise returns <db:code>false</db:code>.</db:para>
</db:section>
<db:section xml:id="operator-gt-2">
<db:title>[noexcept] bool operator&gt;(const QLatin1StringView &amp;<db:emphasis>lhs</db:emphasis>, const QLatin1StringView &amp;<db:emphasis>rhs</db:emphasis>)</db:title>
<db:para>Returns <db:code>true</db:code> if string <db:code role="parameter">lhs</db:code> is lexically greater than string <db:code role="parameter">rhs</db:code>; otherwise returns <db:code>false</db:code>.</db:para>
</db:section>
<db:section xml:id="operator-gt-3">
<db:title>[noexcept] bool operator&gt;(const QLatin1StringView &amp;<db:emphasis>lhs</db:emphasis>, const QStringView &amp;<db:emphasis>rhs</db:emphasis>)</db:title>
<db:para>Returns <db:code>true</db:code> if string <db:code role="parameter">lhs</db:code> is lexically greater than string view <db:code role="parameter">rhs</db:code>; otherwise returns <db:code>false</db:code>.</db:para>
</db:section>
<db:section xml:id="operator-gt-4">
<db:title>[noexcept] bool operator&gt;(const QLatin1StringView &amp;<db:emphasis>lhs</db:emphasis>, const char *const &amp;<db:emphasis>rhs</db:emphasis>)</db:title>
<db:para>Returns <db:code>true</db:code> if the string <db:code role="parameter">lhs</db:code> is lexically greater than const char pointer <db:code role="parameter">rhs</db:code>; otherwise returns <db:code>false</db:code>.</db:para>
<db:para>The <db:code role="parameter">rhs</db:code> const char pointer is converted to a <db:link xlink:href="qutf8stringview.xml">QUtf8StringView</db:link>.</db:para>
<db:para>You can disable this operator by defining <db:link xlink:href="qstring.xml#QT_NO_CAST_FROM_ASCII">QT_NO_CAST_FROM_ASCII</db:link> when you compile your applications. This can be useful if you want to ensure that all user-visible strings go through <db:link xlink:href="qobject.xml#tr">QObject::tr</db:link>(), for example.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qstring.xml#comparing-strings">Comparing Strings</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="operator-gt-5">
<db:title>[noexcept] bool operator&gt;(const QStringView &amp;<db:emphasis>lhs</db:emphasis>, const QLatin1StringView &amp;<db:emphasis>rhs</db:emphasis>)</db:title>
<db:para>Returns <db:code>true</db:code> if string view <db:code role="parameter">lhs</db:code> is lexically greater than string <db:code role="parameter">rhs</db:code>; otherwise returns <db:code>false</db:code>.</db:para>
</db:section>
<db:section xml:id="operator-gt-6">
<db:title>[noexcept] bool operator&gt;(const char *const &amp;<db:emphasis>lhs</db:emphasis>, const QLatin1StringView &amp;<db:emphasis>rhs</db:emphasis>)</db:title>
<db:para>Returns <db:code>true</db:code> if const char pointer <db:code role="parameter">lhs</db:code> is lexically greater than string <db:code role="parameter">rhs</db:code>; otherwise returns <db:code>false</db:code>.</db:para>
</db:section>
<db:section xml:id="operator-gt-10">
<db:title>[noexcept] bool operator&gt;(const QLatin1StringView &amp;<db:emphasis>lhs</db:emphasis>, const QByteArray &amp;<db:emphasis>rhs</db:emphasis>)</db:title>
<db:para>This is an overloaded function.</db:para>
<db:para>The <db:code role="parameter">rhs</db:code> byte array is converted to a <db:link xlink:href="qutf8stringview.xml">QUtf8StringView</db:link>.</db:para>
<db:para>You can disable this operator by defining <db:link xlink:href="qstring.xml#QT_NO_CAST_FROM_ASCII">QT_NO_CAST_FROM_ASCII</db:link> when you compile your applications. This can be useful if you want to ensure that all user-visible strings go through <db:link xlink:href="qobject.xml#tr">QObject::tr</db:link>(), for example.</db:para>
</db:section>
<db:section xml:id="operator-gt-eq">
<db:title>[noexcept] bool operator&gt;=(const QChar &amp;<db:emphasis>lhs</db:emphasis>, const QLatin1StringView &amp;<db:emphasis>rhs</db:emphasis>)</db:title>
<db:para>Returns <db:code>true</db:code> if char <db:code role="parameter">lhs</db:code> is lexically greater than or equal to string <db:code role="parameter">rhs</db:code>; otherwise returns <db:code>false</db:code>.</db:para>
</db:section>
<db:section xml:id="operator-gt-eq-1">
<db:title>[noexcept] bool operator&gt;=(const QLatin1StringView &amp;<db:emphasis>lhs</db:emphasis>, const QChar &amp;<db:emphasis>rhs</db:emphasis>)</db:title>
<db:para>Returns <db:code>true</db:code> if string <db:code role="parameter">lhs</db:code> is lexically greater than or equal to char <db:code role="parameter">rhs</db:code>; otherwise returns <db:code>false</db:code>.</db:para>
</db:section>
<db:section xml:id="operator-gt-eq-2">
<db:title>[noexcept] bool operator&gt;=(const QLatin1StringView &amp;<db:emphasis>lhs</db:emphasis>, const QLatin1StringView &amp;<db:emphasis>rhs</db:emphasis>)</db:title>
<db:para>Returns <db:code>true</db:code> if string <db:code role="parameter">lhs</db:code> is lexically greater than or equal to string <db:code role="parameter">rhs</db:code>; otherwise returns <db:code>false</db:code>.</db:para>
</db:section>
<db:section xml:id="operator-gt-eq-3">
<db:title>[noexcept] bool operator&gt;=(const QLatin1StringView &amp;<db:emphasis>lhs</db:emphasis>, const QStringView &amp;<db:emphasis>rhs</db:emphasis>)</db:title>
<db:para>Returns <db:code>true</db:code> if string <db:code role="parameter">lhs</db:code> is lexically greater than or equal to string view <db:code role="parameter">rhs</db:code>; otherwise returns <db:code>false</db:code>.</db:para>
</db:section>
<db:section xml:id="operator-gt-eq-4">
<db:title>[noexcept] bool operator&gt;=(const QLatin1StringView &amp;<db:emphasis>lhs</db:emphasis>, const char *const &amp;<db:emphasis>rhs</db:emphasis>)</db:title>
<db:para>Returns <db:code>true</db:code> if the string <db:code role="parameter">lhs</db:code> is lexically greater than or equal to const char pointer <db:code role="parameter">rhs</db:code>; otherwise returns <db:code>false</db:code>.</db:para>
<db:para>The <db:code role="parameter">rhs</db:code> const char pointer is converted to a <db:link xlink:href="qutf8stringview.xml">QUtf8StringView</db:link>.</db:para>
<db:para>You can disable this operator by defining <db:link xlink:href="qstring.xml#QT_NO_CAST_FROM_ASCII">QT_NO_CAST_FROM_ASCII</db:link> when you compile your applications. This can be useful if you want to ensure that all user-visible strings go through <db:link xlink:href="qobject.xml#tr">QObject::tr</db:link>(), for example.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qstring.xml#comparing-strings">Comparing Strings</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="operator-gt-eq-5">
<db:title>[noexcept] bool operator&gt;=(const QStringView &amp;<db:emphasis>lhs</db:emphasis>, const QLatin1StringView &amp;<db:emphasis>rhs</db:emphasis>)</db:title>
<db:para>Returns <db:code>true</db:code> if string view <db:code role="parameter">lhs</db:code> is lexically greater than or equal to string <db:code role="parameter">rhs</db:code>; otherwise returns <db:code>false</db:code>.</db:para>
</db:section>
<db:section xml:id="operator-gt-eq-6">
<db:title>[noexcept] bool operator&gt;=(const char *const &amp;<db:emphasis>lhs</db:emphasis>, const QLatin1StringView &amp;<db:emphasis>rhs</db:emphasis>)</db:title>
<db:para>Returns <db:code>true</db:code> if const char pointer <db:code role="parameter">lhs</db:code> is lexically greater than or equal to string <db:code role="parameter">rhs</db:code>; otherwise returns <db:code>false</db:code>.</db:para>
</db:section>
<db:section xml:id="operator-gt-eq-10">
<db:title>[noexcept] bool operator&gt;=(const QLatin1StringView &amp;<db:emphasis>lhs</db:emphasis>, const QByteArray &amp;<db:emphasis>rhs</db:emphasis>)</db:title>
<db:para>This is an overloaded function.</db:para>
<db:para>The <db:code role="parameter">rhs</db:code> byte array is converted to a <db:link xlink:href="qutf8stringview.xml">QUtf8StringView</db:link>.</db:para>
<db:para>You can disable this operator by defining <db:link xlink:href="qstring.xml#QT_NO_CAST_FROM_ASCII">QT_NO_CAST_FROM_ASCII</db:link> when you compile your applications. This can be useful if you want to ensure that all user-visible strings go through <db:link xlink:href="qobject.xml#tr">QObject::tr</db:link>(), for example.</db:para>
</db:section>
</db:section>
</db:article>
