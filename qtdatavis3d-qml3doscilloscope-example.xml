<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en">
<db:info>
<db:title>Qt Quick 2 Oscilloscope Example</db:title>
<db:productname>QtDataVis3D</db:productname>
<db:edition>Qt Data Visualization | Commercial or GPLv3</db:edition>
<db:titleabbrev>Qt Data Visualization Reference Documentation</db:titleabbrev>
<db:abstract>
<db:para>Example of a hybrid C++ and QML application.</db:para>
</db:abstract>
<db:pubdate>2024-01-26</db:pubdate>
<db:date>2024-01-26</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:para>The Qt Quick 2 oscilloscope example shows how to combine C++ and QML in an application, as well as showing data that changes realtime.</db:para>
<db:mediaobject>
<db:imageobject>
<db:imagedata fileref="images/qml3doscilloscope-example.png"/>
</db:imageobject>
</db:mediaobject>
<db:para>The interesting thing about this example is combining C++ and QML, so we'll concentrate on that and skip explaining the basic functionality - for more detailed QML example documentation, see <db:link xlink:href="qtdatavis3d-qmlscatter-example.xml">Qt Quick 2 Scatter Example</db:link>.</db:para>
<db:section xml:id="running-the-example">
<db:title>Running the Example</db:title>
<db:para>To run the example from <db:link xlink:href="https://doc.qt.io/qtcreator/index.html">Qt Creator</db:link>, open the <db:guilabel>Welcome</db:guilabel> mode and select the example from <db:guilabel>Examples</db:guilabel>. For more information, visit <db:link xlink:href="https://doc.qt.io/qtcreator/creator-build-example-application.html">Building and Running an Example</db:link>.</db:para>
</db:section>
<db:section xml:id="data-source-in-c">
<db:title>Data Source in C++</db:title>
<db:para>The item model based proxies are good for simple and/or static graphs, but to achieve best performance when displaying data changing in realtime, the basic proxies should be used. Those are not supported in QML, as the data items they store are not <db:link xlink:href="qobject.xml">QObject</db:link>s and cannot therefore be directly manipulated from QML code. To overcome this limitation, we implement a simple <db:code>DataSource</db:code> class in C++ to populate the data proxy of the series.</db:para>
<db:para>The <db:code>DataSource</db:code> class provides three methods that can be called from QML:</db:para>
<db:programlisting language="cpp">public Q_SLOTS:
void generateData(int cacheCount, int rowCount, int columnCount,
                  float xMin, float xMax, float yMin, float yMax, float zMin, float zMax);

void update(QSurface3DSeries *series);
</db:programlisting>
<db:para>The first method, <db:code>generateData()</db:code>, creates a cache of simulated oscilloscope data for us to display. The data is cached in a format accepted by <db:link xlink:href="qsurfacedataproxy.xml">QSurfaceDataProxy</db:link>:</db:para>
<db:programlisting language="cpp">void DataSource::generateData(int cacheCount, int rowCount, int columnCount,
                              float xMin, float xMax, float yMin, float yMax,
                              float zMin, float zMax)
{
    if (!cacheCount || !rowCount || !columnCount)
        return;

    clearData();
    // Re-create the cache array
    m_data.resize(cacheCount);
    for (int i(0); i &amp;lt; cacheCount; i++) {
        QSurfaceDataArray &amp;amp;array = m_data[i];
        array.reserve(rowCount);
        for (int j(0); j &amp;lt; rowCount; j++)
            array.append(new QSurfaceDataRow(columnCount));
    }

    float xRange = xMax - xMin;
    float yRange = yMax - yMin;
    float zRange = zMax - zMin;
    int cacheIndexStep = columnCount / cacheCount;
    float cacheStep = float(cacheIndexStep) * xRange / float(columnCount);

    // Populate caches
    for (int i(0); i &amp;lt; cacheCount; i++) {
        QSurfaceDataArray &amp;amp;cache = m_data[i];
        float cacheXAdjustment = cacheStep * i;
        float cacheIndexAdjustment = cacheIndexStep * i;
        for (int j(0); j &amp;lt; rowCount; j++) {
            QSurfaceDataRow &amp;amp;row = *(cache[j]);
            float rowMod = (float(j)) / float(rowCount);
            float yRangeMod = yRange * rowMod;
            float zRangeMod = zRange * rowMod;
            float z = zRangeMod + zMin;
            qreal rowColWaveAngleMul = M_PI * M_PI * rowMod;
            float rowColWaveMul = yRangeMod * 0.2f;
            for (int k(0); k &amp;lt; columnCount; k++) {
                float colMod = (float(k)) / float(columnCount);
                float xRangeMod = xRange * colMod;
                float x = xRangeMod + xMin + cacheXAdjustment;
                float colWave = float(qSin((2.0 * M_PI * colMod) - (1.0 / 2.0 * M_PI)) + 1.0);
                float y = (colWave * ((float(qSin(rowColWaveAngleMul * colMod) + 1.0))))
                        * rowColWaveMul
                        + QRandomGenerator::global()-&amp;gt;bounded(0.15f) * yRangeMod;

                int index = k + cacheIndexAdjustment;
                if (index &amp;gt;= columnCount) {
                    // Wrap over
                    index -= columnCount;
                    x -= xRange;
                }
                row[index] = QVector3D(x, y, z);
            }
        }
    }
}
</db:programlisting>
<db:para>The second method, <db:code>update()</db:code>, copies one set of the cached data into another array, which we set to the data proxy of the series by calling <db:link xlink:href="qsurfacedataproxy.xml#resetArray">QSurfaceDataProxy::resetArray</db:link>(). We reuse the same array if the array dimensions have not changed to minimize overhead:</db:para>
<db:programlisting language="cpp">void DataSource::update(QSurface3DSeries *series)
{
    if (series &amp;amp;&amp;amp; m_data.size()) {
        // Each iteration uses data from a different cached array
        m_index++;
        if (m_index &amp;gt; m_data.count() - 1)
            m_index = 0;

        QSurfaceDataArray array = m_data.at(m_index);
        int newRowCount = array.size();
        int newColumnCount = array.at(0)-&amp;gt;size();

        // If the first time or the dimensions of the cache array have changed,
        // reconstruct the reset array
        if (!m_resetArray || series-&amp;gt;dataProxy()-&amp;gt;rowCount() != newRowCount
                || series-&amp;gt;dataProxy()-&amp;gt;columnCount() != newColumnCount) {
            m_resetArray = new QSurfaceDataArray();
            m_resetArray-&amp;gt;reserve(newRowCount);
            for (int i(0); i &amp;lt; newRowCount; i++)
                m_resetArray-&amp;gt;append(new QSurfaceDataRow(newColumnCount));
        }

        // Copy items from our cache to the reset array
        for (int i(0); i &amp;lt; newRowCount; i++) {
            const QSurfaceDataRow &amp;amp;sourceRow = *(array.at(i));
            QSurfaceDataRow &amp;amp;row = *(*m_resetArray)[i];
            for (int j(0); j &amp;lt; newColumnCount; j++)
                row[j].setPosition(sourceRow.at(j).position());
        }

        // Notify the proxy that data has changed
        series-&amp;gt;dataProxy()-&amp;gt;resetArray(m_resetArray);
    }
}
</db:programlisting>
<db:note>
<db:para>Even though we are operating on the array pointer we have previously set to the proxy we still need to call <db:link xlink:href="qsurfacedataproxy.xml#resetArray">QSurfaceDataProxy::resetArray</db:link>() after changing the data in it to prompt the graph to render the data.</db:para>
</db:note>
<db:para>To be able to access the <db:code>DataSource</db:code> methods from QML, we need to expose it. We do this by defining a context property in application main:</db:para>
<db:programlisting language="cpp">DataSource dataSource;
viewer.rootContext()-&amp;gt;setContextProperty(&quot;dataSource&quot;, &amp;amp;dataSource);
</db:programlisting>
<db:para>To make it possible to use <db:link xlink:href="qsurface3dseries.xml">QSurface3DSeries</db:link> pointers as parameters on the <db:code>DataSource</db:code> class methods on all environments and builds, we need to make sure the meta type is registered:</db:para>
<db:programlisting language="cpp">Q_DECLARE_METATYPE(QSurface3DSeries *)
...
qRegisterMetaType&amp;lt;QSurface3DSeries *&amp;gt;();
</db:programlisting>
</db:section>
<db:section xml:id="qml">
<db:title>QML</db:title>
<db:para>In the QML codes, we define a <db:link xlink:href="qml-qtdatavisualization-surface3d.xml">Surface3D</db:link> graph normally and give it a <db:link xlink:href="qml-qtdatavisualization-surface3dseries.xml">Surface3DSeries</db:link>:</db:para>
<db:programlisting language="qml">Surface3DSeries {
    id: surfaceSeries
    drawMode: Surface3DSeries.DrawSurface;
    flatShadingEnabled: false;
    meshSmooth: true
    itemLabelFormat: &quot;@xLabel, @zLabel: @yLabel&quot;
    itemLabelVisible: false

    onItemLabelChanged: {
        if (surfaceSeries.selectedPoint === surfaceSeries.invalidSelectionPosition)
            selectionText.text = &quot;No selection&quot;
        else
            selectionText.text = surfaceSeries.itemLabel
    }
}
</db:programlisting>
<db:para>One interesting detail is that we don't specify a proxy for the <db:link xlink:href="qml-qtdatavisualization-surface3dseries.xml">Surface3DSeries</db:link> we attach to the graph. This makes the series to utilize the default <db:link xlink:href="qsurfacedataproxy.xml">QSurfaceDataProxy</db:link>.</db:para>
<db:para>We also hide the item label with <db:link xlink:href="qml-qtdatavisualization-abstract3dseries.xml#itemLabelVisible-prop">itemLabelVisible</db:link>, since we want to display the selected item information in a <db:code>Text</db:code> element instead of a floating label above the selection pointer. This is done because the selection pointer moves around a lot as the data changes, which makes the regular selection label difficult to read.</db:para>
<db:para>We initialize the <db:code>DataSource</db:code> cache when the graph is complete by calling a helper function <db:code>generateData()</db:code>, which calls the method with the same name on the <db:code>DataSource</db:code>:</db:para>
<db:programlisting language="qml">Component.onCompleted: mainView.generateData()
    ...
function generateData() {
    dataSource.generateData(mainView.sampleCache, mainView.sampleRows,
                            mainView.sampleColumns, surfaceGraph.axisX.min,
                            surfaceGraph.axisX.max, surfaceGraph.axisY.min,
                            surfaceGraph.axisY.max, surfaceGraph.axisZ.min,
                            surfaceGraph.axisZ.max)
}
</db:programlisting>
<db:para>To trigger the updates in data, we define a <db:code>Timer</db:code> item which calls the <db:code>update()</db:code> method on the <db:code>DataSource</db:code> at requested intervals. The label update is also triggered on each cycle:</db:para>
<db:programlisting language="qml">Timer {
    id: refreshTimer
    interval: 1000 / frequencySlider.value
    running: true
    repeat: true
    onTriggered: dataSource.update(surfaceSeries)
}
</db:programlisting>
</db:section>
<db:section xml:id="enabling-direct-rendering">
<db:title>Enabling Direct Rendering</db:title>
<db:para>Since this application potentially deals with a lot of rapidly changing data, we use direct rendering mode for performance. To enable antialiasing in this mode the surface format of the application window needs to be changed, as the default format used by <db:link xlink:href="qquickview.xml">QQuickView</db:link> doesn't support antialiasing. We use the utility function provided by Qt Data Visualization to change the surface format in <db:code>main.cpp</db:code>:</db:para>
<db:programlisting language="cpp">viewer.setFormat(qDefaultSurfaceFormat(true));
...
#include &amp;lt;QtDataVisualization/qutils.h&amp;gt;
</db:programlisting>
</db:section>
<db:section>
<db:title>Example project</db:title>
<db:para><db:link xlink:href="https://code.qt.io/cgit/qt/qtdatavis3d.git/tree/examples/datavisualization/qml3doscilloscope?h=6.4">Example project @ code.qt.io</db:link></db:para>
</db:section>
</db:article>
