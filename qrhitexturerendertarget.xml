<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en">
<db:info>
<db:title>QRhiTextureRenderTarget Class</db:title>
<db:productname>QtGui</db:productname>
<db:edition>Qt 6.8.3 Reference Documentation</db:edition>
<db:titleabbrev>Qt GUI Reference Documentation</db:titleabbrev>
<db:abstract>
<db:para>Texture render target resource.</db:para>
<db:para>This class was introduced in Qt 6.6.</db:para>
</db:abstract>
<db:pubdate>2025-06-29</db:pubdate>
<db:date>2025-06-29</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:variablelist>
<db:varlistentry>
<db:term>Header</db:term>
<db:listitem>
<db:para>rhi/qrhi.h</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Since</db:term>
<db:listitem>
<db:para>Qt 6.6</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>CMake</db:term>
<db:listitem>
<db:para>find_package(Qt6 REQUIRED COMPONENTS Gui)</db:para>
<db:para>target_link_libraries(mytarget PRIVATE Qt6::GuiPrivate)</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>qmake</db:term>
<db:listitem>
<db:para>QT += gui-private</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Inherits</db:term>
<db:listitem>
<db:para><db:link xlink:href="qrhirendertarget.xml" xlink:role="class">QRhiRenderTarget</db:link></db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Inherited By</db:term>
<db:listitem>
<db:para/>
</db:listitem>
</db:varlistentry>
</db:variablelist>
<db:section xml:id="details">
<db:title>Detailed Description</db:title>
<db:para>A texture render target allows rendering into one or more textures, optionally with a depth texture or depth/stencil renderbuffer.</db:para>
<db:para>For multisample rendering the common approach is to use a renderbuffer as the color attachment and set the non-multisample destination texture as the <db:code>resolve texture</db:code>. For more information, read the detailed description of the <db:link xlink:href="qrhicolorattachment.xml">QRhiColorAttachment</db:link> class.</db:para>
<db:note>
<db:para>Textures used in combination with <db:link xlink:href="qrhitexturerendertarget.xml">QRhiTextureRenderTarget</db:link> must be created with the <db:link xlink:href="qrhitexture.xml#Flag-enum">QRhiTexture::RenderTarget</db:link> flag.</db:para>
</db:note>
<db:para>The simplest example of creating a render target with a texture as its single color attachment:</db:para>
<db:programlisting language="cpp">QRhiTexture *texture = rhi-&gt;newTexture(QRhiTexture::RGBA8, size, 1, QRhiTexture::RenderTarget);
texture-&gt;create();
QRhiTextureRenderTarget *rt = rhi-&gt;newTextureRenderTarget({ texture });
rp = rt-&gt;newCompatibleRenderPassDescriptor();
rt-&gt;setRenderPassDescriptor(rp);
rt-&gt;create();
// rt can now be used with beginPass()
</db:programlisting>
<db:note>
<db:para>This is a RHI API with limited compatibility guarantees, see <db:link xlink:href="qrhi.xml">QRhi</db:link> for details.</db:para>
</db:note>
</db:section>
<db:section xml:id="member-type-documentation">
<db:title>Member Type Documentation</db:title>
<db:section xml:id="Flag-enum">
<db:title>enum QRhiTextureRenderTarget::Flag</db:title>
<db:bridgehead renderas="sect2">flags QRhiTextureRenderTarget::Flags</db:bridgehead>
<db:para>Flag values describing the load/store behavior for the render target. The load/store behavior may be baked into native resources under the hood, depending on the backend, and therefore it needs to be known upfront and cannot be changed without rebuilding (and so releasing and creating new native resources).</db:para>
<db:informaltable>
<db:thead>
<db:tr>
<db:th>Constant</db:th>
<db:th>Value</db:th>
<db:th>Description</db:th>
</db:tr>
</db:thead>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qrhitexturerendertarget.xml">QRhiTextureRenderTarget</db:link></db:emphasis>::PreserveColorContents</db:code></db:para>
</db:td>
<db:td><db:code>1 &lt;&lt; 0</db:code></db:td>
<db:td>
<db:para>Indicates that the contents of the color attachments is to be loaded when starting a render pass, instead of clearing. This is potentially more expensive, especially on mobile (tiled) GPUs, but allows preserving the existing contents between passes. When doing multisample rendering with a resolve texture set, setting this flag also requests the multisample color data to be stored (written out) to the multisample texture or render buffer. (for non-multisample rendering the color data is always stored, but for MSAA storing the multisample data decreases efficiency for certain GPU architectures, hence defaulting to not writing it out) Note however that this is non-portable: in some cases there is no intermediate multisample texture on the graphics API level, e.g. when using OpenGL ES's <db:code>GL_EXT_multisampled_render_to_texture</db:code> as it is all implicit, handled by the OpenGL ES implementation. In that case, PreserveColorContents will likely have no effect. Therefore, avoid relying on this flag when using multisample rendering and the color attachment is using a multisample <db:link xlink:href="qrhitexture.xml">QRhiTexture</db:link> (not <db:link xlink:href="qrhirenderbuffer.xml">QRhiRenderBuffer</db:link>).</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qrhitexturerendertarget.xml">QRhiTextureRenderTarget</db:link></db:emphasis>::PreserveDepthStencilContents</db:code></db:para>
</db:td>
<db:td><db:code>1 &lt;&lt; 1</db:code></db:td>
<db:td>
<db:para>Indicates that the contents of the depth texture is to be loaded when starting a render pass, instead clearing. Only applicable when a texture is used as the depth buffer (QRhiTextureRenderTargetDescription::depthTexture() is set) because depth/stencil renderbuffers may not have any physical backing and data may not be written out in the first place.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qrhitexturerendertarget.xml">QRhiTextureRenderTarget</db:link></db:emphasis>::DoNotStoreDepthStencilContents</db:code></db:para>
</db:td>
<db:td><db:code>1 &lt;&lt; 2</db:code></db:td>
<db:td>
<db:para>Indicates that the contents of the depth texture does not need to be written out. Relevant only when a <db:link xlink:href="qrhitexture.xml">QRhiTexture</db:link>, not <db:link xlink:href="qrhirenderbuffer.xml">QRhiRenderBuffer</db:link>, is used as the depth-stencil buffer, because for <db:link xlink:href="qrhirenderbuffer.xml">QRhiRenderBuffer</db:link> this is implicit. When a depthResolveTexture is set, the flag is not relevant, because the behavior is then as if the flag was set. This enum value is introduced in Qt 6.8.</db:para>
</db:td>
</db:tr>
</db:informaltable>
<db:para>The <db:code>Flags</db:code> type is a typedef for <db:code><db:link xlink:href="qflags.xml">QFlags</db:link>&lt;Flag&gt;. </db:code>It stores an OR combination of <db:code>Flag</db:code> values.</db:para>
</db:section>
</db:section>
<db:section xml:id="member-function-documentation">
<db:title>Member Function Documentation</db:title>
<db:section xml:id="resourceType">
<db:title>[override virtual] QRhiResource::Type QRhiTextureRenderTarget::resourceType() const</db:title>
<db:para>Returns the resource type.</db:para>
</db:section>
</db:section>
</db:article>
