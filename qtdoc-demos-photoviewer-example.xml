<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en">
<db:info>
<db:title>Qt Quick Demo - Photo Viewer</db:title>
<db:productname>QtDoc</db:productname>
<db:edition>Qt 6.1.3 Reference Documentation</db:edition>
<db:titleabbrev>Qt Reference Documentation</db:titleabbrev>
<db:abstract>
<db:para>A QML photo viewer that uses XmlListModel and XmlListModelRole custom QML types to download Flickr feeds, and Package to display the photos in different views.</db:para>
</db:abstract>
<db:pubdate>2024-12-27</db:pubdate>
<db:date>2024-12-27</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:mediaobject>
<db:imageobject>
<db:imagedata fileref="images/qtquick-demo-photoviewer-small.png"/>
</db:imageobject>
</db:mediaobject>
<db:para><db:emphasis>Photo Viewer</db:emphasis> demonstrates the following <db:link xlink:href="qtquick-index.xml">Qt Quick</db:link> features:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para>Using custom QML types.</db:para>
</db:listitem>
<db:listitem>
<db:para>Using Qt Quick Controls 1 to create an application window.</db:para>
</db:listitem>
<db:listitem>
<db:para>Using the <db:link xlink:href="qml-qtqml-models-package.xml">Package</db:link> type with a <db:link xlink:href="qml-qtqml-models-delegatemodel.xml">DelegateModel</db:link> to provide delegates with a shared context to multiple views.</db:para>
</db:listitem>
<db:listitem>
<db:para>Using custom types to download Flickr feeds.</db:para>
</db:listitem>
<db:listitem>
<db:para>Using the <db:link xlink:href="qml-qtquick-flipable.xml">Flipable</db:link> type to create labels with different text on the front and back.</db:para>
</db:listitem>
<db:listitem>
<db:para>Using the <db:link xlink:href="qml-qtquick-pathview.xml">PathView</db:link>, <db:link xlink:href="qml-qtquick-path.xml">Path</db:link>, <db:link xlink:href="qml-qtquick-pathattribute.xml">PathAttribute</db:link>, and <db:link xlink:href="qml-qtquick-pathline.xml">PathLine</db:link> types to lay out photos on a path.</db:para>
</db:listitem>
<db:listitem>
<db:para>Providing feedback to users while data is loading.</db:para>
</db:listitem>
<db:listitem>
<db:para>Localizing applications.</db:para>
</db:listitem>
</db:itemizedlist>
<db:section xml:id="running-the-example">
<db:title>Running the Example</db:title>
<db:para>To run the example from <db:link xlink:href="https://doc.qt.io/qtcreator/index.html">Qt Creator</db:link>, open the <db:emphasis role="bold">Welcome</db:emphasis> mode and select the example from <db:emphasis role="bold">Examples</db:emphasis>. For more information, visit <db:link xlink:href="https://doc.qt.io/qtcreator/creator-build-example-application.html">Building and Running an Example</db:link>.</db:para>
</db:section>
<db:section xml:id="using-custom-types">
<db:title>Using Custom Types</db:title>
<db:para>In the Photo Viewer app, we use the following custom types that are each defined in a separate .qml file:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para>AlbumDelegate.qml</db:para>
</db:listitem>
<db:listitem>
<db:para>BusyIndicator.qml</db:para>
</db:listitem>
<db:listitem>
<db:para>Button.qml</db:para>
</db:listitem>
<db:listitem>
<db:para>EditableButton.qml</db:para>
</db:listitem>
<db:listitem>
<db:para>PhotoDelegate.qml</db:para>
</db:listitem>
<db:listitem>
<db:para>ProgressBar.qml</db:para>
</db:listitem>
<db:listitem>
<db:para>RssModel.qml</db:para>
</db:listitem>
<db:listitem>
<db:para>Tag.qml</db:para>
</db:listitem>
</db:itemizedlist>
<db:para>To use the custom types, we add an import statement to the main QML file, main.qml, that imports the folder called PhotoViewerCore where the types are located:</db:para>
<db:programlisting language="cpp">import &quot;PhotoViewerCore&quot;
</db:programlisting>
<db:para>We also use the following custom types that are defined in C++:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para>XmlListModel</db:para>
</db:listitem>
<db:listitem>
<db:para>XmlListModelRole</db:para>
</db:listitem>
</db:itemizedlist>
<db:para>To register QML types from C++ we add the <db:link xlink:href="qqmlengine.xml#QML_ELEMENT">QML_ELEMENT</db:link> macro to the <db:link xlink:href="qobject.xml">QObject</db:link> derived classes' definitions like this:</db:para>
<db:programlisting language="cpp">class XmlListModelRole : public QObject
{
    Q_OBJECT
    Q_PROPERTY(QString elementName READ elementName WRITE setElementName NOTIFY elementNameChanged)
    Q_PROPERTY(QString attributeName READ attributeName WRITE setAttributeName NOTIFY attributeNameChanged)
    QML_ELEMENT
</db:programlisting>
<db:para>In addition we need to add the following to the CMakeLists.txt file of the example:</db:para>
<db:programlisting language="cpp">set_target_properties(photoviewer PROPERTIES
    QT_QML_MODULE_VERSION 1.0
    QT_QML_MODULE_URI XmlListModel
)

qt6_qml_type_registration(photoviewer)
</db:programlisting>
<db:para>To build with qmake, we add CONFIG += qmltypes, QML_IMPORT_NAME, and QML_IMPORT_MAJOR_VERSION to the project file:</db:para>
<db:programlisting language="cpp">CONFIG += lrelease embed_translations qmltypes

QML_IMPORT_NAME = XmlListModel
QML_IMPORT_MAJOR_VERSION = 1
</db:programlisting>
<db:para>For more information on defining QML types from C++ see the <db:link xlink:href="qtqml-cppintegration-definetypes.xml">Defining QML Types from C++</db:link> documentation.</db:para>
<db:para>To use the new types, we add an import statement that imports them to the QML files that use the types:</db:para>
<db:programlisting language="cpp">import XmlListModel
</db:programlisting>
</db:section>
<db:section xml:id="creating-the-main-window">
<db:title>Creating the Main Window</db:title>
<db:para>In main.qml, we use the <db:link xlink:href="qml-qtquick-controls2-applicationwindow.xml">ApplicationWindow</db:link> Qt Quick Control to create the app main window:</db:para>
<db:programlisting language="cpp">ApplicationWindow {
    id: mainWindow

    visible: true
</db:programlisting>
<db:para>We use a <db:link xlink:href="qml-qtqml-models-listmodel.xml">ListModel</db:link> type with <db:link xlink:href="qml-qtqml-models-listelement.xml">ListElement</db:link> types to display photo albums:</db:para>
<db:programlisting language="cpp">    ListModel {
        id: photosModel
        ListElement { tag: &quot;Flowers&quot; }
        ListElement { tag: &quot;Wildlife&quot; }
        ListElement { tag: &quot;Prague&quot; }
    }
</db:programlisting>
<db:para>List elements are defined like other QML types except that they contain a collection of <db:emphasis>role</db:emphasis> definitions instead of properties. Roles both define how the data is accessed and include the data itself. For each list element, we use the tag role to specify the photos to download.</db:para>
<db:para>A <db:link xlink:href="qml-qtqml-models-delegatemodel.xml">DelegateModel</db:link> type is used together with the <db:link xlink:href="qml-qtqml-models-package.xml">Package</db:link> type to provide delegates to multiple views. The model property holds the model providing data for the delegate model and the delegate property specifies the template defining each item instantiated by a view:</db:para>
<db:programlisting language="cpp">    DelegateModel { id: albumVisualModel; model: photosModel; delegate: AlbumDelegate {} }
</db:programlisting>
<db:para>We use a <db:link xlink:href="qml-qtquick-gridview.xml">GridView</db:link> type to lay out the albums as a grid:</db:para>
<db:programlisting language="cpp">    GridView {
        id: albumView; width: parent.width; height: parent.height; cellWidth: 210; cellHeight: 220
        model: albumVisualModel.parts.album; visible: albumsShade.opacity != 1.0
    }
</db:programlisting>
<db:para>The model property references the package name album that we specify in AlbumDelegate.qml. We use the <db:link xlink:href="qml-qtqml-models-package.xml">Package</db:link> type to allow the photos to move between different views. The <db:link xlink:href="qml-qtqml-models-package.xml">Package</db:link> contains the named items browser, fullscreen, and album:</db:para>
<db:programlisting language="cpp">    Package {

        Item {
            Package.name: 'browser'
            GridView {
                id: photosGridView; model: visualModel.parts.grid; width: mainWindow.width; height: mainWindow.height - 21
                x: 0; y: 21; cellWidth: 160; cellHeight: 153; interactive: false
                onCurrentIndexChanged: photosListView.positionViewAtIndex(currentIndex, ListView.Contain)
            }
        }

        Item {
            Package.name: 'fullscreen'
            ListView {
                id: photosListView; model: visualModel.parts.list; orientation: Qt.Horizontal
                width: mainWindow.width; height: mainWindow.height; interactive: false
                onCurrentIndexChanged: photosGridView.positionViewAtIndex(currentIndex, GridView.Contain)
                highlightRangeMode: ListView.StrictlyEnforceRange; snapMode: ListView.SnapOneItem
            }
        }

        Item {
            Package.name: 'album'
            id: albumWrapper; width: 210; height: 220
</db:programlisting>
<db:para>The named items are used as the delegates by the views that reference the special <db:link xlink:href="qml-qtqml-models-delegatemodel.xml#parts-prop">DelegateModel::parts</db:link> property to select the model that provides the chosen delegate.</db:para>
<db:para>We use a <db:link xlink:href="qml-qtquick-listview.xml">ListView</db:link> type to lay out albums in other views:</db:para>
<db:programlisting language="cpp">    ListView { anchors.fill: parent; model: albumVisualModel.parts.browser; interactive: false }

    ListView { anchors.fill: parent; model: albumVisualModel.parts.fullscreen; interactive: false }
</db:programlisting>
</db:section>
<db:section xml:id="displaying-photos">
<db:title>Displaying Photos</db:title>
<db:para>We use the PhotoDelegate custom type that is specified in PhotoDelegate.qml to display photos. We use a <db:link xlink:href="qml-qtqml-models-package.xml">Package</db:link> type to lay out the photos either in a stack, list, or a grid:</db:para>
<db:programlisting language="cpp">Package {
    Item { id: stackItem; Package.name: 'stack'; width: 160; height: 153; z: stackItem.PathView.z }
    Item { id: listItem; Package.name: 'list'; width: mainWindow.width + 40; height: 153 }
    Item { id: gridItem; Package.name: 'grid'; width: 160; height: 153 }
</db:programlisting>
<db:para>The photos are rotated at random angles by using the Math.random() JavaScript method:</db:para>
<db:programlisting language="cpp">    Item {
        width: 160; height: 153

        Item {
            id: photoWrapper

            property double randomAngle: Math.random() * (2 * 6 + 1) - 6
            property double randomAngle2: Math.random() * (2 * 6 + 1) - 6

            x: 0; y: 0; width: 140; height: 133
            z: stackItem.PathView.z; rotation: photoWrapper.randomAngle
</db:programlisting>
<db:para>We use a <db:link xlink:href="qml-qtquick-borderimage.xml">BorderImage</db:link> type to create borders for the images:</db:para>
<db:programlisting language="cpp">            BorderImage {
                anchors {
                    fill: originalImage.status == Image.Ready ? border : placeHolder
                    leftMargin: -6; topMargin: -6; rightMargin: -8; bottomMargin: -8
                }
                source: 'images/box-shadow.png'
                border.left: 10; border.top: 10; border.right: 10; border.bottom: 10
            }
</db:programlisting>
</db:section>
<db:section xml:id="downloading-flickr-feeds">
<db:title>Downloading Flickr Feeds</db:title>
<db:para>In AlbumDelegate.qml, we use the <db:link xlink:href="qml-qtqml-models-delegatemodel.xml">DelegateModel</db:link> to provide the PhotoDelegate delegate to the RssModel model:</db:para>
<db:programlisting language="cpp">            DelegateModel {
                id: visualModel; delegate: PhotoDelegate { }
                model: RssModel { id: rssModel; tags: tag }
            }
</db:programlisting>
<db:para>In RssModel.qml, we use the XmlListModel custom type as a data source for <db:link xlink:href="qml-qtqml-models-package.xml">Package</db:link> objects to download photos from the selected feeds:</db:para>
<db:programlisting language="cpp">import XmlListModel

XmlListModel {
    property string tags : &quot;&quot;

    function encodeTags(x) { return encodeURIComponent(x.replace(' ',',')); }
</db:programlisting>
<db:para>We use the tags custom property to specify which photos to download. The encodeTags custom function uses the encodeURIComponent JavaScript method to ensure that the requests to the server are correctly formatted.</db:para>
<db:para>We use the source property to fetch photos that have the specified tags attached from public Flickr feeds:</db:para>
<db:programlisting language="cpp">    source: &quot;http://api.flickr.com/services/feeds/photos_public.gne?&quot;+(tags ? &quot;tags=&quot;+encodeTags(tags)+&quot;&amp;amp;&quot; : &quot;&quot;)

    query: &quot;/feed/entry&quot;
</db:programlisting>
<db:para>The query property specifies that the XmlListModel generates a model item for each feed entry.</db:para>
<db:para>We use the XmlListModelRole custom type to specify the model item attributes. Each model item has the title and link attributes that match the values of the corresponding feed entry:</db:para>
<db:programlisting language="cpp">    roles: [
        XmlListModelRole { elementName: &quot;title&quot;; attributeName: &quot;&quot; },
        XmlListModelRole { elementName: &quot;link&quot;; attributeName: &quot;href&quot; }
</db:programlisting>
</db:section>
<db:section xml:id="creating-flipable-labels">
<db:title>Creating Flipable Labels</db:title>
<db:para>When users select the <db:emphasis role="bold">Edit</db:emphasis> button, the album labels are flipped from their front side to their back side and the text on them changes from album name to <db:emphasis role="bold">Remove</db:emphasis>.</db:para>
<db:para>In AlbumDelegate.qml, we use the Tag custom type to specify the text to display on the front and back sides of album labels:</db:para>
<db:programlisting language="cpp">            Tag {
                anchors { horizontalCenter: parent.horizontalCenter; bottom: parent.bottom; bottomMargin: 10 }
                frontLabel: tag; backLabel: qsTr(&quot;Remove&quot;); flipped: mainWindow.editMode
                onTagChanged: rssModel.tags = tag
                onBackClicked: if (mainWindow.editMode) photosModel.remove(index);
            }
</db:programlisting>
<db:para>The onTagChanged signal handler is used to change the tag based on which the model is populated. The onBackClicked signal handler is used to remove the album.</db:para>
<db:para>In Tag.qml, we use a <db:link xlink:href="qml-qtquick-flipable.xml">Flipable</db:link> type with custom properties and signals to create the labels:</db:para>
<db:programlisting language="cpp">Flipable {
    id: flipable

    property alias frontLabel: frontButton.label
    property alias backLabel: backButton.label

    property int angle: 0
    property int randomAngle: Math.random() * (2 * 6 + 1) - 6
    property bool flipped: false

    signal frontClicked
    signal backClicked
    signal tagChanged(string tag)
</db:programlisting>
<db:para>The front property holds the EditableButton custom type that enables users to edit the label text:</db:para>
<db:programlisting language="cpp">    front: EditableButton {
        id: frontButton; rotation: flipable.randomAngle
        anchors { centerIn: parent; verticalCenterOffset: -20 }
        onClicked: flipable.frontClicked()
        onLabelChanged: flipable.tagChanged(label)
    }
</db:programlisting>
<db:para>The back property holds the Button custom type that is used to remove the album:</db:para>
<db:programlisting language="cpp">    back: Button {
        id: backButton; tint: &quot;red&quot;; rotation: flipable.randomAngle
        anchors { centerIn: parent; verticalCenterOffset: -20 }
        onClicked: flipable.backClicked()
    }
</db:programlisting>
</db:section>
<db:section xml:id="laying-out-photos-on-a-path">
<db:title>Laying Out Photos on a Path</db:title>
<db:para>In AlbumDelegate.qml, we use a <db:link xlink:href="qml-qtquick-pathview.xml">PathView</db:link> type to lay out the photos provided by the visualModel.parts.stack model on a path that has the form of a stack:</db:para>
<db:programlisting language="cpp">            PathView {
                id: photosPathView; model: visualModel.parts.stack; pathItemCount: 5
                visible: !busyIndicator.visible
                anchors.centerIn: parent; anchors.verticalCenterOffset: -30
                path: Path {
                    PathAttribute { name: 'z'; value: 9999.0 }
                    PathLine { x: 1; y: 1 }
                    PathAttribute { name: 'z'; value: 0.0 }
                }
            }
</db:programlisting>
<db:para>The path property holds the <db:link xlink:href="qml-qtquick-path.xml">Path</db:link> type that defines the path used by the <db:link xlink:href="qml-qtquick-pathview.xml">PathView</db:link>. The <db:link xlink:href="qml-qtquick-pathattribute.xml">PathAttribute</db:link> types are used to set a range of 0 to 9999 for the z attribute. This way, the path creates a stack of album photos. Because each PhotoDelegate is slightly rotated at a random angle, this results in a realistic-looking stack of photos.</db:para>
</db:section>
<db:section xml:id="providing-feedback-to-users">
<db:title>Providing Feedback to Users</db:title>
<db:para>We use a busy indicator and a progress bar to indicate activity while Flickr feeds and photos are being loaded.</db:para>
<db:para>In AlbumDelegate.qml, we use the BusyIndicator custom type and the on custom property to display a rotating image while the Flickr feed is being loaded:</db:para>
<db:programlisting language="cpp">            BusyIndicator {
                id: busyIndicator
                anchors { centerIn: parent; verticalCenterOffset: -20 }
                on: rssModel.status != XmlListModel.Ready
            }
</db:programlisting>
<db:para>In PhotoDelegate.qml, we use them to indicate activity while a photo is being loaded:</db:para>
<db:programlisting language="cpp">            BusyIndicator { anchors.centerIn: parent; on: originalImage.status != Image.Ready }
</db:programlisting>
<db:para>We define the BusyIndicator type in BusyIndicator.qml. We use an <db:link xlink:href="09-qdoc-commands-includingimages.xml#image">Image</db:link> type to display an image and apply a <db:link xlink:href="qml-qtquick-numberanimation.xml">NumberAnimation</db:link> to its rotation property to rotate the image in an infinite loop:</db:para>
<db:programlisting language="cpp">Image {
    id: container
    property bool on: false

    source: &quot;images/busy.png&quot;; visible: container.on
    NumberAnimation on rotation { running: container.on; from: 0; to: 360; loops: Animation.Infinite; duration: 1200 }
}
</db:programlisting>
<db:para>In your apps, you can also use the <db:link xlink:href="qml-qtquick-controls2-busyindicator.xml">BusyIndicator</db:link> type from the <db:link xlink:href="qtquickcontrols-index.xml">Qt Quick Controls</db:link> module.</db:para>
<db:para>In main.qml, we use the ProgressBar custom type to indicate progress while a high quality version of a photo is being opened on full screen:</db:para>
<db:programlisting language="cpp">    ProgressBar {
        progress: mainWindow.downloadProgress; width: parent.width; height: 4
        anchors.bottom: parent.bottom; opacity: mainWindow.imageLoading; visible: opacity != 0.0
    }
</db:programlisting>
<db:para>We define the ProgressBar type in ProgressBar.qml. We use a <db:link xlink:href="qml-qtquick-rectangle.xml">Rectangle</db:link> type to create the progress bar and apply a <db:link xlink:href="qml-qtquick-numberanimation.xml">NumberAnimation</db:link> to its opacity property to change the color of the bar from black to white as data loading proceeds:</db:para>
<db:programlisting language="cpp">Item {
    id: container

    property real progress: 0

    Behavior on opacity { NumberAnimation { duration: 600 } }

    Rectangle { anchors.fill: parent; color: &quot;black&quot;; opacity: 0.5 }

    Rectangle {
        id: fill; color: &quot;white&quot;; height: container.height
        width: container.width * container.progress
    }
}
</db:programlisting>
<db:para>In your apps, you can also use the <db:link xlink:href="qml-qtquick-controls2-progressbar.xml">ProgressBar</db:link> type from the <db:link xlink:href="qtquickcontrols-index.xml">Qt Quick Controls</db:link> module.</db:para>
</db:section>
<db:section xml:id="localizing-applications">
<db:title>Localizing Applications</db:title>
<db:para>The example application is translated into German and French. The translated strings are loaded at runtime according to the current locale.</db:para>
<db:para>We use a <db:link xlink:href="qml-qtquick-column.xml">Column</db:link> type in main.qml to position buttons for adding and editing albums and exiting the application:</db:para>
<db:programlisting language="cpp">    Column {
        spacing: 20; anchors { bottom: parent.bottom; right: parent.right; rightMargin: 20; bottomMargin: 20 }
        Button {
            id: newButton; label: qsTr(&quot;Add&quot;); rotation: 3
            anchors.horizontalCenter: parent.horizontalCenter
            onClicked: {
                mainWindow.editMode = false
                photosModel.append( { tag: &quot;&quot; } )
                albumView.positionViewAtIndex(albumView.count - 1, GridView.Contain)
            }
        }
        Button {
            id: deleteButton; label: qsTr(&quot;Edit&quot;); rotation: -2;
            onClicked: mainWindow.editMode = !mainWindow.editMode
            anchors.horizontalCenter: parent.horizontalCenter
        }
        Button {
            id: quitButton; label: qsTr(&quot;Quit&quot;); rotation: -2;
            onClicked: Qt.quit()
            anchors.horizontalCenter: parent.horizontalCenter
        }
    }
</db:programlisting>
<db:para>We use the <db:link xlink:href="qml-qtqml-qt.xml#qsTr-method">qsTr</db:link>() command to mark the button labels translatable.</db:para>
<db:para>We use the lupdate() tool to generate the translation source files and the lrelease() tool to convert the translated strings to the QM files used by the application at runtime. These files are stored in the i18n directory.</db:para>
<db:para>To make the application aware of the translations, we add code to the main() function in the main.cpp file. The code creates a <db:link xlink:href="qtranslator.xml">QTranslator</db:link> object, loads a translation according to the current locale at runtime, and installs the translator object into the application:</db:para>
<db:programlisting language="cpp">int main(int argc, char *argv[])
{
    QGuiApplication app(argc, argv);

    QTranslator qtTranslator;
    qtTranslator.load(QLocale(), &quot;qml&quot;, &quot;_&quot;, &quot;:/i18n/&quot;);
    app.installTranslator(&amp;amp;qtTranslator);
</db:programlisting>
</db:section>
<db:section>
<db:title>List of Files</db:title>
<db:para>Files:</db:para>
<db:section>
<db:title>List of Files</db:title>
<db:itemizedlist>
<db:listitem>
<db:para><db:link xlink:href="demos/photoviewer/CMakeLists.txt">demos/photoviewer/CMakeLists.txt</db:link></db:para></db:listitem>
<db:listitem>
<db:para><db:link xlink:href="demos/photoviewer/PhotoViewerCore/AlbumDelegate.qml">demos/photoviewer/PhotoViewerCore/AlbumDelegate.qml</db:link></db:para></db:listitem>
<db:listitem>
<db:para><db:link xlink:href="demos/photoviewer/PhotoViewerCore/BusyIndicator.qml">demos/photoviewer/PhotoViewerCore/BusyIndicator.qml</db:link></db:para></db:listitem>
<db:listitem>
<db:para><db:link xlink:href="demos/photoviewer/PhotoViewerCore/Button.qml">demos/photoviewer/PhotoViewerCore/Button.qml</db:link></db:para></db:listitem>
<db:listitem>
<db:para><db:link xlink:href="demos/photoviewer/PhotoViewerCore/EditableButton.qml">demos/photoviewer/PhotoViewerCore/EditableButton.qml</db:link></db:para></db:listitem>
<db:listitem>
<db:para><db:link xlink:href="demos/photoviewer/PhotoViewerCore/PhotoDelegate.qml">demos/photoviewer/PhotoViewerCore/PhotoDelegate.qml</db:link></db:para></db:listitem>
<db:listitem>
<db:para><db:link xlink:href="demos/photoviewer/PhotoViewerCore/ProgressBar.qml">demos/photoviewer/PhotoViewerCore/ProgressBar.qml</db:link></db:para></db:listitem>
<db:listitem>
<db:para><db:link xlink:href="demos/photoviewer/PhotoViewerCore/RssModel.qml">demos/photoviewer/PhotoViewerCore/RssModel.qml</db:link></db:para></db:listitem>
<db:listitem>
<db:para><db:link xlink:href="demos/photoviewer/PhotoViewerCore/Tag.qml">demos/photoviewer/PhotoViewerCore/Tag.qml</db:link></db:para></db:listitem>
<db:listitem>
<db:para><db:link xlink:href="demos/photoviewer/main.cpp">demos/photoviewer/main.cpp</db:link></db:para></db:listitem>
<db:listitem>
<db:para><db:link xlink:href="demos/photoviewer/main.qml">demos/photoviewer/main.qml</db:link></db:para></db:listitem>
<db:listitem>
<db:para><db:link xlink:href="demos/photoviewer/photoviewer.pro">demos/photoviewer/photoviewer.pro</db:link></db:para></db:listitem>
</db:itemizedlist>
</db:section>
<db:section>
<db:title>List of Files</db:title>
<db:para>Images:</db:para>
<db:section>
<db:title>List of Files</db:title>
<db:itemizedlist>
<db:listitem>
<db:para><db:link xlink:href="demos/photoviewer/PhotoViewerCore/images/box-shadow.png">demos/photoviewer/PhotoViewerCore/images/box-shadow.png</db:link></db:para></db:listitem>
<db:listitem>
<db:para><db:link xlink:href="demos/photoviewer/PhotoViewerCore/images/busy.png">demos/photoviewer/PhotoViewerCore/images/busy.png</db:link></db:para></db:listitem>
<db:listitem>
<db:para><db:link xlink:href="demos/photoviewer/PhotoViewerCore/images/cardboard.png">demos/photoviewer/PhotoViewerCore/images/cardboard.png</db:link></db:para></db:listitem>
</db:itemizedlist>
</db:section>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qmlapplications.xml">QML Applications</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section></db:section></db:article>
