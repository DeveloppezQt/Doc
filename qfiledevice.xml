<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en">
<db:info>
<db:title>QFileDevice Class</db:title>
<db:productname>QtCore</db:productname>
<db:edition>Qt 6.7.2 Reference Documentation</db:edition>
<db:titleabbrev>Qt Core Reference Documentation</db:titleabbrev>
<db:abstract>
<db:para>The <db:link xlink:href="qfiledevice.xml">QFileDevice</db:link> class provides an interface for reading from and writing to open files.</db:para>
<db:note>
<db:para>All functions in this class are <db:link xlink:href="threads-reentrancy.xml">reentrant</db:link>.</db:para>
</db:note>
</db:abstract>
<db:pubdate>2024-12-27</db:pubdate>
<db:date>2024-12-27</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:variablelist>
<db:varlistentry>
<db:term>Header</db:term>
<db:listitem>
<db:para>QFileDevice</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>CMake</db:term>
<db:listitem>
<db:para>find_package(Qt6 REQUIRED COMPONENTS Core)</db:para>
<db:para>target_link_libraries(mytarget PRIVATE Qt6::Core)</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>qmake</db:term>
<db:listitem>
<db:para>QT += core</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Inherits</db:term>
<db:listitem>
<db:para><db:link xlink:href="qiodevice.xml" xlink:role="class">QIODevice</db:link></db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Inherited By</db:term>
<db:listitem>
<db:para><db:link xlink:href="qfile.xml" xlink:role="class">QFile</db:link> and <db:link xlink:href="qsavefile.xml" xlink:role="class">QSaveFile</db:link></db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Group</db:term>
<db:listitem>
<db:para>QFileDevice is part of <db:simplelist><db:member><db:link xlink:href="io.xml">Input/Output and Networking</db:link></db:member></db:simplelist></db:para>
</db:listitem>
</db:varlistentry>
</db:variablelist>
<db:section xml:id="details">
<db:title>Detailed Description</db:title>
<db:para><db:link xlink:href="qfiledevice.xml">QFileDevice</db:link> is the base class for I/O devices that can read and write text and binary files and <db:link xlink:href="resources.xml">resources</db:link>. <db:link xlink:href="qfile.xml">QFile</db:link> offers the main functionality, <db:link xlink:href="qfiledevice.xml">QFileDevice</db:link> serves as a base class for sharing functionality with other file devices such as <db:link xlink:href="qsavefile.xml">QSaveFile</db:link>, by providing all the operations that can be done on files that have been opened by <db:link xlink:href="qfile.xml">QFile</db:link> or <db:link xlink:href="qsavefile.xml">QSaveFile</db:link>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qfile.xml">QFile</db:link></db:member>
<db:member><db:link xlink:href="qsavefile.xml">QSaveFile</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="member-type-documentation">
<db:title>Member Type Documentation</db:title>
<db:section xml:id="FileError-enum">
<db:title>enum QFileDevice::FileError</db:title>
<db:enumsynopsis>
<db:enumname>FileError</db:enumname>
<db:enumitem>
<db:enumidentifier>NoError</db:enumidentifier>
<db:enumvalue>0</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>ReadError</db:enumidentifier>
<db:enumvalue>1</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>WriteError</db:enumidentifier>
<db:enumvalue>2</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>FatalError</db:enumidentifier>
<db:enumvalue>3</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>ResourceError</db:enumidentifier>
<db:enumvalue>4</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>OpenError</db:enumidentifier>
<db:enumvalue>5</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>AbortError</db:enumidentifier>
<db:enumvalue>6</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>TimeOutError</db:enumidentifier>
<db:enumvalue>7</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>UnspecifiedError</db:enumidentifier>
<db:enumvalue>8</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>RemoveError</db:enumidentifier>
<db:enumvalue>9</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>RenameError</db:enumidentifier>
<db:enumvalue>10</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>PositionError</db:enumidentifier>
<db:enumvalue>11</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>ResizeError</db:enumidentifier>
<db:enumvalue>12</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>PermissionsError</db:enumidentifier>
<db:enumvalue>13</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>CopyError</db:enumidentifier>
<db:enumvalue>14</db:enumvalue>
</db:enumitem>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:enumsynopsis>
<db:para>This enum describes the errors that may be returned by the <db:link xlink:href="qfiledevice.xml#error">error</db:link>() function.</db:para>
<db:informaltable>
<db:thead>
<db:tr>
<db:th>Constant</db:th>
<db:th>Value</db:th>
<db:th>Description</db:th>
</db:tr>
</db:thead>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qfiledevice.xml">QFileDevice</db:link></db:emphasis>::NoError</db:code></db:para>
</db:td>
<db:td><db:code>0</db:code></db:td>
<db:td>
<db:para>No error occurred.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qfiledevice.xml">QFileDevice</db:link></db:emphasis>::ReadError</db:code></db:para>
</db:td>
<db:td><db:code>1</db:code></db:td>
<db:td>
<db:para>An error occurred when reading from the file.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qfiledevice.xml">QFileDevice</db:link></db:emphasis>::WriteError</db:code></db:para>
</db:td>
<db:td><db:code>2</db:code></db:td>
<db:td>
<db:para>An error occurred when writing to the file.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qfiledevice.xml">QFileDevice</db:link></db:emphasis>::FatalError</db:code></db:para>
</db:td>
<db:td><db:code>3</db:code></db:td>
<db:td>
<db:para>A fatal error occurred.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qfiledevice.xml">QFileDevice</db:link></db:emphasis>::ResourceError</db:code></db:para>
</db:td>
<db:td><db:code>4</db:code></db:td>
<db:td>
<db:para>Out of resources (e.g., too many open files, out of memory, etc.)</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qfiledevice.xml">QFileDevice</db:link></db:emphasis>::OpenError</db:code></db:para>
</db:td>
<db:td><db:code>5</db:code></db:td>
<db:td>
<db:para>The file could not be opened.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qfiledevice.xml">QFileDevice</db:link></db:emphasis>::AbortError</db:code></db:para>
</db:td>
<db:td><db:code>6</db:code></db:td>
<db:td>
<db:para>The operation was aborted.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qfiledevice.xml">QFileDevice</db:link></db:emphasis>::TimeOutError</db:code></db:para>
</db:td>
<db:td><db:code>7</db:code></db:td>
<db:td>
<db:para>A timeout occurred.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qfiledevice.xml">QFileDevice</db:link></db:emphasis>::UnspecifiedError</db:code></db:para>
</db:td>
<db:td><db:code>8</db:code></db:td>
<db:td>
<db:para>An unspecified error occurred.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qfiledevice.xml">QFileDevice</db:link></db:emphasis>::RemoveError</db:code></db:para>
</db:td>
<db:td><db:code>9</db:code></db:td>
<db:td>
<db:para>The file could not be removed.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qfiledevice.xml">QFileDevice</db:link></db:emphasis>::RenameError</db:code></db:para>
</db:td>
<db:td><db:code>10</db:code></db:td>
<db:td>
<db:para>The file could not be renamed.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qfiledevice.xml">QFileDevice</db:link></db:emphasis>::PositionError</db:code></db:para>
</db:td>
<db:td><db:code>11</db:code></db:td>
<db:td>
<db:para>The position in the file could not be changed.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qfiledevice.xml">QFileDevice</db:link></db:emphasis>::ResizeError</db:code></db:para>
</db:td>
<db:td><db:code>12</db:code></db:td>
<db:td>
<db:para>The file could not be resized.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qfiledevice.xml">QFileDevice</db:link></db:emphasis>::PermissionsError</db:code></db:para>
</db:td>
<db:td><db:code>13</db:code></db:td>
<db:td>
<db:para>The file could not be accessed.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qfiledevice.xml">QFileDevice</db:link></db:emphasis>::CopyError</db:code></db:para>
</db:td>
<db:td><db:code>14</db:code></db:td>
<db:td>
<db:para>The file could not be copied.</db:para>
</db:td>
</db:tr>
</db:informaltable>
</db:section>
<db:section xml:id="FileHandleFlag-enum">
<db:title>enum QFileDevice::FileHandleFlag</db:title>
<db:bridgehead renderas="sect2">flags QFileDevice::FileHandleFlags</db:bridgehead>
<db:enumsynopsis>
<db:enumname>FileHandleFlag</db:enumname>
<db:enumitem>
<db:enumidentifier>AutoCloseHandle</db:enumidentifier>
<db:enumvalue>0x0001</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>DontCloseHandle</db:enumidentifier>
<db:enumvalue>0</db:enumvalue>
</db:enumitem>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:enumsynopsis>
<db:typedefsynopsis>
<db:typedefname>QFileDevice::FileHandleFlags</db:typedefname>
</db:typedefsynopsis>
<db:para>This enum is used when opening a file to specify additional options which only apply to files and not to a generic <db:link xlink:href="qiodevice.xml">QIODevice</db:link>.</db:para>
<db:informaltable>
<db:thead>
<db:tr>
<db:th>Constant</db:th>
<db:th>Value</db:th>
<db:th>Description</db:th>
</db:tr>
</db:thead>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qfiledevice.xml">QFileDevice</db:link></db:emphasis>::AutoCloseHandle</db:code></db:para>
</db:td>
<db:td><db:code>0x0001</db:code></db:td>
<db:td>
<db:para>The file handle passed into <db:link xlink:href="qiodevice.xml#open">open</db:link>() should be closed by <db:link xlink:href="qfiledevice.xml#close">close</db:link>(), the default behavior is that close just flushes the file and the application is responsible for closing the file handle. When opening a file by name, this flag is ignored as Qt always owns the file handle and must close it.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qfiledevice.xml">QFileDevice</db:link></db:emphasis>::DontCloseHandle</db:code></db:para>
</db:td>
<db:td><db:code>0</db:code></db:td>
<db:td>
<db:para>If not explicitly closed, the underlying file handle is left open when the <db:link xlink:href="qfile.xml">QFile</db:link> object is destroyed.</db:para>
</db:td>
</db:tr>
</db:informaltable>
<db:para>The <db:code>FileHandleFlags</db:code> type is a typedef for <db:code><db:link xlink:href="qflags.xml">QFlags</db:link>&lt;FileHandleFlag&gt;. </db:code>It stores an OR combination of <db:code>FileHandleFlag</db:code> values.</db:para>
</db:section>
<db:section xml:id="FileTime-enum">
<db:title>enum QFileDevice::FileTime</db:title>
<db:enumsynopsis>
<db:enumname>FileTime</db:enumname>
<db:enumitem>
<db:enumidentifier>FileAccessTime</db:enumidentifier>
<db:enumvalue>0</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>FileBirthTime</db:enumidentifier>
<db:enumvalue>1</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>FileMetadataChangeTime</db:enumidentifier>
<db:enumvalue>2</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>FileModificationTime</db:enumidentifier>
<db:enumvalue>3</db:enumvalue>
</db:enumitem>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:enumsynopsis>
<db:para>This enum is used by the <db:link xlink:href="qfiledevice.xml#fileTime">fileTime</db:link>() and <db:link xlink:href="qfiledevice.xml#setFileTime">setFileTime</db:link>() functions.</db:para>
<db:informaltable>
<db:thead>
<db:tr>
<db:th>Constant</db:th>
<db:th>Value</db:th>
<db:th>Description</db:th>
</db:tr>
</db:thead>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qfiledevice.xml">QFileDevice</db:link></db:emphasis>::FileAccessTime</db:code></db:para>
</db:td>
<db:td><db:code>0</db:code></db:td>
<db:td>
<db:para>When the file was most recently accessed (e.g. read or written to).</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qfiledevice.xml">QFileDevice</db:link></db:emphasis>::FileBirthTime</db:code></db:para>
</db:td>
<db:td><db:code>1</db:code></db:td>
<db:td>
<db:para>When the file was created (may not be not supported on UNIX).</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qfiledevice.xml">QFileDevice</db:link></db:emphasis>::FileMetadataChangeTime</db:code></db:para>
</db:td>
<db:td><db:code>2</db:code></db:td>
<db:td>
<db:para>When the file's metadata was last changed.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qfiledevice.xml">QFileDevice</db:link></db:emphasis>::FileModificationTime</db:code></db:para>
</db:td>
<db:td><db:code>3</db:code></db:td>
<db:td>
<db:para>When the file was most recently modified.</db:para>
</db:td>
</db:tr>
</db:informaltable>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qfiledevice.xml#setFileTime">setFileTime</db:link>()</db:member>
<db:member><db:link xlink:href="qfiledevice.xml#fileTime">fileTime</db:link>()</db:member>
<db:member><db:link xlink:href="qfileinfo.xml#fileTime">QFileInfo::fileTime</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="MemoryMapFlag-enum">
<db:title>enum QFileDevice::MemoryMapFlag</db:title>
<db:bridgehead renderas="sect2">flags QFileDevice::MemoryMapFlags</db:bridgehead>
<db:enumsynopsis>
<db:enumname>MemoryMapFlag</db:enumname>
<db:enumitem>
<db:enumidentifier>NoOptions</db:enumidentifier>
<db:enumvalue>0</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>MapPrivateOption</db:enumidentifier>
<db:enumvalue>0x0001</db:enumvalue>
</db:enumitem>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:enumsynopsis>
<db:typedefsynopsis>
<db:typedefname>QFileDevice::MemoryMapFlags</db:typedefname>
</db:typedefsynopsis>
<db:para>This enum describes special options that may be used by the <db:link xlink:href="qfiledevice.xml#map">map</db:link>() function.</db:para>
<db:informaltable>
<db:thead>
<db:tr>
<db:th>Constant</db:th>
<db:th>Value</db:th>
<db:th>Description</db:th>
</db:tr>
</db:thead>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qfiledevice.xml">QFileDevice</db:link></db:emphasis>::NoOptions</db:code></db:para>
</db:td>
<db:td><db:code>0</db:code></db:td>
<db:td>
<db:para>No options.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qfiledevice.xml">QFileDevice</db:link></db:emphasis>::MapPrivateOption</db:code></db:para>
</db:td>
<db:td><db:code>0x0001</db:code></db:td>
<db:td>
<db:para>The mapped memory will be private, so any modifications will not be visible to other processes and will not be written to disk. Any such modifications will be lost when the memory is unmapped. It is unspecified whether modifications made to the file made after the mapping is created will be visible through the mapped memory. This enum value was introduced in Qt 5.4.</db:para>
</db:td>
</db:tr>
</db:informaltable>
<db:para>The <db:code>MemoryMapFlags</db:code> type is a typedef for <db:code><db:link xlink:href="qflags.xml">QFlags</db:link>&lt;MemoryMapFlag&gt;. </db:code>It stores an OR combination of <db:code>MemoryMapFlag</db:code> values.</db:para>
</db:section>
<db:section xml:id="Permission-enum">
<db:title>enum QFileDevice::Permission</db:title>
<db:bridgehead renderas="sect2">flags QFileDevice::Permissions</db:bridgehead>
<db:enumsynopsis>
<db:enumname>Permission</db:enumname>
<db:enumitem>
<db:enumidentifier>ReadOwner</db:enumidentifier>
<db:enumvalue>0x4000</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>WriteOwner</db:enumidentifier>
<db:enumvalue>0x2000</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>ExeOwner</db:enumidentifier>
<db:enumvalue>0x1000</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>ReadUser</db:enumidentifier>
<db:enumvalue>0x0400</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>WriteUser</db:enumidentifier>
<db:enumvalue>0x0200</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>ExeUser</db:enumidentifier>
<db:enumvalue>0x0100</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>ReadGroup</db:enumidentifier>
<db:enumvalue>0x0040</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>WriteGroup</db:enumidentifier>
<db:enumvalue>0x0020</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>ExeGroup</db:enumidentifier>
<db:enumvalue>0x0010</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>ReadOther</db:enumidentifier>
<db:enumvalue>0x0004</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>WriteOther</db:enumidentifier>
<db:enumvalue>0x0002</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>ExeOther</db:enumidentifier>
<db:enumvalue>0x0001</db:enumvalue>
</db:enumitem>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:enumsynopsis>
<db:typedefsynopsis>
<db:typedefname>QFileDevice::Permissions</db:typedefname>
</db:typedefsynopsis>
<db:para>This enum is used by the permission() function to report the permissions and ownership of a file. The values may be OR-ed together to test multiple permissions and ownership values.</db:para>
<db:informaltable>
<db:thead>
<db:tr>
<db:th>Constant</db:th>
<db:th>Value</db:th>
<db:th>Description</db:th>
</db:tr>
</db:thead>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qfiledevice.xml">QFileDevice</db:link></db:emphasis>::ReadOwner</db:code></db:para>
</db:td>
<db:td><db:code>0x4000</db:code></db:td>
<db:td>
<db:para>The file is readable by the owner of the file.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qfiledevice.xml">QFileDevice</db:link></db:emphasis>::WriteOwner</db:code></db:para>
</db:td>
<db:td><db:code>0x2000</db:code></db:td>
<db:td>
<db:para>The file is writable by the owner of the file.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qfiledevice.xml">QFileDevice</db:link></db:emphasis>::ExeOwner</db:code></db:para>
</db:td>
<db:td><db:code>0x1000</db:code></db:td>
<db:td>
<db:para>The file is executable by the owner of the file.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qfiledevice.xml">QFileDevice</db:link></db:emphasis>::ReadUser</db:code></db:para>
</db:td>
<db:td><db:code>0x0400</db:code></db:td>
<db:td>
<db:para>The file is readable by the user.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qfiledevice.xml">QFileDevice</db:link></db:emphasis>::WriteUser</db:code></db:para>
</db:td>
<db:td><db:code>0x0200</db:code></db:td>
<db:td>
<db:para>The file is writable by the user.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qfiledevice.xml">QFileDevice</db:link></db:emphasis>::ExeUser</db:code></db:para>
</db:td>
<db:td><db:code>0x0100</db:code></db:td>
<db:td>
<db:para>The file is executable by the user.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qfiledevice.xml">QFileDevice</db:link></db:emphasis>::ReadGroup</db:code></db:para>
</db:td>
<db:td><db:code>0x0040</db:code></db:td>
<db:td>
<db:para>The file is readable by the group.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qfiledevice.xml">QFileDevice</db:link></db:emphasis>::WriteGroup</db:code></db:para>
</db:td>
<db:td><db:code>0x0020</db:code></db:td>
<db:td>
<db:para>The file is writable by the group.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qfiledevice.xml">QFileDevice</db:link></db:emphasis>::ExeGroup</db:code></db:para>
</db:td>
<db:td><db:code>0x0010</db:code></db:td>
<db:td>
<db:para>The file is executable by the group.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qfiledevice.xml">QFileDevice</db:link></db:emphasis>::ReadOther</db:code></db:para>
</db:td>
<db:td><db:code>0x0004</db:code></db:td>
<db:td>
<db:para>The file is readable by others.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qfiledevice.xml">QFileDevice</db:link></db:emphasis>::WriteOther</db:code></db:para>
</db:td>
<db:td><db:code>0x0002</db:code></db:td>
<db:td>
<db:para>The file is writable by others.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qfiledevice.xml">QFileDevice</db:link></db:emphasis>::ExeOther</db:code></db:para>
</db:td>
<db:td><db:code>0x0001</db:code></db:td>
<db:td>
<db:para>The file is executable by others.</db:para>
</db:td>
</db:tr>
</db:informaltable>
<db:warning>
<db:para>Because of differences in the platforms supported by Qt, the semantics of ReadUser, WriteUser and ExeUser are platform-dependent: On Unix, the rights of the owner of the file are returned and on Windows the rights of the current user are returned. This behavior might change in a future Qt version.</db:para>
</db:warning>
<db:note>
<db:para>On NTFS file systems, ownership and permissions checking is disabled by default for performance reasons. To enable it, include the following line:</db:para>
</db:note>
<db:programlisting language="cpp">extern Q_CORE_EXPORT int qt_ntfs_permission_lookup;
</db:programlisting>
<db:para>Permission checking is then turned on and off by incrementing and decrementing qt_ntfs_permission_lookup by 1.</db:para>
<db:programlisting language="cpp">qt_ntfs_permission_lookup++; // turn checking on
qt_ntfs_permission_lookup--; // turn it off again
</db:programlisting>
<db:note>
<db:para>Since this is a non-atomic global variable, it is only safe to increment or decrement qt_ntfs_permission_lookup before any threads other than the main thread have started or after every thread other than the main thread has ended.</db:para>
</db:note>
<db:note>
<db:para>From Qt 6.6 the variable qt_ntfs_permission_lookup is deprecated. Please use the following alternatives.</db:para>
</db:note>
<db:para>The safe and easy way to manage permission checks is to use the RAII class QNtfsPermissionCheckGuard.</db:para>
<db:programlisting language="cpp">void complexFunction()
{
    QNtfsPermissionCheckGuard permissionGuard;  // check is enabled

    // do complex things here that need permission check enabled

}   // as the guard goes out of scope the check is disabled
</db:programlisting>
<db:para>If you need more fine-grained control, it is possible to manage the permission with the following functions instead:</db:para>
<db:programlisting language="cpp">qAreNtfsPermissionChecksEnabled();   // check status
qEnableNtfsPermissionChecks();       // turn checking on
qDisableNtfsPermissionChecks();      // turn it off again
</db:programlisting>
<db:para>The <db:code>Permissions</db:code> type is a typedef for <db:code><db:link xlink:href="qflags.xml">QFlags</db:link>&lt;Permission&gt;. </db:code>It stores an OR combination of <db:code>Permission</db:code> values.</db:para>
</db:section>
</db:section>
<db:section xml:id="member-function-documentation">
<db:title>Member Function Documentation</db:title>
<db:section xml:id="dtor.QFileDevice">
<db:title>[virtual] QFileDevice::~QFileDevice()</db:title>
<db:destructorsynopsis>
<db:modifier>virtual</db:modifier>
<db:methodname>~QFileDevice</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">destructor</db:synopsisinfo>
<db:synopsisinfo role="signature">~QFileDevice()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:destructorsynopsis>
<db:para>Destroys the file device, closing it if necessary.</db:para>
</db:section>
<db:section xml:id="atEnd">
<db:title>[override virtual] bool QFileDevice::atEnd() const</db:title>
<db:methodsynopsis>
<db:modifier>virtual</db:modifier>
<db:modifier>const</db:modifier>
<db:type>bool</db:type>
<db:methodname>atEnd</db:methodname>
<db:void/>
<db:modifier>override</db:modifier>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool atEnd() const override</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Reimplements: <db:link xlink:href="qiodevice.xml#atEnd" role="function">QIODevice::atEnd() const</db:link>.</db:para>
<db:para>Returns true if the end of the file has been reached; otherwise returns false.</db:para>
<db:para>For regular empty files on Unix (e.g. those in /proc), this function returns true, since the file system reports that the size of such a file is 0. Therefore, you should not depend on atEnd() when reading data from such a file, but rather call <db:link xlink:href="qiodevice.xml#read">read</db:link>() until no more data can be read.</db:para>
</db:section>
<db:section xml:id="close">
<db:title>[override virtual] void QFileDevice::close()</db:title>
<db:methodsynopsis>
<db:modifier>virtual</db:modifier>
<db:void/>
<db:methodname>close</db:methodname>
<db:void/>
<db:modifier>override</db:modifier>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void close() override</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Reimplements: <db:link xlink:href="qiodevice.xml#close" role="function">QIODevice::close()</db:link>.</db:para>
<db:para>Calls <db:link xlink:href="qfiledevice.xml#flush">QFileDevice::flush</db:link>() and closes the file. Errors from flush are ignored.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qiodevice.xml#close">QIODevice::close</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="error">
<db:title>QFileDevice::FileError QFileDevice::error() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QFileDevice::FileError</db:type>
<db:methodname>error</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QFileDevice::FileError error() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the file error status.</db:para>
<db:para>The I/O device status returns an error code. For example, if <db:link xlink:href="qiodevice.xml#open">open</db:link>() returns false, or a read/write operation returns -1, this function can be called to find out the reason why the operation failed.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qfiledevice.xml#unsetError">unsetError</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="fileName">
<db:title>[virtual] QString QFileDevice::fileName() const</db:title>
<db:methodsynopsis>
<db:modifier>virtual</db:modifier>
<db:modifier>const</db:modifier>
<db:type>QString</db:type>
<db:methodname>fileName</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QString fileName() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the name of the file. The default implementation in <db:link xlink:href="qfiledevice.xml">QFileDevice</db:link> returns a null string.</db:para>
</db:section>
<db:section xml:id="fileTime">
<db:title>QDateTime QFileDevice::fileTime(QFileDevice::FileTime <db:emphasis>time</db:emphasis>) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QDateTime</db:type>
<db:methodname>fileTime</db:methodname>
<db:methodparam>
<db:type>QFileDevice::FileTime</db:type>
<db:parameter>time</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QDateTime fileTime(QFileDevice::FileTime time) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the file time specified by <db:code role="parameter">time</db:code>. If the time cannot be determined return QDateTime() (an invalid date time).</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qfiledevice.xml#setFileTime">setFileTime</db:link>()</db:member>
<db:member><db:link xlink:href="qfiledevice.xml#FileTime-enum">FileTime</db:link></db:member>
<db:member><db:link xlink:href="qdatetime.xml#isValid">QDateTime::isValid</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="flush">
<db:title>bool QFileDevice::flush()</db:title>
<db:methodsynopsis>
<db:type>bool</db:type>
<db:methodname>flush</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool flush()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Flushes any buffered data to the file. Returns true if successful; otherwise returns false.</db:para>
</db:section>
<db:section xml:id="handle">
<db:title>int QFileDevice::handle() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>int</db:type>
<db:methodname>handle</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">int handle() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the file handle of the file.</db:para>
<db:para>This is a small positive integer, suitable for use with C library functions such as fdopen() and fcntl(). On systems that use file descriptors for sockets (i.e. Unix systems, but not Windows) the handle can be used with <db:link xlink:href="qsocketnotifier.xml">QSocketNotifier</db:link> as well.</db:para>
<db:para>If the file is not open, or there is an error, handle() returns -1.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qsocketnotifier.xml">QSocketNotifier</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="isSequential">
<db:title>[override virtual] bool QFileDevice::isSequential() const</db:title>
<db:methodsynopsis>
<db:modifier>virtual</db:modifier>
<db:modifier>const</db:modifier>
<db:type>bool</db:type>
<db:methodname>isSequential</db:methodname>
<db:void/>
<db:modifier>override</db:modifier>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool isSequential() const override</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Reimplements: <db:link xlink:href="qiodevice.xml#isSequential" role="function">QIODevice::isSequential() const</db:link>.</db:para>
<db:para>Returns true if the file can only be manipulated sequentially; otherwise returns false.</db:para>
<db:para>Most files support random-access, but some special files may not.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qiodevice.xml#isSequential">QIODevice::isSequential</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="map">
<db:title>uchar *QFileDevice::map(qint64 <db:emphasis>offset</db:emphasis>, qint64 <db:emphasis>size</db:emphasis>, QFileDevice::MemoryMapFlags <db:emphasis>flags</db:emphasis> = NoOptions)</db:title>
<db:methodsynopsis>
<db:type>uchar *</db:type>
<db:methodname>map</db:methodname>
<db:methodparam>
<db:type>qint64</db:type>
<db:parameter>offset</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>qint64</db:type>
<db:parameter>size</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>QFileDevice::MemoryMapFlags</db:type>
<db:parameter>flags</db:parameter>
<db:initializer>NoOptions</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">uchar * map(qint64 offset, qint64 size, QFileDevice::MemoryMapFlags flags)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Maps <db:code role="parameter">size</db:code> bytes of the file into memory starting at <db:code role="parameter">offset</db:code>. A file should be open for a map to succeed but the file does not need to stay open after the memory has been mapped. When the <db:link xlink:href="qfile.xml">QFile</db:link> is destroyed or a new file is opened with this object, any maps that have not been unmapped will automatically be unmapped.</db:para>
<db:para>The mapping will have the same open mode as the file (read and/or write), except when using <db:link xlink:href="qfiledevice.xml#MemoryMapFlag-enum">MapPrivateOption</db:link>, in which case it is always possible to write to the mapped memory.</db:para>
<db:para>Any mapping options can be passed through <db:code role="parameter">flags</db:code>.</db:para>
<db:para>Returns a pointer to the memory or nullptr if there is an error.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qfiledevice.xml#unmap">unmap</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="permissions">
<db:title>[virtual] QFileDevice::Permissions QFileDevice::permissions() const</db:title>
<db:methodsynopsis>
<db:modifier>virtual</db:modifier>
<db:modifier>const</db:modifier>
<db:type>QFileDevice::Permissions</db:type>
<db:methodname>permissions</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QFileDevice::Permissions permissions() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the complete OR-ed together combination of QFile::Permission for the file.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qfiledevice.xml#setPermissions">setPermissions</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="pos">
<db:title>[override virtual] qint64 QFileDevice::pos() const</db:title>
<db:methodsynopsis>
<db:modifier>virtual</db:modifier>
<db:modifier>const</db:modifier>
<db:type>qint64</db:type>
<db:methodname>pos</db:methodname>
<db:void/>
<db:modifier>override</db:modifier>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">qint64 pos() const override</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Reimplements: <db:link xlink:href="qiodevice.xml#pos" role="function">QIODevice::pos() const</db:link>.</db:para>
</db:section>
<db:section xml:id="readData">
<db:title>[override virtual protected] qint64 QFileDevice::readData(char *<db:emphasis>data</db:emphasis>, qint64 <db:emphasis>len</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:modifier>virtual</db:modifier>
<db:type>qint64</db:type>
<db:methodname>readData</db:methodname>
<db:methodparam>
<db:type>char *</db:type>
<db:parameter>data</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>qint64</db:type>
<db:parameter>len</db:parameter>
</db:methodparam>
<db:modifier>override</db:modifier>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">qint64 readData(char *data, qint64 len) override</db:synopsisinfo>
<db:synopsisinfo role="access">protected</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Reimplements: <db:link xlink:href="qiodevice.xml#readData" role="function">QIODevice::readData(char *data, qint64 maxSize)</db:link>.</db:para>
</db:section>
<db:section xml:id="readLineData">
<db:title>[override virtual protected] qint64 QFileDevice::readLineData(char *<db:emphasis>data</db:emphasis>, qint64 <db:emphasis>maxlen</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:modifier>virtual</db:modifier>
<db:type>qint64</db:type>
<db:methodname>readLineData</db:methodname>
<db:methodparam>
<db:type>char *</db:type>
<db:parameter>data</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>qint64</db:type>
<db:parameter>maxlen</db:parameter>
</db:methodparam>
<db:modifier>override</db:modifier>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">qint64 readLineData(char *data, qint64 maxlen) override</db:synopsisinfo>
<db:synopsisinfo role="access">protected</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Reimplements: <db:link xlink:href="qiodevice.xml#readLineData" role="function">QIODevice::readLineData(char *data, qint64 maxSize)</db:link>.</db:para>
</db:section>
<db:section xml:id="resize">
<db:title>[virtual] bool QFileDevice::resize(qint64 <db:emphasis>sz</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:modifier>virtual</db:modifier>
<db:type>bool</db:type>
<db:methodname>resize</db:methodname>
<db:methodparam>
<db:type>qint64</db:type>
<db:parameter>sz</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool resize(qint64 sz)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Sets the file size (in bytes) <db:code role="parameter">sz</db:code>. Returns true if the resize succeeds; false otherwise. If <db:code role="parameter">sz</db:code> is larger than the file currently is, the new bytes will be set to 0; if <db:code role="parameter">sz</db:code> is smaller, the file is simply truncated.</db:para>
<db:warning>
<db:para>This function can fail if the file doesn't exist.</db:para>
</db:warning>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qfiledevice.xml#size">size</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="seek">
<db:title>[override virtual] bool QFileDevice::seek(qint64 <db:emphasis>pos</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:modifier>virtual</db:modifier>
<db:type>bool</db:type>
<db:methodname>seek</db:methodname>
<db:methodparam>
<db:type>qint64</db:type>
<db:parameter>pos</db:parameter>
</db:methodparam>
<db:modifier>override</db:modifier>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool seek(qint64 pos) override</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Reimplements: <db:link xlink:href="qiodevice.xml#seek" role="function">QIODevice::seek(qint64 pos)</db:link>.</db:para>
<db:para>For random-access devices, this function sets the current position to <db:code role="parameter">pos</db:code>, returning true on success, or false if an error occurred. For sequential devices, the default behavior is to do nothing and return false.</db:para>
<db:para>Seeking beyond the end of a file: If the position is beyond the end of a file, then seek() will not immediately extend the file. If a write is performed at this position, then the file will be extended. The content of the file between the previous end of file and the newly written data is UNDEFINED and varies between platforms and file systems.</db:para>
</db:section>
<db:section xml:id="setFileTime">
<db:title>bool QFileDevice::setFileTime(const QDateTime &amp;<db:emphasis>newDate</db:emphasis>, QFileDevice::FileTime <db:emphasis>fileTime</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>bool</db:type>
<db:methodname>setFileTime</db:methodname>
<db:methodparam>
<db:type>const QDateTime &amp;</db:type>
<db:parameter>newDate</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>QFileDevice::FileTime</db:type>
<db:parameter>fileTime</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool setFileTime(const QDateTime &amp;newDate, QFileDevice::FileTime fileTime)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Sets the file time specified by <db:code role="parameter">fileTime</db:code> to <db:code role="parameter">newDate</db:code>, returning true if successful; otherwise returns false.</db:para>
<db:note>
<db:para>The file must be open to use this function.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qfiledevice.xml#fileTime">fileTime</db:link>()</db:member>
<db:member><db:link xlink:href="qfiledevice.xml#FileTime-enum">FileTime</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setPermissions">
<db:title>[virtual] bool QFileDevice::setPermissions(QFileDevice::Permissions <db:emphasis>permissions</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:modifier>virtual</db:modifier>
<db:type>bool</db:type>
<db:methodname>setPermissions</db:methodname>
<db:methodparam>
<db:type>QFileDevice::Permissions</db:type>
<db:parameter>permissions</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool setPermissions(QFileDevice::Permissions permissions)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Sets the permissions for the file to the <db:code role="parameter">permissions</db:code> specified. Returns true if successful, or false if the permissions cannot be modified.</db:para>
<db:warning>
<db:para>This function does not manipulate ACLs, which may limit its effectiveness.</db:para>
</db:warning>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qfiledevice.xml#permissions">permissions</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="size">
<db:title>[override virtual] qint64 QFileDevice::size() const</db:title>
<db:methodsynopsis>
<db:modifier>virtual</db:modifier>
<db:modifier>const</db:modifier>
<db:type>qint64</db:type>
<db:methodname>size</db:methodname>
<db:void/>
<db:modifier>override</db:modifier>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">qint64 size() const override</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Reimplements: <db:link xlink:href="qiodevice.xml#size" role="function">QIODevice::size() const</db:link>.</db:para>
<db:para>Returns the size of the file.</db:para>
<db:para>For regular empty files on Unix (e.g. those in /proc), this function returns 0; the contents of such a file are generated on demand in response to you calling <db:link xlink:href="qiodevice.xml#read">read</db:link>().</db:para>
</db:section>
<db:section xml:id="unmap">
<db:title>bool QFileDevice::unmap(uchar *<db:emphasis>address</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>bool</db:type>
<db:methodname>unmap</db:methodname>
<db:methodparam>
<db:type>uchar *</db:type>
<db:parameter>address</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool unmap(uchar *address)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Unmaps the memory <db:code role="parameter">address</db:code>.</db:para>
<db:para>Returns true if the unmap succeeds; false otherwise.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qfiledevice.xml#map">map</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="unsetError">
<db:title>void QFileDevice::unsetError()</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>unsetError</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void unsetError()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Sets the file's error to <db:link xlink:href="qfiledevice.xml#FileError-enum">QFileDevice::NoError</db:link>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qfiledevice.xml#error">error</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="writeData">
<db:title>[override virtual protected] qint64 QFileDevice::writeData(const char *<db:emphasis>data</db:emphasis>, qint64 <db:emphasis>len</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:modifier>virtual</db:modifier>
<db:type>qint64</db:type>
<db:methodname>writeData</db:methodname>
<db:methodparam>
<db:type>const char *</db:type>
<db:parameter>data</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>qint64</db:type>
<db:parameter>len</db:parameter>
</db:methodparam>
<db:modifier>override</db:modifier>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">qint64 writeData(const char *data, qint64 len) override</db:synopsisinfo>
<db:synopsisinfo role="access">protected</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Reimplements: <db:link xlink:href="qiodevice.xml#writeData" role="function">QIODevice::writeData(const char *data, qint64 maxSize)</db:link>.</db:para>
</db:section>
</db:section>
</db:article>
