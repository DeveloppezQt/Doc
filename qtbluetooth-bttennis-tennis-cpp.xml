<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en_US">
<db:info>
<db:title>Bluetooth Tennis Example</db:title>
<db:productname>QtBluetooth</db:productname>
<db:edition>Qt 5.2.1 Reference Documentation</db:edition>
<db:titleabbrev>Qt Bluetooth Reference Documentation</db:titleabbrev>
<db:abstract>
<db:para>Qt Bluetooth Reference Documentation.</db:para></db:abstract>
<db:pubdate>2025-06-29</db:pubdate>
<db:date>2025-06-29</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:programlisting language="cpp">/****************************************************************************
**
** Copyright (C) 2013 Digia Plc and/or its subsidiary(-ies).
** Contact: http://www.qt-project.org/legal
**
** This file is part of the Qt Toolkit.
**
** $QT_BEGIN_LICENSE:LGPL$
** Commercial License Usage
** Licensees holding valid commercial Qt licenses may use this file in
** accordance with the commercial license agreement provided with the
** Software or, alternatively, in accordance with the terms contained in
** a written agreement between you and Digia.  For licensing terms and
** conditions see http://qt.digia.com/licensing.  For further information
** use the contact form at http://qt.digia.com/contact-us.
**
** GNU Lesser General Public License Usage
** Alternatively, this file may be used under the terms of the GNU Lesser
** General Public License version 2.1 as published by the Free Software
** Foundation and appearing in the file LICENSE.LGPL included in the
** packaging of this file.  Please review the following information to
** ensure the GNU Lesser General Public License version 2.1 requirements
** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
**
** In addition, as a special exception, Digia gives you certain additional
** rights.  These rights are described in the Digia Qt LGPL Exception
** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
**
** GNU General Public License Usage
** Alternatively, this file may be used under the terms of the GNU
** General Public License version 3.0 as published by the Free Software
** Foundation and appearing in the file LICENSE.GPL included in the
** packaging of this file.  Please review the following information to
** ensure the GNU General Public License version 3.0 requirements will be
** met: http://www.gnu.org/copyleft/gpl.html.
**
**
** $QT_END_LICENSE$
**
****************************************************************************/

#include &quot;tennis.h&quot;

#include &lt;QTimer&gt;
#include &lt;QKeyEvent&gt;
#include &lt;QMouseEvent&gt;

#include &lt;QDebug&gt;

#include &lt;QSettings&gt;
#include &lt;QEvent&gt;
#include &lt;QResizeEvent&gt;

#include &quot;tennisserver.h&quot;
#include &quot;tennisclient.h&quot;
//#include &quot;handover.h&quot;

#include &lt;qbluetooth.h&gt;
#include &lt;qbluetoothdeviceinfo.h&gt;
#include &lt;qbluetoothsocket.h&gt;
#include &lt;qbluetoothservicediscoveryagent.h&gt;
#include &lt;qbluetoothlocaldevice.h&gt;

//#include &lt;qnearfieldmanager.h&gt;
//#include &lt;qllcpserver.h&gt;
//#include &lt;qllcpsocket.h&gt;

Tennis::Tennis(QWidget *parent)
: QDialog(parent), ui(new Ui_Tennis), board(new Board), controller(new Controller), socket(0)
  //, m_handover(0)
{
    // start Bluetooth if not started
    QBluetoothLocalDevice *device = new QBluetoothLocalDevice();
    device-&gt;powerOn();
    delete device;
    device = 0;

    //Using default Bluetooth adapter
    QBluetoothLocalDevice localDevice;
    QBluetoothAddress adapterAddress = localDevice.address();

    /*
     * In case of multiple Bluetooth adapters it is possible to
     * set which adapter will be used by providing MAC Address.
     * Example code:
     *
     * QBluetoothAddress adapterAddress(&quot;XX:XX:XX:XX:XX:XX&quot;);
     * m_discoveryAgent = new QBluetoothServiceDiscoveryAgent(adapterAddress);
     */

    m_discoveryAgent = new QBluetoothServiceDiscoveryAgent(adapterAddress, this);

    ui-&gt;setupUi(this);

    isClient = false;
    isConnected = false;
    quickDiscovery = true;

    ui-&gt;pongView-&gt;setScene(board-&gt;getScene());

    connect(ui-&gt;pongView, SIGNAL(mouseMove(int, int)), this, SLOT(mouseMove(int, int)));
    ui-&gt;pongView-&gt;setMouseTracking(false);

    connect(board, SIGNAL(ballCollision(Board::Edge)), controller, SLOT(ballCollision(Board::Edge)));
    connect(board, SIGNAL(scored(Board::Edge)), controller, SLOT(scored(Board::Edge)));
    connect(controller, SIGNAL(moveBall(int,int)), board, SLOT(setBall(int,int)));
    connect(this, SIGNAL(moveLeftPaddle(int)), board, SLOT(setLeftPaddle(int)));
    connect(this, SIGNAL(moveRightPaddle(int)), board, SLOT(setRightPaddle(int)));
    connect(controller, SIGNAL(score(int,int)), board, SLOT(setScore(int,int)));
    connect(controller, SIGNAL(fps(const QString&amp;)), this, SLOT(fps(const QString&amp;)));

    setFocusPolicy(Qt::WheelFocus);

    paddle_pos = (Board::Height-12)/2-Board::Paddle/2;
    endPaddlePos = paddle_pos;

    emit moveLeftPaddle(paddle_pos);
    board-&gt;setRightPaddle(paddle_pos);

    server = new TennisServer(this);

    connect(controller, SIGNAL(moveBall(int,int)), server, SLOT(moveBall(int,int)));
    connect(controller, SIGNAL(score(int,int)), server, SLOT(score(int,int)));
    connect(this, SIGNAL(moveLeftPaddle(int)), server, SLOT(moveLeftPaddle(int)));
    connect(server, SIGNAL(clientConnected(QString)), this, SLOT(serverConnected(QString)));
    connect(server, SIGNAL(clientDisconnected(QString)), this, SLOT(serverDisconnected()));
    connect(server, SIGNAL(moveRightPaddle(int)), board, SLOT(setRightPaddle(int)));
    connect(server, SIGNAL(lag(int)), this, SLOT(lagReport(int)));

    connect(server, SIGNAL(clientConnected(QString)), controller, SLOT(refresh()));

    server-&gt;startServer();

    client = new TennisClient(this);

    connect(client, SIGNAL(moveBall(int,int)), board, SLOT(setBall(int,int)));
    connect(client, SIGNAL(moveLeftPaddle(int)), board, SLOT(setLeftPaddle(int)));
    connect(client, SIGNAL(connected(QString)), this, SLOT(clientConnected(QString)));
    connect(client, SIGNAL(disconnected()), this, SLOT(clientDisconnected()));
    connect(this, SIGNAL(moveRightPaddle(int)), client, SLOT(moveRightPaddle(int)));
    connect(client, SIGNAL(score(int,int)), board, SLOT(setScore(int,int)));
    connect(client, SIGNAL(lag(int)), this, SLOT(lagReport(int)));

    connect(this, SIGNAL(moveLeftPaddle(int)), controller, SLOT(moveLeftPaddle(int)));
    connect(this, SIGNAL(moveRightPaddle(int)), controller, SLOT(moveRightPaddle(int)));
    connect(server, SIGNAL(moveRightPaddle(int)), controller, SLOT(moveRightPaddle(int)));

//    ui-&gt;pongView-&gt;setBackgroundBrush(QBrush(Qt::white));
    ui-&gt;pongView-&gt;setCacheMode(QGraphicsView::CacheBackground);

/*    QNearFieldManager nearFieldManager;
    if (nearFieldManager.isAvailable()) {
        m_handover = new Handover(server-&gt;serverPort(), this);
        connect(m_handover, SIGNAL(bluetoothServiceChanged()), this, SLOT(nearFieldHandover()));

        connect(m_discoveryAgent, SIGNAL(serviceDiscovered(QBluetoothServiceInfo)),
                this, SLOT(serviceDiscovered(QBluetoothServiceInfo)));
        connect(m_discoveryAgent, SIGNAL(finished()), this, SLOT(discoveryFinished()));
    }*/

    m_discoveryAgent-&gt;setUuidFilter(QBluetoothUuid(serviceUuid));

    QString address;
    QString port;
    QStringList args = QCoreApplication::arguments();
    if (args.length() &gt;= 2){
        address = args.at(1);
        if (args.length() &gt;= 3){
            port = args.at(2);
        }
    }

    if (address.isEmpty()){
        QSettings settings(&quot;QtDF&quot;, &quot;bttennis&quot;);
        address = settings.value(&quot;lastclient&quot;).toString();
    }

    if (!address.isEmpty()){
        qDebug() &lt;&lt; &quot;Connect to&quot; &lt;&lt; address &lt;&lt; port;
        QBluetoothDeviceInfo device = QBluetoothDeviceInfo(QBluetoothAddress(address), &quot;&quot;, QBluetoothDeviceInfo::ComputerDevice);
        QBluetoothServiceInfo service;
        if (!port.isEmpty()) {
            QBluetoothServiceInfo::Sequence protocolDescriptorList;
            QBluetoothServiceInfo::Sequence protocol;
            protocol &lt;&lt; QVariant::fromValue(QBluetoothUuid(QBluetoothUuid::L2cap))
                     &lt;&lt; QVariant::fromValue(port.toUShort());
            protocolDescriptorList.append(QVariant::fromValue(protocol));
            service.setAttribute(QBluetoothServiceInfo::ProtocolDescriptorList,
                                 protocolDescriptorList);
            qDebug() &lt;&lt; &quot;port&quot; &lt;&lt; port.toUShort() &lt;&lt; service.protocolServiceMultiplexer();
        }
        else {
            service.setServiceUuid(QBluetoothUuid(serviceUuid));
        }
        service.setDevice(device);
        client-&gt;startClient(service);
        board-&gt;setStatus(&quot;Connecting&quot;, 100, 25);
    } /*else if (nearFieldManager.isAvailable()) {
        board-&gt;setStatus(tr(&quot;Touch to play&quot;), 100, 25);
    }*/

    setEnabled(true);

    paddleAnimation = new QPropertyAnimation(this, &quot;paddlePos&quot;, this);
    paddleAnimation-&gt;setEasingCurve(QEasingCurve::InOutQuad);

    ui-&gt;pongView-&gt;installEventFilter(this);

}

Tennis::~Tennis()
{
}

void Tennis::keyPressEvent(QKeyEvent *event)
{
    if (event-&gt;matches(QKeySequence::MoveToNextLine)) {
        moveDown();
    }
    else if (event-&gt;matches(QKeySequence::MoveToPreviousLine)){
        moveUp();
    }
}

void Tennis::wheelEvent(QWheelEvent *event)
{
    if (event-&gt;delta() &gt; 0){
        moveUp();
    }
    else {
        moveDown();
    }
}

void Tennis::moveUp(int px)
{
    endPaddlePos -= px;
    if (endPaddlePos &lt;= 0)
        endPaddlePos = 0;
    move(endPaddlePos);
}

void Tennis::moveDown(int px)
{
    endPaddlePos += px;
    if (endPaddlePos &gt; Board::Height-Board::Paddle-24)
        endPaddlePos = Board::Height-Board::Paddle-24;
    move(endPaddlePos);

}

void Tennis::move(int px)
{
    int distance = abs(paddle_pos - endPaddlePos);

    paddleAnimation-&gt;stop();
    paddleAnimation-&gt;setStartValue(paddle_pos);
    paddleAnimation-&gt;setEndValue(px);
    paddleAnimation-&gt;setDuration((1000*distance)/350);
    paddleAnimation-&gt;start();
}

void Tennis::setPaddlePos(int p)
{
    paddle_pos = p;
    if (isClient)
        emit moveRightPaddle(paddle_pos);
    else
        emit moveLeftPaddle(paddle_pos);
}

void Tennis::mouseMove(int x, int y)
{
    if (isConnected == false){
        // look for clicks in the bt connect icon
        if (x &gt; 440 &amp;&amp; x &lt; 540 &amp;&amp; y &gt; 200 &amp;&amp; y &lt; 300) {
            qDebug() &lt;&lt; &quot;Got connect click!&quot;;
            if (m_discoveryAgent-&gt;isActive()) {
                qDebug() &lt;&lt; &quot;stopping!&quot;;
                m_discoveryAgent-&gt;stop();
                board-&gt;animateConnect(false);
            }
            else {
                qDebug() &lt;&lt; &quot;starting!&quot;;
                startDiscovery();
            }
        }

    }
    y-=12+Board::Paddle/2;
    if (y &lt;= 0)
        y = 0;
    else if (y &gt; Board::Height-Board::Paddle-24)
        y = Board::Height-Board::Paddle-24;

    endPaddlePos = y;
    move(y);
}

void Tennis::clientConnected(const QString &amp;name)
{
    board-&gt;setStatus(&quot;Connected to &quot; + name, 100, 0);
    controller-&gt;stop();
    server-&gt;stopServer();
    isClient = true;
    isConnected = true;
    board-&gt;animateConnect(false);
    board-&gt;fadeConnect(true);
    emit moveRightPaddle(paddle_pos);
}

void Tennis::clientDisconnected()
{
    board-&gt;setStatus(&quot;Disconnect&quot;, 100, 25);
    controller-&gt;start();
    server-&gt;startServer();
    client-&gt;stopClient();
    isClient = false;
    isConnected = false;
    discoveryFinished();
}

void Tennis::serverConnected(const QString &amp;name)
{
    board-&gt;setStatus(&quot;Server for &quot; + name, 100, 0);
    m_discoveryAgent-&gt;stop();
    isConnected = true;
    board-&gt;animateConnect(false);
    board-&gt;fadeConnect(true);
    emit moveLeftPaddle(paddle_pos);
}

void Tennis::serverDisconnected()
{
    board-&gt;setStatus(&quot;Disconnected&quot;, 100, 25);
    isConnected = false;
    discoveryFinished();
}

void Tennis::serviceDiscovered(const QBluetoothServiceInfo &amp;serviceInfo)
{
    qDebug() &lt;&lt; &quot;***** Discovered! &quot; &lt;&lt; serviceInfo.device().name() &lt;&lt; serviceInfo.serviceName() &lt;&lt; serviceInfo.serviceUuid();
    qDebug() &lt;&lt; &quot;Found one!&quot; &lt;&lt; serviceInfo.protocolServiceMultiplexer();
    m_discoveryAgent-&gt;stop();
    client-&gt;startClient(serviceInfo);
    QSettings settings(&quot;QtDF&quot;, &quot;bttennis&quot;);
    settings.setValue(&quot;lastclient&quot;, serviceInfo.device().address().toString());
}

void Tennis::discoveryFinished()
{
    if (!m_discoveryAgent-&gt;isActive()) {
        if (!isConnected) {
            board-&gt;setStatus(&quot;Waiting&quot;, 100, 25);
    //        QTimer::singleShot(60000, this, SLOT(startDiscovery()));
            board-&gt;animateConnect(false);
            board-&gt;fadeConnect(false);
       }
    }
}

void Tennis::startDiscovery()
{
    qDebug() &lt;&lt; &quot;startDiscovery() called&quot;;
    if (!isConnected) {
        qDebug() &lt;&lt; &quot;Scanning!&quot;;
        board-&gt;setStatus(&quot;Scanning&quot;, 100, 25);
        board-&gt;fadeConnect(false);
        board-&gt;animateConnect(true);
        m_discoveryAgent-&gt;start(QBluetoothServiceDiscoveryAgent::MinimalDiscovery);
//        if (quickDiscovery)
//            m_discoveryAgent-&gt;start(QBluetoothServiceDiscoveryAgent::MinimalDiscovery);
//        else
//            m_discoveryAgent-&gt;start(QBluetoothServiceDiscoveryAgent::FullDiscovery);
//        quickDiscovery = !quickDiscovery;
    }
    else {
        qDebug() &lt;&lt; &quot;Stop scanning!&quot;;
        board-&gt;setStatus(&quot;&quot;, 0, 0);
        board-&gt;animateConnect(false);
        board-&gt;fadeConnect(true);
    }
}

void Tennis::resizeEvent(QResizeEvent *re)
{
    if (re-&gt;oldSize().height() &gt; 0){
        qreal x, y;
        x = (re-&gt;size().width())/qreal(re-&gt;oldSize().width());
        y = (re-&gt;size().height())/qreal(re-&gt;oldSize().height());
        ui-&gt;pongView-&gt;scale(x, y);
    }
    ui-&gt;pongView-&gt;resize(re-&gt;size());
}

void Tennis::lagReport(int ms)
{
    if (ms &gt; 250){
        board-&gt;setStatus(QString(&quot;Caution Lag %1ms&quot;).arg(ms), 100, 0);
    }
}

/*void Tennis::nearFieldHandover()
{
    qDebug() &lt;&lt; &quot;Connecting to NFC provided address&quot; &lt;&lt; m_handover-&gt;bluetoothAddress().toString();

    QBluetoothDeviceInfo device = QBluetoothDeviceInfo(m_handover-&gt;bluetoothAddress(), QString(),
                                                       QBluetoothDeviceInfo::ComputerDevice);

    QBluetoothServiceInfo service;
    service.setServiceUuid(QBluetoothUuid(serviceUuid));
    service.setDevice(device);

    QBluetoothServiceInfo::Sequence protocolDescriptorList;
    QBluetoothServiceInfo::Sequence protocol;
    protocol &lt;&lt; QVariant::fromValue(QBluetoothUuid(QBluetoothUuid::L2cap))
             &lt;&lt; QVariant::fromValue(m_handover-&gt;serverPort());
    protocolDescriptorList.append(QVariant::fromValue(protocol));
    service.setAttribute(QBluetoothServiceInfo::ProtocolDescriptorList,
                         protocolDescriptorList);

    client-&gt;startClient(service);
    board-&gt;setStatus(tr(&quot;Connecting: %1 %2&quot;).arg(m_handover-&gt;bluetoothAddress().toString()).arg(m_handover-&gt;serverPort()), 100, 25);
}*/

void Tennis::fps(const QString &amp;f)
{
  board-&gt;setStatus(f, 100, 100);
}

</db:programlisting>
</db:article>
