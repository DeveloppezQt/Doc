<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en">
<db:info>
<db:title>QScriptEngine Class</db:title>
<db:productname>QtScript</db:productname>
<db:edition>Qt 5.6.3 Reference Documentation</db:edition>
<db:titleabbrev>QtScript Reference Documentation</db:titleabbrev>
<db:abstract>
<db:para>The <db:link xlink:href="qscriptengine.xml">QScriptEngine</db:link> class provides an environment for evaluating Qt Script code.</db:para>
<db:para>This class was introduced in Qt 4.3.</db:para>
<db:note>
<db:para>All functions in this class are <db:link xlink:href="threads-reentrancy.xml">reentrant</db:link>.</db:para>
</db:note>
</db:abstract>
<db:pubdate>2025-06-29</db:pubdate>
<db:date>2025-06-29</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:variablelist>
<db:varlistentry>
<db:term>Header</db:term>
<db:listitem>
<db:para>QScriptEngine</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Since</db:term>
<db:listitem>
<db:para>Qt 4.3</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>qmake</db:term>
<db:listitem>
<db:para>QT += script</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Inherits</db:term>
<db:listitem>
<db:para><db:link xlink:href="qobject.xml" xlink:role="class">QObject</db:link></db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Group</db:term>
<db:listitem>
<db:para>QScriptEngine is part of <db:simplelist><db:member><db:link xlink:href="script.xml">Scripting Classes and Overviews</db:link></db:member></db:simplelist>
</db:para>
</db:listitem>
</db:varlistentry>
</db:variablelist>
<db:section xml:id="details">
<db:title>Detailed Description</db:title>
<db:para>See the <db:link xlink:href="qtscript-index.xml">Qt Script</db:link> documentation for information about the Qt Script language, and how to get started with scripting your C++ application.</db:para>
<db:section xml:id="evaluating-scripts">
<db:title>Evaluating Scripts</db:title>
<db:para>Use <db:link xlink:href="qscriptengine.xml#evaluate">evaluate</db:link>() to evaluate script code; this is the C++ equivalent of the built-in script function <db:code>eval()</db:code>.</db:para>
<db:programlisting language="cpp">QScriptEngine myEngine;
QScriptValue three = myEngine.evaluate(&quot;1 + 2&quot;);
</db:programlisting>
<db:para><db:link xlink:href="qscriptengine.xml#evaluate">evaluate</db:link>() returns a <db:link xlink:href="qscriptvalue.xml">QScriptValue</db:link> that holds the result of the evaluation. The <db:link xlink:href="qscriptvalue.xml">QScriptValue</db:link> class provides functions for converting the result to various C++ types (e.g. <db:link xlink:href="qscriptvalue.xml#toString">QScriptValue::toString</db:link>() and <db:link xlink:href="qscriptvalue.xml#toNumber">QScriptValue::toNumber</db:link>()).</db:para>
<db:para>The following code snippet shows how a script function can be defined and then invoked from C++ using <db:link xlink:href="qscriptvalue.xml#call">QScriptValue::call</db:link>():</db:para>
<db:programlisting language="cpp">QScriptValue fun = myEngine.evaluate(&quot;(function(a, b) { return a + b; })&quot;);
QScriptValueList args;
args &lt;&lt; 1 &lt;&lt; 2;
QScriptValue threeAgain = fun.call(QScriptValue(), args);
</db:programlisting>
<db:para>As can be seen from the above snippets, a script is provided to the engine in the form of a string. One common way of loading scripts is by reading the contents of a file and passing it to <db:link xlink:href="qscriptengine.xml#evaluate">evaluate</db:link>():</db:para>
<db:programlisting language="cpp">QString fileName = &quot;helloworld.qs&quot;;
QFile scriptFile(fileName);
if (!scriptFile.open(QIODevice::ReadOnly))
    // handle error
QTextStream stream(&amp;scriptFile);
QString contents = stream.readAll();
scriptFile.close();
myEngine.evaluate(contents, fileName);
</db:programlisting>
<db:para>Here we pass the name of the file as the second argument to <db:link xlink:href="qscriptengine.xml#evaluate">evaluate</db:link>(). This does not affect evaluation in any way; the second argument is a general-purpose string that is used to identify the script for debugging purposes (for example, our filename will now show up in any <db:link xlink:href="qscriptengine.xml#uncaughtExceptionBacktrace">uncaughtExceptionBacktrace</db:link>() involving the script).</db:para>
</db:section>
<db:section xml:id="engine-configuration">
<db:title>Engine Configuration</db:title>
<db:para>The <db:link xlink:href="qscriptengine.xml#globalObject">globalObject</db:link>() function returns the <db:emphasis role="bold">Global Object</db:emphasis> associated with the script engine. Properties of the Global Object are accessible from any script code (i.e. they are global variables). Typically, before evaluating &quot;user&quot; scripts, you will want to configure a script engine by adding one or more properties to the Global Object:</db:para>
<db:programlisting language="cpp">myEngine.globalObject().setProperty(&quot;myNumber&quot;, 123);
...
QScriptValue myNumberPlusOne = myEngine.evaluate(&quot;myNumber + 1&quot;);
</db:programlisting>
<db:para>Adding custom properties to the scripting environment is one of the standard means of providing a scripting API that is specific to your application. Usually these custom properties are objects created by the <db:link xlink:href="qscriptengine.xml#newQObject">newQObject</db:link>() or <db:link xlink:href="qscriptengine.xml#newObject">newObject</db:link>() functions, or constructor functions created by <db:link xlink:href="qscriptengine.xml#newFunction">newFunction</db:link>().</db:para>
</db:section>
<db:section xml:id="script-exceptions">
<db:title>Script Exceptions</db:title>
<db:para><db:link xlink:href="qscriptengine.xml#evaluate">evaluate</db:link>() can throw a script exception (e.g. due to a syntax error); in that case, the return value is the value that was thrown (typically an <db:code>Error</db:code> object). You can check whether the evaluation caused an exception by calling <db:link xlink:href="qscriptengine.xml#hasUncaughtException">hasUncaughtException</db:link>(). In that case, you can call toString() on the error object to obtain an error message. The current uncaught exception is also available through <db:link xlink:href="qscriptengine.xml#uncaughtException">uncaughtException</db:link>(). Calling <db:link xlink:href="qscriptengine.xml#clearExceptions">clearExceptions</db:link>() will cause any uncaught exceptions to be cleared.</db:para>
<db:programlisting language="cpp">QScriptValue result = myEngine.evaluate(...);
if (myEngine.hasUncaughtException()) {
    int line = myEngine.uncaughtExceptionLineNumber();
    qDebug() &lt;&lt; &quot;uncaught exception at line&quot; &lt;&lt; line &lt;&lt; &quot;:&quot; &lt;&lt; result.toString();
}
</db:programlisting>
<db:para>The <db:link xlink:href="qscriptengine.xml#checkSyntax">checkSyntax</db:link>() function can be used to determine whether code can be usefully passed to <db:link xlink:href="qscriptengine.xml#evaluate">evaluate</db:link>().</db:para>
</db:section>
<db:section xml:id="script-object-creation">
<db:title>Script Object Creation</db:title>
<db:para>Use <db:link xlink:href="qscriptengine.xml#newObject">newObject</db:link>() to create a standard Qt Script object; this is the C++ equivalent of the script statement <db:code>new Object()</db:code>. You can use the object-specific functionality in <db:link xlink:href="qscriptvalue.xml">QScriptValue</db:link> to manipulate the script object (e.g. <db:link xlink:href="qscriptvalue.xml#setProperty">QScriptValue::setProperty</db:link>()). Similarly, use <db:link xlink:href="qscriptengine.xml#newArray">newArray</db:link>() to create a Qt Script array object. Use <db:link xlink:href="qscriptengine.xml#newDate">newDate</db:link>() to create a <db:code>Date</db:code> object, and <db:link xlink:href="qscriptengine.xml#newRegExp">newRegExp</db:link>() to create a <db:code>RegExp</db:code> object.</db:para>
</db:section>
<db:section xml:id="qobject-integration">
<db:title>QObject Integration</db:title>
<db:para>Use <db:link xlink:href="qscriptengine.xml#newQObject">newQObject</db:link>() to wrap a <db:link xlink:href="qobject.xml">QObject</db:link> (or subclass) pointer. <db:link xlink:href="qscriptengine.xml#newQObject">newQObject</db:link>() returns a proxy script object; properties, children, and signals and slots of the <db:link xlink:href="qobject.xml">QObject</db:link> are available as properties of the proxy object. No binding code is needed because it is done dynamically using the Qt meta object system.</db:para>
<db:programlisting language="cpp">QPushButton button;
QScriptValue scriptButton = myEngine.newQObject(&amp;button);
myEngine.globalObject().setProperty(&quot;button&quot;, scriptButton);

myEngine.evaluate(&quot;button.checkable = true&quot;);

qDebug() &lt;&lt; scriptButton.property(&quot;checkable&quot;).toBoolean();
scriptButton.property(&quot;show&quot;).call(); // call the show() slot
</db:programlisting>
<db:para>Use <db:link xlink:href="qscriptengine.xml#qScriptConnect">qScriptConnect</db:link>() to connect a C++ signal to a script function; this is the Qt Script equivalent of <db:link xlink:href="qobject.xml#connect">QObject::connect</db:link>(). When a script function is invoked in response to a C++ signal, it can cause a script exception; you can connect to the <db:link xlink:href="qscriptengine.xml#signalHandlerException">signalHandlerException</db:link>() signal to catch such an exception.</db:para>
<db:para>Use <db:link xlink:href="qscriptengine.xml#newQMetaObject">newQMetaObject</db:link>() to wrap a <db:link xlink:href="qmetaobject.xml">QMetaObject</db:link>; this gives you a &quot;script representation&quot; of a <db:link xlink:href="qobject.xml">QObject</db:link>-based class. <db:link xlink:href="qscriptengine.xml#newQMetaObject">newQMetaObject</db:link>() returns a proxy script object; enum values of the class are available as properties of the proxy object. You can also specify a function that will be used to construct objects of the class (e.g. when the constructor is invoked from a script). For classes that have a &quot;standard&quot; Qt constructor, Qt Script can provide a default script constructor for you; see scriptValueFromQMetaObject().</db:para>
<db:para>See <db:link xlink:href="qtjavascript.xml">Making Applications Scriptable</db:link> for more information on the <db:link xlink:href="qobject.xml">QObject</db:link> integration.</db:para>
</db:section>
<db:section xml:id="support-for-custom-c-types">
<db:title>Support for Custom C++ Types</db:title>
<db:para>Use <db:link xlink:href="qscriptengine.xml#newVariant">newVariant</db:link>() to wrap a <db:link xlink:href="qvariant.xml">QVariant</db:link>. This can be used to store values of custom (non-<db:link xlink:href="qobject.xml">QObject</db:link>) C++ types that have been registered with the Qt meta-type system. To make such types scriptable, you typically associate a prototype (delegate) object with the C++ type by calling <db:link xlink:href="qscriptengine.xml#setDefaultPrototype">setDefaultPrototype</db:link>(); the prototype object defines the scripting API for the C++ type. Unlike the <db:link xlink:href="qobject.xml">QObject</db:link> integration, there is no automatic binding possible here; i.e. you have to create the scripting API yourself, for example by using the <db:link xlink:href="qscriptable.xml">QScriptable</db:link> class.</db:para>
<db:para>Use fromScriptValue() to cast from a <db:link xlink:href="qscriptvalue.xml">QScriptValue</db:link> to another type, and toScriptValue() to create a <db:link xlink:href="qscriptvalue.xml">QScriptValue</db:link> from another value. You can specify how the conversion of C++ types is to be performed with qScriptRegisterMetaType() and qScriptRegisterSequenceMetaType(). By default, Qt Script will use <db:link xlink:href="qvariant.xml">QVariant</db:link> to store values of custom types.</db:para>
</db:section>
<db:section xml:id="importing-extensions">
<db:title>Importing Extensions</db:title>
<db:para>Use <db:link xlink:href="qscriptengine.xml#importExtension">importExtension</db:link>() to import plugin-based extensions into the engine. Call <db:link xlink:href="qscriptengine.xml#availableExtensions">availableExtensions</db:link>() to obtain a list naming all the available extensions, and <db:link xlink:href="qscriptengine.xml#importedExtensions">importedExtensions</db:link>() to obtain a list naming only those extensions that have been imported.</db:para>
<db:para>Call <db:link xlink:href="qscriptengine.xml#pushContext">pushContext</db:link>() to open up a new variable scope, and <db:link xlink:href="qscriptengine.xml#popContext">popContext</db:link>() to close the current scope. This is useful if you are implementing an extension that evaluates script code containing temporary variable definitions (e.g. <db:code>var foo = 123;</db:code>) that are safe to discard when evaluation has completed.</db:para>
</db:section>
<db:section xml:id="native-functions">
<db:title>Native Functions</db:title>
<db:para>Use <db:link xlink:href="qscriptengine.xml#newFunction">newFunction</db:link>() to wrap native (C++) functions, including constructors for your own custom types, so that these can be invoked from script code. Such functions must have the signature <db:link xlink:href="qscriptengine.xml#FunctionSignature-typedef">QScriptEngine::FunctionSignature</db:link>. You may then pass the function as argument to <db:link xlink:href="qscriptengine.xml#newFunction">newFunction</db:link>(). Here is an example of a function that returns the sum of its first two arguments:</db:para>
<db:programlisting language="cpp">QScriptValue myAdd(QScriptContext *context, QScriptEngine *engine)
{
   QScriptValue a = context-&gt;argument(0);
   QScriptValue b = context-&gt;argument(1);
   return a.toNumber() + b.toNumber();
}
</db:programlisting>
<db:para>To expose this function to script code, you can set it as a property of the Global Object:</db:para>
<db:programlisting language="cpp">QScriptValue fun = myEngine.newFunction(myAdd);
myEngine.globalObject().setProperty(&quot;myAdd&quot;, fun);
</db:programlisting>
<db:para>Once this is done, script code can call your function in the exact same manner as a &quot;normal&quot; script function:</db:para>
<db:programlisting language="cpp">QScriptValue result = myEngine.evaluate(&quot;myAdd(myNumber, 1)&quot;);
</db:programlisting>
</db:section>
<db:section xml:id="long-running-scripts">
<db:title>Long-running Scripts</db:title>
<db:para>If you need to evaluate possibly long-running scripts from the main (GUI) thread, you should first call <db:link xlink:href="qscriptengine.xml#setProcessEventsInterval">setProcessEventsInterval</db:link>() to make sure that the GUI stays responsive. You can abort a currently running script by calling <db:link xlink:href="qscriptengine.xml#abortEvaluation">abortEvaluation</db:link>(). You can determine whether an engine is currently running a script by calling <db:link xlink:href="qscriptengine.xml#isEvaluating">isEvaluating</db:link>().</db:para>
</db:section>
<db:section xml:id="garbage-collection">
<db:title>Garbage Collection</db:title>
<db:para>Qt Script objects may be garbage collected when they are no longer referenced. There is no guarantee as to when automatic garbage collection will take place.</db:para>
<db:para>The <db:link xlink:href="qscriptengine.xml#collectGarbage">collectGarbage</db:link>() function can be called to explicitly request garbage collection.</db:para>
<db:para>The <db:link xlink:href="qscriptengine.xml#reportAdditionalMemoryCost">reportAdditionalMemoryCost</db:link>() function can be called to indicate that a Qt Script object occupies memory that isn't managed by the scripting environment. Reporting the additional cost makes it more likely that the garbage collector will be triggered. This can be useful, for example, when many custom, native Qt Script objects are allocated.</db:para>
</db:section>
<db:section xml:id="core-debugging-tracing-facilities">
<db:title>Core Debugging/Tracing Facilities</db:title>
<db:para>Since Qt 4.4, you can be notified of events pertaining to script execution (e.g. script function calls and statement execution) through the <db:link xlink:href="qscriptengineagent.xml">QScriptEngineAgent</db:link> interface; see the <db:link xlink:href="qscriptengine.xml#setAgent">setAgent</db:link>() function. This can be used to implement debugging and profiling of a <db:link xlink:href="qscriptengine.xml">QScriptEngine</db:link>.</db:para>
</db:section>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qscriptvalue.xml">QScriptValue</db:link></db:member>
<db:member><db:link xlink:href="qscriptcontext.xml">QScriptContext</db:link></db:member>
<db:member><db:link xlink:href="qscriptengineagent.xml">QScriptEngineAgent</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="member-type-documentation">
<db:title>Member Type Documentation</db:title>
<db:section xml:id="FunctionSignature-typedef">
<db:title>QScriptEngine::FunctionSignature</db:title>
<db:para>The function signature <db:code>QScriptValue f(QScriptContext *, QScriptEngine *)</db:code>.</db:para>
<db:para>A function with such a signature can be passed to <db:link xlink:href="qscriptengine.xml#newFunction">QScriptEngine::newFunction</db:link>() to wrap the function.</db:para>
</db:section>
<db:section xml:id="FunctionWithArgSignature-typedef">
<db:title>QScriptEngine::FunctionWithArgSignature</db:title>
<db:para>The function signature <db:code>QScriptValue f(QScriptContext *, QScriptEngine *, void *)</db:code>.</db:para>
<db:para>A function with such a signature can be passed to <db:link xlink:href="qscriptengine.xml#newFunction">QScriptEngine::newFunction</db:link>() to wrap the function.</db:para>
</db:section>
<db:section xml:id="QObjectWrapOption-enum">
<db:title>enum QScriptEngine::QObjectWrapOption</db:title>
<db:bridgehead renderas="sect2">flags QScriptEngine::QObjectWrapOptions</db:bridgehead>
<db:para>These flags specify options when wrapping a <db:link xlink:href="qobject.xml">QObject</db:link> pointer with <db:link xlink:href="qscriptengine.xml#newQObject">newQObject</db:link>().</db:para>
<db:informaltable>
<db:thead>
<db:tr>
<db:th>Constant</db:th>
<db:th>Value</db:th>
<db:th>Description</db:th>
</db:tr>
</db:thead>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qscriptengine.xml">QScriptEngine</db:link></db:emphasis>::ExcludeChildObjects</db:code></db:para>
</db:td>
<db:td><db:code>0x0001</db:code></db:td>
<db:td>
<db:para>The script object will not expose child objects as properties.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qscriptengine.xml">QScriptEngine</db:link></db:emphasis>::ExcludeSuperClassMethods</db:code></db:para>
</db:td>
<db:td><db:code>0x0002</db:code></db:td>
<db:td>
<db:para>The script object will not expose signals and slots inherited from the superclass.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qscriptengine.xml">QScriptEngine</db:link></db:emphasis>::ExcludeSuperClassProperties</db:code></db:para>
</db:td>
<db:td><db:code>0x0004</db:code></db:td>
<db:td>
<db:para>The script object will not expose properties inherited from the superclass.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qscriptengine.xml">QScriptEngine</db:link></db:emphasis>::ExcludeSuperClassContents</db:code></db:para>
</db:td>
<db:td><db:code>0x0006</db:code></db:td>
<db:td>
<db:para>Shorthand form for ExcludeSuperClassMethods | ExcludeSuperClassProperties</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qscriptengine.xml">QScriptEngine</db:link></db:emphasis>::ExcludeDeleteLater</db:code></db:para>
</db:td>
<db:td><db:code>0x0010</db:code></db:td>
<db:td>
<db:para>The script object will not expose the <db:link xlink:href="qobject.xml#deleteLater">QObject::deleteLater</db:link>() slot.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qscriptengine.xml">QScriptEngine</db:link></db:emphasis>::ExcludeSlots</db:code></db:para>
</db:td>
<db:td><db:code>0x0020</db:code></db:td>
<db:td>
<db:para>The script object will not expose the <db:link xlink:href="qobject.xml">QObject</db:link>'s slots.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qscriptengine.xml">QScriptEngine</db:link></db:emphasis>::AutoCreateDynamicProperties</db:code></db:para>
</db:td>
<db:td><db:code>0x0100</db:code></db:td>
<db:td>
<db:para>Properties that don't already exist in the <db:link xlink:href="qobject.xml">QObject</db:link> will be created as dynamic properties of that object, rather than as properties of the script object.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qscriptengine.xml">QScriptEngine</db:link></db:emphasis>::PreferExistingWrapperObject</db:code></db:para>
</db:td>
<db:td><db:code>0x0200</db:code></db:td>
<db:td>
<db:para>If a wrapper object with the requested configuration already exists, return that object.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qscriptengine.xml">QScriptEngine</db:link></db:emphasis>::SkipMethodsInEnumeration</db:code></db:para>
</db:td>
<db:td><db:code>0x0008</db:code></db:td>
<db:td>
<db:para>Don't include methods (signals and slots) when enumerating the object's properties.</db:para>
</db:td>
</db:tr>
</db:informaltable>
<db:para>The <db:code>QObjectWrapOptions</db:code> type is a typedef for <db:code><db:link xlink:href="qflags.xml">QFlags</db:link>&lt;QObjectWrapOption&gt;. </db:code>It stores an OR combination of <db:code>QObjectWrapOption</db:code> values.</db:para>
</db:section>
<db:section xml:id="ValueOwnership-enum">
<db:title>enum QScriptEngine::ValueOwnership</db:title>
<db:para>This enum specifies the ownership when wrapping a C++ value, e.g. by using <db:link xlink:href="qscriptengine.xml#newQObject">newQObject</db:link>().</db:para>
<db:informaltable>
<db:thead>
<db:tr>
<db:th>Constant</db:th>
<db:th>Value</db:th>
<db:th>Description</db:th>
</db:tr>
</db:thead>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qscriptengine.xml">QScriptEngine</db:link></db:emphasis>::QtOwnership</db:code></db:para>
</db:td>
<db:td><db:code>0</db:code></db:td>
<db:td>
<db:para>The standard Qt ownership rules apply, i.e. the associated object will never be explicitly deleted by the script engine. This is the default. (<db:link xlink:href="qobject.xml">QObject</db:link> ownership is explained in <db:link xlink:href="objecttrees.xml">Object Trees &amp; Ownership</db:link>.)</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qscriptengine.xml">QScriptEngine</db:link></db:emphasis>::ScriptOwnership</db:code></db:para>
</db:td>
<db:td><db:code>1</db:code></db:td>
<db:td>
<db:para>The value is owned by the script environment. The associated data will be deleted when appropriate (i.e. after the garbage collector has discovered that there are no more live references to the value).</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qscriptengine.xml">QScriptEngine</db:link></db:emphasis>::AutoOwnership</db:code></db:para>
</db:td>
<db:td><db:code>2</db:code></db:td>
<db:td>
<db:para>If the associated object has a parent, the Qt ownership rules apply (QtOwnership); otherwise, the object is owned by the script environment (ScriptOwnership).</db:para>
</db:td>
</db:tr>
</db:informaltable>
</db:section>
</db:section>
<db:section xml:id="member-function-documentation">
<db:title>Member Function Documentation</db:title>
<db:section xml:id="QScriptEngine">
<db:title>QScriptEngine::QScriptEngine()</db:title>
<db:para>Constructs a <db:link xlink:href="qscriptengine.xml">QScriptEngine</db:link> object.</db:para>
<db:para>The <db:link xlink:href="qscriptengine.xml#globalObject">globalObject</db:link>() is initialized to have properties as described in <db:link xlink:href="http://www.ecma-international.org/publications/standards/Ecma-262.htm">ECMA-262</db:link>, Section 15.1.</db:para>
</db:section>
<db:section xml:id="QScriptEngine-1">
<db:title>[explicit] QScriptEngine::QScriptEngine(QObject *<db:emphasis>parent</db:emphasis>)</db:title>
<db:para>Constructs a <db:link xlink:href="qscriptengine.xml">QScriptEngine</db:link> object with the given <db:code role="parameter">parent</db:code>.</db:para>
<db:para>The <db:link xlink:href="qscriptengine.xml#globalObject">globalObject</db:link>() is initialized to have properties as described in <db:link xlink:href="http://www.ecma-international.org/publications/standards/Ecma-262.htm">ECMA-262</db:link>, Section 15.1.</db:para>
</db:section>
<db:section xml:id="dtor.QScriptEngine">
<db:title>[virtual noexcept] QScriptEngine::~QScriptEngine()</db:title>
<db:para>Destroys this <db:link xlink:href="qscriptengine.xml">QScriptEngine</db:link>.</db:para>
</db:section>
<db:section xml:id="abortEvaluation">
<db:title>[since 4.4] void QScriptEngine::abortEvaluation(const QScriptValue &amp;<db:emphasis>result</db:emphasis> = QScriptValue())</db:title>
<db:para>Aborts any script evaluation currently taking place in this engine. The given <db:code role="parameter">result</db:code> is passed back as the result of the evaluation (i.e. it is returned from the call to <db:link xlink:href="qscriptengine.xml#evaluate">evaluate</db:link>() being aborted).</db:para>
<db:para>If the engine isn't evaluating a script (i.e. <db:link xlink:href="qscriptengine.xml#isEvaluating">isEvaluating</db:link>() returns false), this function does nothing.</db:para>
<db:para>Call this function if you need to abort a running script for some reason, e.g. when you have detected that the script has been running for several seconds without completing.</db:para>
<db:para>This function was introduced in Qt 4.4.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qscriptengine.xml#evaluate">evaluate</db:link>()</db:member>
<db:member><db:link xlink:href="qscriptengine.xml#isEvaluating">isEvaluating</db:link>()</db:member>
<db:member><db:link xlink:href="qscriptengine.xml#setProcessEventsInterval">setProcessEventsInterval</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="agent">
<db:title>[since 4.4] QScriptEngineAgent *QScriptEngine::agent() const</db:title>
<db:para>Returns the agent currently installed on this engine, or 0 if no agent is installed.</db:para>
<db:para>This function was introduced in Qt 4.4.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qscriptengine.xml#setAgent">setAgent</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="availableExtensions">
<db:title>[since 4.4] QStringList QScriptEngine::availableExtensions() const</db:title>
<db:para>Returns a list naming the available extensions that can be imported using the <db:link xlink:href="qscriptengine.xml#importExtension">importExtension</db:link>() function. This list includes extensions that have been imported.</db:para>
<db:para>This function was introduced in Qt 4.4.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qscriptengine.xml#importExtension">importExtension</db:link>()</db:member>
<db:member><db:link xlink:href="qscriptengine.xml#importedExtensions">importedExtensions</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="checkSyntax">
<db:title>[static, since 4.5] QScriptSyntaxCheckResult QScriptEngine::checkSyntax(const QString &amp;<db:emphasis>program</db:emphasis>)</db:title>
<db:para>Checks the syntax of the given <db:code role="parameter">program</db:code>. Returns a <db:link xlink:href="qscriptsyntaxcheckresult.xml">QScriptSyntaxCheckResult</db:link> object that contains the result of the check.</db:para>
<db:para>This function was introduced in Qt 4.5.</db:para>
</db:section>
<db:section xml:id="clearExceptions">
<db:title>[since 4.4] void QScriptEngine::clearExceptions()</db:title>
<db:para>Clears any uncaught exceptions in this engine.</db:para>
<db:para>This function was introduced in Qt 4.4.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qscriptengine.xml#hasUncaughtException">hasUncaughtException</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="collectGarbage">
<db:title>void QScriptEngine::collectGarbage()</db:title>
<db:para>Runs the garbage collector.</db:para>
<db:para>The garbage collector will attempt to reclaim memory by locating and disposing of objects that are no longer reachable in the script environment.</db:para>
<db:para>Normally you don't need to call this function; the garbage collector will automatically be invoked when the <db:link xlink:href="qscriptengine.xml">QScriptEngine</db:link> decides that it's wise to do so (i.e. when a certain number of new objects have been created). However, you can call this function to explicitly request that garbage collection should be performed as soon as possible.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qscriptengine.xml#reportAdditionalMemoryCost">reportAdditionalMemoryCost</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="currentContext">
<db:title>QScriptContext *QScriptEngine::currentContext() const</db:title>
<db:para>Returns the current context.</db:para>
<db:para>The current context is typically accessed to retrieve the arguments and `this' object in native functions; for convenience, it is available as the first argument in <db:link xlink:href="qscriptengine.xml#FunctionSignature-typedef">QScriptEngine::FunctionSignature</db:link>.</db:para>
</db:section>
<db:section xml:id="defaultPrototype">
<db:title>QScriptValue QScriptEngine::defaultPrototype(int <db:emphasis>metaTypeId</db:emphasis>) const</db:title>
<db:para>Returns the default prototype associated with the given <db:code role="parameter">metaTypeId</db:code>, or an invalid <db:link xlink:href="qscriptvalue.xml">QScriptValue</db:link> if no default prototype has been set.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qscriptengine.xml#setDefaultPrototype">setDefaultPrototype</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="evaluate">
<db:title>[since 4.7] QScriptValue QScriptEngine::evaluate(const QScriptProgram &amp;<db:emphasis>program</db:emphasis>)</db:title>
<db:para>Evaluates the given <db:code role="parameter">program</db:code> and returns the result of the evaluation.</db:para>
<db:para>This function was introduced in Qt 4.7.</db:para>
</db:section>
<db:section xml:id="evaluate-1">
<db:title>QScriptValue QScriptEngine::evaluate(const QString &amp;<db:emphasis>program</db:emphasis>, const QString &amp;<db:emphasis>fileName</db:emphasis> = QString(), int <db:emphasis>lineNumber</db:emphasis> = 1)</db:title>
<db:para>Evaluates <db:code role="parameter">program</db:code>, using <db:code role="parameter">lineNumber</db:code> as the base line number, and returns the result of the evaluation.</db:para>
<db:para>The script code will be evaluated in the current context.</db:para>
<db:para>The evaluation of <db:code role="parameter">program</db:code> can cause an exception in the engine; in this case the return value will be the exception that was thrown (typically an <db:code>Error</db:code> object). You can call <db:link xlink:href="qscriptengine.xml#hasUncaughtException">hasUncaughtException</db:link>() to determine if an exception occurred in the last call to <db:link xlink:href="qscriptengine.xml#evaluate">evaluate</db:link>().</db:para>
<db:para><db:code role="parameter">lineNumber</db:code> is used to specify a starting line number for <db:code role="parameter">program</db:code>; line number information reported by the engine that pertain to this evaluation (e.g. <db:link xlink:href="qscriptengine.xml#uncaughtExceptionLineNumber">uncaughtExceptionLineNumber</db:link>()) will be based on this argument. For example, if <db:code role="parameter">program</db:code> consists of two lines of code, and the statement on the second line causes a script exception, <db:link xlink:href="qscriptengine.xml#uncaughtExceptionLineNumber">uncaughtExceptionLineNumber</db:link>() would return the given <db:code role="parameter">lineNumber</db:code> plus one. When no starting line number is specified, line numbers will be 1-based.</db:para>
<db:para><db:code role="parameter">fileName</db:code> is used for error reporting. For example in error objects the file name is accessible through the &quot;fileName&quot; property if it's provided with this function.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qscriptengine.xml#canEvaluate" role="deprecated">canEvaluate</db:link>()</db:member>
<db:member><db:link xlink:href="qscriptengine.xml#hasUncaughtException">hasUncaughtException</db:link>()</db:member>
<db:member><db:link xlink:href="qscriptengine.xml#isEvaluating">isEvaluating</db:link>()</db:member>
<db:member><db:link xlink:href="qscriptengine.xml#abortEvaluation">abortEvaluation</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="globalObject">
<db:title>QScriptValue QScriptEngine::globalObject() const</db:title>
<db:para>Returns this engine's Global Object.</db:para>
<db:para>By default, the Global Object contains the built-in objects that are part of <db:link xlink:href="http://www.ecma-international.org/publications/standards/Ecma-262.htm">ECMA-262</db:link>, such as Math, Date and String. Additionally, you can set properties of the Global Object to make your own extensions available to all script code. Non-local variables in script code will be created as properties of the Global Object, as well as local variables in global code.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qscriptengine.xml#setGlobalObject">setGlobalObject</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="hasUncaughtException">
<db:title>bool QScriptEngine::hasUncaughtException() const</db:title>
<db:para>Returns true if the last script evaluation resulted in an uncaught exception; otherwise returns false.</db:para>
<db:para>The exception state is cleared when <db:link xlink:href="qscriptengine.xml#evaluate">evaluate</db:link>() is called.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qscriptengine.xml#uncaughtException">uncaughtException</db:link>()</db:member>
<db:member><db:link xlink:href="qscriptengine.xml#uncaughtExceptionLineNumber">uncaughtExceptionLineNumber</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="importExtension">
<db:title>QScriptValue QScriptEngine::importExtension(const QString &amp;<db:emphasis>extension</db:emphasis>)</db:title>
<db:para>Imports the given <db:code role="parameter">extension</db:code> into this <db:link xlink:href="qscriptengine.xml">QScriptEngine</db:link>. Returns <db:link xlink:href="qscriptengine.xml#undefinedValue">undefinedValue</db:link>() if the extension was successfully imported. You can call <db:link xlink:href="qscriptengine.xml#hasUncaughtException">hasUncaughtException</db:link>() to check if an error occurred; in that case, the return value is the value that was thrown by the exception (usually an <db:code>Error</db:code> object).</db:para>
<db:para><db:link xlink:href="qscriptengine.xml">QScriptEngine</db:link> ensures that a particular extension is only imported once; subsequent calls to importExtension() with the same extension name will do nothing and return <db:link xlink:href="qscriptengine.xml#undefinedValue">undefinedValue</db:link>().</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qscriptengine.xml#availableExtensions">availableExtensions</db:link>()</db:member>
<db:member><db:link xlink:href="qscriptextensionplugin.xml">QScriptExtensionPlugin</db:link></db:member>
<db:member><db:link xlink:href="qtscriptextensions.xml">Creating Qt Script Extensions</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="importedExtensions">
<db:title>[since 4.4] QStringList QScriptEngine::importedExtensions() const</db:title>
<db:para>Returns a list naming the extensions that have been imported using the <db:link xlink:href="qscriptengine.xml#importExtension">importExtension</db:link>() function.</db:para>
<db:para>This function was introduced in Qt 4.4.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qscriptengine.xml#availableExtensions">availableExtensions</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="installTranslatorFunctions">
<db:title>[since 4.5] void QScriptEngine::installTranslatorFunctions(const QScriptValue &amp;<db:emphasis>object</db:emphasis> = QScriptValue())</db:title>
<db:para>Installs translator functions on the given <db:code role="parameter">object</db:code>, or on the Global Object if no object is specified.</db:para>
<db:para>The relation between Qt Script translator functions and C++ translator functions is described in the following table:</db:para>
<db:informaltable style="generic">
<db:thead>
<db:tr>
<db:th>
<db:para>Script Function</db:para>
</db:th>
<db:th>
<db:para>Corresponding C++ Function</db:para>
</db:th>
</db:tr>
</db:thead>
<db:tr valign="top">
<db:td>
<db:para>qsTr()</db:para>
</db:td>
<db:td>
<db:para><db:link xlink:href="qobject.xml#tr">QObject::tr</db:link>()</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para><db:link xlink:href="qtglobal.xml#QT_TR_NOOP">QT_TR_NOOP</db:link>()</db:para>
</db:td>
<db:td>
<db:para><db:link xlink:href="qtglobal.xml#QT_TR_NOOP">QT_TR_NOOP</db:link>()</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>qsTranslate()</db:para>
</db:td>
<db:td>
<db:para><db:link xlink:href="qcoreapplication.xml#translate">QCoreApplication::translate</db:link>()</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para><db:link xlink:href="qtglobal.xml#QT_TRANSLATE_NOOP">QT_TRANSLATE_NOOP</db:link>()</db:para>
</db:td>
<db:td>
<db:para><db:link xlink:href="qtglobal.xml#QT_TRANSLATE_NOOP">QT_TRANSLATE_NOOP</db:link>()</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>qsTrId() (since 4.7)</db:para>
</db:td>
<db:td>
<db:para><db:link xlink:href="qtglobal.xml#qtTrId">qtTrId</db:link>()</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para><db:link xlink:href="qtglobal.xml#QT_TRID_NOOP">QT_TRID_NOOP</db:link>() (since 4.7)</db:para>
</db:td>
<db:td>
<db:para><db:link xlink:href="qtglobal.xml#QT_TRID_NOOP">QT_TRID_NOOP</db:link>()</db:para>
</db:td>
</db:tr>
</db:informaltable>
<db:para>This function was introduced in Qt 4.5.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="internationalization.xml">Internationalization with Qt</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="isEvaluating">
<db:title>[since 4.4] bool QScriptEngine::isEvaluating() const</db:title>
<db:para>Returns true if this engine is currently evaluating a script, otherwise returns false.</db:para>
<db:para>This function was introduced in Qt 4.4.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qscriptengine.xml#evaluate">evaluate</db:link>()</db:member>
<db:member><db:link xlink:href="qscriptengine.xml#abortEvaluation">abortEvaluation</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="newArray">
<db:title>QScriptValue QScriptEngine::newArray(uint <db:emphasis>length</db:emphasis> = 0)</db:title>
<db:para>Creates a Qt Script object of class Array with the given <db:code role="parameter">length</db:code>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qscriptengine.xml#newObject">newObject</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="newDate">
<db:title>QScriptValue QScriptEngine::newDate(const QDateTime &amp;<db:emphasis>value</db:emphasis>)</db:title>
<db:para>Creates a Qt Script object of class Date from the given <db:code role="parameter">value</db:code>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qscriptvalue.xml#toDateTime">QScriptValue::toDateTime</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="newDate-1">
<db:title>QScriptValue QScriptEngine::newDate(qsreal <db:emphasis>value</db:emphasis>)</db:title>
<db:para>Creates a Qt Script object of class Date with the given <db:code role="parameter">value</db:code> (the number of milliseconds since 01 January 1970, UTC).</db:para>
</db:section>
<db:section xml:id="newFunction">
<db:title>QScriptValue QScriptEngine::newFunction(QScriptEngine::FunctionSignature <db:emphasis>fun</db:emphasis>, int <db:emphasis>length</db:emphasis> = 0)</db:title>
<db:para>Creates a <db:link xlink:href="qscriptvalue.xml">QScriptValue</db:link> that wraps a native (C++) function. <db:code role="parameter">fun</db:code> must be a C++ function with signature <db:link xlink:href="qscriptengine.xml#FunctionSignature-typedef">QScriptEngine::FunctionSignature</db:link>. <db:code role="parameter">length</db:code> is the number of arguments that <db:code role="parameter">fun</db:code> expects; this becomes the <db:code>length</db:code> property of the created <db:link xlink:href="qscriptvalue.xml">QScriptValue</db:link>.</db:para>
<db:para>Note that <db:code role="parameter">length</db:code> only gives an indication of the number of arguments that the function expects; an actual invocation of a function can include any number of arguments. You can check the <db:link xlink:href="qscriptcontext.xml#argumentCount">argumentCount</db:link>() of the <db:link xlink:href="qscriptcontext.xml">QScriptContext</db:link> associated with the invocation to determine the actual number of arguments passed.</db:para>
<db:para>A <db:code>prototype</db:code> property is automatically created for the resulting function object, to provide for the possibility that the function will be used as a constructor.</db:para>
<db:para>By combining newFunction() and the property flags <db:link xlink:href="qscriptvalue.xml#PropertyFlag-enum">QScriptValue::PropertyGetter</db:link> and <db:link xlink:href="qscriptvalue.xml#PropertyFlag-enum">QScriptValue::PropertySetter</db:link>, you can create script object properties that behave like normal properties in script code, but are in fact accessed through functions (analogous to how properties work in <db:link xlink:href="properties.xml">Qt's Property System</db:link>). Example:</db:para>
<db:programlisting language="cpp">static QScriptValue getSetFoo(QScriptContext *context, QScriptEngine *engine)
{
    QScriptValue callee = context-&gt;callee();
    if (context-&gt;argumentCount() == 1) // writing?
        callee.setProperty(&quot;value&quot;, context-&gt;argument(0));
    return callee.property(&quot;value&quot;);
}

....

QScriptValue object = engine.newObject();
object.setProperty(&quot;foo&quot;, engine.newFunction(getSetFoo),
    QScriptValue::PropertyGetter | QScriptValue::PropertySetter);
</db:programlisting>
<db:para>When the property <db:code>foo</db:code> of the script object is subsequently accessed in script code, <db:code>getSetFoo()</db:code> will be invoked to handle the access. In this particular case, we chose to store the &quot;real&quot; value of <db:code>foo</db:code> as a property of the accessor function itself; you are of course free to do whatever you like in this function.</db:para>
<db:para>In the above example, a single native function was used to handle both reads and writes to the property; the argument count is used to determine if we are handling a read or write. You can also use two separate functions; just specify the relevant flag (<db:link xlink:href="qscriptvalue.xml#PropertyFlag-enum">QScriptValue::PropertyGetter</db:link> or <db:link xlink:href="qscriptvalue.xml#PropertyFlag-enum">QScriptValue::PropertySetter</db:link>) when setting the property, e.g.:</db:para>
<db:programlisting language="cpp">QScriptValue object = engine.newObject();
object.setProperty(&quot;foo&quot;, engine.newFunction(getFoo), QScriptValue::PropertyGetter);
object.setProperty(&quot;foo&quot;, engine.newFunction(setFoo), QScriptValue::PropertySetter);
</db:programlisting>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qscriptvalue.xml#call">QScriptValue::call</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="newFunction-1">
<db:title>QScriptValue QScriptEngine::newFunction(QScriptEngine::FunctionSignature <db:emphasis>fun</db:emphasis>, const QScriptValue &amp;<db:emphasis>prototype</db:emphasis>, int <db:emphasis>length</db:emphasis> = 0)</db:title>
<db:para>Creates a constructor function from <db:code role="parameter">fun</db:code>, with the given <db:code role="parameter">length</db:code>. The <db:code>prototype</db:code> property of the resulting function is set to be the given <db:code role="parameter">prototype</db:code>. The <db:code>constructor</db:code> property of <db:code role="parameter">prototype</db:code> is set to be the resulting function.</db:para>
<db:para>When a function is called as a constructor (e.g. <db:code>new Foo()</db:code>), the `this' object associated with the function call is the new object that the function is expected to initialize; the prototype of this default constructed object will be the function's public <db:code>prototype</db:code> property. If you always want the function to behave as a constructor (e.g. <db:code>Foo()</db:code> should also create a new object), or if you need to create your own object rather than using the default `this' object, you should make sure that the prototype of your object is set correctly; either by setting it manually, or, when wrapping a custom type, by having registered the <db:link xlink:href="qscriptengine.xml#defaultPrototype">defaultPrototype</db:link>() of that type. Example:</db:para>
<db:programlisting language="cpp">QScriptValue Foo(QScriptContext *context, QScriptEngine *engine)
{
    if (context-&gt;calledAsConstructor()) {
        // initialize the new object
        context-&gt;thisObject().setProperty(&quot;bar&quot;, ...);
        // ...
        // return a non-object value to indicate that the
        // thisObject() should be the result of the &quot;new Foo()&quot; expression
        return engine-&gt;undefinedValue();
    } else {
        // not called as &quot;new Foo()&quot;, just &quot;Foo()&quot;
        // create our own object and return that one
        QScriptValue object = engine-&gt;newObject();
        object.setPrototype(context-&gt;callee().property(&quot;prototype&quot;));
        object.setProperty(&quot;baz&quot;, ...);
        return object;
    }
}

...

QScriptValue fooProto = engine-&gt;newObject();
fooProto.setProperty(&quot;whatever&quot;, ...);
engine-&gt;globalObject().setProperty(&quot;Foo&quot;, engine-&gt;newFunction(Foo, fooProto));
</db:programlisting>
<db:para>To wrap a custom type and provide a constructor for it, you'd typically do something like this:</db:para>
<db:programlisting language="cpp">class Bar { ... };

Q_DECLARE_METATYPE(Bar)

QScriptValue constructBar(QScriptContext *context, QScriptEngine *engine)
{
    Bar bar;
    // initialize from arguments in context, if desired
    ...
    return engine-&gt;toScriptValue(bar);
}

class BarPrototype : public QObject, public QScriptable
{
// provide the scriptable interface of this type using slots and properties
...
};

...

// create and register the Bar prototype and constructor in the engine
BarPrototype *barPrototypeObject = new BarPrototype(...);
QScriptValue barProto = engine-&gt;newQObject(barPrototypeObject);
engine-&gt;setDefaultPrototype(qMetaTypeId&lt;Bar&gt;, barProto);
QScriptValue barCtor = engine-&gt;newFunction(constructBar, barProto);
engine-&gt;globalObject().setProperty(&quot;Bar&quot;, barCtor);
</db:programlisting>
</db:section>
<db:section xml:id="newObject">
<db:title>QScriptValue QScriptEngine::newObject()</db:title>
<db:para>Creates a Qt Script object of class Object.</db:para>
<db:para>The prototype of the created object will be the Object prototype object.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qscriptengine.xml#newArray">newArray</db:link>()</db:member>
<db:member><db:link xlink:href="qscriptvalue.xml#setProperty">QScriptValue::setProperty</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="newObject-1">
<db:title>[since 4.4] QScriptValue QScriptEngine::newObject(QScriptClass *<db:emphasis>scriptClass</db:emphasis>, const QScriptValue &amp;<db:emphasis>data</db:emphasis> = QScriptValue())</db:title>
<db:para>This is an overloaded function.</db:para>
<db:para>Creates a Qt Script Object of the given class, <db:code role="parameter">scriptClass</db:code>.</db:para>
<db:para>The prototype of the created object will be the Object prototype object.</db:para>
<db:para><db:code role="parameter">data</db:code>, if specified, is set as the internal data of the new object (using <db:link xlink:href="qscriptvalue.xml#setData">QScriptValue::setData</db:link>()).</db:para>
<db:para>This function was introduced in Qt 4.4.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qscriptvalue.xml#scriptClass">QScriptValue::scriptClass</db:link>()</db:member>
<db:member><db:link xlink:href="qscriptengine.xml#reportAdditionalMemoryCost">reportAdditionalMemoryCost</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="newQMetaObject">
<db:title>QScriptValue QScriptEngine::newQMetaObject(const QMetaObject *<db:emphasis>metaObject</db:emphasis>, const QScriptValue &amp;<db:emphasis>ctor</db:emphasis> = QScriptValue())</db:title>
<db:para>Creates a Qt Script object that represents a <db:link xlink:href="qobject.xml">QObject</db:link> class, using the the given <db:code role="parameter">metaObject</db:code> and constructor <db:code role="parameter">ctor</db:code>.</db:para>
<db:para>Enums of <db:code role="parameter">metaObject</db:code> (declared with Q_ENUMS) are available as properties of the created <db:link xlink:href="qscriptvalue.xml">QScriptValue</db:link>. When the class is called as a function, <db:code role="parameter">ctor</db:code> will be called to create a new instance of the class.</db:para>
<db:para>Example:</db:para>
<db:programlisting language="cpp">QScriptValue mySpecialQObjectConstructor(QScriptContext *context,
                                         QScriptEngine *engine)
{
    QObject *parent = context-&gt;argument(0).toQObject();
    QObject *object = new QObject(parent);
    return engine-&gt;newQObject(object, QScriptEngine::ScriptOwnership);
}

...

QScriptValue ctor = engine.newFunction(mySpecialQObjectConstructor);
QScriptValue metaObject = engine.newQMetaObject(&amp;QObject::staticMetaObject, ctor);
engine.globalObject().setProperty(&quot;QObject&quot;, metaObject);

QScriptValue result = engine.evaluate(&quot;new QObject()&quot;);
</db:programlisting>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qscriptengine.xml#newQObject">newQObject</db:link>()</db:member>
<db:member><db:link xlink:href="">scriptValueFromQMetaObject()</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="newQObject">
<db:title>QScriptValue QScriptEngine::newQObject(QObject *<db:emphasis>object</db:emphasis>, QScriptEngine::ValueOwnership <db:emphasis>ownership</db:emphasis> = QtOwnership, const QScriptEngine::QObjectWrapOptions &amp;<db:emphasis>options</db:emphasis> = QObjectWrapOptions())</db:title>
<db:para>Creates a Qt Script object that wraps the given <db:link xlink:href="qobject.xml">QObject</db:link> <db:code role="parameter">object</db:code>, using the given <db:code role="parameter">ownership</db:code>. The given <db:code role="parameter">options</db:code> control various aspects of the interaction with the resulting script object.</db:para>
<db:para>Signals and slots, properties and children of <db:code role="parameter">object</db:code> are available as properties of the created <db:link xlink:href="qscriptvalue.xml">QScriptValue</db:link>. For more information, see the <db:link xlink:href="qtscript-index.xml">Qt Script</db:link> documentation.</db:para>
<db:para>If <db:code role="parameter">object</db:code> is a null pointer, this function returns <db:link xlink:href="qscriptengine.xml#nullValue">nullValue</db:link>().</db:para>
<db:para>If a default prototype has been registered for the <db:code role="parameter">object</db:code>'s class (or its superclass, recursively), the prototype of the new script object will be set to be that default prototype.</db:para>
<db:para>If the given <db:code role="parameter">object</db:code> is deleted outside of Qt Script's control, any attempt to access the deleted <db:link xlink:href="qobject.xml">QObject</db:link>'s members through the Qt Script wrapper object (either by script code or C++) will result in a script exception.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qscriptvalue.xml#toQObject">QScriptValue::toQObject</db:link>()</db:member>
<db:member><db:link xlink:href="qscriptengine.xml#reportAdditionalMemoryCost">reportAdditionalMemoryCost</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="newQObject-1">
<db:title>[since 4.4] QScriptValue QScriptEngine::newQObject(const QScriptValue &amp;<db:emphasis>scriptObject</db:emphasis>, QObject *<db:emphasis>qtObject</db:emphasis>, QScriptEngine::ValueOwnership <db:emphasis>ownership</db:emphasis> = QtOwnership, const QScriptEngine::QObjectWrapOptions &amp;<db:emphasis>options</db:emphasis> = QObjectWrapOptions())</db:title>
<db:para>This is an overloaded function.</db:para>
<db:para>Initializes the given <db:code role="parameter">scriptObject</db:code> to hold the given <db:code role="parameter">qtObject</db:code>, and returns the <db:code role="parameter">scriptObject</db:code>.</db:para>
<db:para>This function enables you to &quot;promote&quot; a plain Qt Script object (created by the <db:link xlink:href="qscriptengine.xml#newObject">newObject</db:link>() function) to a <db:link xlink:href="qobject.xml">QObject</db:link> proxy, or to replace the <db:link xlink:href="qobject.xml">QObject</db:link> contained inside an object previously created by the <db:link xlink:href="qscriptengine.xml#newQObject">newQObject</db:link>() function.</db:para>
<db:para>The prototype() of the <db:code role="parameter">scriptObject</db:code> will remain unchanged.</db:para>
<db:para>If <db:code role="parameter">scriptObject</db:code> is not an object, this function behaves like the normal <db:link xlink:href="qscriptengine.xml#newQObject">newQObject</db:link>(), i.e. it creates a new script object and returns it.</db:para>
<db:para>This function is useful when you want to provide a script constructor for a <db:link xlink:href="qobject.xml">QObject</db:link>-based class. If your constructor is invoked in a <db:code>new</db:code> expression (<db:link xlink:href="qscriptcontext.xml#isCalledAsConstructor">QScriptContext::isCalledAsConstructor</db:link>() returns true), you can pass <db:link xlink:href="qscriptcontext.xml#thisObject">QScriptContext::thisObject</db:link>() (the default constructed script object) to this function to initialize the new object.</db:para>
<db:para>This function was introduced in Qt 4.4.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qscriptengine.xml#reportAdditionalMemoryCost">reportAdditionalMemoryCost</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="newRegExp">
<db:title>QScriptValue QScriptEngine::newRegExp(const QRegExp &amp;<db:emphasis>regexp</db:emphasis>)</db:title>
<db:para>Creates a Qt Script object of class RegExp with the given <db:code role="parameter">regexp</db:code>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qscriptvalue.xml#toRegExp">QScriptValue::toRegExp</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="newRegExp-1">
<db:title>QScriptValue QScriptEngine::newRegExp(const QString &amp;<db:emphasis>pattern</db:emphasis>, const QString &amp;<db:emphasis>flags</db:emphasis>)</db:title>
<db:para>Creates a Qt Script object of class RegExp with the given <db:code role="parameter">pattern</db:code> and <db:code role="parameter">flags</db:code>.</db:para>
<db:para>The legal flags are 'g' (global), 'i' (ignore case), and 'm' (multiline).</db:para>
</db:section>
<db:section xml:id="newVariant">
<db:title>QScriptValue QScriptEngine::newVariant(const QVariant &amp;<db:emphasis>value</db:emphasis>)</db:title>
<db:para>Creates a Qt Script object holding the given variant <db:code role="parameter">value</db:code>.</db:para>
<db:para>If a default prototype has been registered with the meta type id of <db:code role="parameter">value</db:code>, then the prototype of the created object will be that prototype; otherwise, the prototype will be the Object prototype object.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qscriptengine.xml#setDefaultPrototype">setDefaultPrototype</db:link>()</db:member>
<db:member><db:link xlink:href="qscriptvalue.xml#toVariant">QScriptValue::toVariant</db:link>()</db:member>
<db:member><db:link xlink:href="qscriptengine.xml#reportAdditionalMemoryCost">reportAdditionalMemoryCost</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="newVariant-1">
<db:title>[since 4.4] QScriptValue QScriptEngine::newVariant(const QScriptValue &amp;<db:emphasis>object</db:emphasis>, const QVariant &amp;<db:emphasis>value</db:emphasis>)</db:title>
<db:para>This is an overloaded function.</db:para>
<db:para>Initializes the given Qt Script <db:code role="parameter">object</db:code> to hold the given variant <db:code role="parameter">value</db:code>, and returns the <db:code role="parameter">object</db:code>.</db:para>
<db:para>This function enables you to &quot;promote&quot; a plain Qt Script object (created by the <db:link xlink:href="qscriptengine.xml#newObject">newObject</db:link>() function) to a variant, or to replace the variant contained inside an object previously created by the <db:link xlink:href="qscriptengine.xml#newVariant">newVariant</db:link>() function.</db:para>
<db:para>The prototype() of the <db:code role="parameter">object</db:code> will remain unchanged.</db:para>
<db:para>If <db:code role="parameter">object</db:code> is not an object, this function behaves like the normal <db:link xlink:href="qscriptengine.xml#newVariant">newVariant</db:link>(), i.e. it creates a new script object and returns it.</db:para>
<db:para>This function is useful when you want to provide a script constructor for a C++ type. If your constructor is invoked in a <db:code>new</db:code> expression (<db:link xlink:href="qscriptcontext.xml#isCalledAsConstructor">QScriptContext::isCalledAsConstructor</db:link>() returns true), you can pass <db:link xlink:href="qscriptcontext.xml#thisObject">QScriptContext::thisObject</db:link>() (the default constructed script object) to this function to initialize the new object.</db:para>
<db:para>This function was introduced in Qt 4.4.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qscriptengine.xml#reportAdditionalMemoryCost">reportAdditionalMemoryCost</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="nullValue">
<db:title>QScriptValue QScriptEngine::nullValue()</db:title>
<db:para>Returns a <db:link xlink:href="qscriptvalue.xml">QScriptValue</db:link> of the primitive type Null.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qscriptengine.xml#undefinedValue">undefinedValue</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="popContext">
<db:title>void QScriptEngine::popContext()</db:title>
<db:para>Pops the current execution context and restores the previous one. This function must be used in conjunction with <db:link xlink:href="qscriptengine.xml#pushContext">pushContext</db:link>().</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qscriptengine.xml#pushContext">pushContext</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="processEventsInterval">
<db:title>int QScriptEngine::processEventsInterval() const</db:title>
<db:para>Returns the interval in milliseconds between calls to <db:link xlink:href="qcoreapplication.xml#processEvents">QCoreApplication::processEvents</db:link>() while the interpreter is running.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qscriptengine.xml#setProcessEventsInterval">setProcessEventsInterval</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="pushContext">
<db:title>QScriptContext *QScriptEngine::pushContext()</db:title>
<db:para>Enters a new execution context and returns the associated <db:link xlink:href="qscriptcontext.xml">QScriptContext</db:link> object.</db:para>
<db:para>Once you are done with the context, you should call <db:link xlink:href="qscriptengine.xml#popContext">popContext</db:link>() to restore the old context.</db:para>
<db:para>By default, the `this' object of the new context is the Global Object. The context's <db:link xlink:href="qscriptcontext.xml#callee">callee</db:link>() will be invalid.</db:para>
<db:para>This function is useful when you want to evaluate script code as if it were the body of a function. You can use the context's <db:link xlink:href="qscriptcontext.xml#activationObject">activationObject</db:link>() to initialize local variables that will be available to scripts. Example:</db:para>
<db:programlisting language="cpp">QScriptEngine engine;
QScriptContext *context = engine.pushContext();
context-&gt;activationObject().setProperty(&quot;myArg&quot;, 123);
engine.evaluate(&quot;var tmp = myArg + 42&quot;);
...
engine.popContext();
</db:programlisting>
<db:para>In the above example, the new variable &quot;tmp&quot; defined in the script will be local to the context; in other words, the script doesn't have any effect on the global environment.</db:para>
<db:para>Returns 0 in case of stack overflow</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qscriptengine.xml#popContext">popContext</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="reportAdditionalMemoryCost">
<db:title>[since 4.7] void QScriptEngine::reportAdditionalMemoryCost(int <db:emphasis>size</db:emphasis>)</db:title>
<db:para>Reports an additional memory cost of the given <db:code role="parameter">size</db:code>, measured in bytes, to the garbage collector.</db:para>
<db:para>This function can be called to indicate that a Qt Script object has memory associated with it that isn't managed by Qt Script itself. Reporting the additional cost makes it more likely that the garbage collector will be triggered.</db:para>
<db:para>Note that if the additional memory is shared with objects outside the scripting environment, the cost should not be reported, since collecting the Qt Script object would not cause the memory to be freed anyway.</db:para>
<db:para>Negative <db:code role="parameter">size</db:code> values are ignored, i.e. this function can't be used to report that the additional memory has been deallocated.</db:para>
<db:para>This function was introduced in Qt 4.7.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qscriptengine.xml#collectGarbage">collectGarbage</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setAgent">
<db:title>[since 4.4] void QScriptEngine::setAgent(QScriptEngineAgent *<db:emphasis>agent</db:emphasis>)</db:title>
<db:para>Installs the given <db:code role="parameter">agent</db:code> on this engine. The agent will be notified of various events pertaining to script execution. This is useful when you want to find out exactly what the engine is doing, e.g. when <db:link xlink:href="qscriptengine.xml#evaluate">evaluate</db:link>() is called. The agent interface is the basis of tools like debuggers and profilers.</db:para>
<db:para>The engine maintains ownership of the <db:code role="parameter">agent</db:code>.</db:para>
<db:para>Calling this function will replace the existing agent, if any.</db:para>
<db:para>This function was introduced in Qt 4.4.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qscriptengine.xml#agent">agent</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setDefaultPrototype">
<db:title>void QScriptEngine::setDefaultPrototype(int <db:emphasis>metaTypeId</db:emphasis>, const QScriptValue &amp;<db:emphasis>prototype</db:emphasis>)</db:title>
<db:para>Sets the default prototype of the C++ type identified by the given <db:code role="parameter">metaTypeId</db:code> to <db:code role="parameter">prototype</db:code>.</db:para>
<db:para>The default prototype provides a script interface for values of type <db:code role="parameter">metaTypeId</db:code> when a value of that type is accessed from script code. Whenever the script engine (implicitly or explicitly) creates a <db:link xlink:href="qscriptvalue.xml">QScriptValue</db:link> from a value of type <db:code role="parameter">metaTypeId</db:code>, the default prototype will be set as the <db:link xlink:href="qscriptvalue.xml">QScriptValue</db:link>'s prototype.</db:para>
<db:para>The <db:code role="parameter">prototype</db:code> object itself may be constructed using one of two principal techniques; the simplest is to subclass <db:link xlink:href="qscriptable.xml">QScriptable</db:link>, which enables you to define the scripting API of the type through <db:link xlink:href="qobject.xml">QObject</db:link> properties and slots. Another possibility is to create a script object by calling <db:link xlink:href="qscriptengine.xml#newObject">newObject</db:link>(), and populate the object with the desired properties (e.g. native functions wrapped with <db:link xlink:href="qscriptengine.xml#newFunction">newFunction</db:link>()).</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qscriptengine.xml#defaultPrototype">defaultPrototype</db:link>()</db:member>
<db:member><db:link xlink:href="">qScriptRegisterMetaType()</db:link></db:member>
<db:member><db:link xlink:href="qscriptable.xml">QScriptable</db:link></db:member>
<db:member><db:link xlink:href="qtscript-script-defaultprototypes-example.xml">Default Prototypes Example</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setGlobalObject">
<db:title>[since 4.5] void QScriptEngine::setGlobalObject(const QScriptValue &amp;<db:emphasis>object</db:emphasis>)</db:title>
<db:para>Sets this engine's Global Object to be the given <db:code role="parameter">object</db:code>. If <db:code role="parameter">object</db:code> is not a valid script object, this function does nothing.</db:para>
<db:para>When setting a custom global object, you may want to use <db:link xlink:href="qscriptvalueiterator.xml">QScriptValueIterator</db:link> to copy the properties of the standard Global Object; alternatively, you can set the internal prototype of your custom object to be the original Global Object.</db:para>
<db:para>This function was introduced in Qt 4.5.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qscriptengine.xml#globalObject">globalObject</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setProcessEventsInterval">
<db:title>void QScriptEngine::setProcessEventsInterval(int <db:emphasis>interval</db:emphasis>)</db:title>
<db:para>Sets the interval between calls to <db:link xlink:href="qcoreapplication.xml#processEvents">QCoreApplication::processEvents</db:link> to <db:code role="parameter">interval</db:code> milliseconds.</db:para>
<db:para>While the interpreter is running, all event processing is by default blocked. This means for instance that the gui will not be updated and timers will not be fired. To allow event processing during interpreter execution one can specify the processing interval to be a positive value, indicating the number of milliseconds between each time <db:link xlink:href="qcoreapplication.xml#processEvents">QCoreApplication::processEvents</db:link>() is called.</db:para>
<db:para>The default value is -1, which disables event processing during interpreter execution.</db:para>
<db:para>You can use <db:link xlink:href="qcoreapplication.xml#postEvent">QCoreApplication::postEvent</db:link>() to post an event that performs custom processing at the next interval. For example, you could keep track of the total running time of the script and call <db:link xlink:href="qscriptengine.xml#abortEvaluation">abortEvaluation</db:link>() when you detect that the script has been running for a long time without completing.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qscriptengine.xml#processEventsInterval">processEventsInterval</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="signalHandlerException">
<db:title>[since 4.4] void QScriptEngine::signalHandlerException(const QScriptValue &amp;<db:emphasis>exception</db:emphasis>)</db:title>
<db:para>This signal is emitted when a script function connected to a signal causes an <db:code role="parameter">exception</db:code>.</db:para>
<db:para>This function was introduced in Qt 4.4.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qscriptengine.xml#qScriptConnect">qScriptConnect</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="toObject">
<db:title>[since 4.5] QScriptValue QScriptEngine::toObject(const QScriptValue &amp;<db:emphasis>value</db:emphasis>)</db:title>
<db:para>Converts the given <db:code role="parameter">value</db:code> to an object, if such a conversion is possible; otherwise returns an invalid <db:link xlink:href="qscriptvalue.xml">QScriptValue</db:link>. The conversion is performed according to the following table:</db:para>
<db:informaltable style="generic">
<db:thead>
<db:tr>
<db:th>
<db:para>Input Type</db:para>
</db:th>
<db:th>
<db:para>Result</db:para>
</db:th>
</db:tr>
</db:thead>
<db:tr valign="top">
<db:td>
<db:para>Undefined</db:para>
</db:td>
<db:td>
<db:para>An invalid <db:link xlink:href="qscriptvalue.xml">QScriptValue</db:link>.</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>Null</db:para>
</db:td>
<db:td>
<db:para>An invalid <db:link xlink:href="qscriptvalue.xml">QScriptValue</db:link>.</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>Boolean</db:para>
</db:td>
<db:td>
<db:para>A new Boolean object whose internal value is set to the value of the boolean.</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>Number</db:para>
</db:td>
<db:td>
<db:para>A new Number object whose internal value is set to the value of the number.</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>String</db:para>
</db:td>
<db:td>
<db:para>A new String object whose internal value is set to the value of the string.</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>Object</db:para>
</db:td>
<db:td>
<db:para>The result is the object itself (no conversion).</db:para>
</db:td>
</db:tr>
</db:informaltable>
<db:para>This function was introduced in Qt 4.5.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qscriptengine.xml#newObject">newObject</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="toStringHandle">
<db:title>[since 4.4] QScriptString QScriptEngine::toStringHandle(const QString &amp;<db:emphasis>str</db:emphasis>)</db:title>
<db:para>Returns a handle that represents the given string, <db:code role="parameter">str</db:code>.</db:para>
<db:para><db:link xlink:href="qscriptstring.xml">QScriptString</db:link> can be used to quickly look up properties, and compare property names, of script objects.</db:para>
<db:para>This function was introduced in Qt 4.4.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qscriptvalue.xml#property">QScriptValue::property</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="uncaughtException">
<db:title>QScriptValue QScriptEngine::uncaughtException() const</db:title>
<db:para>Returns the current uncaught exception, or an invalid <db:link xlink:href="qscriptvalue.xml">QScriptValue</db:link> if there is no uncaught exception.</db:para>
<db:para>The exception value is typically an <db:code>Error</db:code> object; in that case, you can call toString() on the return value to obtain an error message.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qscriptengine.xml#hasUncaughtException">hasUncaughtException</db:link>()</db:member>
<db:member><db:link xlink:href="qscriptengine.xml#uncaughtExceptionLineNumber">uncaughtExceptionLineNumber</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="uncaughtExceptionBacktrace">
<db:title>QStringList QScriptEngine::uncaughtExceptionBacktrace() const</db:title>
<db:para>Returns a human-readable backtrace of the last uncaught exception.</db:para>
<db:para>It is in the form <db:code>&lt;function-name&gt;() at &lt;file-name&gt;:&lt;line-number&gt;</db:code>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qscriptengine.xml#uncaughtException">uncaughtException</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="uncaughtExceptionLineNumber">
<db:title>int QScriptEngine::uncaughtExceptionLineNumber() const</db:title>
<db:para>Returns the line number where the last uncaught exception occurred.</db:para>
<db:para>Line numbers are 1-based, unless a different base was specified as the second argument to <db:link xlink:href="qscriptengine.xml#evaluate">evaluate</db:link>().</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qscriptengine.xml#hasUncaughtException">hasUncaughtException</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="undefinedValue">
<db:title>QScriptValue QScriptEngine::undefinedValue()</db:title>
<db:para>Returns a <db:link xlink:href="qscriptvalue.xml">QScriptValue</db:link> of the primitive type Undefined.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qscriptengine.xml#nullValue">nullValue</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
</db:section>
<db:section xml:id="related-non-members">
<db:title>Related Non-Members</db:title>
<db:section xml:id="qScriptConnect">
<db:title>[since 4.4] bool qScriptConnect(QObject *<db:emphasis>sender</db:emphasis>, const char *<db:emphasis>signal</db:emphasis>, const QScriptValue &amp;<db:emphasis>receiver</db:emphasis>, const QScriptValue &amp;<db:emphasis>function</db:emphasis>)</db:title>
<db:para>Creates a connection from the <db:code role="parameter">signal</db:code> in the <db:code role="parameter">sender</db:code> to the given <db:code role="parameter">function</db:code>. If <db:code role="parameter">receiver</db:code> is an object, it will act as the `this' object when the signal handler function is invoked. Returns true if the connection succeeds; otherwise returns false.</db:para>
<db:para>This function was introduced in Qt 4.4.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qscriptengine.xml#qScriptDisconnect">qScriptDisconnect</db:link>()</db:member>
<db:member><db:link xlink:href="qscriptengine.xml#signalHandlerException">QScriptEngine::signalHandlerException</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="qScriptDisconnect">
<db:title>[since 4.4] bool qScriptDisconnect(QObject *<db:emphasis>sender</db:emphasis>, const char *<db:emphasis>signal</db:emphasis>, const QScriptValue &amp;<db:emphasis>receiver</db:emphasis>, const QScriptValue &amp;<db:emphasis>function</db:emphasis>)</db:title>
<db:para>Disconnects the <db:code role="parameter">signal</db:code> in the <db:code role="parameter">sender</db:code> from the given (<db:code role="parameter">receiver</db:code>, <db:code role="parameter">function</db:code>) pair. Returns true if the connection is successfully broken; otherwise returns false.</db:para>
<db:para>This function was introduced in Qt 4.4.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qscriptengine.xml#qScriptConnect">qScriptConnect</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
</db:section>
<db:section xml:id="macro-documentation">
<db:title>Macro Documentation</db:title>
<db:section xml:id="Q_SCRIPT_DECLARE_QMETAOBJECT">
<db:title>[since 4.3] Q_SCRIPT_DECLARE_QMETAOBJECT(<db:emphasis>QMetaObject</db:emphasis>, <db:emphasis>ArgType</db:emphasis>)</db:title>
<db:para>Declares the given <db:code role="parameter">QMetaObject</db:code>. Used in combination with QScriptEngine::scriptValueFromQMetaObject() to make enums and instantiation of <db:code role="parameter">QMetaObject</db:code> available to script code. The constructor generated by this macro takes a single argument of type <db:code role="parameter">ArgType</db:code>; typically the argument is the parent type of the new instance, in which case <db:code role="parameter">ArgType</db:code> is <db:code>QWidget*</db:code> or <db:code>QObject*</db:code>. Objects created by the constructor will have <db:link xlink:href="qscriptengine.xml#ValueOwnership-enum">QScriptEngine::AutoOwnership</db:link> ownership.</db:para>
<db:para>This macro was introduced in Qt 4.3.</db:para>
</db:section>
</db:section>
<db:section xml:id="obsolete">
<db:title>Obsolete Members for QScriptEngine</db:title>
<db:para><db:emphasis role="bold">The following members of class <db:link xlink:href="qscriptengine.xml">QScriptEngine</db:link> are deprecated.</db:emphasis> We strongly advise against using them in new code.</db:para>
<db:section xml:id="obsolete-member-function-documentation">
<db:title>Obsolete Member Function Documentation</db:title>
<db:section xml:id="canEvaluate">
<db:title>[deprecated] bool QScriptEngine::canEvaluate(const QString &amp;<db:emphasis>program</db:emphasis>) const</db:title>
<db:para>This function is deprecated. We strongly advise against using it in new code.</db:para>
<db:para>Returns true if <db:code role="parameter">program</db:code> can be evaluated; i.e. the code is sufficient to determine whether it appears to be a syntactically correct program, or contains a syntax error.</db:para>
<db:para>This function returns false if <db:code role="parameter">program</db:code> is incomplete; i.e. the input is syntactically correct up to the point where the input is terminated.</db:para>
<db:para>Note that this function only does a static check of <db:code role="parameter">program</db:code>; e.g. it does not check whether references to variables are valid, and so on.</db:para>
<db:para>A typical usage of canEvaluate() is to implement an interactive interpreter for Qt Script. The user is repeatedly queried for individual lines of code; the lines are concatened internally, and only when canEvaluate() returns true for the resulting program is it passed to <db:link xlink:href="qscriptengine.xml#evaluate">evaluate</db:link>().</db:para>
<db:para>The following are some examples to illustrate the behavior of canEvaluate(). (Note that all example inputs are assumed to have an explicit newline as their last character, since otherwise the Qt Script parser would automatically insert a semi-colon character at the end of the input, and this could cause canEvaluate() to produce different results.)</db:para>
<db:para>Given the input</db:para>
<db:programlisting language="cpp">if (hello &amp;&amp; world)
    print(&quot;hello world&quot;);
</db:programlisting>
<db:para>canEvaluate() will return true, since the program appears to be complete.</db:para>
<db:para>Given the input</db:para>
<db:programlisting language="cpp">if (hello &amp;&amp;
</db:programlisting>
<db:para>canEvaluate() will return false, since the if-statement is not complete, but is syntactically correct so far.</db:para>
<db:para>Given the input</db:para>
<db:programlisting language="cpp">0 = 0
</db:programlisting>
<db:para>canEvaluate() will return true, but <db:link xlink:href="qscriptengine.xml#evaluate">evaluate</db:link>() will throw a SyntaxError given the same input.</db:para>
<db:para>Given the input</db:para>
<db:programlisting language="cpp">./test.js
</db:programlisting>
<db:para>canEvaluate() will return true, even though the code is clearly not syntactically valid Qt Script code. <db:link xlink:href="qscriptengine.xml#evaluate">evaluate</db:link>() will throw a SyntaxError when this code is evaluated.</db:para>
<db:para>Given the input</db:para>
<db:programlisting language="cpp">foo[&quot;bar&quot;]
</db:programlisting>
<db:para>canEvaluate() will return true, but <db:link xlink:href="qscriptengine.xml#evaluate">evaluate</db:link>() will throw a ReferenceError if <db:code>foo</db:code> is not defined in the script environment.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qscriptengine.xml#evaluate">evaluate</db:link>()</db:member>
<db:member><db:link xlink:href="qscriptengine.xml#checkSyntax">checkSyntax</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
</db:section>
</db:section>
</db:article>
