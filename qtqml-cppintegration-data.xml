<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en">
<db:info>
<db:title>Data Type Conversion Between QML and C++</db:title>
<db:productname>QtQml</db:productname>
<db:edition>Qt 5.5.1 Reference Documentation</db:edition>
<db:titleabbrev>Qt QML Reference Documentation</db:titleabbrev>
<db:abstract>
<db:para>Description of how data types are exchanged between QML and C++.</db:para>
</db:abstract>
<db:pubdate>2025-06-29</db:pubdate>
<db:date>2025-06-29</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:para>When data values are exchanged between QML and C++, they are converted by the QML engine to have the correct data types as appropriate for use in QML or C++. This requires the exchanged data to be of a type that is recognizable by the engine.</db:para>
<db:para>The QML engine provides built-in support for a large number of Qt C++ data types. Additionally, custom C++ types may be registered with the QML type system to make them available to the engine.</db:para>
<db:para>This page discusses the data types supported by the QML engine and how they are converted between QML and C++.</db:para>
<db:section xml:id="data-ownership">
<db:title>Data Ownership</db:title>
<db:para>When data is transferred from C++ to QML, the ownership of the data always remains with C++. The exception to this rule is when a <db:link xlink:href="qobject.xml">QObject</db:link> is returned from an explicit C++ method call: in this case, the QML engine assumes ownership of the object, unless the ownership of the object has explicitly been set to remain with C++ by invoking QQmlEngine::setObjectOwnership() with QQmlEngine::CppOwnership specified.</db:para>
<db:para>Additionally, the QML engine respects the normal <db:link xlink:href="qobject.xml">QObject</db:link> parent ownership semantics of Qt C++ objects, and will not ever take ownership of a <db:link xlink:href="qobject.xml">QObject</db:link> instance which already has a parent.</db:para>
</db:section>
<db:section xml:id="basic-qt-data-types">
<db:title>Basic Qt Data Types</db:title>
<db:para>By default, QML recognizes the following Qt data types, which are automatically converted to a corresponding <db:link xlink:href="qtqml-typesystem-basictypes.xml">QML basic type</db:link> when passed from C++ to QML and vice-versa:</db:para>
<db:informaltable style="generic">
<db:tr valign="top">
<db:td>
<db:para>Qt Type</db:para>
</db:td>
<db:td>
<db:para>QML Basic Type</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>bool</db:para>
</db:td>
<db:td>
<db:para><db:link xlink:href="qml-bool.xml">bool</db:link></db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>unsigned int, int</db:para>
</db:td>
<db:td>
<db:para><db:link xlink:href="qml-int.xml">int</db:link></db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>double</db:para>
</db:td>
<db:td>
<db:para><db:link xlink:href="qml-double.xml">double</db:link></db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>float, qreal</db:para>
</db:td>
<db:td>
<db:para><db:link xlink:href="qml-real.xml">real</db:link></db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para><db:link xlink:href="qstring.xml">QString</db:link></db:para>
</db:td>
<db:td>
<db:para><db:link xlink:href="qml-string.xml">string</db:link></db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para><db:link xlink:href="qurl.xml">QUrl</db:link></db:para>
</db:td>
<db:td>
<db:para><db:link xlink:href="qml-url.xml">url</db:link></db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>QColor</db:para>
</db:td>
<db:td>
<db:para><db:link xlink:href="stylesheet-reference.xml#color">color</db:link></db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>QFont</db:para>
</db:td>
<db:td>
<db:para><db:link xlink:href="stylesheet-reference.xml#font">font</db:link></db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para><db:link xlink:href="qdate.xml">QDate</db:link></db:para>
</db:td>
<db:td>
<db:para><db:link xlink:href="qml-date.xml">date</db:link></db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para><db:link xlink:href="qpoint.xml">QPoint</db:link>, <db:link xlink:href="qpointf.xml">QPointF</db:link></db:para>
</db:td>
<db:td>
<db:para><db:link xlink:href="qml-point.xml">point</db:link></db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para><db:link xlink:href="qsize.xml">QSize</db:link>, <db:link xlink:href="qsizef.xml">QSizeF</db:link></db:para>
</db:td>
<db:td>
<db:para><db:link xlink:href="qml-size.xml">size</db:link></db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para><db:link xlink:href="qrect.xml">QRect</db:link>, <db:link xlink:href="qrectf.xml">QRectF</db:link></db:para>
</db:td>
<db:td>
<db:para><db:link xlink:href="qml-rect.xml">rect</db:link></db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>QMatrix4x4</db:para>
</db:td>
<db:td>
<db:para>matrix4x4</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>QQuaternion</db:para>
</db:td>
<db:td>
<db:para>quaternion</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>QVector2D, QVector3D, QVector4D</db:para>
</db:td>
<db:td>
<db:para>vector2d, vector3d, vector4d</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>Enums declared with Q_ENUMS()</db:para>
</db:td>
<db:td>
<db:para><db:link xlink:href="qml-enumeration.xml">enumeration</db:link></db:para>
</db:td>
</db:tr>
</db:informaltable>
<db:note>
<db:para>Classes provided by the <db:link xlink:href="qtgui-index.xml">Qt GUI</db:link> module, such as QColor, QFont, QQuaternion and QMatrix4x4, are only available from QML when the <db:link xlink:href="">Qt Quick</db:link> module is included.</db:para>
</db:note>
<db:para>As a convenience, many of these types can be specified in QML by string values, or by a related method provided by the <db:link xlink:href="qml-qtqml-qt.xml">QtQml::Qt</db:link> object. For example, the <db:link xlink:href="">Image::sourceSize</db:link> property is of type <db:link xlink:href="qml-size.xml">size</db:link> (which automatically translates to the <db:link xlink:href="qsize.xml">QSize</db:link> type) and can be specified by a string value formatted as &quot;width<db:code>x</db:code>height&quot;, or by the Qt.size() function:</db:para>
<db:programlisting language="qml">Item {
    Image { sourceSize: &quot;100x200&quot; }
    Image { sourceSize: Qt.size(100, 200) }
}
</db:programlisting>
<db:para>See documentation for each individual type under <db:link xlink:href="qtqml-typesystem-basictypes.xml">QML Basic Types</db:link> for more information.</db:para>
</db:section>
<db:section xml:id="qobject-derived-types">
<db:title>QObject-derived Types</db:title>
<db:para>Any <db:link xlink:href="qobject.xml">QObject</db:link>-derived class may be used as a type for the exchange of data between QML and C++, providing the class has been registered with the QML type system.</db:para>
<db:para>The engine allows the registration of both instantiable and non-instantiable types. Once a class is registered as a QML type, it can be used as a data type for exchanging data between QML and C++. See <db:link xlink:href="qtqml-cppintegration-definetypes.xml#registering-c-types-with-the-qml-type-system">Registering C++ types with the QML type system</db:link> for further details on type registration.</db:para>
</db:section>
<db:section xml:id="conversion-between-qt-and-javascript-types">
<db:title>Conversion Between Qt and JavaScript Types</db:title>
<db:para>The QML engine has built-in support for converting a number of Qt types to related JavaScript types, and vice-versa, when transferring data between QML and C++. This makes it possible to use these types and receive them in C++ or JavaScript without needing to implement custom types that provide access to the data values and their attributes.</db:para>
<db:para>(Note that the JavaScript environment in QML modifies native JavaScript object prototypes, including those of <db:code>String</db:code>, <db:code>Date</db:code> and <db:code>Number</db:code>, to provide additional features. See the <db:link xlink:href="qtqml-javascript-hostenvironment.xml">JavaScript Host Environment</db:link> for further details.)</db:para>
<db:section xml:id="qvariantlist-and-qvariantmap-to-javascript-array-and-object">
<db:title>QVariantList and QVariantMap to JavaScript Array and Object</db:title>
<db:para>The QML engine provides automatic type conversion between <db:link xlink:href="qvariant.xml#QVariantList-typedef">QVariantList</db:link> and JavaScript arrays, and between <db:link xlink:href="qvariant.xml#QVariantMap-typedef">QVariantMap</db:link> and JavaScript objects.</db:para>
<db:para>For example, the function defined in QML below left expects two arguments, an array and an object, and prints their contents using the standard JavaScript syntax for array and object item access. The C++ code below right calls this function, passing a <db:link xlink:href="qvariant.xml#QVariantList-typedef">QVariantList</db:link> and a <db:link xlink:href="qvariant.xml#QVariantMap-typedef">QVariantMap</db:link>, which are automatically converted to JavaScript array and object values, repectively:</db:para>
<db:informaltable style="generic">
<db:tr valign="top">
<db:td>
<db:para>QML</db:para>
</db:td>
<db:td>
<db:programlisting language="qml">// MyItem.qml
Item {
    function readValues(anArray, anObject) {
        for (var i=0; i&lt;anArray.length; i++)
            console.log(&quot;Array item:&quot;, anArray[i])

        for (var prop in anObject) {
            console.log(&quot;Object item:&quot;, prop, &quot;=&quot;, anObject[prop])
        }
    }
}
</db:programlisting>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>C++</db:para>
</db:td>
<db:td>
<db:programlisting language="cpp">// C++
QQuickView view(QUrl::fromLocalFile(&quot;MyItem.qml&quot;));

QVariantList list;
list &lt;&lt; 10 &lt;&lt; QColor(Qt::green) &lt;&lt; &quot;bottles&quot;;

QVariantMap map;
map.insert(&quot;language&quot;, &quot;QML&quot;);
map.insert(&quot;released&quot;, QDate(2010, 9, 21));

QMetaObject::invokeMethod(view.rootObject(), &quot;readValues&quot;,
        Q_ARG(QVariant, QVariant::fromValue(list)),
        Q_ARG(QVariant, QVariant::fromValue(map)));
</db:programlisting>
</db:td>
</db:tr>
</db:informaltable>
<db:para>This produces output like:</db:para>
<db:programlisting language="cpp">Array item: 10
Array item: #00ff00
Array item: bottles
Object item: language = QML
Object item: released = Tue Sep 21 2010 00:00:00 GMT+1000 (EST)
</db:programlisting>
<db:para>Similarly, if a C++ type uses a <db:link xlink:href="qvariant.xml#QVariantList-typedef">QVariantList</db:link> or <db:link xlink:href="qvariant.xml#QVariantMap-typedef">QVariantMap</db:link> type for a property type or method parameter, the value can be created as a JavaScript array or object in QML, and is automatically converted to a <db:link xlink:href="qvariant.xml#QVariantList-typedef">QVariantList</db:link> or <db:link xlink:href="qvariant.xml#QVariantMap-typedef">QVariantMap</db:link> when it is passed to C++.</db:para>
</db:section>
<db:section xml:id="qdatetime-to-javascript-date">
<db:title>QDateTime to JavaScript Date</db:title>
<db:para>The QML engine provides automatic type conversion between <db:link xlink:href="qdatetime.xml">QDateTime</db:link> values and JavaScript <db:code>Date</db:code> objects.</db:para>
<db:para>For example, the function defined in QML below left expects a JavaScript <db:code>Date</db:code> object, and also returns a new <db:code>Date</db:code> object with the current date and time. The C++ code below right calls this function, passing a <db:link xlink:href="qdatetime.xml">QDateTime</db:link> value that is automatically converted by the engine into a <db:code>Date</db:code> object when it is passed to the <db:code>readDate()</db:code> function. In turn, the readDate() function returns a <db:code>Date</db:code> object that is automatically converted into a <db:link xlink:href="qdatetime.xml">QDateTime</db:link> value when it is received in C++:</db:para>
<db:informaltable style="generic">
<db:tr valign="top">
<db:td>
<db:programlisting language="qml">// MyItem.qml
Item {
    function readDate(dt) {
        console.log(&quot;The given date is:&quot;, dt.toUTCString());
        return new Date();
    }
}
</db:programlisting>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:programlisting language="cpp">// C++
QQuickView view(QUrl::fromLocalFile(&quot;MyItem.qml&quot;));

QDateTime dateTime = QDateTime::currentDateTime();
QDateTime retValue;

QMetaObject::invokeMethod(view.rootObject(), &quot;readDate&quot;,
        Q_RETURN_ARG(QVariant, retValue),
        Q_ARG(QVariant, QVariant::fromValue(dateTime)));

qDebug() &lt;&lt; &quot;Value returned from readDate():&quot; &lt;&lt; retValue;
</db:programlisting>
</db:td>
</db:tr>
</db:informaltable>
<db:para>Similarly, if a C++ type uses a <db:link xlink:href="qdatetime.xml">QDateTime</db:link> for a property type or method parameter, the value can be created as a JavaScript <db:code>Date</db:code> object in QML, and is automatically converted to a <db:link xlink:href="qdatetime.xml">QDateTime</db:link> value when it is passed to C++.</db:para>
</db:section>
<db:section xml:id="sequence-type-to-javascript-array">
<db:title>Sequence Type to JavaScript Array</db:title>
<db:para>Certain C++ sequence types are supported transparently in QML as JavaScript <db:code>Array</db:code> types.</db:para>
<db:para>In particular, QML currently supports:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:code>QList&lt;int&gt;</db:code></db:para>
</db:listitem>
<db:listitem>
<db:para><db:code>QList&lt;qreal&gt;</db:code></db:para>
</db:listitem>
<db:listitem>
<db:para><db:code>QList&lt;bool&gt;</db:code></db:para>
</db:listitem>
<db:listitem>
<db:para><db:code>QList&lt;QString&gt;</db:code> and <db:code>QStringList</db:code></db:para>
</db:listitem>
<db:listitem>
<db:para><db:code>QList&lt;QUrl&gt;</db:code></db:para>
</db:listitem>
</db:itemizedlist>
<db:para>These sequence types are implemented directly in terms of the underlying C++ sequence. There are two ways in which such sequences can be exposed to QML: as a <db:link xlink:href="qobject.xml#Q_PROPERTY">Q_PROPERTY</db:link> of the given sequence type; or as the return type of a <db:link xlink:href="qobject.xml#Q_INVOKABLE">Q_INVOKABLE</db:link> method. There are some differences in the way these are implemented, which are important to note.</db:para>
<db:para>If the sequence is exposed as a <db:link xlink:href="qobject.xml#Q_PROPERTY">Q_PROPERTY</db:link>, accessing any value in the sequence by index will cause the sequence data to be read from the <db:link xlink:href="qobject.xml">QObject</db:link>'s property, then a read to occur. Similarly, modifying any value in the sequence will cause the sequence data to be read, and then the modification will be performed and the modified sequence will be written back to the <db:link xlink:href="qobject.xml">QObject</db:link>'s property.</db:para>
<db:para>If the sequence is returned from a <db:link xlink:href="qobject.xml#Q_INVOKABLE">Q_INVOKABLE</db:link> function, access and mutation is much cheaper, as no <db:link xlink:href="qobject.xml">QObject</db:link> property read or write occurs; instead, the C++ sequence data is accessed and modified directly.</db:para>
<db:para>Other sequence types are not supported transparently, and instead an instance of any other sequence type will be passed between QML and C++ as an opaque <db:link xlink:href="qvariant.xml#QVariantList-typedef">QVariantList</db:link>.</db:para>
<db:para><db:emphasis role="bold">Important Note:</db:emphasis> There are some minor differences between the semantics of such sequence Array types and default JavaScript Array types which result from the use of a C++ storage type in the implementation. In particular, deleting an element from an Array will result in a default-constructed value replacing that element, rather than an Undefined value. Similarly, setting the length property of the Array to a value larger than its current value will result in the Array being padded out to the specified length with default-constructed elements rather than Undefined elements. Finally, the Qt container classes support signed (rather than unsigned) integer indexes; thus, attempting to access any index greater than INT_MAX will fail.</db:para>
<db:para>The default-constructed values for each sequence type are as follows:</db:para>
<db:informaltable style="generic">
<db:tr valign="top">
<db:td>
<db:para><db:link xlink:href="qlist.xml">QList</db:link>&lt;int&gt;</db:para>
</db:td>
<db:td>
<db:para>integer value 0</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para><db:link xlink:href="qlist.xml">QList</db:link>&lt;qreal&gt;</db:para>
</db:td>
<db:td>
<db:para>real value 0.0</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para><db:link xlink:href="qlist.xml">QList</db:link>&lt;bool&gt;</db:para>
</db:td>
<db:td>
<db:para>boolean value <db:code>false</db:code></db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para><db:link xlink:href="qlist.xml">QList</db:link>&lt;<db:link xlink:href="qstring.xml">QString</db:link>&gt; and <db:link xlink:href="qstringlist.xml">QStringList</db:link></db:para>
</db:td>
<db:td>
<db:para>empty <db:link xlink:href="qstring.xml">QString</db:link></db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para><db:link xlink:href="qlist.xml">QList</db:link>&lt;<db:link xlink:href="qurl.xml">QUrl</db:link>&gt;</db:para>
</db:td>
<db:td>
<db:para>empty <db:link xlink:href="qurl.xml">QUrl</db:link></db:para>
</db:td>
</db:tr>
</db:informaltable>
<db:para>If you wish to remove elements from a sequence rather than simply replace them with default constructed values, do not use the indexed delete operator (&quot;delete sequence[i]&quot;) but instead use the <db:code>splice</db:code> function (&quot;sequence.splice(startIndex, deleteCount)&quot;).</db:para>
</db:section>
<db:section xml:id="value-types">
<db:title>Value types</db:title>
<db:para>Some value types in Qt such as <db:link xlink:href="qpoint.xml">QPoint</db:link> are represented in JavaScript as objects that have the same properties and functions like in the C++ API. The same representation is possible with custom C++ value types. To enable a custom value type with the QML engine, the class declaration needs to be annotated with <db:code>Q_GADGET</db:code>. Properties that are intended to be visible in the JavaScript representation need to be declared with <db:code>Q_PROPERTY</db:code>. Similarly functions need to be marked with <db:code>Q_INVOKABLE</db:code>. This is the same with <db:link xlink:href="qobject.xml">QObject</db:link> based C++ APIs. For example, the <db:code>Actor</db:code> class below is annotated as gadget and has properties:</db:para>
<db:programlisting language="cpp">class Actor
{
    Q_GADGET
    Q_PROPERTY(QString name READ name WRITE setName)
public:
    QString name() const { return m_name; }
    void setName(const QString &amp;name) { m_name = name; }

private:
    QString m_name;
}

Q_DECLARE_METATYPE(Actor)
</db:programlisting>
</db:section>
</db:section>
<db:section xml:id="enumeration-types">
<db:title>Enumeration Types</db:title>
<db:para>To use a custom enumeration as a data type, its class must be registered and the enumeration must also be declared with Q_ENUMS() to register it with Qt's meta object system. For example, the <db:code>Message</db:code> class below has a <db:code>Status</db:code> enum:</db:para>
<db:programlisting language="cpp">class Message : public QObject
{
    Q_OBJECT
    Q_ENUMS(Status)
    Q_PROPERTY(Status status READ status NOTIFY statusChanged)
public:
    enum Status {
        Ready,
        Loading,
        Error
    };
    Status status() const;
signals:
    void statusChanged();
};
</db:programlisting>
<db:para>Providing the <db:code>Message</db:code> class has been <db:link xlink:href="qtqml-cppintegration-definetypes.xml#registering-c-types-with-the-qml-type-system">registered</db:link> with the QML type system, its <db:code>Status</db:code> enum can be used from QML:</db:para>
<db:programlisting language="qml">Message {
     onStatusChanged: {
         if (status == Message.Ready)
             console.log(&quot;Message is loaded!&quot;)
     }
 }
</db:programlisting>
<db:note>
<db:para>The names of enum values must begin with a capital letter in order to be accessible from QML.</db:para>
</db:note>
<db:section xml:id="enumeration-types-as-signal-and-method-parameters">
<db:title>Enumeration Types as Signal and Method Parameters</db:title>
<db:para>C++ signals and methods with enumeration-type parameters can be used from QML provided that the enumeration and the signal or method are both declared within the same class, or that the enumeration value is one of those declared in the <db:link xlink:href="qml-qtqml-qt.xml">Qt Namespace</db:link>.</db:para>
<db:para>Additionally, if a C++ signal with an enum parameter should be connectable to a QML function using the <db:link xlink:href="qtqml-syntax-signals.xml#connecting-signals-to-methods-and-signals">connect()</db:link> function, the enum type must be registered using qRegisterMetaType().</db:para>
<db:para>For QML signals, enum values may be passed as signal parameters using the <db:code>int</db:code> type:</db:para>
<db:programlisting language="qml">Message {
    signal someOtherSignal(int statusValue)

    Component.onCompleted: {
        someOtherSignal(Message.Loading)
    }
}
</db:programlisting>
</db:section>
</db:section>
</db:article>
