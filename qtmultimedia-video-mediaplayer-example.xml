<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en">
<db:info>
<db:title>QML Media Player Example</db:title>
<db:productname>QtMultimedia</db:productname>
<db:edition>Qt 6.7.2 Reference Documentation</db:edition>
<db:titleabbrev>Qt Multimedia Documentation</db:titleabbrev>
<db:abstract>
<db:para>Playing audio and video using the QML <db:code>MediaPlayer</db:code> type.</db:para>
</db:abstract>
<db:pubdate>2024-12-27</db:pubdate>
<db:date>2024-12-27</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:mediaobject>
<db:imageobject>
<db:imagedata fileref="images/mediaplayer.png"/>
</db:imageobject>
</db:mediaobject>
<db:para>This example demonstrates a simple multimedia player that can play audio and video files using various codecs.</db:para>
<db:section xml:id="running-the-example">
<db:title>Running the Example</db:title>
<db:para>To run the example from <db:link xlink:href="https://doc.qt.io/qtcreator/index.html">Qt Creator</db:link>, open the <db:guilabel>Welcome</db:guilabel> mode and select the example from <db:guilabel>Examples</db:guilabel>. For more information, visit <db:link xlink:href="https://doc.qt.io/qtcreator/creator-build-example-application.html">Building and Running an Example</db:link>.</db:para>
</db:section>
<db:section xml:id="instantiating-the-mediaplayer">
<db:title>Instantiating the MediaPlayer</db:title>
<db:para>The entry point for the QML code in this example is <db:code>Main.qml</db:code>. Here an <db:code>ApplicationWindow</db:code> is created and properties such as the <db:code>id</db:code>, <db:code>title</db:code>, <db:code>width</db:code> and <db:code>height</db:code> are set.</db:para>
<db:programlisting language="qml">ApplicationWindow {
    id: root
    title: qsTr(&quot;Multimedia Player&quot;)
    width: 1280
    height: 720
</db:programlisting>
<db:para>Next the <db:code>MediaPlayer</db:code> is created and the two properties that are responsible for the video and audio output are defined. Firstly, <db:code>videoOutput</db:code> which renders the video viewfinder and secondly <db:code>audioOutput</db:code> which provides the audio output for the player.</db:para>
<db:programlisting language="qml">MediaPlayer {
    id: mediaPlayer
    ...
videoOutput: videoOutput
audioOutput: AudioOutput {
    id: audio
    muted: playbackController.muted
    volume: playbackController.volume
}
    ...
VideoOutput {
    id: videoOutput
    anchors.fill: parent
    visible: mediaPlayer.mediaStatus &amp;gt; 0

    TapHandler {
        onDoubleTapped: {
            root.fullScreen ?  root.showNormal() : root.showFullScreen()
            root.fullScreen = !root.fullScreen
        }
    }
}
</db:programlisting>
<db:para>The <db:code>visible</db:code> property of the <db:code>VideoOutput</db:code> type is set to <db:code>true</db:code> when the <db:code>mediaStatus</db:code> property of the <db:code>MediaPlayer</db:code> is greater than 0. <db:code>mediaStatus</db:code> is of enumeration type and is equal to 0 when <db:emphasis>No media has been set</db:emphasis>, and greater than 0 otherwise. Therefore, the <db:code>VideoOutput</db:code> is visible when media has been set.</db:para>
<db:para>The <db:code>MediaPlayer</db:code> type has a signal property called <db:code>onErrorOccurred</db:code> that can be overridden specifically to handle errors. In this case the signal opens a <db:code>MessageDialog</db:code> using the method <db:code>open()</db:code> and sets its <db:code>text</db:code> property to a <db:code>MediaPlayer</db:code> property called <db:code>errorString</db:code>.</db:para>
<db:programlisting language="qml">onErrorOccurred: {
    mediaError.open()
    mediaError.text = mediaPlayer.errorString
}
</db:programlisting>
</db:section>
<db:section xml:id="playback-controls">
<db:title>Playback Controls</db:title>
<db:para>In order to have a useable media player, there needs to be an interface to control the playback. This is created in its own component file, <db:code>PlaybackControl.qml</db:code>, and instantiated in <db:code>Main.qml</db:code>.</db:para>
<db:programlisting language="qml">PlaybackControl {
    id: playbackController
    ...
onTracksChanged: {
    audioTracksInfo.read(mediaPlayer.audioTracks)
    videoTracksInfo.read(mediaPlayer.videoTracks)
    subtitleTracksInfo.read(mediaPlayer.subtitleTracks, 6) /* QMediaMetaData::Language = 6 */
    updateMetadata()
    mediaPlayer.play()
}
</db:programlisting>
<db:para>When created, objects are forwarded to this type such as track information, metadata information and the <db:code>MediaPlayer</db:code> object itself. In <db:code>PlaybackControl.qml</db:code>, each one of these objects have a <db:code>required property</db:code>, meaning that these properties must be set when the <db:code>PlaybackControl</db:code> object is created.</db:para>
<db:programlisting language="qml">Item {
    id: playbackController

    required property MediaPlayer mediaPlayer
    required property MetadataInfo metadataInfo
    required property TracksInfo audioTracksInfo
    required property TracksInfo videoTracksInfo
    required property TracksInfo subtitleTracksInfo
</db:programlisting>
<db:para>These playback controls can be broken down into sections. In the top left of the panel lies a collection of buttons used to open a file, either by selecting a file from a file explorer or entering a URL. The file is loaded into the <db:code>MediaPlayer</db:code> by setting the <db:code>source</db:code> property. Both buttons are instantiated using a <db:code>CustomButton</db:code> <db:code>custom component</db:code>.</db:para>
<db:programlisting language="qml">CustomButton {
    id: fileDialogButton
    icon.source: &quot;../images/open_new.svg&quot;
    flat: false
    onClicked: fileDialog.open()
}

CustomButton {
    id: openUrlButton
    icon.source: &quot;../images/link.svg&quot;
    flat: false
    onClicked: urlPopup.open()
}
</db:programlisting>
<db:para>Three buttons are created and centered on this panel, handling play, pause and seeking ten seconds backwards or forwards. The media is played and paused using the methods <db:code>play()</db:code> and <db:code>pause()</db:code>, respectively. To know when to draw a play or pause button, the <db:code>playbackState</db:code> property is queried. For example, when it is equal to the enum value <db:code>MediaPlayer.PlayingState</db:code> then the pause button is drawn.</db:para>
<db:programlisting language="qml">CustomRoundButton {
    id: playButton
    visible: playbackController.mediaPlayer.playbackState !== MediaPlayer.PlayingState
    icon.source: &quot;../images/play_symbol.svg&quot;
    onClicked: playbackController.mediaPlayer.play()
}

CustomRoundButton {
    id: pauseButton
    visible: playbackController.mediaPlayer.playbackState === MediaPlayer.PlayingState
    icon.source: &quot;../images/pause_symbol.svg&quot;
    onClicked: playbackController.mediaPlayer.pause()
}
</db:programlisting>
<db:para>To navigate ten seconds forward or backwards, the <db:code>position</db:code> of the <db:code>MediaPlayer</db:code> type is incremented by 10,000 milliseconds and set using the method <db:code>setPosition()</db:code>.</db:para>
<db:programlisting language="qml">CustomRoundButton {
    id: forward10Button
    icon.source: &quot;../images/forward10.svg&quot;
    onClicked: {
        const pos = Math.min(playbackController.mediaPlayer.duration,
                           playbackController.mediaPlayer.position + 10000)
        playbackController.mediaPlayer.setPosition(pos)
    }
}
</db:programlisting>
</db:section>
<db:section xml:id="playback-seeking-and-audio">
<db:title>Playback Seeking and Audio</db:title>
<db:para>In <db:code>PlaybackControl.qml</db:code>, an <db:code>AudioControl</db:code> and a <db:code>PlaybackSeekControl</db:code> type are instantiated. These are both defined in their own component file and are responsible for volume control and playback seeking, respectively. The <db:code>AudioControl</db:code> type defines a button to mute and a <db:code>Slider</db:code>, from <db:code>QtQuick Controls</db:code>, to set the volume of the player. Both of these attributes are exposed by defining a <db:code>mute</db:code> and <db:code>volume</db:code> property and are accessed from the <db:code>AudioOutput</db:code> definition in <db:code>Main.qml</db:code>.</db:para>
<db:programlisting language="qml">property alias muted: muteButton.checked
property real volume: slider.value
</db:programlisting>
<db:para>The <db:code>PlaybackSeekControl</db:code> uses a <db:code>RowLayout</db:code> containing a <db:code>Slider</db:code> with a <db:code>Text</db:code> item either side. The two <db:code>Text</db:code> items display the current time and the remaining time of the media being played. These are both calculated using two properties of the <db:code>MediaPlayer</db:code> type, <db:code>position</db:code>, which gives the current playback position in milliseconds, and <db:code>duration</db:code>, which gives the duration of the media in milliseconds.</db:para>
<db:programlisting language="qml">Text {
    id: currentTime
    Layout.preferredWidth: 45
    text: seekController.formatToMinutes(seekController.mediaPlayer.position)
    horizontalAlignment: Text.AlignLeft
    font.pixelSize: 11
}
    ...
Text {
    id: remainingTime
    Layout.preferredWidth: 45
    text: seekController.formatToMinutes(seekController.mediaPlayer.duration - seekController.mediaPlayer.position)
    horizontalAlignment: Text.AlignRight
    font.pixelSize: 11
}
</db:programlisting>
<db:para>The <db:code>Slider</db:code> is only enabled when the media player is seekable and not, for example, live media. The <db:code>MediaPlayer</db:code> type has a property for this called <db:code>seekable</db:code>. The <db:code>value</db:code> of the <db:code>Slider</db:code> is calculated using the <db:code>position</db:code> and <db:code>duration</db:code> properties of the <db:code>MediaPlayer</db:code>.</db:para>
<db:programlisting language="qml">enabled: seekController.mediaPlayer.seekable
value: seekController.mediaPlayer.position / seekController.mediaPlayer.duration
</db:programlisting>
</db:section>
<db:section xml:id="metadata-and-track-information">
<db:title>Metadata and Track Information</db:title>
<db:para>The <db:code>PlaybackControl</db:code> type instantiates a <db:code>SettingsPopup</db:code>, which contains information about the metadata of the currently loaded media and track selection, as well as the ability to update the playback rate. This <db:code>Popup</db:code> is defined in <db:code>SettingsPopup.qml</db:code>.</db:para>
<db:mediaobject>
<db:imageobject>
<db:imagedata fileref="images/settings.png"/>
</db:imageobject>
</db:mediaobject>
<db:para>The metadata is contained in its own component file, <db:code>MetadataInfo.qml</db:code>. It contains a <db:code>ListModel</db:code>, a function to clear it, <db:code>clear()</db:code>, and a function to populate it, <db:code>read(MediaMetadata metadata)</db:code>. The <db:code>read(MediaMetadata metadata)</db:code> function takes as a parameter an object of type <db:code>MediaMetaData</db:code>, and navigates its key-value structure to extract its data into the <db:code>model</db:code> of the <db:code>ListView</db:code>. The methods used to do this are <db:code>keys()</db:code>, which returns all the keys of the <db:code>MediaMetaData</db:code>, and {stringValue(Key key)}, which returns the <db:code>value</db:code> for a given <db:code>key</db:code>.</db:para>
<db:programlisting language="qml">function read(metadata) {
    if (!metadata)
        return
    for (const key of metadata.keys())
        if (metadata.stringValue(key))
            listModel.append({
                                name: metadata.metaDataKeyToString(key),
                                value: metadata.stringValue(key)
                            })
}

ListModel {
    id: listModel
}
</db:programlisting>
<db:para>The data is then displayed in <db:code>SettingsPopup.qml</db:code> in a <db:code>ListView</db:code> type. The <db:code>delegate</db:code> of this <db:code>ListView</db:code> is a row of two <db:code>Text</db:code> items, corresponding to the key-value pairs abstracted from the <db:code>MediaMetaData</db:code> item.</db:para>
<db:para>On the other side of the <db:code>Popup</db:code> there is playback rate controls and track selection for audio, video and subtitles. The playback rate is chosen from a <db:code>ComboBox</db:code> and set using the property <db:code>playbackRate</db:code>.</db:para>
<db:programlisting language="qml">settingsController.mediaPlayer.playbackRate = (currentIndex + 1) * 0.25
</db:programlisting>
<db:para>The type called <db:code>TracksInfo</db:code>, defined in <db:code>TracksInfo.qml</db:code>, contains the data about the tracks. More specifically, a <db:code>ListModel</db:code> containing the titles of the tracks, or for subtitles specifically, the langauges. This information is populated in <db:code>Main.qml</db:code> by calling the <db:code>read(MediaMetadata mediaMetadata)</db:code> function defined in the <db:code>TracksInfo</db:code> type.</db:para>
<db:programlisting language="qml">onTracksChanged: {
    audioTracksInfo.read(mediaPlayer.audioTracks)
    videoTracksInfo.read(mediaPlayer.videoTracks)
    subtitleTracksInfo.read(mediaPlayer.subtitleTracks, 6) /* QMediaMetaData::Language = 6 */
    updateMetadata()
    mediaPlayer.play()
}
</db:programlisting>
<db:para>The <db:code>model</db:code> defined in <db:code>TracksInfo</db:code> is then queried in the <db:code>ComboBox</db:code>es in the <db:code>SettingsPopup</db:code> to select the current track.</db:para>
<db:programlisting language="qml">settingsController.mediaPlayer.pause()
tracksInfo.selectedTrack = currentIndex
settingsController.mediaPlayer.play()
</db:programlisting>
</db:section>
<db:section>
<db:title>Example project</db:title>
<db:para><db:link xlink:href="https://code.qt.io/cgit/qt/qtmultimedia.git/tree/examples/multimedia/video/mediaplayer?h=6.7">Example project @ code.qt.io</db:link></db:para>
</db:section>
</db:article>
