<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en">
<db:info>
<db:title>QMetaType Class</db:title>
<db:productname>QtCore</db:productname>
<db:edition>Qt 5.12.12 Reference Documentation</db:edition>
<db:titleabbrev>Qt Core Reference Documentation</db:titleabbrev>
<db:abstract>
<db:para>The <db:link xlink:href="qmetatype.xml">QMetaType</db:link> class manages named types in the meta-object system.</db:para>
<db:note>
<db:para>All functions in this class are <db:link xlink:href="threads-reentrancy.xml">thread-safe</db:link>.</db:para>
</db:note>
</db:abstract>
<db:pubdate>2024-12-27</db:pubdate>
<db:date>2024-12-27</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:variablelist>
<db:varlistentry>
<db:term>Header</db:term>
<db:listitem>
<db:para>QMetaType</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>qmake</db:term>
<db:listitem>
<db:para>QT += core</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Group</db:term>
<db:listitem>
<db:para>QMetaType is part of <db:simplelist><db:member>objectmodel</db:member></db:simplelist></db:para>
</db:listitem>
</db:varlistentry>
</db:variablelist>
<db:section xml:id="details">
<db:title>Detailed Description</db:title>
<db:para>The class is used as a helper to marshall types in <db:link xlink:href="qmetatype.xml#Type-enum">QVariant</db:link> and in queued signals and slots connections. It associates a type name to a type so that it can be created and destructed dynamically at run-time. Declare new types with <db:link xlink:href="qmetatype.xml#Q_DECLARE_METATYPE">Q_DECLARE_METATYPE</db:link>() to make them available to <db:link xlink:href="qmetatype.xml#Type-enum">QVariant</db:link> and other template-based functions. Call <db:link xlink:href="qmetatype.xml#qRegisterMetaType-1">qRegisterMetaType</db:link>() to make types available to non-template based functions, such as the queued signal and slot connections.</db:para>
<db:para>Any class or struct that has a public default constructor, a public copy constructor, and a public destructor can be registered.</db:para>
<db:para>The following code allocates and destructs an instance of MyClass:</db:para>
<db:programlisting language="cpp">int id = QMetaType::type(&quot;MyClass&quot;);
if (id != QMetaType::UnknownType) {
    void *myClassPtr = QMetaType::create(id);
    ...
    QMetaType::destroy(id, myClassPtr);
    myClassPtr = 0;
}
</db:programlisting>
<db:para>If we want the stream operators operator&lt;&lt;() and operator&gt;&gt;() to work on <db:link xlink:href="qmetatype.xml#Type-enum">QVariant</db:link> objects that store custom types, the custom type must provide operator&lt;&lt;() and operator&gt;&gt;() operators.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qmetatype.xml#Q_DECLARE_METATYPE">Q_DECLARE_METATYPE</db:link>()</db:member>
<db:member><db:link xlink:href="qvariant.xml#setValue">QVariant::setValue</db:link>()</db:member>
<db:member><db:link xlink:href="qvariant.xml#value">QVariant::value</db:link>()</db:member>
<db:member><db:link xlink:href="qvariant.xml#fromValue">QVariant::fromValue</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="member-type-documentation">
<db:title>Member Type Documentation</db:title>
<db:section xml:id="Type-enum">
<db:title>enum QMetaType::Type</db:title>
<db:enumsynopsis>
<db:enumname>Type</db:enumname>
<db:enumitem>
<db:enumidentifier>UnknownType</db:enumidentifier>
<db:enumvalue>0</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>Bool</db:enumidentifier>
<db:enumvalue>1</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>Int</db:enumidentifier>
<db:enumvalue>2</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>UInt</db:enumidentifier>
<db:enumvalue>3</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>LongLong</db:enumidentifier>
<db:enumvalue>4</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>ULongLong</db:enumidentifier>
<db:enumvalue>5</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>Double</db:enumidentifier>
<db:enumvalue>6</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>Long</db:enumidentifier>
<db:enumvalue>32</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>Short</db:enumidentifier>
<db:enumvalue>33</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>Char</db:enumidentifier>
<db:enumvalue>34</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>ULong</db:enumidentifier>
<db:enumvalue>35</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>UShort</db:enumidentifier>
<db:enumvalue>36</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>UChar</db:enumidentifier>
<db:enumvalue>37</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>Float</db:enumidentifier>
<db:enumvalue>38</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>VoidStar</db:enumidentifier>
<db:enumvalue>31</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>QChar</db:enumidentifier>
<db:enumvalue>7</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>QString</db:enumidentifier>
<db:enumvalue>10</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>QStringList</db:enumidentifier>
<db:enumvalue>11</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>QByteArray</db:enumidentifier>
<db:enumvalue>12</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>QBitArray</db:enumidentifier>
<db:enumvalue>13</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>QDate</db:enumidentifier>
<db:enumvalue>14</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>QTime</db:enumidentifier>
<db:enumvalue>15</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>QDateTime</db:enumidentifier>
<db:enumvalue>16</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>QUrl</db:enumidentifier>
<db:enumvalue>17</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>QLocale</db:enumidentifier>
<db:enumvalue>18</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>QRect</db:enumidentifier>
<db:enumvalue>19</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>QRectF</db:enumidentifier>
<db:enumvalue>20</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>QSize</db:enumidentifier>
<db:enumvalue>21</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>QSizeF</db:enumidentifier>
<db:enumvalue>22</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>QLine</db:enumidentifier>
<db:enumvalue>23</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>QLineF</db:enumidentifier>
<db:enumvalue>24</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>QPoint</db:enumidentifier>
<db:enumvalue>25</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>QPointF</db:enumidentifier>
<db:enumvalue>26</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>QRegExp</db:enumidentifier>
<db:enumvalue>27</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>QEasingCurve</db:enumidentifier>
<db:enumvalue>29</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>QUuid</db:enumidentifier>
<db:enumvalue>30</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>QVariant</db:enumidentifier>
<db:enumvalue>41</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>QModelIndex</db:enumidentifier>
<db:enumvalue>42</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>QPersistentModelIndex</db:enumidentifier>
<db:enumvalue>50</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>QRegularExpression</db:enumidentifier>
<db:enumvalue>44</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>QJsonValue</db:enumidentifier>
<db:enumvalue>45</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>QJsonObject</db:enumidentifier>
<db:enumvalue>46</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>QJsonArray</db:enumidentifier>
<db:enumvalue>47</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>QJsonDocument</db:enumidentifier>
<db:enumvalue>48</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>QByteArrayList</db:enumidentifier>
<db:enumvalue>49</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>QObjectStar</db:enumidentifier>
<db:enumvalue>39</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>SChar</db:enumidentifier>
<db:enumvalue>40</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>Void</db:enumidentifier>
<db:enumvalue>43</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>Nullptr</db:enumidentifier>
<db:enumvalue>51</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>QVariantMap</db:enumidentifier>
<db:enumvalue>8</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>QVariantList</db:enumidentifier>
<db:enumvalue>9</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>QVariantHash</db:enumidentifier>
<db:enumvalue>28</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>QCborSimpleType</db:enumidentifier>
<db:enumvalue>52</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>QCborValue</db:enumidentifier>
<db:enumvalue>53</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>QCborArray</db:enumidentifier>
<db:enumvalue>54</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>QCborMap</db:enumidentifier>
<db:enumvalue>55</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>QFont</db:enumidentifier>
<db:enumvalue>64</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>QPixmap</db:enumidentifier>
<db:enumvalue>65</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>QBrush</db:enumidentifier>
<db:enumvalue>66</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>QColor</db:enumidentifier>
<db:enumvalue>67</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>QPalette</db:enumidentifier>
<db:enumvalue>68</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>QIcon</db:enumidentifier>
<db:enumvalue>69</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>QImage</db:enumidentifier>
<db:enumvalue>70</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>QPolygon</db:enumidentifier>
<db:enumvalue>71</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>QRegion</db:enumidentifier>
<db:enumvalue>72</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>QBitmap</db:enumidentifier>
<db:enumvalue>73</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>QCursor</db:enumidentifier>
<db:enumvalue>74</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>QKeySequence</db:enumidentifier>
<db:enumvalue>75</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>QPen</db:enumidentifier>
<db:enumvalue>76</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>QTextLength</db:enumidentifier>
<db:enumvalue>77</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>QTextFormat</db:enumidentifier>
<db:enumvalue>78</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>QMatrix</db:enumidentifier>
<db:enumvalue>79</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>QTransform</db:enumidentifier>
<db:enumvalue>80</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>QMatrix4x4</db:enumidentifier>
<db:enumvalue>81</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>QVector2D</db:enumidentifier>
<db:enumvalue>82</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>QVector3D</db:enumidentifier>
<db:enumvalue>83</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>QVector4D</db:enumidentifier>
<db:enumvalue>84</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>QQuaternion</db:enumidentifier>
<db:enumvalue>85</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>QPolygonF</db:enumidentifier>
<db:enumvalue>86</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>QSizePolicy</db:enumidentifier>
<db:enumvalue>121</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>LastCoreType</db:enumidentifier>
<db:enumvalue>QCborMap</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>LastGuiType</db:enumidentifier>
<db:enumvalue>QPolygonF</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>User</db:enumidentifier>
<db:enumvalue>1024</db:enumvalue>
</db:enumitem>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:enumsynopsis>
<db:para>These are the built-in types supported by <db:link xlink:href="qmetatype.xml">QMetaType</db:link>:</db:para>
<db:informaltable>
<db:thead>
<db:tr>
<db:th>Constant</db:th>
<db:th>Value</db:th>
<db:th>Description</db:th>
</db:tr>
</db:thead>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::Void</db:code></db:para>
</db:td>
<db:td><db:code>43</db:code></db:td>
<db:td>
<db:para>void</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::Bool</db:code></db:para>
</db:td>
<db:td><db:code>1</db:code></db:td>
<db:td>
<db:para>bool</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::Int</db:code></db:para>
</db:td>
<db:td><db:code>2</db:code></db:td>
<db:td>
<db:para>int</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::UInt</db:code></db:para>
</db:td>
<db:td><db:code>3</db:code></db:td>
<db:td>
<db:para>unsigned int</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::Double</db:code></db:para>
</db:td>
<db:td><db:code>6</db:code></db:td>
<db:td>
<db:para>double</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::QChar</db:code></db:para>
</db:td>
<db:td><db:code>7</db:code></db:td>
<db:td>
<db:para>QChar</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::QString</db:code></db:para>
</db:td>
<db:td><db:code>10</db:code></db:td>
<db:td>
<db:para>QString</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::QByteArray</db:code></db:para>
</db:td>
<db:td><db:code>12</db:code></db:td>
<db:td>
<db:para>QByteArray</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::Nullptr</db:code></db:para>
</db:td>
<db:td><db:code>51</db:code></db:td>
<db:td>
<db:para>std::nullptr_t</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::VoidStar</db:code></db:para>
</db:td>
<db:td><db:code>31</db:code></db:td>
<db:td>
<db:para>void *</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::Long</db:code></db:para>
</db:td>
<db:td><db:code>32</db:code></db:td>
<db:td>
<db:para>long</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::LongLong</db:code></db:para>
</db:td>
<db:td><db:code>4</db:code></db:td>
<db:td>
<db:para>LongLong</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::Short</db:code></db:para>
</db:td>
<db:td><db:code>33</db:code></db:td>
<db:td>
<db:para>short</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::Char</db:code></db:para>
</db:td>
<db:td><db:code>34</db:code></db:td>
<db:td>
<db:para>char</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::ULong</db:code></db:para>
</db:td>
<db:td><db:code>35</db:code></db:td>
<db:td>
<db:para>unsigned long</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::ULongLong</db:code></db:para>
</db:td>
<db:td><db:code>5</db:code></db:td>
<db:td>
<db:para>ULongLong</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::UShort</db:code></db:para>
</db:td>
<db:td><db:code>36</db:code></db:td>
<db:td>
<db:para>unsigned short</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::SChar</db:code></db:para>
</db:td>
<db:td><db:code>40</db:code></db:td>
<db:td>
<db:para>signed char</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::UChar</db:code></db:para>
</db:td>
<db:td><db:code>37</db:code></db:td>
<db:td>
<db:para>unsigned char</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::Float</db:code></db:para>
</db:td>
<db:td><db:code>38</db:code></db:td>
<db:td>
<db:para>float</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::QObjectStar</db:code></db:para>
</db:td>
<db:td><db:code>39</db:code></db:td>
<db:td>
<db:para><db:link xlink:href="qobject.xml">QObject</db:link> *</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::QVariant</db:code></db:para>
</db:td>
<db:td><db:code>41</db:code></db:td>
<db:td>
<db:para>QVariant</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::QCursor</db:code></db:para>
</db:td>
<db:td><db:code>74</db:code></db:td>
<db:td>
<db:para>QCursor</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::QDate</db:code></db:para>
</db:td>
<db:td><db:code>14</db:code></db:td>
<db:td>
<db:para>QDate</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::QSize</db:code></db:para>
</db:td>
<db:td><db:code>21</db:code></db:td>
<db:td>
<db:para>QSize</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::QTime</db:code></db:para>
</db:td>
<db:td><db:code>15</db:code></db:td>
<db:td>
<db:para>QTime</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::QVariantList</db:code></db:para>
</db:td>
<db:td><db:code>9</db:code></db:td>
<db:td>
<db:para>QVariantList</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::QPolygon</db:code></db:para>
</db:td>
<db:td><db:code>71</db:code></db:td>
<db:td>
<db:para>QPolygon</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::QPolygonF</db:code></db:para>
</db:td>
<db:td><db:code>86</db:code></db:td>
<db:td>
<db:para>QPolygonF</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::QColor</db:code></db:para>
</db:td>
<db:td><db:code>67</db:code></db:td>
<db:td>
<db:para>QColor</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::QSizeF</db:code></db:para>
</db:td>
<db:td><db:code>22</db:code></db:td>
<db:td>
<db:para>QSizeF</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::QRectF</db:code></db:para>
</db:td>
<db:td><db:code>20</db:code></db:td>
<db:td>
<db:para>QRectF</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::QLine</db:code></db:para>
</db:td>
<db:td><db:code>23</db:code></db:td>
<db:td>
<db:para>QLine</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::QTextLength</db:code></db:para>
</db:td>
<db:td><db:code>77</db:code></db:td>
<db:td>
<db:para>QTextLength</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::QStringList</db:code></db:para>
</db:td>
<db:td><db:code>11</db:code></db:td>
<db:td>
<db:para>QStringList</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::QVariantMap</db:code></db:para>
</db:td>
<db:td><db:code>8</db:code></db:td>
<db:td>
<db:para>QVariantMap</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::QVariantHash</db:code></db:para>
</db:td>
<db:td><db:code>28</db:code></db:td>
<db:td>
<db:para>QVariantHash</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::QIcon</db:code></db:para>
</db:td>
<db:td><db:code>69</db:code></db:td>
<db:td>
<db:para>QIcon</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::QPen</db:code></db:para>
</db:td>
<db:td><db:code>76</db:code></db:td>
<db:td>
<db:para>QPen</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::QLineF</db:code></db:para>
</db:td>
<db:td><db:code>24</db:code></db:td>
<db:td>
<db:para>QLineF</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::QTextFormat</db:code></db:para>
</db:td>
<db:td><db:code>78</db:code></db:td>
<db:td>
<db:para>QTextFormat</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::QRect</db:code></db:para>
</db:td>
<db:td><db:code>19</db:code></db:td>
<db:td>
<db:para>QRect</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::QPoint</db:code></db:para>
</db:td>
<db:td><db:code>25</db:code></db:td>
<db:td>
<db:para>QPoint</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::QUrl</db:code></db:para>
</db:td>
<db:td><db:code>17</db:code></db:td>
<db:td>
<db:para>QUrl</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::QRegExp</db:code></db:para>
</db:td>
<db:td><db:code>27</db:code></db:td>
<db:td>
<db:para>QRegExp</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::QRegularExpression</db:code></db:para>
</db:td>
<db:td><db:code>44</db:code></db:td>
<db:td>
<db:para>QRegularExpression</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::QDateTime</db:code></db:para>
</db:td>
<db:td><db:code>16</db:code></db:td>
<db:td>
<db:para>QDateTime</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::QPointF</db:code></db:para>
</db:td>
<db:td><db:code>26</db:code></db:td>
<db:td>
<db:para>QPointF</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::QPalette</db:code></db:para>
</db:td>
<db:td><db:code>68</db:code></db:td>
<db:td>
<db:para>QPalette</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::QFont</db:code></db:para>
</db:td>
<db:td><db:code>64</db:code></db:td>
<db:td>
<db:para>QFont</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::QBrush</db:code></db:para>
</db:td>
<db:td><db:code>66</db:code></db:td>
<db:td>
<db:para>QBrush</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::QRegion</db:code></db:para>
</db:td>
<db:td><db:code>72</db:code></db:td>
<db:td>
<db:para>QRegion</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::QBitArray</db:code></db:para>
</db:td>
<db:td><db:code>13</db:code></db:td>
<db:td>
<db:para>QBitArray</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::QImage</db:code></db:para>
</db:td>
<db:td><db:code>70</db:code></db:td>
<db:td>
<db:para>QImage</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::QKeySequence</db:code></db:para>
</db:td>
<db:td><db:code>75</db:code></db:td>
<db:td>
<db:para>QKeySequence</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::QSizePolicy</db:code></db:para>
</db:td>
<db:td><db:code>121</db:code></db:td>
<db:td>
<db:para>QSizePolicy</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::QPixmap</db:code></db:para>
</db:td>
<db:td><db:code>65</db:code></db:td>
<db:td>
<db:para>QPixmap</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::QLocale</db:code></db:para>
</db:td>
<db:td><db:code>18</db:code></db:td>
<db:td>
<db:para>QLocale</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::QBitmap</db:code></db:para>
</db:td>
<db:td><db:code>73</db:code></db:td>
<db:td>
<db:para>QBitmap</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::QMatrix</db:code></db:para>
</db:td>
<db:td><db:code>79</db:code></db:td>
<db:td>
<db:para>QMatrix</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::QTransform</db:code></db:para>
</db:td>
<db:td><db:code>80</db:code></db:td>
<db:td>
<db:para>QTransform</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::QMatrix4x4</db:code></db:para>
</db:td>
<db:td><db:code>81</db:code></db:td>
<db:td>
<db:para>QMatrix4x4</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::QVector2D</db:code></db:para>
</db:td>
<db:td><db:code>82</db:code></db:td>
<db:td>
<db:para>QVector2D</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::QVector3D</db:code></db:para>
</db:td>
<db:td><db:code>83</db:code></db:td>
<db:td>
<db:para>QVector3D</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::QVector4D</db:code></db:para>
</db:td>
<db:td><db:code>84</db:code></db:td>
<db:td>
<db:para>QVector4D</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::QQuaternion</db:code></db:para>
</db:td>
<db:td><db:code>85</db:code></db:td>
<db:td>
<db:para>QQuaternion</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::QEasingCurve</db:code></db:para>
</db:td>
<db:td><db:code>29</db:code></db:td>
<db:td>
<db:para>QEasingCurve</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::QJsonValue</db:code></db:para>
</db:td>
<db:td><db:code>45</db:code></db:td>
<db:td>
<db:para>QJsonValue</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::QJsonObject</db:code></db:para>
</db:td>
<db:td><db:code>46</db:code></db:td>
<db:td>
<db:para>QJsonObject</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::QJsonArray</db:code></db:para>
</db:td>
<db:td><db:code>47</db:code></db:td>
<db:td>
<db:para>QJsonArray</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::QJsonDocument</db:code></db:para>
</db:td>
<db:td><db:code>48</db:code></db:td>
<db:td>
<db:para>QJsonDocument</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::QModelIndex</db:code></db:para>
</db:td>
<db:td><db:code>42</db:code></db:td>
<db:td>
<db:para>QModelIndex</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::QPersistentModelIndex</db:code></db:para>
</db:td>
<db:td><db:code>50</db:code></db:td>
<db:td>
<db:para>QPersistentModelIndex (since 5.5)</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::QUuid</db:code></db:para>
</db:td>
<db:td><db:code>30</db:code></db:td>
<db:td>
<db:para>QUuid</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::QByteArrayList</db:code></db:para>
</db:td>
<db:td><db:code>49</db:code></db:td>
<db:td>
<db:para>QByteArrayList</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::User</db:code></db:para>
</db:td>
<db:td><db:code>1024</db:code></db:td>
<db:td>
<db:para>Base value for user types</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::UnknownType</db:code></db:para>
</db:td>
<db:td><db:code>0</db:code></db:td>
<db:td>
<db:para>This is an invalid type id. It is returned from <db:link xlink:href="qmetatype.xml">QMetaType</db:link> for types that are not registered</db:para>
</db:td>
</db:tr>
</db:informaltable>
<db:para>Additional types can be registered using <db:link xlink:href="qmetatype.xml#Q_DECLARE_METATYPE">Q_DECLARE_METATYPE</db:link>().</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qmetatype.xml#type">type</db:link>()</db:member>
<db:member><db:link xlink:href="qmetatype.xml#typeName">typeName</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="TypeFlag-enum">
<db:title>enum QMetaType::TypeFlag</db:title>
<db:bridgehead renderas="sect2">flags QMetaType::TypeFlags</db:bridgehead>
<db:enumsynopsis>
<db:enumname>TypeFlag</db:enumname>
<db:enumitem>
<db:enumidentifier>NeedsConstruction</db:enumidentifier>
<db:enumvalue>0x1</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>NeedsDestruction</db:enumidentifier>
<db:enumvalue>0x2</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>MovableType</db:enumidentifier>
<db:enumvalue>0x4</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>PointerToQObject</db:enumidentifier>
<db:enumvalue>0x8</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>IsEnumeration</db:enumidentifier>
<db:enumvalue>0x10</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>SharedPointerToQObject</db:enumidentifier>
<db:enumvalue>0x20</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>WeakPointerToQObject</db:enumidentifier>
<db:enumvalue>0x40</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>TrackingPointerToQObject</db:enumidentifier>
<db:enumvalue>0x80</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>WasDeclaredAsMetaType</db:enumidentifier>
<db:enumvalue>0x100</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>IsGadget</db:enumidentifier>
<db:enumvalue>0x200</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>PointerToGadget</db:enumidentifier>
<db:enumvalue>0x400</db:enumvalue>
</db:enumitem>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:enumsynopsis>
<db:typedefsynopsis>
<db:typedefname>QMetaType::TypeFlags</db:typedefname>
</db:typedefsynopsis>
<db:para>The enum describes attributes of a type supported by <db:link xlink:href="qmetatype.xml">QMetaType</db:link>.</db:para>
<db:informaltable>
<db:thead>
<db:tr>
<db:th>Constant</db:th>
<db:th>Value</db:th>
<db:th>Description</db:th>
</db:tr>
</db:thead>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::NeedsConstruction</db:code></db:para>
</db:td>
<db:td><db:code>0x1</db:code></db:td>
<db:td>
<db:para>This type has non-trivial constructors. If the flag is not set instances can be safely initialized with memset to 0.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::NeedsDestruction</db:code></db:para>
</db:td>
<db:td><db:code>0x2</db:code></db:td>
<db:td>
<db:para>This type has a non-trivial destructor. If the flag is not set calls to the destructor are not necessary before discarding objects.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::MovableType</db:code></db:para>
</db:td>
<db:td><db:code>0x4</db:code></db:td>
<db:td>
<db:para>An instance of a type having this attribute can be safely moved by memcpy.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::IsEnumeration</db:code></db:para>
</db:td>
<db:td><db:code>0x10</db:code></db:td>
<db:td>
<db:para>This type is an enumeration</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::PointerToQObject</db:code></db:para>
</db:td>
<db:td><db:code>0x8</db:code></db:td>
<db:td>
<db:para>This type is a pointer to a derived of <db:link xlink:href="qobject.xml">QObject</db:link></db:para>
</db:td>
</db:tr>
</db:informaltable>
<db:para>The <db:code>TypeFlags</db:code> type is a typedef for <db:code><db:link xlink:href="qflags.xml">QFlags</db:link>&lt;TypeFlag&gt;. </db:code>It stores an OR combination of <db:code>TypeFlag</db:code> values.</db:para>
</db:section>
</db:section>
<db:section xml:id="member-function-documentation">
<db:title>Member Function Documentation</db:title>
<db:section xml:id="QMetaType">
<db:title>[explicit, since 5.0] QMetaType::QMetaType(const int <db:emphasis>typeId</db:emphasis>)</db:title>
<db:constructorsynopsis>
<db:methodname>QMetaType</db:methodname>
<db:methodparam>
<db:type>const int</db:type>
<db:parameter>typeId</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">constructor</db:synopsisinfo>
<db:synopsisinfo role="signature">QMetaType(const int typeId)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:constructorsynopsis>
<db:para>Constructs a <db:link xlink:href="qmetatype.xml">QMetaType</db:link> object that contains all information about type <db:code role="parameter">typeId</db:code>.</db:para>
<db:para>This function was introduced in Qt 5.0.</db:para>
</db:section>
<db:section xml:id="dtor.QMetaType">
<db:title>QMetaType::~QMetaType()</db:title>
<db:destructorsynopsis>
<db:methodname>~QMetaType</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">destructor</db:synopsisinfo>
<db:synopsisinfo role="signature">~QMetaType()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:destructorsynopsis>
<db:para>Destructs this object.</db:para>
</db:section>
<db:section xml:id="compare">
<db:title>[static, since 5.2] bool QMetaType::compare(const void *<db:emphasis>lhs</db:emphasis>, const void *<db:emphasis>rhs</db:emphasis>, int <db:emphasis>typeId</db:emphasis>, int *<db:emphasis>result</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:modifier>static</db:modifier>
<db:type>bool</db:type>
<db:methodname>compare</db:methodname>
<db:methodparam>
<db:type>const void *</db:type>
<db:parameter>lhs</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const void *</db:type>
<db:parameter>rhs</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>typeId</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>int *</db:type>
<db:parameter>result</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool compare(const void *lhs, const void *rhs, int typeId, int *result)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Compares the objects at <db:code role="parameter">lhs</db:code> and <db:code role="parameter">rhs</db:code>. Both objects need to be of type <db:code role="parameter">typeId</db:code>. <db:code role="parameter">result</db:code> is set to less than, equal to or greater than zero, if <db:code role="parameter">lhs</db:code> is less than, equal to or greater than <db:code role="parameter">rhs</db:code>. Returns true, if the comparison succeeded, otherwise false.</db:para>
<db:para>This function was introduced in Qt 5.2.</db:para>
</db:section>
<db:section xml:id="construct">
<db:title>[static, since 5.0] void *QMetaType::construct(int <db:emphasis>type</db:emphasis>, void *<db:emphasis>where</db:emphasis>, const void *<db:emphasis>copy</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:modifier>static</db:modifier>
<db:type>void *</db:type>
<db:methodname>construct</db:methodname>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>type</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>void *</db:type>
<db:parameter>where</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const void *</db:type>
<db:parameter>copy</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void * construct(int type, void *where, const void *copy)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Constructs a value of the given <db:code role="parameter">type</db:code> in the existing memory addressed by <db:code role="parameter">where</db:code>, that is a copy of <db:code role="parameter">copy</db:code>, and returns <db:code role="parameter">where</db:code>. If <db:code role="parameter">copy</db:code> is zero, the value is default constructed.</db:para>
<db:para>This is a low-level function for explicitly managing the memory used to store the type. Consider calling <db:link xlink:href="qmetatype.xml#create">create</db:link>() if you don't need this level of control (that is, use &quot;new&quot; rather than &quot;placement new&quot;).</db:para>
<db:para>You must ensure that <db:code role="parameter">where</db:code> points to a location that can store a value of type <db:code role="parameter">type</db:code>, and that <db:code role="parameter">where</db:code> is suitably aligned. The type's size can be queried by calling <db:link xlink:href="qmetatype.xml#sizeOf-1">sizeOf</db:link>().</db:para>
<db:para>The rule of thumb for alignment is that a type is aligned to its natural boundary, which is the smallest power of 2 that is bigger than the type, unless that alignment is larger than the maximum useful alignment for the platform. For practical purposes, alignment larger than 2 * sizeof(void*) is only necessary for special hardware instructions (e.g., aligned SSE loads and stores on x86).</db:para>
<db:para>This function was introduced in Qt 5.0.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qmetatype.xml#destruct">destruct</db:link>()</db:member>
<db:member><db:link xlink:href="qmetatype.xml#sizeOf-1">sizeOf</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="construct-1">
<db:title>[since 5.0] void *QMetaType::construct(void *<db:emphasis>where</db:emphasis>, const void *<db:emphasis>copy</db:emphasis> = 0) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>void *</db:type>
<db:methodname>construct</db:methodname>
<db:methodparam>
<db:type>void *</db:type>
<db:parameter>where</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const void *</db:type>
<db:parameter>copy</db:parameter>
<db:initializer>0</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">void * construct(void *where, const void *copy) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Constructs a value of the type that this <db:link xlink:href="qmetatype.xml">QMetaType</db:link> instance was constructed for in the existing memory addressed by <db:code role="parameter">where</db:code>, that is a copy of <db:code role="parameter">copy</db:code>, and returns <db:code role="parameter">where</db:code>. If <db:code role="parameter">copy</db:code> is zero, the value is default constructed.</db:para>
<db:para>This is a low-level function for explicitly managing the memory used to store the type. Consider calling <db:link xlink:href="qmetatype.xml#create">create</db:link>() if you don't need this level of control (that is, use &quot;new&quot; rather than &quot;placement new&quot;).</db:para>
<db:para>You must ensure that <db:code role="parameter">where</db:code> points to a location where the new value can be stored and that <db:code role="parameter">where</db:code> is suitably aligned. The type's size can be queried by calling <db:link xlink:href="qmetatype.xml#sizeOf-1">sizeOf</db:link>().</db:para>
<db:para>The rule of thumb for alignment is that a type is aligned to its natural boundary, which is the smallest power of 2 that is bigger than the type, unless that alignment is larger than the maximum useful alignment for the platform. For practical purposes, alignment larger than 2 * sizeof(void*) is only necessary for special hardware instructions (e.g., aligned SSE loads and stores on x86).</db:para>
<db:para>This function was introduced in Qt 5.0.</db:para>
</db:section>
<db:section xml:id="convert">
<db:title>[static, since 5.2] bool QMetaType::convert(const void *<db:emphasis>from</db:emphasis>, int <db:emphasis>fromTypeId</db:emphasis>, void *<db:emphasis>to</db:emphasis>, int <db:emphasis>toTypeId</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:modifier>static</db:modifier>
<db:type>bool</db:type>
<db:methodname>convert</db:methodname>
<db:methodparam>
<db:type>const void *</db:type>
<db:parameter>from</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>fromTypeId</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>void *</db:type>
<db:parameter>to</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>toTypeId</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool convert(const void *from, int fromTypeId, void *to, int toTypeId)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Converts the object at <db:code role="parameter">from</db:code> from <db:code role="parameter">fromTypeId</db:code> to the preallocated space at <db:code role="parameter">to</db:code> typed <db:code role="parameter">toTypeId</db:code>. Returns true, if the conversion succeeded, otherwise false.</db:para>
<db:para>This function was introduced in Qt 5.2.</db:para>
</db:section>
<db:section xml:id="create">
<db:title>[static] void *QMetaType::create(int <db:emphasis>type</db:emphasis>, const void *<db:emphasis>copy</db:emphasis> = nullptr)</db:title>
<db:methodsynopsis>
<db:modifier>static</db:modifier>
<db:type>void *</db:type>
<db:methodname>create</db:methodname>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>type</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const void *</db:type>
<db:parameter>copy</db:parameter>
<db:initializer>nullptr</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void * create(int type, const void *copy)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns a copy of <db:code role="parameter">copy</db:code>, assuming it is of type <db:code role="parameter">type</db:code>. If <db:code role="parameter">copy</db:code> is zero, creates a default constructed instance.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qmetatype.xml#destroy">destroy</db:link>()</db:member>
<db:member><db:link xlink:href="qmetatype.xml#isRegistered-1">isRegistered</db:link>()</db:member>
<db:member><db:link xlink:href="qmetatype.xml#Type-enum">Type</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="create-1">
<db:title>[since 5.0] void *QMetaType::create(const void *<db:emphasis>copy</db:emphasis> = 0) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>void *</db:type>
<db:methodname>create</db:methodname>
<db:methodparam>
<db:type>const void *</db:type>
<db:parameter>copy</db:parameter>
<db:initializer>0</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">void * create(const void *copy) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns a copy of <db:code role="parameter">copy</db:code>, assuming it is of the type that this <db:link xlink:href="qmetatype.xml">QMetaType</db:link> instance was created for. If <db:code role="parameter">copy</db:code> is null, creates a default constructed instance.</db:para>
<db:para>This function was introduced in Qt 5.0.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qmetatype.xml#destroy">QMetaType::destroy</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="debugStream">
<db:title>[static, since 5.2] bool QMetaType::debugStream(QDebug &amp;<db:emphasis>dbg</db:emphasis>, const void *<db:emphasis>rhs</db:emphasis>, int <db:emphasis>typeId</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:modifier>static</db:modifier>
<db:type>bool</db:type>
<db:methodname>debugStream</db:methodname>
<db:methodparam>
<db:type>QDebug &amp;</db:type>
<db:parameter>dbg</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const void *</db:type>
<db:parameter>rhs</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>typeId</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool debugStream(QDebug &amp;dbg, const void *rhs, int typeId)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Streams the object at <db:code role="parameter">rhs</db:code> of type <db:code role="parameter">typeId</db:code> to the debug stream <db:code role="parameter">dbg</db:code>. Returns true on success, otherwise false.</db:para>
<db:para>This function was introduced in Qt 5.2.</db:para>
</db:section>
<db:section xml:id="destroy">
<db:title>[static] void QMetaType::destroy(int <db:emphasis>type</db:emphasis>, void *<db:emphasis>data</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:modifier>static</db:modifier>
<db:void/>
<db:methodname>destroy</db:methodname>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>type</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>void *</db:type>
<db:parameter>data</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void destroy(int type, void *data)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Destroys the <db:code role="parameter">data</db:code>, assuming it is of the <db:code role="parameter">type</db:code> given.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qmetatype.xml#create">create</db:link>()</db:member>
<db:member><db:link xlink:href="qmetatype.xml#isRegistered-1">isRegistered</db:link>()</db:member>
<db:member><db:link xlink:href="qmetatype.xml#Type-enum">Type</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="destroy-1">
<db:title>[since 5.0] void QMetaType::destroy(void *<db:emphasis>data</db:emphasis>) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:void/>
<db:methodname>destroy</db:methodname>
<db:methodparam>
<db:type>void *</db:type>
<db:parameter>data</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">void destroy(void *data) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Destroys the <db:code role="parameter">data</db:code>, assuming it is of the type that this <db:link xlink:href="qmetatype.xml">QMetaType</db:link> instance was created for.</db:para>
<db:para>This function was introduced in Qt 5.0.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qmetatype.xml#create">QMetaType::create</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="destruct">
<db:title>[static, since 5.0] void QMetaType::destruct(int <db:emphasis>type</db:emphasis>, void *<db:emphasis>where</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:modifier>static</db:modifier>
<db:void/>
<db:methodname>destruct</db:methodname>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>type</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>void *</db:type>
<db:parameter>where</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void destruct(int type, void *where)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Destructs the value of the given <db:code role="parameter">type</db:code>, located at <db:code role="parameter">where</db:code>.</db:para>
<db:para>Unlike <db:link xlink:href="qmetatype.xml#destroy">destroy</db:link>(), this function only invokes the type's destructor, it doesn't invoke the delete operator.</db:para>
<db:para>This function was introduced in Qt 5.0.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qmetatype.xml#construct">construct</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="destruct-1">
<db:title>[since 5.0] void QMetaType::destruct(void *<db:emphasis>data</db:emphasis>) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:void/>
<db:methodname>destruct</db:methodname>
<db:methodparam>
<db:type>void *</db:type>
<db:parameter>data</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">void destruct(void *data) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Destructs the value, located at <db:code role="parameter">data</db:code>, assuming that it is of the type for which this <db:link xlink:href="qmetatype.xml">QMetaType</db:link> instance was constructed for.</db:para>
<db:para>Unlike <db:link xlink:href="qmetatype.xml#destroy">destroy</db:link>(), this function only invokes the type's destructor, it doesn't invoke the delete operator.</db:para>
<db:para>This function was introduced in Qt 5.0.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qmetatype.xml#construct">QMetaType::construct</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="equals">
<db:title>[static, since 5.5] bool QMetaType::equals(const void *<db:emphasis>lhs</db:emphasis>, const void *<db:emphasis>rhs</db:emphasis>, int <db:emphasis>typeId</db:emphasis>, int *<db:emphasis>result</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:modifier>static</db:modifier>
<db:type>bool</db:type>
<db:methodname>equals</db:methodname>
<db:methodparam>
<db:type>const void *</db:type>
<db:parameter>lhs</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const void *</db:type>
<db:parameter>rhs</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>typeId</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>int *</db:type>
<db:parameter>result</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool equals(const void *lhs, const void *rhs, int typeId, int *result)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Compares the objects at <db:code role="parameter">lhs</db:code> and <db:code role="parameter">rhs</db:code>. Both objects need to be of type <db:code role="parameter">typeId</db:code>. <db:code role="parameter">result</db:code> is set to zero, if <db:code role="parameter">lhs</db:code> equals to rhs. Returns true, if the comparison succeeded, otherwise false.</db:para>
<db:para>This function was introduced in Qt 5.5.</db:para>
</db:section>
<db:section xml:id="flags">
<db:title>[since 5.0] QMetaType::TypeFlags QMetaType::flags() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QMetaType::TypeFlags</db:type>
<db:methodname>flags</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QMetaType::TypeFlags flags() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns flags of the type for which this <db:link xlink:href="qmetatype.xml">QMetaType</db:link> instance was constructed.</db:para>
<db:para>This function was introduced in Qt 5.0.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qmetatype.xml#TypeFlag-enum">QMetaType::TypeFlags</db:link></db:member>
<db:member><db:link xlink:href="qmetatype.xml#typeFlags">QMetaType::typeFlags</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="hasRegisteredComparators">
<db:title>[static, since 5.2] bool QMetaType::hasRegisteredComparators()</db:title>
<db:methodsynopsis>
<db:modifier>static</db:modifier>
<db:type>bool</db:type>
<db:methodname>hasRegisteredComparators</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool hasRegisteredComparators()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns true, if the meta type system has registered comparators for type T.</db:para>
<db:para>This function was introduced in Qt 5.2.</db:para>
</db:section>
<db:section xml:id="hasRegisteredComparators-1">
<db:title>[static, since 5.2] bool QMetaType::hasRegisteredComparators(int <db:emphasis>typeId</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:modifier>static</db:modifier>
<db:type>bool</db:type>
<db:methodname>hasRegisteredComparators</db:methodname>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>typeId</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">bool hasRegisteredComparators(int typeId)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns true, if the meta type system has registered comparators for type id <db:code role="parameter">typeId</db:code>.</db:para>
<db:para>This function was introduced in Qt 5.2.</db:para>
</db:section>
<db:section xml:id="hasRegisteredConverterFunction">
<db:title>[static, since 5.2] bool QMetaType::hasRegisteredConverterFunction(int <db:emphasis>fromTypeId</db:emphasis>, int <db:emphasis>toTypeId</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:modifier>static</db:modifier>
<db:type>bool</db:type>
<db:methodname>hasRegisteredConverterFunction</db:methodname>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>fromTypeId</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>toTypeId</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool hasRegisteredConverterFunction(int fromTypeId, int toTypeId)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns true, if the meta type system has a registered conversion from meta type id <db:code role="parameter">fromTypeId</db:code> to <db:code role="parameter">toTypeId</db:code></db:para>
<db:para>This function was introduced in Qt 5.2.</db:para>
</db:section>
<db:section xml:id="hasRegisteredConverterFunction-1">
<db:title>[static, since 5.2] bool QMetaType::hasRegisteredConverterFunction()</db:title>
<db:methodsynopsis>
<db:modifier>static</db:modifier>
<db:type>bool</db:type>
<db:methodname>hasRegisteredConverterFunction</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">bool hasRegisteredConverterFunction()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns true, if the meta type system has a registered conversion from type From to type To.</db:para>
<db:para>This is an overloaded function.</db:para>
<db:para>This function was introduced in Qt 5.2.</db:para>
</db:section>
<db:section xml:id="hasRegisteredDebugStreamOperator">
<db:title>[static, since 5.2] bool QMetaType::hasRegisteredDebugStreamOperator()</db:title>
<db:methodsynopsis>
<db:modifier>static</db:modifier>
<db:type>bool</db:type>
<db:methodname>hasRegisteredDebugStreamOperator</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool hasRegisteredDebugStreamOperator()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns true, if the meta type system has a registered debug stream operator for type T.</db:para>
<db:para>This function was introduced in Qt 5.2.</db:para>
</db:section>
<db:section xml:id="hasRegisteredDebugStreamOperator-1">
<db:title>[static, since 5.2] bool QMetaType::hasRegisteredDebugStreamOperator(int <db:emphasis>typeId</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:modifier>static</db:modifier>
<db:type>bool</db:type>
<db:methodname>hasRegisteredDebugStreamOperator</db:methodname>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>typeId</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">bool hasRegisteredDebugStreamOperator(int typeId)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns true, if the meta type system has a registered debug stream operator for type id <db:code role="parameter">typeId</db:code>.</db:para>
<db:para>This function was introduced in Qt 5.2.</db:para>
</db:section>
<db:section xml:id="isRegistered">
<db:title>[static] bool QMetaType::isRegistered(int <db:emphasis>type</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:modifier>static</db:modifier>
<db:type>bool</db:type>
<db:methodname>isRegistered</db:methodname>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>type</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool isRegistered(int type)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns true if the datatype with ID <db:code role="parameter">type</db:code> is registered; otherwise returns false.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qmetatype.xml#type">type</db:link>()</db:member>
<db:member><db:link xlink:href="qmetatype.xml#typeName">typeName</db:link>()</db:member>
<db:member><db:link xlink:href="qmetatype.xml#Type-enum">Type</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="isRegistered-1">
<db:title>[since 5.0] bool QMetaType::isRegistered() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>bool</db:type>
<db:methodname>isRegistered</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">bool isRegistered() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns true if this <db:link xlink:href="qmetatype.xml">QMetaType</db:link> object contains valid information about a type, false otherwise.</db:para>
<db:para>This function was introduced in Qt 5.0.</db:para>
</db:section>
<db:section xml:id="isValid">
<db:title>[since 5.0] bool QMetaType::isValid() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>bool</db:type>
<db:methodname>isValid</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool isValid() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns true if this <db:link xlink:href="qmetatype.xml">QMetaType</db:link> object contains valid information about a type, false otherwise.</db:para>
<db:para>This function was introduced in Qt 5.0.</db:para>
</db:section>
<db:section xml:id="load">
<db:title>[static] bool QMetaType::load(QDataStream &amp;<db:emphasis>stream</db:emphasis>, int <db:emphasis>type</db:emphasis>, void *<db:emphasis>data</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:modifier>static</db:modifier>
<db:type>bool</db:type>
<db:methodname>load</db:methodname>
<db:methodparam>
<db:type>QDataStream &amp;</db:type>
<db:parameter>stream</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>type</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>void *</db:type>
<db:parameter>data</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool load(QDataStream &amp;stream, int type, void *data)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Reads the object of the specified <db:code role="parameter">type</db:code> from the given <db:code role="parameter">stream</db:code> into <db:code role="parameter">data</db:code>. Returns true if the object is loaded successfully; otherwise returns false.</db:para>
<db:para>The type must have been registered with <db:link xlink:href="qmetatype.xml#qRegisterMetaType-1">qRegisterMetaType</db:link>() and <db:link xlink:href="qmetatype.xml#qRegisterMetaTypeStreamOperators">qRegisterMetaTypeStreamOperators</db:link>() beforehand.</db:para>
<db:para>Normally, you should not need to call this function directly. Instead, use <db:link xlink:href="qmetatype.xml#Type-enum">QVariant</db:link>'s operator&gt;&gt;(), which relies on load() to stream custom types.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qmetatype.xml#save">save</db:link>()</db:member>
<db:member><db:link xlink:href="qmetatype.xml#qRegisterMetaTypeStreamOperators">qRegisterMetaTypeStreamOperators</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="metaObject">
<db:title>[since 5.5] const QMetaObject *QMetaType::metaObject() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>const QMetaObject *</db:type>
<db:methodname>metaObject</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">const QMetaObject * metaObject() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>return a <db:link xlink:href="qmetaobject.xml">QMetaObject</db:link> relative to this type.</db:para>
<db:para>If the type is a pointer type to a subclass of <db:link xlink:href="qobject.xml">QObject</db:link>, <db:link xlink:href="qmetatype.xml#flags">flags</db:link>() contains <db:link xlink:href="qmetatype.xml#TypeFlag-enum">QMetaType::PointerToQObject</db:link> and this function returns the corresponding <db:link xlink:href="qmetaobject.xml">QMetaObject</db:link>. This can be used to in combinaison with QMetaObject::construct to create <db:link xlink:href="qobject.xml">QObject</db:link> of this type.</db:para>
<db:para>If the type is a <db:link xlink:href="qobject.xml#Q_GADGET">Q_GADGET</db:link>, <db:link xlink:href="qmetatype.xml#flags">flags</db:link>() contains <db:link xlink:href="qmetatype.xml#TypeFlag-enum">QMetaType::IsGadget</db:link>, and this function returns its <db:link xlink:href="qmetaobject.xml">QMetaObject</db:link>. This can be used to retrieve <db:link xlink:href="qmetamethod.xml">QMetaMethod</db:link> and <db:link xlink:href="qmetaproperty.xml">QMetaProperty</db:link> and use them on a pointer of this type. (given by QVariant::data for example)</db:para>
<db:para>If the type is an enumeration, <db:link xlink:href="qmetatype.xml#flags">flags</db:link>() contains <db:link xlink:href="qmetatype.xml#TypeFlag-enum">QMetaType::IsEnumeration</db:link>, and this function returns the <db:link xlink:href="qmetaobject.xml">QMetaObject</db:link> of the enclosing object if the enum was registered as a <db:link xlink:href="qobject.xml#Q_ENUM">Q_ENUM</db:link> or 0 otherwise</db:para>
<db:para>This function was introduced in Qt 5.5.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qmetatype.xml#metaObjectForType">QMetaType::metaObjectForType</db:link>()</db:member>
<db:member><db:link xlink:href="qmetatype.xml#flags">QMetaType::flags</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="metaObjectForType">
<db:title>[static, since 5.0] const QMetaObject *QMetaType::metaObjectForType(int <db:emphasis>type</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:modifier>static</db:modifier>
<db:type>const QMetaObject *</db:type>
<db:methodname>metaObjectForType</db:methodname>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>type</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">const QMetaObject * metaObjectForType(int type)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>returns <db:link xlink:href="qmetatype.xml#metaObject">QMetaType::metaObject</db:link> for <db:code role="parameter">type</db:code></db:para>
<db:para>This function was introduced in Qt 5.0.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qmetatype.xml#metaObject">metaObject</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="registerComparators">
<db:title>[static, since 5.2] bool QMetaType::registerComparators()</db:title>
<db:methodsynopsis>
<db:modifier>static</db:modifier>
<db:type>bool</db:type>
<db:methodname>registerComparators</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool registerComparators()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Registers comparison operators for the user-registered type T. This requires T to have both an operator== and an operator&lt;. Returns true if the registration succeeded, otherwise false.</db:para>
<db:para>This function was introduced in Qt 5.2.</db:para>
</db:section>
<db:section xml:id="registerConverter">
<db:title>[static, since 5.2] bool QMetaType::registerConverter()</db:title>
<db:methodsynopsis>
<db:modifier>static</db:modifier>
<db:type>bool</db:type>
<db:methodname>registerConverter</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool registerConverter()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Registers the possibility of an implicit conversion from type From to type To in the meta type system. Returns true if the registration succeeded, otherwise false.</db:para>
<db:para>This function was introduced in Qt 5.2.</db:para>
</db:section>
<db:section xml:id="registerConverter-1">
<db:title>[static, since 5.2] bool QMetaType::registerConverter(MemberFunction <db:emphasis>function</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:modifier>static</db:modifier>
<db:type>bool</db:type>
<db:methodname>registerConverter</db:methodname>
<db:methodparam>
<db:type>MemberFunction</db:type>
<db:parameter>function</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">bool registerConverter(MemberFunction function)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>Registers a method <db:code role="parameter">function</db:code> like To From::function() const as converter from type From to type To in the meta type system. Returns true if the registration succeeded, otherwise false.</db:para>
<db:para>This function was introduced in Qt 5.2.</db:para>
</db:section>
<db:section xml:id="registerConverter-2">
<db:title>[static, since 5.2] bool QMetaType::registerConverter(MemberFunctionOk <db:emphasis>function</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:modifier>static</db:modifier>
<db:type>bool</db:type>
<db:methodname>registerConverter</db:methodname>
<db:methodparam>
<db:type>MemberFunctionOk</db:type>
<db:parameter>function</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">2</db:synopsisinfo>
<db:synopsisinfo role="signature">bool registerConverter(MemberFunctionOk function)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>Registers a method <db:code role="parameter">function</db:code> like To From::function(bool *ok) const as converter from type From to type To in the meta type system. Returns true if the registration succeeded, otherwise false.</db:para>
<db:para>This function was introduced in Qt 5.2.</db:para>
</db:section>
<db:section xml:id="registerConverter-3">
<db:title>[static, since 5.2] bool QMetaType::registerConverter(UnaryFunction <db:emphasis>function</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:modifier>static</db:modifier>
<db:type>bool</db:type>
<db:methodname>registerConverter</db:methodname>
<db:methodparam>
<db:type>UnaryFunction</db:type>
<db:parameter>function</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">3</db:synopsisinfo>
<db:synopsisinfo role="signature">bool registerConverter(UnaryFunction function)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>Registers a unary function object <db:code role="parameter">function</db:code> as converter from type From to type To in the meta type system. Returns true if the registration succeeded, otherwise false.</db:para>
<db:para>This function was introduced in Qt 5.2.</db:para>
</db:section>
<db:section xml:id="registerDebugStreamOperator">
<db:title>[static] bool QMetaType::registerDebugStreamOperator()</db:title>
<db:methodsynopsis>
<db:modifier>static</db:modifier>
<db:type>bool</db:type>
<db:methodname>registerDebugStreamOperator</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool registerDebugStreamOperator()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Registers the debug stream operator for the user-registered type T. This requires T to have an operator&lt;&lt;(<db:link xlink:href="qdebug.xml">QDebug</db:link> dbg, T). Returns true if the registration succeeded, otherwise false.</db:para>
</db:section>
<db:section xml:id="registerEqualsComparator">
<db:title>[static, since 5.5] bool QMetaType::registerEqualsComparator()</db:title>
<db:methodsynopsis>
<db:modifier>static</db:modifier>
<db:type>bool</db:type>
<db:methodname>registerEqualsComparator</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool registerEqualsComparator()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Registers equals operator for the user-registered type T. This requires T to have an operator==. Returns true if the registration succeeded, otherwise false.</db:para>
<db:para>This function was introduced in Qt 5.5.</db:para>
</db:section>
<db:section xml:id="save">
<db:title>[static] bool QMetaType::save(QDataStream &amp;<db:emphasis>stream</db:emphasis>, int <db:emphasis>type</db:emphasis>, const void *<db:emphasis>data</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:modifier>static</db:modifier>
<db:type>bool</db:type>
<db:methodname>save</db:methodname>
<db:methodparam>
<db:type>QDataStream &amp;</db:type>
<db:parameter>stream</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>type</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const void *</db:type>
<db:parameter>data</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool save(QDataStream &amp;stream, int type, const void *data)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Writes the object pointed to by <db:code role="parameter">data</db:code> with the ID <db:code role="parameter">type</db:code> to the given <db:code role="parameter">stream</db:code>. Returns true if the object is saved successfully; otherwise returns false.</db:para>
<db:para>The type must have been registered with <db:link xlink:href="qmetatype.xml#qRegisterMetaType-1">qRegisterMetaType</db:link>() and <db:link xlink:href="qmetatype.xml#qRegisterMetaTypeStreamOperators">qRegisterMetaTypeStreamOperators</db:link>() beforehand.</db:para>
<db:para>Normally, you should not need to call this function directly. Instead, use <db:link xlink:href="qmetatype.xml#Type-enum">QVariant</db:link>'s operator&lt;&lt;(), which relies on save() to stream custom types.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qmetatype.xml#load">load</db:link>()</db:member>
<db:member><db:link xlink:href="qmetatype.xml#qRegisterMetaTypeStreamOperators">qRegisterMetaTypeStreamOperators</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="sizeOf">
<db:title>[static, since 5.0] int QMetaType::sizeOf(int <db:emphasis>type</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:modifier>static</db:modifier>
<db:type>int</db:type>
<db:methodname>sizeOf</db:methodname>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>type</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">int sizeOf(int type)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the size of the given <db:code role="parameter">type</db:code> in bytes (i.e. sizeof(T), where T is the actual type identified by the <db:code role="parameter">type</db:code> argument).</db:para>
<db:para>This function is typically used together with <db:link xlink:href="qmetatype.xml#construct">construct</db:link>() to perform low-level management of the memory used by a type.</db:para>
<db:para>This function was introduced in Qt 5.0.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qmetatype.xml#construct">construct</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="sizeOf-1">
<db:title>[since 5.0] int QMetaType::sizeOf() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>int</db:type>
<db:methodname>sizeOf</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">int sizeOf() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the size of the type in bytes (i.e. sizeof(T), where T is the actual type for which this <db:link xlink:href="qmetatype.xml">QMetaType</db:link> instance was constructed for).</db:para>
<db:para>This function is typically used together with <db:link xlink:href="qmetatype.xml#construct">construct</db:link>() to perform low-level management of the memory used by a type.</db:para>
<db:para>This function was introduced in Qt 5.0.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qmetatype.xml#construct">QMetaType::construct</db:link>()</db:member>
<db:member><db:link xlink:href="">QMetaType::sizeOf</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="type">
<db:title>[static] int QMetaType::type(const char *<db:emphasis>typeName</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:modifier>static</db:modifier>
<db:type>int</db:type>
<db:methodname>type</db:methodname>
<db:methodparam>
<db:type>const char *</db:type>
<db:parameter>typeName</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">int type(const char *typeName)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns a handle to the type called <db:code role="parameter">typeName</db:code>, or <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::UnknownType</db:link> if there is no such type.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qmetatype.xml#isRegistered-1">isRegistered</db:link>()</db:member>
<db:member><db:link xlink:href="qmetatype.xml#typeName">typeName</db:link>()</db:member>
<db:member><db:link xlink:href="qmetatype.xml#Type-enum">Type</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="type-1">
<db:title>[static, since 5.5] int QMetaType::type(const ::QByteArray &amp;<db:emphasis>typeName</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:modifier>static</db:modifier>
<db:type>int</db:type>
<db:methodname>type</db:methodname>
<db:methodparam>
<db:type>const ::QByteArray &amp;</db:type>
<db:parameter>typeName</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">int type(const ::QByteArray &amp;typeName)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>Returns a handle to the type called <db:code role="parameter">typeName</db:code>, or 0 if there is no such type.</db:para>
<db:para>This function was introduced in Qt 5.5.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qmetatype.xml#isRegistered-1">isRegistered</db:link>()</db:member>
<db:member><db:link xlink:href="qmetatype.xml#typeName">typeName</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="typeFlags">
<db:title>[static, since 5.0] QMetaType::TypeFlags QMetaType::typeFlags(int <db:emphasis>type</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:modifier>static</db:modifier>
<db:type>QMetaType::TypeFlags</db:type>
<db:methodname>typeFlags</db:methodname>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>type</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QMetaType::TypeFlags typeFlags(int type)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns flags of the given <db:code role="parameter">type</db:code>.</db:para>
<db:para>This function was introduced in Qt 5.0.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qmetatype.xml#TypeFlag-enum">QMetaType::TypeFlags</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="typeName">
<db:title>[static] const char *QMetaType::typeName(int <db:emphasis>typeId</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:modifier>static</db:modifier>
<db:type>const char *</db:type>
<db:methodname>typeName</db:methodname>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>typeId</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">const char * typeName(int typeId)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the type name associated with the given <db:code role="parameter">typeId</db:code>, or a null pointer if no matching type was found. The returned pointer must not be deleted.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qmetatype.xml#type">type</db:link>()</db:member>
<db:member><db:link xlink:href="qmetatype.xml#isRegistered-1">isRegistered</db:link>()</db:member>
<db:member><db:link xlink:href="qmetatype.xml#Type-enum">Type</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
</db:section>
<db:section xml:id="related-non-members">
<db:title>Related Non-Members</db:title>
<db:section xml:id="qMetaTypeId">
<db:title>[since 4.1] int qMetaTypeId()</db:title>
<db:methodsynopsis>
<db:type>int</db:type>
<db:methodname>qMetaTypeId</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">int qMetaTypeId()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the meta type id of type T at compile time. If the type was not declared with <db:link xlink:href="qmetatype.xml#Q_DECLARE_METATYPE">Q_DECLARE_METATYPE</db:link>(), compilation will fail.</db:para>
<db:para>Typical usage:</db:para>
<db:programlisting language="cpp">int id = qMetaTypeId&amp;lt;QString&amp;gt;();    // id is now QMetaType::QString
id = qMetaTypeId&amp;lt;MyStruct&amp;gt;();       // compile error if MyStruct not declared
</db:programlisting>
<db:para><db:link xlink:href="qmetatype.xml#type">QMetaType::type</db:link>() returns the same ID as qMetaTypeId(), but does a lookup at runtime based on the name of the type. <db:link xlink:href="qmetatype.xml#type">QMetaType::type</db:link>() is a bit slower, but compilation succeeds if a type is not registered.</db:para>
<db:para>This function was introduced in Qt 4.1.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qmetatype.xml#Q_DECLARE_METATYPE">Q_DECLARE_METATYPE</db:link>()</db:member>
<db:member><db:link xlink:href="qmetatype.xml#type">QMetaType::type</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="qRegisterMetaType">
<db:title>int qRegisterMetaType(const char *<db:emphasis>typeName</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>int</db:type>
<db:methodname>qRegisterMetaType</db:methodname>
<db:methodparam>
<db:type>const char *</db:type>
<db:parameter>typeName</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">int qRegisterMetaType(const char *typeName)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Registers the type name <db:code role="parameter">typeName</db:code> for the type T. Returns the internal ID used by <db:link xlink:href="qmetatype.xml">QMetaType</db:link>. Any class or struct that has a public default constructor, a public copy constructor and a public destructor can be registered.</db:para>
<db:para>This function requires that T is a fully defined type at the point where the function is called. For pointer types, it also requires that the pointed to type is fully defined. Use <db:link xlink:href="qmetatype.xml#Q_DECLARE_OPAQUE_POINTER">Q_DECLARE_OPAQUE_POINTER</db:link>() to be able to register pointers to forward declared types.</db:para>
<db:para>After a type has been registered, you can create and destroy objects of that type dynamically at run-time.</db:para>
<db:para>This example registers the class MyClass:</db:para>
<db:programlisting language="cpp">qRegisterMetaType&amp;lt;MyClass&amp;gt;(&quot;MyClass&quot;);
</db:programlisting>
<db:para>This function is useful to register typedefs so they can be used by <db:link xlink:href="qmetaproperty.xml">QMetaProperty</db:link>, or in QueuedConnections</db:para>
<db:programlisting language="cpp">typedef QString CustomString;
qRegisterMetaType&amp;lt;CustomString&amp;gt;(&quot;CustomString&quot;);
</db:programlisting>
<db:warning>
<db:para>This function is useful only for registering an alias (typedef) for every other use case <db:link xlink:href="qmetatype.xml#Q_DECLARE_METATYPE">Q_DECLARE_METATYPE</db:link> and <db:link xlink:href="qmetatype.xml#qMetaTypeId">qMetaTypeId</db:link>() should be used instead.</db:para>
</db:warning>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qmetatype.xml#qRegisterMetaTypeStreamOperators">qRegisterMetaTypeStreamOperators</db:link>()</db:member>
<db:member><db:link xlink:href="qmetatype.xml#isRegistered-1">isRegistered</db:link>()</db:member>
<db:member><db:link xlink:href="qmetatype.xml#Q_DECLARE_METATYPE">Q_DECLARE_METATYPE</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="qRegisterMetaType-1">
<db:title>[since 4.2] int qRegisterMetaType()</db:title>
<db:methodsynopsis>
<db:type>int</db:type>
<db:methodname>qRegisterMetaType</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">int qRegisterMetaType()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Call this function to register the type T. T must be declared with <db:link xlink:href="qmetatype.xml#Q_DECLARE_METATYPE">Q_DECLARE_METATYPE</db:link>(). Returns the meta type Id.</db:para>
<db:para>Example:</db:para>
<db:programlisting language="cpp">int id = qRegisterMetaType&amp;lt;MyStruct&amp;gt;();
</db:programlisting>
<db:para>This function requires that T is a fully defined type at the point where the function is called. For pointer types, it also requires that the pointed to type is fully defined. Use <db:link xlink:href="qmetatype.xml#Q_DECLARE_OPAQUE_POINTER">Q_DECLARE_OPAQUE_POINTER</db:link>() to be able to register pointers to forward declared types.</db:para>
<db:para>After a type has been registered, you can create and destroy objects of that type dynamically at run-time.</db:para>
<db:para>To use the type T in <db:link xlink:href="qmetatype.xml#Type-enum">QVariant</db:link>, using <db:link xlink:href="qmetatype.xml#Q_DECLARE_METATYPE">Q_DECLARE_METATYPE</db:link>() is sufficient. To use the type T in queued signal and slot connections, qRegisterMetaType&lt;T&gt;() must be called before the first connection is established.</db:para>
<db:para>Also, to use type T with the <db:link xlink:href="qobject.xml#property">QObject::property</db:link>() API, qRegisterMetaType&lt;T&gt;() must be called before it is used, typically in the constructor of the class that uses T, or in the main() function.</db:para>
<db:para>This function was introduced in Qt 4.2.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qmetatype.xml#Q_DECLARE_METATYPE">Q_DECLARE_METATYPE</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="qRegisterMetaTypeStreamOperators">
<db:title>void qRegisterMetaTypeStreamOperators(const char *<db:emphasis>typeName</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>qRegisterMetaTypeStreamOperators</db:methodname>
<db:methodparam>
<db:type>const char *</db:type>
<db:parameter>typeName</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void qRegisterMetaTypeStreamOperators(const char *typeName)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Registers the stream operators for the type T called <db:code role="parameter">typeName</db:code>.</db:para>
<db:para>Afterward, the type can be streamed using <db:link xlink:href="qmetatype.xml#load">QMetaType::load</db:link>() and <db:link xlink:href="qmetatype.xml#save">QMetaType::save</db:link>(). These functions are used when streaming a <db:link xlink:href="qmetatype.xml#Type-enum">QVariant</db:link>.</db:para>
<db:programlisting language="cpp">qRegisterMetaTypeStreamOperators&amp;lt;MyClass&amp;gt;(&quot;MyClass&quot;);
</db:programlisting>
<db:para>The stream operators should have the following signatures:</db:para>
<db:programlisting language="cpp">QDataStream &amp;amp;operator&amp;lt;&amp;lt;(QDataStream &amp;amp;out, const MyClass &amp;amp;myObj);
QDataStream &amp;amp;operator&amp;gt;&amp;gt;(QDataStream &amp;amp;in, MyClass &amp;amp;myObj);
</db:programlisting>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qmetatype.xml#qRegisterMetaType-1">qRegisterMetaType</db:link>()</db:member>
<db:member><db:link xlink:href="qmetatype.xml#isRegistered-1">QMetaType::isRegistered</db:link>()</db:member>
<db:member><db:link xlink:href="qmetatype.xml#Q_DECLARE_METATYPE">Q_DECLARE_METATYPE</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
</db:section>
<db:section xml:id="macro-documentation">
<db:title>Macro Documentation</db:title>
<db:section xml:id="Q_DECLARE_ASSOCIATIVE_CONTAINER_METATYPE">
<db:title>Q_DECLARE_ASSOCIATIVE_CONTAINER_METATYPE(<db:emphasis>Container</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:methodname>Q_DECLARE_ASSOCIATIVE_CONTAINER_METATYPE</db:methodname>
<db:methodparam>
<db:type></db:type>
<db:parameter>Container</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">macrowithparams</db:synopsisinfo>
<db:synopsisinfo role="signature">Q_DECLARE_ASSOCIATIVE_CONTAINER_METATYPE(Container)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This macro makes the container <db:code role="parameter">Container</db:code> known to <db:link xlink:href="qmetatype.xml">QMetaType</db:link> as an associative container. This makes it possible to put an instance of Container&lt;T, U&gt; into a <db:link xlink:href="qmetatype.xml#Type-enum">QVariant</db:link>, if T and U are themselves known to <db:link xlink:href="qmetatype.xml">QMetaType</db:link>.</db:para>
<db:para>Note that all of the Qt associative containers already have built-in support, and it is not necessary to use this macro with them. The std::map container also has built-in support.</db:para>
<db:para>This example shows a typical use of Q_DECLARE_ASSOCIATIVE_CONTAINER_METATYPE():</db:para>
<db:programlisting language="cpp">#include &amp;lt;unordered_list&amp;gt;

Q_DECLARE_ASSOCIATIVE_CONTAINER_METATYPE(std::unordered_map)

void someFunc()
{
    std::unordered_map&amp;lt;int, bool&amp;gt; container;
    QVariant var = QVariant::fromValue(container);
    // ...
}

</db:programlisting>
</db:section>
<db:section xml:id="Q_DECLARE_METATYPE">
<db:title>Q_DECLARE_METATYPE(<db:emphasis>Type</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:methodname>Q_DECLARE_METATYPE</db:methodname>
<db:methodparam>
<db:type></db:type>
<db:parameter>Type</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">macrowithparams</db:synopsisinfo>
<db:synopsisinfo role="signature">Q_DECLARE_METATYPE(Type)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This macro makes the type <db:code role="parameter">Type</db:code> known to <db:link xlink:href="qmetatype.xml">QMetaType</db:link> as long as it provides a public default constructor, a public copy constructor and a public destructor. It is needed to use the type <db:code role="parameter">Type</db:code> as a custom type in <db:link xlink:href="qmetatype.xml#Type-enum">QVariant</db:link>.</db:para>
<db:para>This macro requires that <db:code role="parameter">Type</db:code> is a fully defined type at the point where it is used. For pointer types, it also requires that the pointed to type is fully defined. Use in conjunction with <db:link xlink:href="qmetatype.xml#Q_DECLARE_OPAQUE_POINTER">Q_DECLARE_OPAQUE_POINTER</db:link>() to register pointers to forward declared types.</db:para>
<db:para>Ideally, this macro should be placed below the declaration of the class or struct. If that is not possible, it can be put in a private header file which has to be included every time that type is used in a <db:link xlink:href="qmetatype.xml#Type-enum">QVariant</db:link>.</db:para>
<db:para>Adding a Q_DECLARE_METATYPE() makes the type known to all template based functions, including <db:link xlink:href="qmetatype.xml#Type-enum">QVariant</db:link>. Note that if you intend to use the type in <db:emphasis>queued</db:emphasis> signal and slot connections or in <db:link xlink:href="qobject.xml">QObject</db:link>'s property system, you also have to call <db:link xlink:href="qmetatype.xml#qRegisterMetaType-1">qRegisterMetaType</db:link>() since the names are resolved at runtime.</db:para>
<db:para>This example shows a typical use case of Q_DECLARE_METATYPE():</db:para>
<db:programlisting language="cpp">struct MyStruct
{
    int i;
    ...
};

Q_DECLARE_METATYPE(MyStruct)
</db:programlisting>
<db:para>If MyStruct is in a namespace, the Q_DECLARE_METATYPE() macro has to be outside the namespace:</db:para>
<db:programlisting language="cpp">namespace MyNamespace
{
    ...
}

Q_DECLARE_METATYPE(MyNamespace::MyStruct)
</db:programlisting>
<db:para>Since MyStruct is now known to <db:link xlink:href="qmetatype.xml">QMetaType</db:link>, it can be used in <db:link xlink:href="qmetatype.xml#Type-enum">QVariant</db:link>:</db:para>
<db:programlisting language="cpp">MyStruct s;
QVariant var;
var.setValue(s); // copy s into the variant

...

// retrieve the value
MyStruct s2 = var.value&amp;lt;MyStruct&amp;gt;();
</db:programlisting>
<db:para>Some types are registered automatically and do not need this macro:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para>Pointers to classes derived from <db:link xlink:href="qobject.xml">QObject</db:link></db:para>
</db:listitem>
<db:listitem>
<db:para><db:link xlink:href="qlist.xml">QList</db:link>&lt;T&gt;, <db:link xlink:href="qvector.xml">QVector</db:link>&lt;T&gt;, <db:link xlink:href="qqueue.xml">QQueue</db:link>&lt;T&gt;, <db:link xlink:href="qstack.xml">QStack</db:link>&lt;T&gt;, <db:link xlink:href="qset.xml">QSet</db:link>&lt;T&gt; or <db:link xlink:href="qlinkedlist.xml">QLinkedList</db:link>&lt;T&gt; where T is a registered meta type</db:para>
</db:listitem>
<db:listitem>
<db:para><db:link xlink:href="qhash.xml#qhash">QHash</db:link>&lt;T1, T2&gt;, <db:link xlink:href="qmap.xml">QMap</db:link>&lt;T1, T2&gt; or <db:link xlink:href="qpair.xml">QPair</db:link>&lt;T1, T2&gt; where T1 and T2 are registered meta types</db:para>
</db:listitem>
<db:listitem>
<db:para><db:link xlink:href="qpointer.xml">QPointer</db:link>&lt;T&gt;, <db:link xlink:href="qsharedpointer.xml">QSharedPointer</db:link>&lt;T&gt;, <db:link xlink:href="qweakpointer.xml">QWeakPointer</db:link>&lt;T&gt;, where T is a class that derives from <db:link xlink:href="qobject.xml">QObject</db:link></db:para>
</db:listitem>
<db:listitem>
<db:para>Enumerations registered with <db:link xlink:href="qobject.xml#Q_ENUM">Q_ENUM</db:link> or <db:link xlink:href="qobject.xml#Q_FLAG">Q_FLAG</db:link></db:para>
</db:listitem>
<db:listitem>
<db:para>Classes that have a <db:link xlink:href="qobject.xml#Q_GADGET">Q_GADGET</db:link> macro</db:para>
</db:listitem>
</db:itemizedlist>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qmetatype.xml#qRegisterMetaType-1">qRegisterMetaType</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="Q_DECLARE_OPAQUE_POINTER">
<db:title>[since 5.0] Q_DECLARE_OPAQUE_POINTER(<db:emphasis>PointerType</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:methodname>Q_DECLARE_OPAQUE_POINTER</db:methodname>
<db:methodparam>
<db:type></db:type>
<db:parameter>PointerType</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">macrowithparams</db:synopsisinfo>
<db:synopsisinfo role="signature">Q_DECLARE_OPAQUE_POINTER(PointerType)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This macro enables pointers to forward-declared types (<db:code role="parameter">PointerType</db:code>) to be registered with <db:link xlink:href="qmetatype.xml">QMetaType</db:link> using either <db:link xlink:href="qmetatype.xml#Q_DECLARE_METATYPE">Q_DECLARE_METATYPE</db:link>() or <db:link xlink:href="qmetatype.xml#qRegisterMetaType-1">qRegisterMetaType</db:link>().</db:para>
<db:para>This macro was introduced in Qt 5.0.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qmetatype.xml#Q_DECLARE_METATYPE">Q_DECLARE_METATYPE</db:link>()</db:member>
<db:member><db:link xlink:href="qmetatype.xml#qRegisterMetaType-1">qRegisterMetaType</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="Q_DECLARE_SEQUENTIAL_CONTAINER_METATYPE">
<db:title>Q_DECLARE_SEQUENTIAL_CONTAINER_METATYPE(<db:emphasis>Container</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:methodname>Q_DECLARE_SEQUENTIAL_CONTAINER_METATYPE</db:methodname>
<db:methodparam>
<db:type></db:type>
<db:parameter>Container</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">macrowithparams</db:synopsisinfo>
<db:synopsisinfo role="signature">Q_DECLARE_SEQUENTIAL_CONTAINER_METATYPE(Container)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This macro makes the container <db:code role="parameter">Container</db:code> known to <db:link xlink:href="qmetatype.xml">QMetaType</db:link> as a sequential container. This makes it possible to put an instance of Container&lt;T&gt; into a <db:link xlink:href="qmetatype.xml#Type-enum">QVariant</db:link>, if T itself is known to <db:link xlink:href="qmetatype.xml">QMetaType</db:link>.</db:para>
<db:para>Note that all of the Qt sequential containers already have built-in support, and it is not necessary to use this macro with them. The std::vector and std::list containers also have built-in support.</db:para>
<db:para>This example shows a typical use of Q_DECLARE_SEQUENTIAL_CONTAINER_METATYPE():</db:para>
<db:programlisting language="cpp">#include &amp;lt;deque&amp;gt;

Q_DECLARE_SEQUENTIAL_CONTAINER_METATYPE(std::deque)

void someFunc()
{
    std::deque&amp;lt;QFile*&amp;gt; container;
    QVariant var = QVariant::fromValue(container);
    // ...
}

</db:programlisting>
</db:section>
<db:section xml:id="Q_DECLARE_SMART_POINTER_METATYPE">
<db:title>Q_DECLARE_SMART_POINTER_METATYPE(<db:emphasis>SmartPointer</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:methodname>Q_DECLARE_SMART_POINTER_METATYPE</db:methodname>
<db:methodparam>
<db:type></db:type>
<db:parameter>SmartPointer</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">macrowithparams</db:synopsisinfo>
<db:synopsisinfo role="signature">Q_DECLARE_SMART_POINTER_METATYPE(SmartPointer)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This macro makes the smart pointer <db:code role="parameter">SmartPointer</db:code> known to <db:link xlink:href="qmetatype.xml">QMetaType</db:link> as a smart pointer. This makes it possible to put an instance of SmartPointer&lt;T&gt; into a <db:link xlink:href="qmetatype.xml#Type-enum">QVariant</db:link>, if T is a type which inherits <db:link xlink:href="qobject.xml">QObject</db:link>.</db:para>
<db:para>Note that the <db:link xlink:href="qweakpointer.xml">QWeakPointer</db:link>, <db:link xlink:href="qsharedpointer.xml">QSharedPointer</db:link> and <db:link xlink:href="qpointer.xml">QPointer</db:link> already have built-in support, and it is not necessary to use this macro with them.</db:para>
<db:para>This example shows a typical use of Q_DECLARE_SMART_POINTER_METATYPE():</db:para>
<db:programlisting language="cpp">#include &amp;lt;memory&amp;gt;

Q_DECLARE_SMART_POINTER_METATYPE(std::shared_ptr)

void someFunc()
{
    auto smart_ptr = std::make_shared&amp;lt;QFile&amp;gt;();
    QVariant var = QVariant::fromValue(smart_ptr);
    // ...
    if (var.canConvert&amp;lt;QObject*&amp;gt;()) {
        QObject *sp = var.value&amp;lt;QObject*&amp;gt;();
        qDebug() &amp;lt;&amp;lt; sp-&amp;gt;metaObject()-&amp;gt;className(); // Prints 'QFile'.
    }
}

</db:programlisting>
</db:section>
</db:section>
</db:article>
