<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en">
<db:info>
<db:title>QMetaType Class</db:title>
<db:productname>QtCore</db:productname>
<db:edition>Qt 6.3.2 Reference Documentation</db:edition>
<db:titleabbrev>Qt Core Reference Documentation</db:titleabbrev>
<db:abstract>
<db:para>The <db:link xlink:href="qmetatype.xml">QMetaType</db:link> class manages named types in the meta-object system.</db:para>
<db:note>
<db:para>All functions in this class are <db:link xlink:href="">thread-safe</db:link>.</db:para>
</db:note>
</db:abstract>
<db:pubdate>2024-12-27</db:pubdate>
<db:date>2024-12-27</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:variablelist>
<db:varlistentry>
<db:term>Header</db:term>
<db:listitem>
<db:para>QMetaType</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>CMake</db:term>
<db:listitem>
<db:para>find_package(Qt6 REQUIRED COMPONENTS Core)</db:para>
<db:para>target_link_libraries(mytarget PRIVATE Qt6::Core)</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>qmake</db:term>
<db:listitem>
<db:para>QT += core</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Group</db:term>
<db:listitem>
<db:para>QMetaType is part of <db:simplelist><db:member>objectmodel</db:member></db:simplelist></db:para>
</db:listitem>
</db:varlistentry>
</db:variablelist>
<db:section xml:id="details">
<db:title>Detailed Description</db:title>
<db:para>The class is used as a helper to marshall types in <db:link xlink:href="qmetatype.xml#Type-enum">QVariant</db:link> and in queued signals and slots connections. It associates a type name to a type so that it can be created and destructed dynamically at run-time. Declare new types with <db:link xlink:href="qmetatype.xml#Q_DECLARE_METATYPE">Q_DECLARE_METATYPE</db:link>() to make them available to <db:link xlink:href="qmetatype.xml#Type-enum">QVariant</db:link> and other template-based functions. Call <db:link xlink:href="qmetatype.xml#qRegisterMetaType-1">qRegisterMetaType</db:link>() to make types available to non-template based functions, such as the queued signal and slot connections.</db:para>
<db:para>Any class or struct that has a public default constructor, a public copy constructor, and a public destructor can be registered.</db:para>
<db:para>The following code allocates and destructs an instance of MyClass:</db:para>
<db:programlisting language="cpp">int id = QMetaType::type(&quot;MyClass&quot;);
if (id != QMetaType::UnknownType) {
    void *myClassPtr = QMetaType::create(id);
    ...
    QMetaType::destroy(id, myClassPtr);
    myClassPtr = 0;
}
</db:programlisting>
<db:para>If we want the stream operators operator&lt;&lt;() and operator&gt;&gt;() to work on <db:link xlink:href="qmetatype.xml#Type-enum">QVariant</db:link> objects that store custom types, the custom type must provide operator&lt;&lt;() and operator&gt;&gt;() operators.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qmetatype.xml#Q_DECLARE_METATYPE">Q_DECLARE_METATYPE</db:link>()</db:member>
<db:member><db:link xlink:href="qvariant.xml#setValue">QVariant::setValue</db:link>()</db:member>
<db:member><db:link xlink:href="qvariant.xml#value">QVariant::value</db:link>()</db:member>
<db:member><db:link xlink:href="qvariant.xml#fromValue">QVariant::fromValue</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="member-type-documentation">
<db:title>Member Type Documentation</db:title>
<db:section xml:id="Type-enum">
<db:title>enum QMetaType::Type</db:title>
<db:enumsynopsis>
<db:enumname>Type</db:enumname>
<db:enumitem>
<db:enumidentifier>UnknownType</db:enumidentifier>
<db:enumvalue>0</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>Bool</db:enumidentifier>
<db:enumvalue>1</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>Int</db:enumidentifier>
<db:enumvalue>2</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>UInt</db:enumidentifier>
<db:enumvalue>3</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>LongLong</db:enumidentifier>
<db:enumvalue>4</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>ULongLong</db:enumidentifier>
<db:enumvalue>5</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>Double</db:enumidentifier>
<db:enumvalue>6</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>Long</db:enumidentifier>
<db:enumvalue>32</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>Short</db:enumidentifier>
<db:enumvalue>33</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>Char</db:enumidentifier>
<db:enumvalue>34</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>ULong</db:enumidentifier>
<db:enumvalue>35</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>UShort</db:enumidentifier>
<db:enumvalue>36</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>UChar</db:enumidentifier>
<db:enumvalue>37</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>Float</db:enumidentifier>
<db:enumvalue>38</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>VoidStar</db:enumidentifier>
<db:enumvalue>31</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>QChar</db:enumidentifier>
<db:enumvalue>7</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>QString</db:enumidentifier>
<db:enumvalue>10</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>QStringList</db:enumidentifier>
<db:enumvalue>11</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>QByteArray</db:enumidentifier>
<db:enumvalue>12</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>QBitArray</db:enumidentifier>
<db:enumvalue>13</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>QDate</db:enumidentifier>
<db:enumvalue>14</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>QTime</db:enumidentifier>
<db:enumvalue>15</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>QDateTime</db:enumidentifier>
<db:enumvalue>16</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>QUrl</db:enumidentifier>
<db:enumvalue>17</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>QLocale</db:enumidentifier>
<db:enumvalue>18</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>QRect</db:enumidentifier>
<db:enumvalue>19</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>QRectF</db:enumidentifier>
<db:enumvalue>20</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>QSize</db:enumidentifier>
<db:enumvalue>21</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>QSizeF</db:enumidentifier>
<db:enumvalue>22</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>QLine</db:enumidentifier>
<db:enumvalue>23</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>QLineF</db:enumidentifier>
<db:enumvalue>24</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>QPoint</db:enumidentifier>
<db:enumvalue>25</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>QPointF</db:enumidentifier>
<db:enumvalue>26</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>QEasingCurve</db:enumidentifier>
<db:enumvalue>29</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>QUuid</db:enumidentifier>
<db:enumvalue>30</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>QVariant</db:enumidentifier>
<db:enumvalue>41</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>QModelIndex</db:enumidentifier>
<db:enumvalue>42</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>QPersistentModelIndex</db:enumidentifier>
<db:enumvalue>50</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>QRegularExpression</db:enumidentifier>
<db:enumvalue>44</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>QJsonValue</db:enumidentifier>
<db:enumvalue>45</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>QJsonObject</db:enumidentifier>
<db:enumvalue>46</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>QJsonArray</db:enumidentifier>
<db:enumvalue>47</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>QJsonDocument</db:enumidentifier>
<db:enumvalue>48</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>QByteArrayList</db:enumidentifier>
<db:enumvalue>49</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>QObjectStar</db:enumidentifier>
<db:enumvalue>39</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>SChar</db:enumidentifier>
<db:enumvalue>40</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>Void</db:enumidentifier>
<db:enumvalue>43</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>Nullptr</db:enumidentifier>
<db:enumvalue>51</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>QVariantMap</db:enumidentifier>
<db:enumvalue>8</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>QVariantList</db:enumidentifier>
<db:enumvalue>9</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>QVariantHash</db:enumidentifier>
<db:enumvalue>28</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>QCborSimpleType</db:enumidentifier>
<db:enumvalue>52</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>QCborValue</db:enumidentifier>
<db:enumvalue>53</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>QCborArray</db:enumidentifier>
<db:enumvalue>54</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>QCborMap</db:enumidentifier>
<db:enumvalue>55</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>Char16</db:enumidentifier>
<db:enumvalue>56</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>Char32</db:enumidentifier>
<db:enumvalue>57</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>QFont</db:enumidentifier>
<db:enumvalue>0x1000</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>QPixmap</db:enumidentifier>
<db:enumvalue>0x1001</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>QBrush</db:enumidentifier>
<db:enumvalue>0x1002</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>QColor</db:enumidentifier>
<db:enumvalue>0x1003</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>QPalette</db:enumidentifier>
<db:enumvalue>0x1004</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>QIcon</db:enumidentifier>
<db:enumvalue>0x1005</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>QImage</db:enumidentifier>
<db:enumvalue>0x1006</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>QPolygon</db:enumidentifier>
<db:enumvalue>0x1007</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>QRegion</db:enumidentifier>
<db:enumvalue>0x1008</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>QBitmap</db:enumidentifier>
<db:enumvalue>0x1009</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>QCursor</db:enumidentifier>
<db:enumvalue>0x100a</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>QKeySequence</db:enumidentifier>
<db:enumvalue>0x100b</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>QPen</db:enumidentifier>
<db:enumvalue>0x100c</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>QTextLength</db:enumidentifier>
<db:enumvalue>0x100d</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>QTextFormat</db:enumidentifier>
<db:enumvalue>0x100e</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>QTransform</db:enumidentifier>
<db:enumvalue>0x1010</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>QMatrix4x4</db:enumidentifier>
<db:enumvalue>0x1011</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>QVector2D</db:enumidentifier>
<db:enumvalue>0x1012</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>QVector3D</db:enumidentifier>
<db:enumvalue>0x1013</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>QVector4D</db:enumidentifier>
<db:enumvalue>0x1014</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>QQuaternion</db:enumidentifier>
<db:enumvalue>0x1015</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>QPolygonF</db:enumidentifier>
<db:enumvalue>0x1016</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>QColorSpace</db:enumidentifier>
<db:enumvalue>0x1017</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>QSizePolicy</db:enumidentifier>
<db:enumvalue>0x2000</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>LastCoreType</db:enumidentifier>
<db:enumvalue>Char32</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>LastGuiType</db:enumidentifier>
<db:enumvalue>QColorSpace</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>User</db:enumidentifier>
<db:enumvalue>65536</db:enumvalue>
</db:enumitem>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:enumsynopsis>
<db:para>These are the built-in types supported by <db:link xlink:href="qmetatype.xml">QMetaType</db:link>:</db:para>
<db:informaltable>
<db:thead>
<db:tr>
<db:th>Constant</db:th>
<db:th>Value</db:th>
<db:th>Description</db:th>
</db:tr>
</db:thead>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::Void</db:code></db:para>
</db:td>
<db:td><db:code>43</db:code></db:td>
<db:td>
<db:para>void</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::Bool</db:code></db:para>
</db:td>
<db:td><db:code>1</db:code></db:td>
<db:td>
<db:para>bool</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::Int</db:code></db:para>
</db:td>
<db:td><db:code>2</db:code></db:td>
<db:td>
<db:para>int</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::UInt</db:code></db:para>
</db:td>
<db:td><db:code>3</db:code></db:td>
<db:td>
<db:para>unsigned int</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::Double</db:code></db:para>
</db:td>
<db:td><db:code>6</db:code></db:td>
<db:td>
<db:para>double</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::QChar</db:code></db:para>
</db:td>
<db:td><db:code>7</db:code></db:td>
<db:td>
<db:para>QChar</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::QString</db:code></db:para>
</db:td>
<db:td><db:code>10</db:code></db:td>
<db:td>
<db:para>QString</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::QByteArray</db:code></db:para>
</db:td>
<db:td><db:code>12</db:code></db:td>
<db:td>
<db:para>QByteArray</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::Nullptr</db:code></db:para>
</db:td>
<db:td><db:code>51</db:code></db:td>
<db:td>
<db:para>std::nullptr_t</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::VoidStar</db:code></db:para>
</db:td>
<db:td><db:code>31</db:code></db:td>
<db:td>
<db:para>void *</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::Long</db:code></db:para>
</db:td>
<db:td><db:code>32</db:code></db:td>
<db:td>
<db:para>long</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::LongLong</db:code></db:para>
</db:td>
<db:td><db:code>4</db:code></db:td>
<db:td>
<db:para>LongLong</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::Short</db:code></db:para>
</db:td>
<db:td><db:code>33</db:code></db:td>
<db:td>
<db:para>short</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::Char</db:code></db:para>
</db:td>
<db:td><db:code>34</db:code></db:td>
<db:td>
<db:para>char</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::Char16</db:code></db:para>
</db:td>
<db:td><db:code>56</db:code></db:td>
<db:td>
<db:para>char16_t</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::Char32</db:code></db:para>
</db:td>
<db:td><db:code>57</db:code></db:td>
<db:td>
<db:para>char32_t</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::ULong</db:code></db:para>
</db:td>
<db:td><db:code>35</db:code></db:td>
<db:td>
<db:para>unsigned long</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::ULongLong</db:code></db:para>
</db:td>
<db:td><db:code>5</db:code></db:td>
<db:td>
<db:para>ULongLong</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::UShort</db:code></db:para>
</db:td>
<db:td><db:code>36</db:code></db:td>
<db:td>
<db:para>unsigned short</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::SChar</db:code></db:para>
</db:td>
<db:td><db:code>40</db:code></db:td>
<db:td>
<db:para>signed char</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::UChar</db:code></db:para>
</db:td>
<db:td><db:code>37</db:code></db:td>
<db:td>
<db:para>unsigned char</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::Float</db:code></db:para>
</db:td>
<db:td><db:code>38</db:code></db:td>
<db:td>
<db:para>float</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::QObjectStar</db:code></db:para>
</db:td>
<db:td><db:code>39</db:code></db:td>
<db:td>
<db:para><db:link xlink:href="qobject.xml">QObject</db:link> *</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::QVariant</db:code></db:para>
</db:td>
<db:td><db:code>41</db:code></db:td>
<db:td>
<db:para>QVariant</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::QCursor</db:code></db:para>
</db:td>
<db:td><db:code>0x100a</db:code></db:td>
<db:td>
<db:para>QCursor</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::QDate</db:code></db:para>
</db:td>
<db:td><db:code>14</db:code></db:td>
<db:td>
<db:para>QDate</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::QSize</db:code></db:para>
</db:td>
<db:td><db:code>21</db:code></db:td>
<db:td>
<db:para>QSize</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::QTime</db:code></db:para>
</db:td>
<db:td><db:code>15</db:code></db:td>
<db:td>
<db:para>QTime</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::QVariantList</db:code></db:para>
</db:td>
<db:td><db:code>9</db:code></db:td>
<db:td>
<db:para>QVariantList</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::QPolygon</db:code></db:para>
</db:td>
<db:td><db:code>0x1007</db:code></db:td>
<db:td>
<db:para>QPolygon</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::QPolygonF</db:code></db:para>
</db:td>
<db:td><db:code>0x1016</db:code></db:td>
<db:td>
<db:para>QPolygonF</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::QColor</db:code></db:para>
</db:td>
<db:td><db:code>0x1003</db:code></db:td>
<db:td>
<db:para>QColor</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::QColorSpace</db:code></db:para>
</db:td>
<db:td><db:code>0x1017</db:code></db:td>
<db:td>
<db:para>QColorSpace (introduced in Qt 5.15)</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::QSizeF</db:code></db:para>
</db:td>
<db:td><db:code>22</db:code></db:td>
<db:td>
<db:para>QSizeF</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::QRectF</db:code></db:para>
</db:td>
<db:td><db:code>20</db:code></db:td>
<db:td>
<db:para>QRectF</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::QLine</db:code></db:para>
</db:td>
<db:td><db:code>23</db:code></db:td>
<db:td>
<db:para>QLine</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::QTextLength</db:code></db:para>
</db:td>
<db:td><db:code>0x100d</db:code></db:td>
<db:td>
<db:para>QTextLength</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::QStringList</db:code></db:para>
</db:td>
<db:td><db:code>11</db:code></db:td>
<db:td>
<db:para>QStringList</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::QVariantMap</db:code></db:para>
</db:td>
<db:td><db:code>8</db:code></db:td>
<db:td>
<db:para>QVariantMap</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::QVariantHash</db:code></db:para>
</db:td>
<db:td><db:code>28</db:code></db:td>
<db:td>
<db:para>QVariantHash</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::QIcon</db:code></db:para>
</db:td>
<db:td><db:code>0x1005</db:code></db:td>
<db:td>
<db:para>QIcon</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::QPen</db:code></db:para>
</db:td>
<db:td><db:code>0x100c</db:code></db:td>
<db:td>
<db:para>QPen</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::QLineF</db:code></db:para>
</db:td>
<db:td><db:code>24</db:code></db:td>
<db:td>
<db:para>QLineF</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::QTextFormat</db:code></db:para>
</db:td>
<db:td><db:code>0x100e</db:code></db:td>
<db:td>
<db:para>QTextFormat</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::QRect</db:code></db:para>
</db:td>
<db:td><db:code>19</db:code></db:td>
<db:td>
<db:para>QRect</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::QPoint</db:code></db:para>
</db:td>
<db:td><db:code>25</db:code></db:td>
<db:td>
<db:para>QPoint</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::QUrl</db:code></db:para>
</db:td>
<db:td><db:code>17</db:code></db:td>
<db:td>
<db:para>QUrl</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::QRegularExpression</db:code></db:para>
</db:td>
<db:td><db:code>44</db:code></db:td>
<db:td>
<db:para>QRegularExpression</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::QDateTime</db:code></db:para>
</db:td>
<db:td><db:code>16</db:code></db:td>
<db:td>
<db:para>QDateTime</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::QPointF</db:code></db:para>
</db:td>
<db:td><db:code>26</db:code></db:td>
<db:td>
<db:para>QPointF</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::QPalette</db:code></db:para>
</db:td>
<db:td><db:code>0x1004</db:code></db:td>
<db:td>
<db:para>QPalette</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::QFont</db:code></db:para>
</db:td>
<db:td><db:code>0x1000</db:code></db:td>
<db:td>
<db:para>QFont</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::QBrush</db:code></db:para>
</db:td>
<db:td><db:code>0x1002</db:code></db:td>
<db:td>
<db:para>QBrush</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::QRegion</db:code></db:para>
</db:td>
<db:td><db:code>0x1008</db:code></db:td>
<db:td>
<db:para>QRegion</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::QBitArray</db:code></db:para>
</db:td>
<db:td><db:code>13</db:code></db:td>
<db:td>
<db:para>QBitArray</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::QImage</db:code></db:para>
</db:td>
<db:td><db:code>0x1006</db:code></db:td>
<db:td>
<db:para>QImage</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::QKeySequence</db:code></db:para>
</db:td>
<db:td><db:code>0x100b</db:code></db:td>
<db:td>
<db:para>QKeySequence</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::QSizePolicy</db:code></db:para>
</db:td>
<db:td><db:code>0x2000</db:code></db:td>
<db:td>
<db:para>QSizePolicy</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::QPixmap</db:code></db:para>
</db:td>
<db:td><db:code>0x1001</db:code></db:td>
<db:td>
<db:para>QPixmap</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::QLocale</db:code></db:para>
</db:td>
<db:td><db:code>18</db:code></db:td>
<db:td>
<db:para>QLocale</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::QBitmap</db:code></db:para>
</db:td>
<db:td><db:code>0x1009</db:code></db:td>
<db:td>
<db:para>QBitmap</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::QTransform</db:code></db:para>
</db:td>
<db:td><db:code>0x1010</db:code></db:td>
<db:td>
<db:para>QTransform</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::QMatrix4x4</db:code></db:para>
</db:td>
<db:td><db:code>0x1011</db:code></db:td>
<db:td>
<db:para>QMatrix4x4</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::QVector2D</db:code></db:para>
</db:td>
<db:td><db:code>0x1012</db:code></db:td>
<db:td>
<db:para>QVector2D</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::QVector3D</db:code></db:para>
</db:td>
<db:td><db:code>0x1013</db:code></db:td>
<db:td>
<db:para>QVector3D</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::QVector4D</db:code></db:para>
</db:td>
<db:td><db:code>0x1014</db:code></db:td>
<db:td>
<db:para>QVector4D</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::QQuaternion</db:code></db:para>
</db:td>
<db:td><db:code>0x1015</db:code></db:td>
<db:td>
<db:para>QQuaternion</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::QEasingCurve</db:code></db:para>
</db:td>
<db:td><db:code>29</db:code></db:td>
<db:td>
<db:para>QEasingCurve</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::QJsonValue</db:code></db:para>
</db:td>
<db:td><db:code>45</db:code></db:td>
<db:td>
<db:para>QJsonValue</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::QJsonObject</db:code></db:para>
</db:td>
<db:td><db:code>46</db:code></db:td>
<db:td>
<db:para>QJsonObject</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::QJsonArray</db:code></db:para>
</db:td>
<db:td><db:code>47</db:code></db:td>
<db:td>
<db:para>QJsonArray</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::QJsonDocument</db:code></db:para>
</db:td>
<db:td><db:code>48</db:code></db:td>
<db:td>
<db:para>QJsonDocument</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::QCborValue</db:code></db:para>
</db:td>
<db:td><db:code>53</db:code></db:td>
<db:td>
<db:para>QCborValue</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::QCborArray</db:code></db:para>
</db:td>
<db:td><db:code>54</db:code></db:td>
<db:td>
<db:para>QCborArray</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::QCborMap</db:code></db:para>
</db:td>
<db:td><db:code>55</db:code></db:td>
<db:td>
<db:para>QCborMap</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::QCborSimpleType</db:code></db:para>
</db:td>
<db:td><db:code>52</db:code></db:td>
<db:td>
<db:para>QCborSimpleType</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::QModelIndex</db:code></db:para>
</db:td>
<db:td><db:code>42</db:code></db:td>
<db:td>
<db:para>QModelIndex</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::QPersistentModelIndex</db:code></db:para>
</db:td>
<db:td><db:code>50</db:code></db:td>
<db:td>
<db:para>QPersistentModelIndex (introduced in Qt 5.5)</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::QUuid</db:code></db:para>
</db:td>
<db:td><db:code>30</db:code></db:td>
<db:td>
<db:para>QUuid</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::QByteArrayList</db:code></db:para>
</db:td>
<db:td><db:code>49</db:code></db:td>
<db:td>
<db:para>QByteArrayList</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::User</db:code></db:para>
</db:td>
<db:td><db:code>65536</db:code></db:td>
<db:td>
<db:para>Base value for user types</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::UnknownType</db:code></db:para>
</db:td>
<db:td><db:code>0</db:code></db:td>
<db:td>
<db:para>This is an invalid type id. It is returned from <db:link xlink:href="qmetatype.xml">QMetaType</db:link> for types that are not registered</db:para>
</db:td>
</db:tr>
</db:informaltable>
<db:para>Additional types can be registered using <db:link xlink:href="qmetatype.xml#Q_DECLARE_METATYPE">Q_DECLARE_METATYPE</db:link>().</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qmetatype.xml#type" role="deprecated">type</db:link>()</db:member>
<db:member><db:link xlink:href="qmetatype.xml#typeName" role="deprecated">typeName</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="TypeFlag-enum">
<db:title>enum QMetaType::TypeFlag</db:title>
<db:bridgehead renderas="sect2">flags QMetaType::TypeFlags</db:bridgehead>
<db:enumsynopsis>
<db:enumname>TypeFlag</db:enumname>
<db:enumitem>
<db:enumidentifier>NeedsConstruction</db:enumidentifier>
<db:enumvalue>0x1</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>NeedsDestruction</db:enumidentifier>
<db:enumvalue>0x2</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>RelocatableType</db:enumidentifier>
<db:enumvalue>0x4</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>MovableType</db:enumidentifier>
<db:enumvalue>RelocatableType</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>PointerToQObject</db:enumidentifier>
<db:enumvalue>0x8</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>IsEnumeration</db:enumidentifier>
<db:enumvalue>0x10</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>SharedPointerToQObject</db:enumidentifier>
<db:enumvalue>0x20</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>WeakPointerToQObject</db:enumidentifier>
<db:enumvalue>0x40</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>TrackingPointerToQObject</db:enumidentifier>
<db:enumvalue>0x80</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>IsUnsignedEnumeration</db:enumidentifier>
<db:enumvalue>0x100</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>IsGadget</db:enumidentifier>
<db:enumvalue>0x200</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>PointerToGadget</db:enumidentifier>
<db:enumvalue>0x400</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>IsPointer</db:enumidentifier>
<db:enumvalue>0x800</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>IsQmlList</db:enumidentifier>
<db:enumvalue>0x1000</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>IsConst</db:enumidentifier>
<db:enumvalue>0x2000</db:enumvalue>
</db:enumitem>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:enumsynopsis>
<db:typedefsynopsis>
<db:typedefname>QMetaType::TypeFlags</db:typedefname>
</db:typedefsynopsis>
<db:para>The enum describes attributes of a type supported by <db:link xlink:href="qmetatype.xml">QMetaType</db:link>.</db:para>
<db:informaltable>
<db:thead>
<db:tr>
<db:th>Constant</db:th>
<db:th>Value</db:th>
<db:th>Description</db:th>
</db:tr>
</db:thead>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::NeedsConstruction</db:code></db:para>
</db:td>
<db:td><db:code>0x1</db:code></db:td>
<db:td>
<db:para>This type has non-trivial constructors. If the flag is not set instances can be safely initialized with memset to 0.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::NeedsDestruction</db:code></db:para>
</db:td>
<db:td><db:code>0x2</db:code></db:td>
<db:td>
<db:para>This type has a non-trivial destructor. If the flag is not set calls to the destructor are not necessary before discarding objects.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::RelocatableType</db:code></db:para>
</db:td>
<db:td><db:code>0x4</db:code></db:td>
<db:td>
<db:para>An instance of a type having this attribute can be safely moved to a different memory location using memcpy.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::IsEnumeration</db:code></db:para>
</db:td>
<db:td><db:code>0x10</db:code></db:td>
<db:td>
<db:para>This type is an enumeration.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::IsUnsignedEnumeration</db:code></db:para>
</db:td>
<db:td><db:code>0x100</db:code></db:td>
<db:td>
<db:para>If the type is an Enumeration, its underlying type is unsigned.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::PointerToQObject</db:code></db:para>
</db:td>
<db:td><db:code>0x8</db:code></db:td>
<db:td>
<db:para>This type is a pointer to a derived of <db:link xlink:href="qobject.xml">QObject</db:link>.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::IsPointer</db:code></db:para>
</db:td>
<db:td><db:code>0x800</db:code></db:td>
<db:td>
<db:para>This type is a pointer to another type.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::IsConst</db:code></db:para>
</db:td>
<db:td><db:code>0x2000</db:code></db:td>
<db:td>
<db:para>Indicates that values of this types are immutable; for instance because they are pointers to const objects.</db:para>
</db:td>
</db:tr>
</db:informaltable>
<db:para>The <db:code>TypeFlags</db:code> type is a typedef for <db:code><db:link xlink:href="qflags.xml">QFlags</db:link>&lt;TypeFlag&gt;. </db:code>It stores an OR combination of <db:code>TypeFlag</db:code> values.</db:para>
</db:section>
</db:section>
<db:section xml:id="member-function-documentation">
<db:title>Member Function Documentation</db:title>
<db:section xml:id="QMetaType">
<db:title>[explicit, since 5.0] QMetaType::QMetaType(int <db:emphasis>typeId</db:emphasis>)</db:title>
<db:constructorsynopsis>
<db:methodname>QMetaType</db:methodname>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>typeId</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">constructor</db:synopsisinfo>
<db:synopsisinfo role="signature">QMetaType(int typeId)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:constructorsynopsis>
<db:para>Constructs a <db:link xlink:href="qmetatype.xml">QMetaType</db:link> object that contains all information about type <db:code role="parameter">typeId</db:code>.</db:para>
<db:para>This function was introduced in Qt 5.0.</db:para>
</db:section>
<db:section xml:id="alignOf">
<db:title>[constexpr, since 6.0] qsizetype QMetaType::alignOf() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>qsizetype</db:type>
<db:methodname>alignOf</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">qsizetype alignOf() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the alignment of the type in bytes (i.e. alignof(T), where T is the actual type for which this <db:link xlink:href="qmetatype.xml">QMetaType</db:link> instance was constructed for).</db:para>
<db:para>This function is typically used together with construct() to perform low-level management of the memory used by a type.</db:para>
<db:para>This function was introduced in Qt 6.0.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qmetatype.xml#construct" role="deprecated">QMetaType::construct</db:link>()</db:member>
<db:member><db:link xlink:href="qmetatype.xml#sizeOf-1">QMetaType::sizeOf</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="canConvert">
<db:title>[static] bool QMetaType::canConvert(QMetaType <db:emphasis>fromType</db:emphasis>, QMetaType <db:emphasis>toType</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:modifier>static</db:modifier>
<db:type>bool</db:type>
<db:methodname>canConvert</db:methodname>
<db:methodparam>
<db:type>QMetaType</db:type>
<db:parameter>fromType</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>QMetaType</db:type>
<db:parameter>toType</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool canConvert(QMetaType fromType, QMetaType toType)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns true if <db:link xlink:href="qmetatype.xml#convert">QMetaType::convert</db:link> can convert from <db:code role="parameter">fromType</db:code> to <db:code role="parameter">toType</db:code>.</db:para>
<db:para>The following conversions are supported by Qt:</db:para>
<db:informaltable style="generic">
<db:thead>
<db:tr>
<db:th>
<db:para>Type</db:para>
</db:th>
<db:th>
<db:para>Automatically Cast To</db:para>
</db:th>
</db:tr>
</db:thead>
<db:tr valign="top">
<db:td>
<db:para><db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::Bool</db:link></db:para>
</db:td>
<db:td>
<db:para><db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QChar</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::Double</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::Int</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::LongLong</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QString</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::UInt</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::ULongLong</db:link></db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para><db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QByteArray</db:link></db:para>
</db:td>
<db:td>
<db:para><db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::Double</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::Int</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::LongLong</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QString</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::UInt</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::ULongLong</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QUuid</db:link></db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para><db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QChar</db:link></db:para>
</db:td>
<db:td>
<db:para><db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::Bool</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::Int</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::UInt</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::LongLong</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::ULongLong</db:link></db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para><db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QColor</db:link></db:para>
</db:td>
<db:td>
<db:para><db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QString</db:link></db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para><db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QDate</db:link></db:para>
</db:td>
<db:td>
<db:para><db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QDateTime</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QString</db:link></db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para><db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QDateTime</db:link></db:para>
</db:td>
<db:td>
<db:para><db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QDate</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QString</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QTime</db:link></db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para><db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::Double</db:link></db:para>
</db:td>
<db:td>
<db:para><db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::Bool</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::Int</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::LongLong</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QString</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::UInt</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::ULongLong</db:link></db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para><db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QFont</db:link></db:para>
</db:td>
<db:td>
<db:para><db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QString</db:link></db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para><db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::Int</db:link></db:para>
</db:td>
<db:td>
<db:para><db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::Bool</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QChar</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::Double</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::LongLong</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QString</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::UInt</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::ULongLong</db:link></db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para><db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QKeySequence</db:link></db:para>
</db:td>
<db:td>
<db:para><db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::Int</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QString</db:link></db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para><db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QVariantList</db:link></db:para>
</db:td>
<db:td>
<db:para><db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QStringList</db:link> (if the list's items can be converted to QStrings)</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para><db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::LongLong</db:link></db:para>
</db:td>
<db:td>
<db:para><db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::Bool</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QByteArray</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QChar</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::Double</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::Int</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QString</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::UInt</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::ULongLong</db:link></db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para><db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QPoint</db:link></db:para>
</db:td>
<db:td>
<db:para><db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QPointF</db:link></db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para><db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QRect</db:link></db:para>
</db:td>
<db:td>
<db:para><db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QRectF</db:link></db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para><db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QString</db:link></db:para>
</db:td>
<db:td>
<db:para><db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::Bool</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QByteArray</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QChar</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QColor</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QDate</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QDateTime</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::Double</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QFont</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::Int</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QKeySequence</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::LongLong</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QStringList</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QTime</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::UInt</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::ULongLong</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QUuid</db:link></db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para><db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QStringList</db:link></db:para>
</db:td>
<db:td>
<db:para><db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QVariantList</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QString</db:link> (if the list contains exactly one item)</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para><db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QTime</db:link></db:para>
</db:td>
<db:td>
<db:para><db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QString</db:link></db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para><db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::UInt</db:link></db:para>
</db:td>
<db:td>
<db:para><db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::Bool</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QChar</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::Double</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::Int</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::LongLong</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QString</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::ULongLong</db:link></db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para><db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::ULongLong</db:link></db:para>
</db:td>
<db:td>
<db:para><db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::Bool</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QChar</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::Double</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::Int</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::LongLong</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QString</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::UInt</db:link></db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para><db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QUuid</db:link></db:para>
</db:td>
<db:td>
<db:para><db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QByteArray</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QString</db:link></db:para>
</db:td>
</db:tr>
</db:informaltable>
<db:para>Casting between primitive type (int, float, bool etc.) is supported.</db:para>
<db:para>Converting between pointers of types derived from <db:link xlink:href="qobject.xml">QObject</db:link> will also return true for this function if a <db:link xlink:href="qobject.xml#qobject_cast-1">qobject_cast</db:link> from the type described by <db:code role="parameter">fromType</db:code> to the type described by <db:code role="parameter">toType</db:code> would succeed.</db:para>
<db:para>A cast from a sequential container will also return true for this function if the <db:code role="parameter">toType</db:code> is <db:link xlink:href="qmetatype.xml#Type-enum">QVariantList</db:link>.</db:para>
<db:para>Similarly, a cast from an associative container will also return true for this function the <db:code role="parameter">toType</db:code> is <db:link xlink:href="qmetatype.xml#Type-enum">QVariantHash</db:link> or <db:link xlink:href="qmetatype.xml#Type-enum">QVariantMap</db:link>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qmetatype.xml#convert">convert</db:link>()</db:member>
<db:member><db:link xlink:href="qsequentialiterable.xml">QSequentialIterable</db:link></db:member>
<db:member><db:link xlink:href="qmetatype.xml#Q_DECLARE_SEQUENTIAL_CONTAINER_METATYPE">Q_DECLARE_SEQUENTIAL_CONTAINER_METATYPE</db:link>()</db:member>
<db:member><db:link xlink:href="qassociativeiterable.xml">QAssociativeIterable</db:link></db:member>
<db:member><db:link xlink:href="qmetatype.xml#Q_DECLARE_ASSOCIATIVE_CONTAINER_METATYPE">Q_DECLARE_ASSOCIATIVE_CONTAINER_METATYPE</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="canView">
<db:title>[static] bool QMetaType::canView(QMetaType <db:emphasis>fromType</db:emphasis>, QMetaType <db:emphasis>toType</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:modifier>static</db:modifier>
<db:type>bool</db:type>
<db:methodname>canView</db:methodname>
<db:methodparam>
<db:type>QMetaType</db:type>
<db:parameter>fromType</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>QMetaType</db:type>
<db:parameter>toType</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool canView(QMetaType fromType, QMetaType toType)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns true if <db:link xlink:href="qmetatype.xml#view">QMetaType::view</db:link> can create a mutable view of type <db:code role="parameter">toType</db:code> on type <db:code role="parameter">fromType</db:code>.</db:para>
<db:para>Converting between pointers of types derived from <db:link xlink:href="qobject.xml">QObject</db:link> will return true for this function if a <db:link xlink:href="qobject.xml#qobject_cast-1">qobject_cast</db:link> from the type described by <db:code role="parameter">fromType</db:code> to the type described by <db:code role="parameter">toType</db:code> would succeed.</db:para>
<db:para>You can create a mutable view of type <db:link xlink:href="qsequentialiterable.xml">QSequentialIterable</db:link> on any container registered with <db:link xlink:href="qmetatype.xml#Q_DECLARE_SEQUENTIAL_CONTAINER_METATYPE">Q_DECLARE_SEQUENTIAL_CONTAINER_METATYPE</db:link>().</db:para>
<db:para>Similarly you can create a mutable view of type <db:link xlink:href="qassociativeiterable.xml">QAssociativeIterable</db:link> on any container registered with <db:link xlink:href="qmetatype.xml#Q_DECLARE_ASSOCIATIVE_CONTAINER_METATYPE">Q_DECLARE_ASSOCIATIVE_CONTAINER_METATYPE</db:link>().</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qmetatype.xml#convert">convert</db:link>()</db:member>
<db:member><db:link xlink:href="qsequentialiterable.xml">QSequentialIterable</db:link></db:member>
<db:member><db:link xlink:href="qmetatype.xml#Q_DECLARE_SEQUENTIAL_CONTAINER_METATYPE">Q_DECLARE_SEQUENTIAL_CONTAINER_METATYPE</db:link>()</db:member>
<db:member><db:link xlink:href="qassociativeiterable.xml">QAssociativeIterable</db:link></db:member>
<db:member><db:link xlink:href="qmetatype.xml#Q_DECLARE_ASSOCIATIVE_CONTAINER_METATYPE">Q_DECLARE_ASSOCIATIVE_CONTAINER_METATYPE</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="compare">
<db:title>[since 6.0] QPartialOrdering QMetaType::compare(const void *<db:emphasis>lhs</db:emphasis>, const void *<db:emphasis>rhs</db:emphasis>) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QPartialOrdering</db:type>
<db:methodname>compare</db:methodname>
<db:methodparam>
<db:type>const void *</db:type>
<db:parameter>lhs</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const void *</db:type>
<db:parameter>rhs</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QPartialOrdering compare(const void *lhs, const void *rhs) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Compares the objects at <db:code role="parameter">lhs</db:code> and <db:code role="parameter">rhs</db:code> for ordering.</db:para>
<db:para>Returns <db:link xlink:href="qpartialordering.xml#Unordered-var">QPartialOrdering::Unordered</db:link> if comparison is not supported or the values are unordered. Otherwise, returns <db:link xlink:href="qpartialordering.xml#Less-var">QPartialOrdering::Less</db:link>, <db:link xlink:href="qpartialordering.xml#Equivalent-var">QPartialOrdering::Equivalent</db:link> or <db:link xlink:href="qpartialordering.xml#Greater-var">QPartialOrdering::Greater</db:link> if <db:code role="parameter">lhs</db:code> is less than, equivalent to or greater than <db:code role="parameter">rhs</db:code>, respectively.</db:para>
<db:para>Both objects must be of the type described by this metatype. If either <db:code role="parameter">lhs</db:code> or <db:code role="parameter">rhs</db:code> is nullptr, the values are unordered. Comparison is only supported if the type's less than operator was visible to the metatype declaration.</db:para>
<db:para>If the type's equality operator was also visible, values will only compare equal if the equality operator says they are. In the absence of an equality operator, when neither value is less than the other, values are considered equal; if equality is also available and two such values are not equal, they are considered unordered, just as NaN (not a number) values of a floating point type lie outside its ordering.</db:para>
<db:note>
<db:para>If no less than operator was visible to the metatype declaration, values are unordered even if an equality operator visible to the declaration considers them equal: compare() == 0 only agrees with <db:link xlink:href="qmetatype.xml#equals">equals</db:link>() if the less than operator was visible.</db:para>
</db:note>
<db:para>This function was introduced in Qt 6.0.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qmetatype.xml#equals">equals</db:link>()</db:member>
<db:member><db:link xlink:href="qmetatype.xml#isOrdered">isOrdered</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="construct-1">
<db:title>[since 5.0] void *QMetaType::construct(void *<db:emphasis>where</db:emphasis>, const void *<db:emphasis>copy</db:emphasis> = nullptr) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>void *</db:type>
<db:methodname>construct</db:methodname>
<db:methodparam>
<db:type>void *</db:type>
<db:parameter>where</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const void *</db:type>
<db:parameter>copy</db:parameter>
<db:initializer>nullptr</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">void * construct(void *where, const void *copy) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Constructs a value of the type that this <db:link xlink:href="qmetatype.xml">QMetaType</db:link> instance was constructed for in the existing memory addressed by <db:code role="parameter">where</db:code>, that is a copy of <db:code role="parameter">copy</db:code>, and returns <db:code role="parameter">where</db:code>. If <db:code role="parameter">copy</db:code> is zero, the value is default constructed.</db:para>
<db:para>This is a low-level function for explicitly managing the memory used to store the type. Consider calling create() if you don't need this level of control (that is, use &quot;new&quot; rather than &quot;placement new&quot;).</db:para>
<db:para>You must ensure that <db:code role="parameter">where</db:code> points to a location where the new value can be stored and that <db:code role="parameter">where</db:code> is suitably aligned. The type's size can be queried by calling <db:link xlink:href="qmetatype.xml#sizeOf-1">sizeOf</db:link>().</db:para>
<db:para>The rule of thumb for alignment is that a type is aligned to its natural boundary, which is the smallest power of 2 that is bigger than the type, unless that alignment is larger than the maximum useful alignment for the platform. For practical purposes, alignment larger than 2 * sizeof(void*) is only necessary for special hardware instructions (e.g., aligned SSE loads and stores on x86).</db:para>
<db:para>This function was introduced in Qt 5.0.</db:para>
</db:section>
<db:section xml:id="convert">
<db:title>[static, since 5.2] bool QMetaType::convert(QMetaType <db:emphasis>fromType</db:emphasis>, const void *<db:emphasis>from</db:emphasis>, QMetaType <db:emphasis>toType</db:emphasis>, void *<db:emphasis>to</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:modifier>static</db:modifier>
<db:type>bool</db:type>
<db:methodname>convert</db:methodname>
<db:methodparam>
<db:type>QMetaType</db:type>
<db:parameter>fromType</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const void *</db:type>
<db:parameter>from</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>QMetaType</db:type>
<db:parameter>toType</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>void *</db:type>
<db:parameter>to</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool convert(QMetaType fromType, const void *from, QMetaType toType, void *to)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Converts the object at <db:code role="parameter">from</db:code> from <db:code role="parameter">fromType</db:code> to the preallocated space at <db:code role="parameter">to</db:code> typed <db:code role="parameter">toType</db:code>. Returns true, if the conversion succeeded, otherwise false.</db:para>
<db:para>Both <db:code role="parameter">from</db:code> and <db:code role="parameter">to</db:code> have to be valid pointers.</db:para>
<db:para>This function was introduced in Qt 5.2.</db:para>
</db:section>
<db:section xml:id="create-1">
<db:title>[since 5.0] void *QMetaType::create(const void *<db:emphasis>copy</db:emphasis> = nullptr) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>void *</db:type>
<db:methodname>create</db:methodname>
<db:methodparam>
<db:type>const void *</db:type>
<db:parameter>copy</db:parameter>
<db:initializer>nullptr</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">void * create(const void *copy) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns a copy of <db:code role="parameter">copy</db:code>, assuming it is of the type that this <db:link xlink:href="qmetatype.xml">QMetaType</db:link> instance was created for. If <db:code role="parameter">copy</db:code> is nullptr, creates a default constructed instance.</db:para>
<db:para>This function was introduced in Qt 5.0.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qmetatype.xml#destroy" role="deprecated">QMetaType::destroy</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="debugStream">
<db:title>[since 5.2] bool QMetaType::debugStream(QDebug &amp;<db:emphasis>dbg</db:emphasis>, const void *<db:emphasis>rhs</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>bool</db:type>
<db:methodname>debugStream</db:methodname>
<db:methodparam>
<db:type>QDebug &amp;</db:type>
<db:parameter>dbg</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const void *</db:type>
<db:parameter>rhs</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool debugStream(QDebug &amp;dbg, const void *rhs)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Streams the object at <db:code role="parameter">rhs</db:code> to the debug stream <db:code role="parameter">dbg</db:code>. Returns true on success, otherwise false.</db:para>
<db:para>This function was introduced in Qt 5.2.</db:para>
</db:section>
<db:section xml:id="destroy-1">
<db:title>[since 5.0] void QMetaType::destroy(void *<db:emphasis>data</db:emphasis>) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:void/>
<db:methodname>destroy</db:methodname>
<db:methodparam>
<db:type>void *</db:type>
<db:parameter>data</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">void destroy(void *data) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Destroys the <db:code role="parameter">data</db:code>, assuming it is of the type that this <db:link xlink:href="qmetatype.xml">QMetaType</db:link> instance was created for.</db:para>
<db:para>This function was introduced in Qt 5.0.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qmetatype.xml#create" role="deprecated">QMetaType::create</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="destruct-1">
<db:title>[since 5.0] void QMetaType::destruct(void *<db:emphasis>data</db:emphasis>) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:void/>
<db:methodname>destruct</db:methodname>
<db:methodparam>
<db:type>void *</db:type>
<db:parameter>data</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">void destruct(void *data) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Destructs the value, located at <db:code role="parameter">data</db:code>, assuming that it is of the type for which this <db:link xlink:href="qmetatype.xml">QMetaType</db:link> instance was constructed for.</db:para>
<db:para>Unlike destroy(), this function only invokes the type's destructor, it doesn't invoke the delete operator.</db:para>
<db:para>This function was introduced in Qt 5.0.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qmetatype.xml#construct" role="deprecated">QMetaType::construct</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="equals">
<db:title>[since 6.0] bool QMetaType::equals(const void *<db:emphasis>lhs</db:emphasis>, const void *<db:emphasis>rhs</db:emphasis>) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>bool</db:type>
<db:methodname>equals</db:methodname>
<db:methodparam>
<db:type>const void *</db:type>
<db:parameter>lhs</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const void *</db:type>
<db:parameter>rhs</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool equals(const void *lhs, const void *rhs) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Compares the objects at <db:code role="parameter">lhs</db:code> and <db:code role="parameter">rhs</db:code> for equality.</db:para>
<db:para>Both objects must be of the type described by this metatype. Can only compare the two objects if a less than or equality operator for the type was visible to the metatype declaration. Otherwise, the metatype never considers values equal. When an equality operator was visible to the metatype declaration, it is authoritative; otherwise, if less than is visible, when neither value is less than the other, the two are considered equal. If values are unordered (see <db:link xlink:href="qmetatype.xml#compare">compare</db:link>() for details) they are not equal.</db:para>
<db:para>Returns true if the two objects compare equal, otherwise false.</db:para>
<db:para>This function was introduced in Qt 6.0.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qmetatype.xml#isEqualityComparable">isEqualityComparable</db:link>()</db:member>
<db:member><db:link xlink:href="qmetatype.xml#compare">compare</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="flags">
<db:title>[constexpr, since 5.0] QMetaType::TypeFlags QMetaType::flags() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QMetaType::TypeFlags</db:type>
<db:methodname>flags</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QMetaType::TypeFlags flags() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns flags of the type for which this <db:link xlink:href="qmetatype.xml">QMetaType</db:link> instance was constructed.</db:para>
<db:para>This function was introduced in Qt 5.0.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qmetatype.xml#TypeFlag-enum">QMetaType::TypeFlags</db:link></db:member>
<db:member><db:link xlink:href="">QMetaType::flags</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="fromName">
<db:title>[static] QMetaType QMetaType::fromName(QByteArrayView <db:emphasis>typeName</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:modifier>static</db:modifier>
<db:type>QMetaType</db:type>
<db:methodname>fromName</db:methodname>
<db:methodparam>
<db:type>QByteArrayView</db:type>
<db:parameter>typeName</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QMetaType fromName(QByteArrayView typeName)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns a <db:link xlink:href="qmetatype.xml">QMetaType</db:link> matching <db:code role="parameter">typeName</db:code>. The returned object is not valid if the typeName is not known to <db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:para>
</db:section>
<db:section xml:id="fromType">
<db:title>[static constexpr, since 5.15] QMetaType QMetaType::fromType()</db:title>
<db:methodsynopsis>
<db:modifier>static</db:modifier>
<db:type>QMetaType</db:type>
<db:methodname>fromType</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QMetaType fromType()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the <db:link xlink:href="qmetatype.xml">QMetaType</db:link> corresponding to the type in the template parameter.</db:para>
<db:para>This function was introduced in Qt 5.15.</db:para>
</db:section>
<db:section xml:id="hasRegisteredConverterFunction">
<db:title>[static, since 5.2] bool QMetaType::hasRegisteredConverterFunction(QMetaType <db:emphasis>fromType</db:emphasis>, QMetaType <db:emphasis>toType</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:modifier>static</db:modifier>
<db:type>bool</db:type>
<db:methodname>hasRegisteredConverterFunction</db:methodname>
<db:methodparam>
<db:type>QMetaType</db:type>
<db:parameter>fromType</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>QMetaType</db:type>
<db:parameter>toType</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool hasRegisteredConverterFunction(QMetaType fromType, QMetaType toType)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns true, if the meta type system has a registered conversion from meta type id <db:code role="parameter">fromType</db:code> to <db:code role="parameter">toType</db:code></db:para>
<db:para>This function was introduced in Qt 5.2.</db:para>
</db:section>
<db:section xml:id="hasRegisteredConverterFunction-1">
<db:title>[static, since 5.2] bool QMetaType::hasRegisteredConverterFunction()</db:title>
<db:methodsynopsis>
<db:modifier>static</db:modifier>
<db:type>bool</db:type>
<db:methodname>hasRegisteredConverterFunction</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">bool hasRegisteredConverterFunction()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns true, if the meta type system has a registered conversion from type From to type To.</db:para>
<db:para>This is an overloaded function.</db:para>
<db:para>This function was introduced in Qt 5.2.</db:para>
</db:section>
<db:section xml:id="hasRegisteredDataStreamOperators">
<db:title>[since 6.1] bool QMetaType::hasRegisteredDataStreamOperators() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>bool</db:type>
<db:methodname>hasRegisteredDataStreamOperators</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool hasRegisteredDataStreamOperators() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns true, if the meta type system has registered data stream operators for this meta type.</db:para>
<db:para>This function was introduced in Qt 6.1.</db:para>
</db:section>
<db:section xml:id="hasRegisteredDebugStreamOperator">
<db:title>[since 6.0] bool QMetaType::hasRegisteredDebugStreamOperator() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>bool</db:type>
<db:methodname>hasRegisteredDebugStreamOperator</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool hasRegisteredDebugStreamOperator() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns true, if the meta type system has a registered debug stream operator for this meta type.</db:para>
<db:para>This function was introduced in Qt 6.0.</db:para>
</db:section>
<db:section xml:id="hasRegisteredMutableViewFunction">
<db:title>[static, since 5.2] bool QMetaType::hasRegisteredMutableViewFunction(QMetaType <db:emphasis>fromType</db:emphasis>, QMetaType <db:emphasis>toType</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:modifier>static</db:modifier>
<db:type>bool</db:type>
<db:methodname>hasRegisteredMutableViewFunction</db:methodname>
<db:methodparam>
<db:type>QMetaType</db:type>
<db:parameter>fromType</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>QMetaType</db:type>
<db:parameter>toType</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool hasRegisteredMutableViewFunction(QMetaType fromType, QMetaType toType)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns true, if the meta type system has a registered mutable view on meta type id <db:code role="parameter">fromType</db:code> of meta type id <db:code role="parameter">toType</db:code>.</db:para>
<db:para>This function was introduced in Qt 5.2.</db:para>
</db:section>
<db:section xml:id="hasRegisteredMutableViewFunction-1">
<db:title>[static, since 6.0] bool QMetaType::hasRegisteredMutableViewFunction()</db:title>
<db:methodsynopsis>
<db:modifier>static</db:modifier>
<db:type>bool</db:type>
<db:methodname>hasRegisteredMutableViewFunction</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">bool hasRegisteredMutableViewFunction()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns true, if the meta type system has a registered mutable view on type From of type To.</db:para>
<db:para>This is an overloaded function.</db:para>
<db:para>This function was introduced in Qt 6.0.</db:para>
</db:section>
<db:section xml:id="id">
<db:title>[since 5.13] int QMetaType::id() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>int</db:type>
<db:methodname>id</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">int id() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns id type hold by this QMetatype instance.</db:para>
<db:para>This function was introduced in Qt 5.13.</db:para>
</db:section>
<db:section xml:id="isEqualityComparable">
<db:title>bool QMetaType::isEqualityComparable() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>bool</db:type>
<db:methodname>isEqualityComparable</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool isEqualityComparable() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns true if a less than or equality operator for the type described by this metatype was visible to the metatype declaration, otherwise false.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qmetatype.xml#equals">equals</db:link>()</db:member>
<db:member><db:link xlink:href="qmetatype.xml#isOrdered">isOrdered</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="isOrdered">
<db:title>bool QMetaType::isOrdered() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>bool</db:type>
<db:methodname>isOrdered</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool isOrdered() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns true if a less than operator for the type described by this metatype was visible to the metatype declaration, otherwise false.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qmetatype.xml#compare">compare</db:link>()</db:member>
<db:member><db:link xlink:href="qmetatype.xml#isEqualityComparable">isEqualityComparable</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="isRegistered">
<db:title>[static] bool QMetaType::isRegistered(int <db:emphasis>type</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:modifier>static</db:modifier>
<db:type>bool</db:type>
<db:methodname>isRegistered</db:methodname>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>type</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool isRegistered(int type)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns true if the datatype with ID <db:code role="parameter">type</db:code> is registered; otherwise returns false.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qmetatype.xml#type" role="deprecated">type</db:link>()</db:member>
<db:member><db:link xlink:href="qmetatype.xml#typeName" role="deprecated">typeName</db:link>()</db:member>
<db:member><db:link xlink:href="qmetatype.xml#Type-enum">Type</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="isRegistered-1">
<db:title>[since 5.0] bool QMetaType::isRegistered() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>bool</db:type>
<db:methodname>isRegistered</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">bool isRegistered() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns true if this <db:link xlink:href="qmetatype.xml">QMetaType</db:link> object contains valid information about a type, false otherwise.</db:para>
<db:para>This function was introduced in Qt 5.0.</db:para>
</db:section>
<db:section xml:id="isValid">
<db:title>[since 5.0] bool QMetaType::isValid() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>bool</db:type>
<db:methodname>isValid</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool isValid() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns true if this <db:link xlink:href="qmetatype.xml">QMetaType</db:link> object contains valid information about a type, false otherwise.</db:para>
<db:para>This function was introduced in Qt 5.0.</db:para>
</db:section>
<db:section xml:id="load">
<db:title>bool QMetaType::load(QDataStream &amp;<db:emphasis>stream</db:emphasis>, void *<db:emphasis>data</db:emphasis>) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>bool</db:type>
<db:methodname>load</db:methodname>
<db:methodparam>
<db:type>QDataStream &amp;</db:type>
<db:parameter>stream</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>void *</db:type>
<db:parameter>data</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool load(QDataStream &amp;stream, void *data) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Reads the object of this type from the given <db:code role="parameter">stream</db:code> into <db:code role="parameter">data</db:code>. Returns true if the object is loaded successfully; otherwise returns false.</db:para>
<db:para>The type must have been registered with <db:link xlink:href="qmetatype.xml#Q_DECLARE_METATYPE">Q_DECLARE_METATYPE</db:link>() beforehand.</db:para>
<db:para>Normally, you should not need to call this function directly. Instead, use <db:link xlink:href="qmetatype.xml#Type-enum">QVariant</db:link>'s operator&gt;&gt;(), which relies on load() to stream custom types.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qmetatype.xml#save">save</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="metaObject">
<db:title>[constexpr, since 5.5] const QMetaObject *QMetaType::metaObject() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>const QMetaObject *</db:type>
<db:methodname>metaObject</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">const QMetaObject * metaObject() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>return a <db:link xlink:href="qmetaobject.xml">QMetaObject</db:link> relative to this type.</db:para>
<db:para>If the type is a pointer type to a subclass of <db:link xlink:href="qobject.xml">QObject</db:link>, <db:link xlink:href="qmetatype.xml#flags">flags</db:link>() contains <db:link xlink:href="qmetatype.xml#TypeFlag-enum">QMetaType::PointerToQObject</db:link> and this function returns the corresponding <db:link xlink:href="qmetaobject.xml">QMetaObject</db:link>. This can be used to in combinaison with QMetaObject::construct to create <db:link xlink:href="qobject.xml">QObject</db:link> of this type.</db:para>
<db:para>If the type is a <db:link xlink:href="qobject.xml#Q_GADGET">Q_GADGET</db:link>, <db:link xlink:href="qmetatype.xml#flags">flags</db:link>() contains <db:link xlink:href="qmetatype.xml#TypeFlag-enum">QMetaType::IsGadget</db:link>, and this function returns its <db:link xlink:href="qmetaobject.xml">QMetaObject</db:link>. This can be used to retrieve <db:link xlink:href="qmetamethod.xml">QMetaMethod</db:link> and <db:link xlink:href="qmetaproperty.xml">QMetaProperty</db:link> and use them on a pointer of this type. (given by <db:link xlink:href="qvariant.xml#data">QVariant::data</db:link> for example)</db:para>
<db:para>If the type is an enumeration, <db:link xlink:href="qmetatype.xml#flags">flags</db:link>() contains <db:link xlink:href="qmetatype.xml#TypeFlag-enum">QMetaType::IsEnumeration</db:link>, and this function returns the <db:link xlink:href="qmetaobject.xml">QMetaObject</db:link> of the enclosing object if the enum was registered as a <db:link xlink:href="qobject.xml#Q_ENUM">Q_ENUM</db:link> or nullptr otherwise</db:para>
<db:para>This function was introduced in Qt 5.5.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qmetatype.xml#flags">QMetaType::flags</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="name">
<db:title>[constexpr, since 5.15] const char *QMetaType::name() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>const char *</db:type>
<db:methodname>name</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">const char * name() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the type name associated with this <db:link xlink:href="qmetatype.xml">QMetaType</db:link>, or a null pointer if no matching type was found. The returned pointer must not be deleted.</db:para>
<db:para>This function was introduced in Qt 5.15.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qmetatype.xml#typeName" role="deprecated">typeName</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="registerConverter">
<db:title>[static, since 5.2] bool QMetaType::registerConverter()</db:title>
<db:methodsynopsis>
<db:modifier>static</db:modifier>
<db:type>bool</db:type>
<db:methodname>registerConverter</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool registerConverter()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Registers the possibility of an implicit conversion from type From to type To in the meta type system. Returns true if the registration succeeded, otherwise false.</db:para>
<db:programlisting language="cpp">class Counter {
  int number = 0;
public:
  int value() const { return number; }
  operator int() const { return value(); }
  void increment() {++number;}
};
QMetaType::registerConverter&amp;lt;Counter, int&amp;gt;();
</db:programlisting>
<db:para>This function was introduced in Qt 5.2.</db:para>
</db:section>
<db:section xml:id="registerConverter-1">
<db:title>[static, since 5.2] bool QMetaType::registerConverter(To (From::*)() const <db:emphasis>function</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:modifier>static</db:modifier>
<db:type>bool</db:type>
<db:methodname>registerConverter</db:methodname>
<db:methodparam>
<db:type>To (From::*)() const</db:type>
<db:parameter>function</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">bool registerConverter(To (From::*)() const function)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>Registers a method <db:code role="parameter">function</db:code> like To From::function() const as converter from type From to type To in the meta type system. Returns true if the registration succeeded, otherwise false.</db:para>
<db:programlisting language="cpp">struct Coordinates {
  int x;
  int y;
  int z;

  QString toString() const { return u&quot;[x: %1; y: %2, z: %3]&quot;_qs.arg(QString::number(x),
    QString::number(y),
    QString::number(z)); }
};
QMetaType::registerConverter&amp;lt;Coordinates, QString&amp;gt;(&amp;amp;Coordinates::toString);
</db:programlisting>
<db:para>This function was introduced in Qt 5.2.</db:para>
</db:section>
<db:section xml:id="registerConverter-2">
<db:title>[static, since 5.2] bool QMetaType::registerConverter(To (From::*)(bool *) const <db:emphasis>function</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:modifier>static</db:modifier>
<db:type>bool</db:type>
<db:methodname>registerConverter</db:methodname>
<db:methodparam>
<db:type>To (From::*)(bool *) const</db:type>
<db:parameter>function</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">2</db:synopsisinfo>
<db:synopsisinfo role="signature">bool registerConverter(To (From::*)(bool *) const function)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>Registers a method <db:code role="parameter">function</db:code> like To From::function(bool *ok) const as converter from type From to type To in the meta type system. Returns true if the registration succeeded, otherwise false.</db:para>
<db:para>The ok pointer can be used by the function to indicate whether the conversion succeeded.</db:para>
<db:programlisting language="cpp">struct BigNumber {
    long long l;

    int toInt(bool *ok = nullptr) const {
      const bool canConvertSafely = l &amp;lt; std::numeric_limits&amp;lt;int&amp;gt;::max();
      if (ok)
        *ok = canConvertSafely;
      return l;
    }
};
QMetaType::registerConverter&amp;lt;BigNumber, int&amp;gt;(&amp;amp;BigNumber::toInt);
</db:programlisting>
<db:para>This function was introduced in Qt 5.2.</db:para>
</db:section>
<db:section xml:id="registerConverter-3">
<db:title>[static, since 5.2] bool QMetaType::registerConverter(UnaryFunction <db:emphasis>function</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:modifier>static</db:modifier>
<db:type>bool</db:type>
<db:methodname>registerConverter</db:methodname>
<db:methodparam>
<db:type>UnaryFunction</db:type>
<db:parameter>function</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">3</db:synopsisinfo>
<db:synopsisinfo role="signature">bool registerConverter(UnaryFunction function)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>Registers a unary function object <db:code role="parameter">function</db:code> as converter from type From to type To in the meta type system. Returns true if the registration succeeded, otherwise false.</db:para>
<db:para><db:code role="parameter">function</db:code> must take an instance of type From and return an instance of To. It can be a function pointer, a lambda or a functor object.</db:para>
<db:programlisting language="cpp">QMetaType::registerConverter&amp;lt;CustomStringType, QString&amp;gt;([](const CustomStringType &amp;amp;str) {
    return QString::fromUtf8(str.data());
});
</db:programlisting>
<db:para>This function was introduced in Qt 5.2.</db:para>
</db:section>
<db:section xml:id="registerMutableView">
<db:title>[static, since 6.0] bool QMetaType::registerMutableView(To (From::*)() <db:emphasis>function</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:modifier>static</db:modifier>
<db:type>bool</db:type>
<db:methodname>registerMutableView</db:methodname>
<db:methodparam>
<db:type>To (From::*)()</db:type>
<db:parameter>function</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool registerMutableView(To (From::*)() function)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>Registers a method <db:code role="parameter">function</db:code> like To From::function() as mutable view of type To on type From in the meta type system. Returns true if the registration succeeded, otherwise false.</db:para>
<db:para>This function was introduced in Qt 6.0.</db:para>
</db:section>
<db:section xml:id="registerMutableView-1">
<db:title>[static, since 6.0] bool QMetaType::registerMutableView(UnaryFunction <db:emphasis>function</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:modifier>static</db:modifier>
<db:type>bool</db:type>
<db:methodname>registerMutableView</db:methodname>
<db:methodparam>
<db:type>UnaryFunction</db:type>
<db:parameter>function</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">bool registerMutableView(UnaryFunction function)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>Registers a unary function object <db:code role="parameter">function</db:code> as mutable view of type To on type From in the meta type system. Returns true if the registration succeeded, otherwise false.</db:para>
<db:para>This function was introduced in Qt 6.0.</db:para>
</db:section>
<db:section xml:id="save">
<db:title>bool QMetaType::save(QDataStream &amp;<db:emphasis>stream</db:emphasis>, const void *<db:emphasis>data</db:emphasis>) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>bool</db:type>
<db:methodname>save</db:methodname>
<db:methodparam>
<db:type>QDataStream &amp;</db:type>
<db:parameter>stream</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const void *</db:type>
<db:parameter>data</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool save(QDataStream &amp;stream, const void *data) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Writes the object pointed to by <db:code role="parameter">data</db:code> to the given <db:code role="parameter">stream</db:code>. Returns true if the object is saved successfully; otherwise returns false.</db:para>
<db:para>The type must have been registered with <db:link xlink:href="qmetatype.xml#Q_DECLARE_METATYPE">Q_DECLARE_METATYPE</db:link>() beforehand.</db:para>
<db:para>Normally, you should not need to call this function directly. Instead, use <db:link xlink:href="qmetatype.xml#Type-enum">QVariant</db:link>'s operator&lt;&lt;(), which relies on save() to stream custom types.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qmetatype.xml#load">load</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="sizeOf-1">
<db:title>[constexpr, since 5.0] qsizetype QMetaType::sizeOf() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>qsizetype</db:type>
<db:methodname>sizeOf</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">qsizetype sizeOf() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the size of the type in bytes (i.e. sizeof(T), where T is the actual type for which this <db:link xlink:href="qmetatype.xml">QMetaType</db:link> instance was constructed for).</db:para>
<db:para>This function is typically used together with construct() to perform low-level management of the memory used by a type.</db:para>
<db:para>This function was introduced in Qt 5.0.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qmetatype.xml#construct" role="deprecated">QMetaType::construct</db:link>()</db:member>
<db:member><db:link xlink:href="">QMetaType::sizeOf</db:link>()</db:member>
<db:member><db:link xlink:href="qmetatype.xml#alignOf">QMetaType::alignOf</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="view">
<db:title>[static, since 6.0] bool QMetaType::view(QMetaType <db:emphasis>fromType</db:emphasis>, void *<db:emphasis>from</db:emphasis>, QMetaType <db:emphasis>toType</db:emphasis>, void *<db:emphasis>to</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:modifier>static</db:modifier>
<db:type>bool</db:type>
<db:methodname>view</db:methodname>
<db:methodparam>
<db:type>QMetaType</db:type>
<db:parameter>fromType</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>void *</db:type>
<db:parameter>from</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>QMetaType</db:type>
<db:parameter>toType</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>void *</db:type>
<db:parameter>to</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool view(QMetaType fromType, void *from, QMetaType toType, void *to)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Creates a mutable view on the object at <db:code role="parameter">from</db:code> of <db:code role="parameter">fromType</db:code> in the preallocated space at <db:code role="parameter">to</db:code> typed <db:code role="parameter">toType</db:code>. Returns true if the conversion succeeded, otherwise false.</db:para>
<db:para>This function was introduced in Qt 6.0.</db:para>
</db:section>
</db:section>
<db:section xml:id="related-non-members">
<db:title>Related Non-Members</db:title>
<db:section xml:id="qMetaTypeId">
<db:title>[constexpr] int qMetaTypeId()</db:title>
<db:methodsynopsis>
<db:type>int</db:type>
<db:methodname>qMetaTypeId</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">int qMetaTypeId()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the meta type id of type T at compile time. If the type was not declared with <db:link xlink:href="qmetatype.xml#Q_DECLARE_METATYPE">Q_DECLARE_METATYPE</db:link>(), compilation will fail.</db:para>
<db:para>Typical usage:</db:para>
<db:programlisting language="cpp">int id = qMetaTypeId&amp;lt;QString&amp;gt;();    // id is now QMetaType::QString
id = qMetaTypeId&amp;lt;MyStruct&amp;gt;();       // compile error if MyStruct not declared
</db:programlisting>
<db:para>QMetaType::type() returns the same ID as qMetaTypeId(), but does a lookup at runtime based on the name of the type. QMetaType::type() is a bit slower, but compilation succeeds if a type is not registered.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qmetatype.xml#Q_DECLARE_METATYPE">Q_DECLARE_METATYPE</db:link>()</db:member>
<db:member><db:link xlink:href="qmetatype.xml#type" role="deprecated">QMetaType::type</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="qRegisterMetaType">
<db:title>int qRegisterMetaType(const char *<db:emphasis>typeName</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>int</db:type>
<db:methodname>qRegisterMetaType</db:methodname>
<db:methodparam>
<db:type>const char *</db:type>
<db:parameter>typeName</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">int qRegisterMetaType(const char *typeName)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Registers the type name <db:code role="parameter">typeName</db:code> for the type T. Returns the internal ID used by <db:link xlink:href="qmetatype.xml">QMetaType</db:link>. Any class or struct that has a public default constructor, a public copy constructor and a public destructor can be registered.</db:para>
<db:para>This function requires that T is a fully defined type at the point where the function is called. For pointer types, it also requires that the pointed to type is fully defined. Use <db:link xlink:href="qmetatype.xml#Q_DECLARE_OPAQUE_POINTER">Q_DECLARE_OPAQUE_POINTER</db:link>() to be able to register pointers to forward declared types.</db:para>
<db:para>After a type has been registered, you can create and destroy objects of that type dynamically at run-time.</db:para>
<db:para>This example registers the class MyClass:</db:para>
<db:programlisting language="cpp">qRegisterMetaType&amp;lt;MyClass&amp;gt;(&quot;MyClass&quot;);
</db:programlisting>
<db:para>This function is useful to register typedefs so they can be used by <db:link xlink:href="qmetaproperty.xml">QMetaProperty</db:link>, or in QueuedConnections</db:para>
<db:programlisting language="cpp">typedef QString CustomString;
qRegisterMetaType&amp;lt;CustomString&amp;gt;(&quot;CustomString&quot;);
</db:programlisting>
<db:warning>
<db:para>This function is useful only for registering an alias (typedef) for every other use case <db:link xlink:href="qmetatype.xml#Q_DECLARE_METATYPE">Q_DECLARE_METATYPE</db:link> and <db:link xlink:href="qmetatype.xml#qMetaTypeId">qMetaTypeId</db:link>() should be used instead.</db:para>
</db:warning>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qmetatype.xml#isRegistered-1">isRegistered</db:link>()</db:member>
<db:member><db:link xlink:href="qmetatype.xml#Q_DECLARE_METATYPE">Q_DECLARE_METATYPE</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="qRegisterMetaType-1">
<db:title>[constexpr] int qRegisterMetaType()</db:title>
<db:methodsynopsis>
<db:type>int</db:type>
<db:methodname>qRegisterMetaType</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">int qRegisterMetaType()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Call this function to register the type T. T must be declared with <db:link xlink:href="qmetatype.xml#Q_DECLARE_METATYPE">Q_DECLARE_METATYPE</db:link>(). Returns the meta type Id.</db:para>
<db:para>Example:</db:para>
<db:programlisting language="cpp">int id = qRegisterMetaType&amp;lt;MyStruct&amp;gt;();
</db:programlisting>
<db:para>This function requires that T is a fully defined type at the point where the function is called. For pointer types, it also requires that the pointed to type is fully defined. Use <db:link xlink:href="qmetatype.xml#Q_DECLARE_OPAQUE_POINTER">Q_DECLARE_OPAQUE_POINTER</db:link>() to be able to register pointers to forward declared types.</db:para>
<db:para>After a type has been registered, you can create and destroy objects of that type dynamically at run-time.</db:para>
<db:para>To use the type T in <db:link xlink:href="qmetatype.xml#Type-enum">QVariant</db:link>, using <db:link xlink:href="qmetatype.xml#Q_DECLARE_METATYPE">Q_DECLARE_METATYPE</db:link>() is sufficient. To use the type T in queued signal and slot connections, qRegisterMetaType&lt;T&gt;() must be called before the first connection is established.</db:para>
<db:para>Also, to use type T with the <db:link xlink:href="qobject.xml#property">QObject::property</db:link>() API, qRegisterMetaType&lt;T&gt;() must be called before it is used, typically in the constructor of the class that uses T, or in the main() function.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qmetatype.xml#Q_DECLARE_METATYPE">Q_DECLARE_METATYPE</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="operator-not-eq">
<db:title>[since 5.15] bool operator!=(QMetaType <db:emphasis>a</db:emphasis>, QMetaType <db:emphasis>b</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>bool</db:type>
<db:methodname>operator!=</db:methodname>
<db:methodparam>
<db:type>QMetaType</db:type>
<db:parameter>a</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>QMetaType</db:type>
<db:parameter>b</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool operator!=(QMetaType a, QMetaType b)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>Returns true if the <db:link xlink:href="qmetatype.xml">QMetaType</db:link> <db:code role="parameter">a</db:code> represents a different type than the <db:link xlink:href="qmetatype.xml">QMetaType</db:link> <db:code role="parameter">b</db:code>, otherwise returns false.</db:para>
<db:para>This function was introduced in Qt 5.15.</db:para>
</db:section>
<db:section xml:id="operator-eq-eq">
<db:title>[since 5.15] bool operator==(QMetaType <db:emphasis>a</db:emphasis>, QMetaType <db:emphasis>b</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>bool</db:type>
<db:methodname>operator==</db:methodname>
<db:methodparam>
<db:type>QMetaType</db:type>
<db:parameter>a</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>QMetaType</db:type>
<db:parameter>b</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool operator==(QMetaType a, QMetaType b)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>Returns true if the <db:link xlink:href="qmetatype.xml">QMetaType</db:link> <db:code role="parameter">a</db:code> represents the same type as the <db:link xlink:href="qmetatype.xml">QMetaType</db:link> <db:code role="parameter">b</db:code>, otherwise returns false.</db:para>
<db:para>This function was introduced in Qt 5.15.</db:para>
</db:section>
</db:section>
<db:section xml:id="macro-documentation">
<db:title>Macro Documentation</db:title>
<db:section xml:id="Q_DECLARE_ASSOCIATIVE_CONTAINER_METATYPE">
<db:title>Q_DECLARE_ASSOCIATIVE_CONTAINER_METATYPE(<db:emphasis>Container</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:methodname>Q_DECLARE_ASSOCIATIVE_CONTAINER_METATYPE</db:methodname>
<db:methodparam>
<db:type></db:type>
<db:parameter>Container</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">macrowithparams</db:synopsisinfo>
<db:synopsisinfo role="signature">Q_DECLARE_ASSOCIATIVE_CONTAINER_METATYPE(Container)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This macro makes the container <db:code role="parameter">Container</db:code> known to <db:link xlink:href="qmetatype.xml">QMetaType</db:link> as an associative container. This makes it possible to put an instance of Container&lt;T, U&gt; into a <db:link xlink:href="qmetatype.xml#Type-enum">QVariant</db:link>, if T and U are themselves known to <db:link xlink:href="qmetatype.xml">QMetaType</db:link>.</db:para>
<db:para>Note that all of the Qt associative containers already have built-in support, and it is not necessary to use this macro with them. The std::map container also has built-in support.</db:para>
<db:para>This example shows a typical use of Q_DECLARE_ASSOCIATIVE_CONTAINER_METATYPE():</db:para>
<db:programlisting language="cpp">#include &amp;lt;unordered_list&amp;gt;

Q_DECLARE_ASSOCIATIVE_CONTAINER_METATYPE(std::unordered_map)

void someFunc()
{
    std::unordered_map&amp;lt;int, bool&amp;gt; container;
    QVariant var = QVariant::fromValue(container);
    // ...
}

</db:programlisting>
</db:section>
<db:section xml:id="Q_DECLARE_METATYPE">
<db:title>Q_DECLARE_METATYPE(<db:emphasis>Type</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:methodname>Q_DECLARE_METATYPE</db:methodname>
<db:methodparam>
<db:type></db:type>
<db:parameter>Type</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">macrowithparams</db:synopsisinfo>
<db:synopsisinfo role="signature">Q_DECLARE_METATYPE(Type)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This macro makes the type <db:code role="parameter">Type</db:code> known to <db:link xlink:href="qmetatype.xml">QMetaType</db:link> as long as it provides a public default constructor, a public copy constructor and a public destructor. It is needed to use the type <db:code role="parameter">Type</db:code> as a custom type in <db:link xlink:href="qmetatype.xml#Type-enum">QVariant</db:link>.</db:para>
<db:para>This macro requires that <db:code role="parameter">Type</db:code> is a fully defined type at the point where it is used. For pointer types, it also requires that the pointed to type is fully defined. Use in conjunction with <db:link xlink:href="qmetatype.xml#Q_DECLARE_OPAQUE_POINTER">Q_DECLARE_OPAQUE_POINTER</db:link>() to register pointers to forward declared types.</db:para>
<db:para>Ideally, this macro should be placed below the declaration of the class or struct. If that is not possible, it can be put in a private header file which has to be included every time that type is used in a <db:link xlink:href="qmetatype.xml#Type-enum">QVariant</db:link>.</db:para>
<db:para>Adding a Q_DECLARE_METATYPE() makes the type known to all template based functions, including <db:link xlink:href="qmetatype.xml#Type-enum">QVariant</db:link>. Note that if you intend to use the type in <db:emphasis>queued</db:emphasis> signal and slot connections or in <db:link xlink:href="qobject.xml">QObject</db:link>'s property system, you also have to call <db:link xlink:href="qmetatype.xml#qRegisterMetaType-1">qRegisterMetaType</db:link>() since the names are resolved at runtime.</db:para>
<db:para>This example shows a typical use case of Q_DECLARE_METATYPE():</db:para>
<db:programlisting language="cpp">struct MyStruct
{
    int i;
    ...
};

Q_DECLARE_METATYPE(MyStruct)
</db:programlisting>
<db:para>If MyStruct is in a namespace, the Q_DECLARE_METATYPE() macro has to be outside the namespace:</db:para>
<db:programlisting language="cpp">namespace MyNamespace
{
    ...
}

Q_DECLARE_METATYPE(MyNamespace::MyStruct)
</db:programlisting>
<db:para>Since MyStruct is now known to <db:link xlink:href="qmetatype.xml">QMetaType</db:link>, it can be used in <db:link xlink:href="qmetatype.xml#Type-enum">QVariant</db:link>:</db:para>
<db:programlisting language="cpp">MyStruct s;
QVariant var;
var.setValue(s); // copy s into the variant

...

// retrieve the value
MyStruct s2 = var.value&amp;lt;MyStruct&amp;gt;();
</db:programlisting>
<db:para>Some types are registered automatically and do not need this macro:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para>Pointers to classes derived from <db:link xlink:href="qobject.xml">QObject</db:link></db:para>
</db:listitem>
<db:listitem>
<db:para><db:link xlink:href="qlist.xml">QList</db:link>&lt;T&gt;, <db:link xlink:href="qqueue.xml">QQueue</db:link>&lt;T&gt;, <db:link xlink:href="qstack.xml">QStack</db:link>&lt;T&gt; or <db:link xlink:href="qset.xml">QSet</db:link>&lt;T&gt; where T is a registered meta type</db:para>
</db:listitem>
<db:listitem>
<db:para><db:link xlink:href="qhash.xml#qhash">QHash</db:link>&lt;T1, T2&gt;, <db:link xlink:href="qmap.xml">QMap</db:link>&lt;T1, T2&gt; or <db:link xlink:href="qpair-proxy.xml#QPair-typedef">QPair</db:link>&lt;T1, T2&gt; where T1 and T2 are registered meta types</db:para>
</db:listitem>
<db:listitem>
<db:para><db:link xlink:href="qpointer.xml">QPointer</db:link>&lt;T&gt;, <db:link xlink:href="qsharedpointer.xml">QSharedPointer</db:link>&lt;T&gt;, <db:link xlink:href="qweakpointer.xml">QWeakPointer</db:link>&lt;T&gt;, where T is a class that derives from <db:link xlink:href="qobject.xml">QObject</db:link></db:para>
</db:listitem>
<db:listitem>
<db:para>Enumerations registered with <db:link xlink:href="qobject.xml#Q_ENUM">Q_ENUM</db:link> or <db:link xlink:href="qobject.xml#Q_FLAG">Q_FLAG</db:link></db:para>
</db:listitem>
<db:listitem>
<db:para>Classes that have a <db:link xlink:href="qobject.xml#Q_GADGET">Q_GADGET</db:link> macro</db:para>
</db:listitem>
</db:itemizedlist>
<db:note>
<db:para>This method also registers the stream and debug operators for the type if they are visible at registration time. As this is done automatically in some places, it is strongly recommended to declare the stream operators for a type directly after the type itself. Because of the argument dependent lookup rules of C++, it is also strongly recommended to declare the operators in the same namespace as the type itself.</db:para>
</db:note>
<db:para>The stream operators should have the following signatures:</db:para>
<db:programlisting language="cpp">QDataStream &amp;amp;operator&amp;lt;&amp;lt;(QDataStream &amp;amp;out, const MyClass &amp;amp;myObj);
QDataStream &amp;amp;operator&amp;gt;&amp;gt;(QDataStream &amp;amp;in, MyClass &amp;amp;myObj);
</db:programlisting>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qmetatype.xml#qRegisterMetaType-1">qRegisterMetaType</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="Q_DECLARE_OPAQUE_POINTER">
<db:title>[since 5.0] Q_DECLARE_OPAQUE_POINTER(<db:emphasis>PointerType</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:methodname>Q_DECLARE_OPAQUE_POINTER</db:methodname>
<db:methodparam>
<db:type></db:type>
<db:parameter>PointerType</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">macrowithparams</db:synopsisinfo>
<db:synopsisinfo role="signature">Q_DECLARE_OPAQUE_POINTER(PointerType)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This macro enables pointers to forward-declared types (<db:code role="parameter">PointerType</db:code>) to be registered with <db:link xlink:href="qmetatype.xml">QMetaType</db:link> using either <db:link xlink:href="qmetatype.xml#Q_DECLARE_METATYPE">Q_DECLARE_METATYPE</db:link>() or <db:link xlink:href="qmetatype.xml#qRegisterMetaType-1">qRegisterMetaType</db:link>().</db:para>
<db:para>This macro was introduced in Qt 5.0.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qmetatype.xml#Q_DECLARE_METATYPE">Q_DECLARE_METATYPE</db:link>()</db:member>
<db:member><db:link xlink:href="qmetatype.xml#qRegisterMetaType-1">qRegisterMetaType</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="Q_DECLARE_SEQUENTIAL_CONTAINER_METATYPE">
<db:title>Q_DECLARE_SEQUENTIAL_CONTAINER_METATYPE(<db:emphasis>Container</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:methodname>Q_DECLARE_SEQUENTIAL_CONTAINER_METATYPE</db:methodname>
<db:methodparam>
<db:type></db:type>
<db:parameter>Container</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">macrowithparams</db:synopsisinfo>
<db:synopsisinfo role="signature">Q_DECLARE_SEQUENTIAL_CONTAINER_METATYPE(Container)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This macro makes the container <db:code role="parameter">Container</db:code> known to <db:link xlink:href="qmetatype.xml">QMetaType</db:link> as a sequential container. This makes it possible to put an instance of Container&lt;T&gt; into a <db:link xlink:href="qmetatype.xml#Type-enum">QVariant</db:link>, if T itself is known to <db:link xlink:href="qmetatype.xml">QMetaType</db:link>.</db:para>
<db:para>Note that all of the Qt sequential containers already have built-in support, and it is not necessary to use this macro with them. The std::vector and std::list containers also have built-in support.</db:para>
<db:para>This example shows a typical use of Q_DECLARE_SEQUENTIAL_CONTAINER_METATYPE():</db:para>
<db:programlisting language="cpp">#include &amp;lt;deque&amp;gt;

Q_DECLARE_SEQUENTIAL_CONTAINER_METATYPE(std::deque)

void someFunc()
{
    std::deque&amp;lt;QFile*&amp;gt; container;
    QVariant var = QVariant::fromValue(container);
    // ...
}

</db:programlisting>
</db:section>
<db:section xml:id="Q_DECLARE_SMART_POINTER_METATYPE">
<db:title>Q_DECLARE_SMART_POINTER_METATYPE(<db:emphasis>SmartPointer</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:methodname>Q_DECLARE_SMART_POINTER_METATYPE</db:methodname>
<db:methodparam>
<db:type></db:type>
<db:parameter>SmartPointer</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">macrowithparams</db:synopsisinfo>
<db:synopsisinfo role="signature">Q_DECLARE_SMART_POINTER_METATYPE(SmartPointer)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This macro makes the smart pointer <db:code role="parameter">SmartPointer</db:code> known to <db:link xlink:href="qmetatype.xml">QMetaType</db:link> as a smart pointer. This makes it possible to put an instance of SmartPointer&lt;T&gt; into a <db:link xlink:href="qmetatype.xml#Type-enum">QVariant</db:link>, if T is a type which inherits <db:link xlink:href="qobject.xml">QObject</db:link>.</db:para>
<db:para>Note that the <db:link xlink:href="qweakpointer.xml">QWeakPointer</db:link>, <db:link xlink:href="qsharedpointer.xml">QSharedPointer</db:link> and <db:link xlink:href="qpointer.xml">QPointer</db:link> already have built-in support, and it is not necessary to use this macro with them.</db:para>
<db:para>This example shows a typical use of Q_DECLARE_SMART_POINTER_METATYPE():</db:para>
<db:programlisting language="cpp">#include &amp;lt;memory&amp;gt;

Q_DECLARE_SMART_POINTER_METATYPE(std::shared_ptr)

void someFunc()
{
    auto smart_ptr = std::make_shared&amp;lt;QFile&amp;gt;();
    QVariant var = QVariant::fromValue(smart_ptr);
    // ...
    if (var.canConvert&amp;lt;QObject*&amp;gt;()) {
        QObject *sp = var.value&amp;lt;QObject*&amp;gt;();
        qDebug() &amp;lt;&amp;lt; sp-&amp;gt;metaObject()-&amp;gt;className(); // Prints 'QFile'.
    }
}

</db:programlisting>
</db:section>
</db:section>
<db:section xml:id="obsolete">
<db:title>Obsolete Members for QMetaType</db:title>
<db:para><db:emphasis role="bold">The following members of class <db:link xlink:href="qmetatype.xml">QMetaType</db:link> are deprecated.</db:emphasis> We strongly advise against using them in new code.</db:para>
<db:section xml:id="obsolete-member-function-documentation">
<db:title>Obsolete Member Function Documentation</db:title>
<db:section xml:id="compare-1">
<db:title>[static] bool QMetaType::compare(const void *<db:emphasis>lhs</db:emphasis>, const void *<db:emphasis>rhs</db:emphasis>, int <db:emphasis>typeId</db:emphasis>, int *<db:emphasis>result</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:modifier>static</db:modifier>
<db:type>bool</db:type>
<db:methodname>compare</db:methodname>
<db:methodparam>
<db:type>const void *</db:type>
<db:parameter>lhs</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const void *</db:type>
<db:parameter>rhs</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>typeId</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>int *</db:type>
<db:parameter>result</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">bool compare(const void *lhs, const void *rhs, int typeId, int *result)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">deprecated</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This function is deprecated. We strongly advise against using it in new code.</db:para>
<db:para>Use the non-static compare method instead</db:para>
<db:para>Compares the objects at <db:code role="parameter">lhs</db:code> and <db:code role="parameter">rhs</db:code>. Both objects need to be of type <db:code role="parameter">typeId</db:code>. <db:code role="parameter">result</db:code> is set to less than, equal to or greater than zero, if <db:code role="parameter">lhs</db:code> is less than, equal to or greater than <db:code role="parameter">rhs</db:code>. Returns true, if the comparison succeeded, otherwise false.</db:para>
</db:section>
<db:section xml:id="construct">
<db:title>[static, since 5.0] void *QMetaType::construct(int <db:emphasis>type</db:emphasis>, void *<db:emphasis>where</db:emphasis>, const void *<db:emphasis>copy</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:modifier>static</db:modifier>
<db:type>void *</db:type>
<db:methodname>construct</db:methodname>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>type</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>void *</db:type>
<db:parameter>where</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const void *</db:type>
<db:parameter>copy</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void * construct(int type, void *where, const void *copy)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">deprecated</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This function is deprecated. We strongly advise against using it in new code.</db:para>
<db:para>Constructs a value of the given <db:code role="parameter">type</db:code> in the existing memory addressed by <db:code role="parameter">where</db:code>, that is a copy of <db:code role="parameter">copy</db:code>, and returns <db:code role="parameter">where</db:code>. If <db:code role="parameter">copy</db:code> is zero, the value is default constructed.</db:para>
<db:para>This is a low-level function for explicitly managing the memory used to store the type. Consider calling <db:link xlink:href="qmetatype.xml#create">create</db:link>() if you don't need this level of control (that is, use &quot;new&quot; rather than &quot;placement new&quot;).</db:para>
<db:para>You must ensure that <db:code role="parameter">where</db:code> points to a location that can store a value of type <db:code role="parameter">type</db:code>, and that <db:code role="parameter">where</db:code> is suitably aligned. The type's size can be queried by calling <db:link xlink:href="qmetatype.xml#sizeOf-1">sizeOf</db:link>().</db:para>
<db:para>The rule of thumb for alignment is that a type is aligned to its natural boundary, which is the smallest power of 2 that is bigger than the type, unless that alignment is larger than the maximum useful alignment for the platform. For practical purposes, alignment larger than 2 * sizeof(void*) is only necessary for special hardware instructions (e.g., aligned SSE loads and stores on x86).</db:para>
<db:para>This function was introduced in Qt 5.0.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qmetatype.xml#destruct">destruct</db:link>()</db:member>
<db:member><db:link xlink:href="qmetatype.xml#sizeOf-1">sizeOf</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="convert-1">
<db:title>[static, since 5.2] bool QMetaType::convert(const void *<db:emphasis>from</db:emphasis>, int <db:emphasis>fromTypeId</db:emphasis>, void *<db:emphasis>to</db:emphasis>, int <db:emphasis>toTypeId</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:modifier>static</db:modifier>
<db:type>bool</db:type>
<db:methodname>convert</db:methodname>
<db:methodparam>
<db:type>const void *</db:type>
<db:parameter>from</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>fromTypeId</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>void *</db:type>
<db:parameter>to</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>toTypeId</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">bool convert(const void *from, int fromTypeId, void *to, int toTypeId)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">deprecated</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This function is deprecated. We strongly advise against using it in new code.</db:para>
<db:para>Converts the object at <db:code role="parameter">from</db:code> from <db:code role="parameter">fromTypeId</db:code> to the preallocated space at <db:code role="parameter">to</db:code> typed <db:code role="parameter">toTypeId</db:code>. Returns true, if the conversion succeeded, otherwise false.</db:para>
<db:para>Both <db:code role="parameter">from</db:code> and <db:code role="parameter">to</db:code> have to be valid pointers.</db:para>
<db:para>This function was introduced in Qt 5.2.</db:para>
</db:section>
<db:section xml:id="create">
<db:title>[static] void *QMetaType::create(int <db:emphasis>type</db:emphasis>, const void *<db:emphasis>copy</db:emphasis> = nullptr)</db:title>
<db:methodsynopsis>
<db:modifier>static</db:modifier>
<db:type>void *</db:type>
<db:methodname>create</db:methodname>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>type</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const void *</db:type>
<db:parameter>copy</db:parameter>
<db:initializer>nullptr</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void * create(int type, const void *copy)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">deprecated</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This function is deprecated. We strongly advise against using it in new code.</db:para>
<db:para>Returns a copy of <db:code role="parameter">copy</db:code>, assuming it is of type <db:code role="parameter">type</db:code>. If <db:code role="parameter">copy</db:code> is zero, creates a default constructed instance.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qmetatype.xml#destroy">destroy</db:link>()</db:member>
<db:member><db:link xlink:href="qmetatype.xml#isRegistered-1">isRegistered</db:link>()</db:member>
<db:member><db:link xlink:href="qmetatype.xml#Type-enum">Type</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="debugStream-1">
<db:title>[static] bool QMetaType::debugStream(QDebug &amp;<db:emphasis>dbg</db:emphasis>, const void *<db:emphasis>rhs</db:emphasis>, int <db:emphasis>typeId</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:modifier>static</db:modifier>
<db:type>bool</db:type>
<db:methodname>debugStream</db:methodname>
<db:methodparam>
<db:type>QDebug &amp;</db:type>
<db:parameter>dbg</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const void *</db:type>
<db:parameter>rhs</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>typeId</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">bool debugStream(QDebug &amp;dbg, const void *rhs, int typeId)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">deprecated</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This function is deprecated. We strongly advise against using it in new code.</db:para>
<db:para>This is an overloaded function.</db:para>
</db:section>
<db:section xml:id="destroy">
<db:title>[static] void QMetaType::destroy(int <db:emphasis>type</db:emphasis>, void *<db:emphasis>data</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:modifier>static</db:modifier>
<db:void/>
<db:methodname>destroy</db:methodname>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>type</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>void *</db:type>
<db:parameter>data</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void destroy(int type, void *data)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">deprecated</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This function is deprecated. We strongly advise against using it in new code.</db:para>
<db:para>Destroys the <db:code role="parameter">data</db:code>, assuming it is of the <db:code role="parameter">type</db:code> given.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qmetatype.xml#create">create</db:link>()</db:member>
<db:member><db:link xlink:href="qmetatype.xml#isRegistered-1">isRegistered</db:link>()</db:member>
<db:member><db:link xlink:href="qmetatype.xml#Type-enum">Type</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="destruct">
<db:title>[static, since 5.0] void QMetaType::destruct(int <db:emphasis>type</db:emphasis>, void *<db:emphasis>where</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:modifier>static</db:modifier>
<db:void/>
<db:methodname>destruct</db:methodname>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>type</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>void *</db:type>
<db:parameter>where</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void destruct(int type, void *where)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">deprecated</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This function is deprecated. We strongly advise against using it in new code.</db:para>
<db:para>Destructs the value of the given <db:code role="parameter">type</db:code>, located at <db:code role="parameter">where</db:code>.</db:para>
<db:para>Unlike <db:link xlink:href="qmetatype.xml#destroy">destroy</db:link>(), this function only invokes the type's destructor, it doesn't invoke the delete operator.</db:para>
<db:para>This function was introduced in Qt 5.0.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qmetatype.xml#construct">construct</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="hasRegisteredDebugStreamOperator-1">
<db:title>[static, since 5.2] bool QMetaType::hasRegisteredDebugStreamOperator()</db:title>
<db:methodsynopsis>
<db:modifier>static</db:modifier>
<db:type>bool</db:type>
<db:methodname>hasRegisteredDebugStreamOperator</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">bool hasRegisteredDebugStreamOperator()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">deprecated</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This function is deprecated. We strongly advise against using it in new code.</db:para>
<db:para>Returns true, if the meta type system has a registered debug stream operator for type T.</db:para>
<db:para>This function was introduced in Qt 5.2.</db:para>
</db:section>
<db:section xml:id="hasRegisteredDebugStreamOperator-2">
<db:title>[static, since 5.2] bool QMetaType::hasRegisteredDebugStreamOperator(int <db:emphasis>typeId</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:modifier>static</db:modifier>
<db:type>bool</db:type>
<db:methodname>hasRegisteredDebugStreamOperator</db:methodname>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>typeId</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">2</db:synopsisinfo>
<db:synopsisinfo role="signature">bool hasRegisteredDebugStreamOperator(int typeId)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">deprecated</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This function is deprecated. We strongly advise against using it in new code.</db:para>
<db:para>Use <db:link xlink:href="qmetatype.xml#hasRegisteredDebugStreamOperator">QMetaType::hasRegisteredDebugStreamOperator</db:link>() instead.</db:para>
<db:para>Returns true, if the meta type system has a registered debug stream operator for type id <db:code role="parameter">typeId</db:code>.</db:para>
<db:para>This function was introduced in Qt 5.2.</db:para>
</db:section>
<db:section xml:id="load-1">
<db:title>[static] bool QMetaType::load(QDataStream &amp;<db:emphasis>stream</db:emphasis>, int <db:emphasis>type</db:emphasis>, void *<db:emphasis>data</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:modifier>static</db:modifier>
<db:type>bool</db:type>
<db:methodname>load</db:methodname>
<db:methodparam>
<db:type>QDataStream &amp;</db:type>
<db:parameter>stream</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>type</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>void *</db:type>
<db:parameter>data</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">bool load(QDataStream &amp;stream, int type, void *data)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">deprecated</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This function is deprecated. We strongly advise against using it in new code.</db:para>
<db:para>This is an overloaded function.</db:para>
</db:section>
<db:section xml:id="metaObjectForType">
<db:title>[static, since 5.0] const QMetaObject *QMetaType::metaObjectForType(int <db:emphasis>type</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:modifier>static</db:modifier>
<db:type>const QMetaObject *</db:type>
<db:methodname>metaObjectForType</db:methodname>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>type</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">const QMetaObject * metaObjectForType(int type)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">deprecated</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This function is deprecated. We strongly advise against using it in new code.</db:para>
<db:para>returns <db:link xlink:href="qmetatype.xml#metaObject">QMetaType::metaObject</db:link> for <db:code role="parameter">type</db:code></db:para>
<db:para>This function was introduced in Qt 5.0.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qmetatype.xml#metaObject">metaObject</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="save-1">
<db:title>[static] bool QMetaType::save(QDataStream &amp;<db:emphasis>stream</db:emphasis>, int <db:emphasis>type</db:emphasis>, const void *<db:emphasis>data</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:modifier>static</db:modifier>
<db:type>bool</db:type>
<db:methodname>save</db:methodname>
<db:methodparam>
<db:type>QDataStream &amp;</db:type>
<db:parameter>stream</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>type</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const void *</db:type>
<db:parameter>data</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">bool save(QDataStream &amp;stream, int type, const void *data)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">deprecated</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This function is deprecated. We strongly advise against using it in new code.</db:para>
<db:para>This is an overloaded function.</db:para>
</db:section>
<db:section xml:id="sizeOf">
<db:title>[static, since 5.0] int QMetaType::sizeOf(int <db:emphasis>type</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:modifier>static</db:modifier>
<db:type>int</db:type>
<db:methodname>sizeOf</db:methodname>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>type</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">int sizeOf(int type)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">deprecated</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This function is deprecated. We strongly advise against using it in new code.</db:para>
<db:para>Returns the size of the given <db:code role="parameter">type</db:code> in bytes (i.e. sizeof(T), where T is the actual type identified by the <db:code role="parameter">type</db:code> argument).</db:para>
<db:para>This function is typically used together with <db:link xlink:href="qmetatype.xml#construct">construct</db:link>() to perform low-level management of the memory used by a type.</db:para>
<db:para>This function was introduced in Qt 5.0.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qmetatype.xml#construct">construct</db:link>()</db:member>
<db:member><db:link xlink:href="qmetatype.xml#alignOf">QMetaType::alignOf</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="type">
<db:title>[static] int QMetaType::type(const char *<db:emphasis>typeName</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:modifier>static</db:modifier>
<db:type>int</db:type>
<db:methodname>type</db:methodname>
<db:methodparam>
<db:type>const char *</db:type>
<db:parameter>typeName</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">int type(const char *typeName)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">deprecated</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This function is deprecated. We strongly advise against using it in new code.</db:para>
<db:para>Returns a handle to the type called <db:code role="parameter">typeName</db:code>, or <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::UnknownType</db:link> if there is no such type.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qmetatype.xml#isRegistered-1">isRegistered</db:link>()</db:member>
<db:member><db:link xlink:href="qmetatype.xml#typeName">typeName</db:link>()</db:member>
<db:member><db:link xlink:href="qmetatype.xml#Type-enum">Type</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="type-1">
<db:title>[static, since 5.5] int QMetaType::type(const ::QByteArray &amp;<db:emphasis>typeName</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:modifier>static</db:modifier>
<db:type>int</db:type>
<db:methodname>type</db:methodname>
<db:methodparam>
<db:type>const ::QByteArray &amp;</db:type>
<db:parameter>typeName</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">int type(const ::QByteArray &amp;typeName)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">deprecated</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This function is deprecated. We strongly advise against using it in new code.</db:para>
<db:para>This is an overloaded function.</db:para>
<db:para>Returns a handle to the type called <db:code role="parameter">typeName</db:code>, or 0 if there is no such type.</db:para>
<db:para>This function was introduced in Qt 5.5.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qmetatype.xml#isRegistered-1">isRegistered</db:link>()</db:member>
<db:member><db:link xlink:href="qmetatype.xml#typeName">typeName</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="typeFlags">
<db:title>[static, since 5.0] QMetaType::TypeFlags QMetaType::typeFlags(int <db:emphasis>type</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:modifier>static</db:modifier>
<db:type>QMetaType::TypeFlags</db:type>
<db:methodname>typeFlags</db:methodname>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>type</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QMetaType::TypeFlags typeFlags(int type)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">deprecated</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This function is deprecated. We strongly advise against using it in new code.</db:para>
<db:para>Returns flags of the given <db:code role="parameter">type</db:code>.</db:para>
<db:para>This function was introduced in Qt 5.0.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qmetatype.xml#TypeFlag-enum">QMetaType::TypeFlags</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="typeName">
<db:title>[static] const char *QMetaType::typeName(int <db:emphasis>typeId</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:modifier>static</db:modifier>
<db:type>const char *</db:type>
<db:methodname>typeName</db:methodname>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>typeId</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">const char * typeName(int typeId)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">deprecated</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This function is deprecated. We strongly advise against using it in new code.</db:para>
<db:para>Returns the type name associated with the given <db:code role="parameter">typeId</db:code>, or a null pointer if no matching type was found. The returned pointer must not be deleted.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qmetatype.xml#type">type</db:link>()</db:member>
<db:member><db:link xlink:href="qmetatype.xml#isRegistered-1">isRegistered</db:link>()</db:member>
<db:member><db:link xlink:href="qmetatype.xml#Type-enum">Type</db:link></db:member>
<db:member><db:link xlink:href="qmetatype.xml#name">name</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
</db:section>
</db:section>
</db:article>
