<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en">
<db:info>
<db:title>QMetaType Class</db:title>
<db:productname>QtCore</db:productname>
<db:edition>Qt 5.7.1 Reference Documentation</db:edition>
<db:titleabbrev>Qt Core Reference Documentation</db:titleabbrev>
<db:abstract>
<db:para>The <db:link xlink:href="qmetatype.xml">QMetaType</db:link> class manages named types in the meta-object system.</db:para>
<db:note>
<db:para>All functions in this class are <db:link xlink:href="threads-reentrancy.xml">thread-safe</db:link>.</db:para>
</db:note>
</db:abstract>
<db:pubdate>2025-06-29</db:pubdate>
<db:date>2025-06-29</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:variablelist>
<db:varlistentry>
<db:term>Header</db:term>
<db:listitem>
<db:para>QMetaType</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>qmake</db:term>
<db:listitem>
<db:para>QT += core</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Group</db:term>
<db:listitem>
<db:para>QMetaType is part of <db:simplelist><db:member>objectmodel</db:member></db:simplelist>
</db:para>
</db:listitem>
</db:varlistentry>
</db:variablelist>
<db:section xml:id="details">
<db:title>Detailed Description</db:title>
<db:para>The class is used as a helper to marshall types in <db:link xlink:href="qmetatype.xml#Type-enum">QVariant</db:link> and in queued signals and slots connections. It associates a type name to a type so that it can be created and destructed dynamically at run-time. Declare new types with <db:link xlink:href="qmetatype.xml#Q_DECLARE_METATYPE">Q_DECLARE_METATYPE</db:link>() to make them available to <db:link xlink:href="qmetatype.xml#Type-enum">QVariant</db:link> and other template-based functions. Call qRegisterMetaType() to make types available to non-template based functions, such as the queued signal and slot connections.</db:para>
<db:para>Any class or struct that has a public default constructor, a public copy constructor, and a public destructor can be registered.</db:para>
<db:para>The following code allocates and destructs an instance of <db:code>MyClass</db:code>:</db:para>
<db:programlisting language="cpp">int id = QMetaType::type(&quot;MyClass&quot;);
if (id != QMetaType::UnknownType) {
    void *myClassPtr = QMetaType::create(id);
    ...
    QMetaType::destroy(id, myClassPtr);
    myClassPtr = 0;
}
</db:programlisting>
<db:para>If we want the stream operators <db:code>operator&lt;&lt;()</db:code> and <db:code>operator&gt;&gt;()</db:code> to work on <db:link xlink:href="qmetatype.xml#Type-enum">QVariant</db:link> objects that store custom types, the custom type must provide <db:code>operator&lt;&lt;()</db:code> and <db:code>operator&gt;&gt;()</db:code> operators.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qmetatype.xml#Q_DECLARE_METATYPE">Q_DECLARE_METATYPE</db:link>()</db:member>
<db:member><db:link xlink:href="">QVariant::setValue()</db:link></db:member>
<db:member><db:link xlink:href="">QVariant::value()</db:link></db:member>
<db:member><db:link xlink:href="">QVariant::fromValue()</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="member-type-documentation">
<db:title>Member Type Documentation</db:title>
<db:section xml:id="Type-enum">
<db:title>enum QMetaType::Type</db:title>
<db:para>These are the built-in types supported by <db:link xlink:href="qmetatype.xml">QMetaType</db:link>: Read doc on QChar Read doc on QChar</db:para>
<db:informaltable>
<db:thead>
<db:tr>
<db:th>Constant</db:th>
<db:th>Value</db:th>
<db:th>Description</db:th>
</db:tr>
</db:thead>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::Void</db:code></db:para>
</db:td>
<db:td><db:code>43</db:code></db:td>
<db:td>
<db:para><db:code>void</db:code></db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::Bool</db:code></db:para>
</db:td>
<db:td><db:code>1</db:code></db:td>
<db:td>
<db:para><db:code>bool</db:code></db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::Int</db:code></db:para>
</db:td>
<db:td><db:code>2</db:code></db:td>
<db:td>
<db:para><db:code>int</db:code></db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::UInt</db:code></db:para>
</db:td>
<db:td><db:code>3</db:code></db:td>
<db:td>
<db:para><db:code>unsigned int</db:code></db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::Double</db:code></db:para>
</db:td>
<db:td><db:code>6</db:code></db:td>
<db:td>
<db:para><db:code>double</db:code></db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::QChar</db:code></db:para>
</db:td>
<db:td><db:code>7</db:code></db:td>
<db:td>
<db:para>QChar</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::QString</db:code></db:para>
</db:td>
<db:td><db:code>10</db:code></db:td>
<db:td>
<db:para>QString</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::QByteArray</db:code></db:para>
</db:td>
<db:td><db:code>12</db:code></db:td>
<db:td>
<db:para>QByteArray</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::VoidStar</db:code></db:para>
</db:td>
<db:td><db:code>31</db:code></db:td>
<db:td>
<db:para><db:code>void *</db:code></db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::Long</db:code></db:para>
</db:td>
<db:td><db:code>32</db:code></db:td>
<db:td>
<db:para><db:code>long</db:code></db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::LongLong</db:code></db:para>
</db:td>
<db:td><db:code>4</db:code></db:td>
<db:td>
<db:para>LongLong</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::Short</db:code></db:para>
</db:td>
<db:td><db:code>33</db:code></db:td>
<db:td>
<db:para><db:code>short</db:code></db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::Char</db:code></db:para>
</db:td>
<db:td><db:code>34</db:code></db:td>
<db:td>
<db:para><db:code>char</db:code></db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::ULong</db:code></db:para>
</db:td>
<db:td><db:code>35</db:code></db:td>
<db:td>
<db:para><db:code>unsigned long</db:code></db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::ULongLong</db:code></db:para>
</db:td>
<db:td><db:code>5</db:code></db:td>
<db:td>
<db:para>ULongLong</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::UShort</db:code></db:para>
</db:td>
<db:td><db:code>36</db:code></db:td>
<db:td>
<db:para><db:code>unsigned short</db:code></db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::SChar</db:code></db:para>
</db:td>
<db:td><db:code>40</db:code></db:td>
<db:td>
<db:para><db:code>signed char</db:code></db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::UChar</db:code></db:para>
</db:td>
<db:td><db:code>37</db:code></db:td>
<db:td>
<db:para><db:code>unsigned char</db:code></db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::Float</db:code></db:para>
</db:td>
<db:td><db:code>38</db:code></db:td>
<db:td>
<db:para><db:code>float</db:code></db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::QObjectStar</db:code></db:para>
</db:td>
<db:td><db:code>39</db:code></db:td>
<db:td>
<db:para><db:link xlink:href="qobject.xml">QObject</db:link> *</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::QVariant</db:code></db:para>
</db:td>
<db:td><db:code>41</db:code></db:td>
<db:td>
<db:para>QVariant</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::QCursor</db:code></db:para>
</db:td>
<db:td><db:code>74</db:code></db:td>
<db:td>
<db:para>QCursor</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::QDate</db:code></db:para>
</db:td>
<db:td><db:code>14</db:code></db:td>
<db:td>
<db:para>QDate</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::QSize</db:code></db:para>
</db:td>
<db:td><db:code>21</db:code></db:td>
<db:td>
<db:para>QSize</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::QTime</db:code></db:para>
</db:td>
<db:td><db:code>15</db:code></db:td>
<db:td>
<db:para>QTime</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::QVariantList</db:code></db:para>
</db:td>
<db:td><db:code>9</db:code></db:td>
<db:td>
<db:para>QVariantList</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::QPolygon</db:code></db:para>
</db:td>
<db:td><db:code>71</db:code></db:td>
<db:td>
<db:para>QPolygon</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::QPolygonF</db:code></db:para>
</db:td>
<db:td><db:code>86</db:code></db:td>
<db:td>
<db:para>QPolygonF</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::QColor</db:code></db:para>
</db:td>
<db:td><db:code>67</db:code></db:td>
<db:td>
<db:para>QColor</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::QSizeF</db:code></db:para>
</db:td>
<db:td><db:code>22</db:code></db:td>
<db:td>
<db:para>QSizeF</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::QRectF</db:code></db:para>
</db:td>
<db:td><db:code>20</db:code></db:td>
<db:td>
<db:para>QRectF</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::QLine</db:code></db:para>
</db:td>
<db:td><db:code>23</db:code></db:td>
<db:td>
<db:para>QLine</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::QTextLength</db:code></db:para>
</db:td>
<db:td><db:code>77</db:code></db:td>
<db:td>
<db:para>QTextLength</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::QStringList</db:code></db:para>
</db:td>
<db:td><db:code>11</db:code></db:td>
<db:td>
<db:para>QStringList</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::QVariantMap</db:code></db:para>
</db:td>
<db:td><db:code>8</db:code></db:td>
<db:td>
<db:para>QVariantMap</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::QVariantHash</db:code></db:para>
</db:td>
<db:td><db:code>28</db:code></db:td>
<db:td>
<db:para>QVariantHash</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::QIcon</db:code></db:para>
</db:td>
<db:td><db:code>69</db:code></db:td>
<db:td>
<db:para>QIcon</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::QPen</db:code></db:para>
</db:td>
<db:td><db:code>76</db:code></db:td>
<db:td>
<db:para>QPen</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::QLineF</db:code></db:para>
</db:td>
<db:td><db:code>24</db:code></db:td>
<db:td>
<db:para>QLineF</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::QTextFormat</db:code></db:para>
</db:td>
<db:td><db:code>78</db:code></db:td>
<db:td>
<db:para>QTextFormat</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::QRect</db:code></db:para>
</db:td>
<db:td><db:code>19</db:code></db:td>
<db:td>
<db:para>QRect</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::QPoint</db:code></db:para>
</db:td>
<db:td><db:code>25</db:code></db:td>
<db:td>
<db:para>QPoint</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::QUrl</db:code></db:para>
</db:td>
<db:td><db:code>17</db:code></db:td>
<db:td>
<db:para>QUrl</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::QRegExp</db:code></db:para>
</db:td>
<db:td><db:code>27</db:code></db:td>
<db:td>
<db:para>QRegExp</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::QRegularExpression</db:code></db:para>
</db:td>
<db:td><db:code>44</db:code></db:td>
<db:td>
<db:para>QRegularExpression</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::QDateTime</db:code></db:para>
</db:td>
<db:td><db:code>16</db:code></db:td>
<db:td>
<db:para>QDateTime</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::QPointF</db:code></db:para>
</db:td>
<db:td><db:code>26</db:code></db:td>
<db:td>
<db:para>QPointF</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::QPalette</db:code></db:para>
</db:td>
<db:td><db:code>68</db:code></db:td>
<db:td>
<db:para>QPalette</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::QFont</db:code></db:para>
</db:td>
<db:td><db:code>64</db:code></db:td>
<db:td>
<db:para>QFont</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::QBrush</db:code></db:para>
</db:td>
<db:td><db:code>66</db:code></db:td>
<db:td>
<db:para>QBrush</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::QRegion</db:code></db:para>
</db:td>
<db:td><db:code>72</db:code></db:td>
<db:td>
<db:para>QRegion</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::QBitArray</db:code></db:para>
</db:td>
<db:td><db:code>13</db:code></db:td>
<db:td>
<db:para>QBitArray</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::QImage</db:code></db:para>
</db:td>
<db:td><db:code>70</db:code></db:td>
<db:td>
<db:para>QImage</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::QKeySequence</db:code></db:para>
</db:td>
<db:td><db:code>75</db:code></db:td>
<db:td>
<db:para>QKeySequence</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::QSizePolicy</db:code></db:para>
</db:td>
<db:td><db:code>121</db:code></db:td>
<db:td>
<db:para>QSizePolicy</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::QPixmap</db:code></db:para>
</db:td>
<db:td><db:code>65</db:code></db:td>
<db:td>
<db:para>QPixmap</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::QLocale</db:code></db:para>
</db:td>
<db:td><db:code>18</db:code></db:td>
<db:td>
<db:para>QLocale</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::QBitmap</db:code></db:para>
</db:td>
<db:td><db:code>73</db:code></db:td>
<db:td>
<db:para>QBitmap</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::QMatrix</db:code></db:para>
</db:td>
<db:td><db:code>79</db:code></db:td>
<db:td>
<db:para>QMatrix</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::QTransform</db:code></db:para>
</db:td>
<db:td><db:code>80</db:code></db:td>
<db:td>
<db:para>QTransform</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::QMatrix4x4</db:code></db:para>
</db:td>
<db:td><db:code>81</db:code></db:td>
<db:td>
<db:para>QMatrix4x4</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::QVector2D</db:code></db:para>
</db:td>
<db:td><db:code>82</db:code></db:td>
<db:td>
<db:para>QVector2D</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::QVector3D</db:code></db:para>
</db:td>
<db:td><db:code>83</db:code></db:td>
<db:td>
<db:para>QVector3D</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::QVector4D</db:code></db:para>
</db:td>
<db:td><db:code>84</db:code></db:td>
<db:td>
<db:para>QVector4D</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::QQuaternion</db:code></db:para>
</db:td>
<db:td><db:code>85</db:code></db:td>
<db:td>
<db:para>QQuaternion</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::QEasingCurve</db:code></db:para>
</db:td>
<db:td><db:code>29</db:code></db:td>
<db:td>
<db:para>QEasingCurve</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::QJsonValue</db:code></db:para>
</db:td>
<db:td><db:code>45</db:code></db:td>
<db:td>
<db:para>QJsonValue</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::QJsonObject</db:code></db:para>
</db:td>
<db:td><db:code>46</db:code></db:td>
<db:td>
<db:para>QJsonObject</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::QJsonArray</db:code></db:para>
</db:td>
<db:td><db:code>47</db:code></db:td>
<db:td>
<db:para>QJsonArray</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::QJsonDocument</db:code></db:para>
</db:td>
<db:td><db:code>48</db:code></db:td>
<db:td>
<db:para>QJsonDocument</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::QModelIndex</db:code></db:para>
</db:td>
<db:td><db:code>42</db:code></db:td>
<db:td>
<db:para>QModelIndex</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::QPersistentModelIndex</db:code></db:para>
</db:td>
<db:td><db:code>50</db:code></db:td>
<db:td>
<db:para>QPersistentModelIndex (since 5.5)</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::QUuid</db:code></db:para>
</db:td>
<db:td><db:code>30</db:code></db:td>
<db:td>
<db:para>QUuid</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::QByteArrayList</db:code></db:para>
</db:td>
<db:td><db:code>49</db:code></db:td>
<db:td>
<db:para>QByteArrayList</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::User</db:code></db:para>
</db:td>
<db:td><db:code>1024</db:code></db:td>
<db:td>
<db:para>Base value for user types</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::UnknownType</db:code></db:para>
</db:td>
<db:td><db:code>0</db:code></db:td>
<db:td>
<db:para>This is an invalid type id. It is returned from <db:link xlink:href="qmetatype.xml">QMetaType</db:link> for types that are not registered</db:para>
</db:td>
</db:tr>
</db:informaltable>
<db:para>Additional types can be registered using <db:link xlink:href="qmetatype.xml#Q_DECLARE_METATYPE">Q_DECLARE_METATYPE</db:link>().</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qmetatype.xml#type">type</db:link>()</db:member>
<db:member><db:link xlink:href="qmetatype.xml#typeName">typeName</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="TypeFlag-enum">
<db:title>enum QMetaType::TypeFlag</db:title>
<db:bridgehead renderas="sect2">flags QMetaType::TypeFlags</db:bridgehead>
<db:para>The enum describes attributes of a type supported by <db:link xlink:href="qmetatype.xml">QMetaType</db:link>.</db:para>
<db:informaltable>
<db:thead>
<db:tr>
<db:th>Constant</db:th>
<db:th>Value</db:th>
<db:th>Description</db:th>
</db:tr>
</db:thead>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::NeedsConstruction</db:code></db:para>
</db:td>
<db:td><db:code>0x1</db:code></db:td>
<db:td>
<db:para>This type has non-trivial constructors. If the flag is not set instances can be safely initialized with memset to 0.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::NeedsDestruction</db:code></db:para>
</db:td>
<db:td><db:code>0x2</db:code></db:td>
<db:td>
<db:para>This type has a non-trivial destructor. If the flag is not set calls to the destructor are not necessary before discarding objects.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::MovableType</db:code></db:para>
</db:td>
<db:td><db:code>0x4</db:code></db:td>
<db:td>
<db:para>An instance of a type having this attribute can be safely moved by memcpy.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::IsEnumeration</db:code></db:para>
</db:td>
<db:td><db:code>0x10</db:code></db:td>
<db:td>
<db:para>This type is an enumeration</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::PointerToQObject</db:code></db:para>
</db:td>
<db:td><db:code>0x8</db:code></db:td>
<db:td>
<db:para>This type is a pointer to a derived of <db:link xlink:href="qobject.xml">QObject</db:link></db:para>
</db:td>
</db:tr>
</db:informaltable>
<db:para>The <db:code>TypeFlags</db:code> type is a typedef for <db:code><db:link xlink:href="qflags.xml">QFlags</db:link>&lt;TypeFlag&gt;. </db:code>It stores an OR combination of <db:code>TypeFlag</db:code> values.</db:para>
</db:section>
</db:section>
<db:section xml:id="member-function-documentation">
<db:title>Member Function Documentation</db:title>
<db:section xml:id="QMetaType-1">
<db:title>[explicit, since 5.0] QMetaType::QMetaType(const int <db:emphasis>typeId</db:emphasis>)</db:title>
<db:para>Constructs a <db:link xlink:href="qmetatype.xml">QMetaType</db:link> object that contains all information about type <db:code role="parameter">typeId</db:code>.</db:para>
<db:para>This function was introduced in Qt 5.0.</db:para>
</db:section>
<db:section xml:id="dtor.QMetaType">
<db:title>[noexcept] QMetaType::~QMetaType()</db:title>
<db:para>Destructs this object.</db:para>
</db:section>
<db:section xml:id="compare">
<db:title>[static, since 5.2] bool QMetaType::compare(const void *<db:emphasis>lhs</db:emphasis>, const void *<db:emphasis>rhs</db:emphasis>, int <db:emphasis>typeId</db:emphasis>, int *<db:emphasis>result</db:emphasis>)</db:title>
<db:para>Compares the objects at <db:code role="parameter">lhs</db:code> and <db:code role="parameter">rhs</db:code>. Both objects need to be of type <db:code role="parameter">typeId</db:code>. <db:code role="parameter">result</db:code> is set to less than, equal to or greater than zero, if <db:code role="parameter">lhs</db:code> is less than, equal to or greater than <db:code role="parameter">rhs</db:code>. Returns <db:code>true</db:code>, if the comparison succeeded, otherwise <db:code>false</db:code>.</db:para>
<db:para>This function was introduced in Qt 5.2.</db:para>
</db:section>
<db:section xml:id="construct">
<db:title>[since 5.0] void *QMetaType::construct(void *<db:emphasis>where</db:emphasis>, const void *<db:emphasis>copy</db:emphasis> = 0) const</db:title>
<db:para>Constructs a value of the type that this <db:link xlink:href="qmetatype.xml">QMetaType</db:link> instance was constructed for in the existing memory addressed by <db:code role="parameter">where</db:code>, that is a copy of <db:code role="parameter">copy</db:code>, and returns <db:code role="parameter">where</db:code>. If <db:code role="parameter">copy</db:code> is zero, the value is default constructed.</db:para>
<db:para>This is a low-level function for explicitly managing the memory used to store the type. Consider calling <db:link xlink:href="qmetatype.xml#create">create</db:link>() if you don't need this level of control (that is, use &quot;new&quot; rather than &quot;placement new&quot;).</db:para>
<db:para>You must ensure that <db:code role="parameter">where</db:code> points to a location where the new value can be stored and that <db:code role="parameter">where</db:code> is suitably aligned. The type's size can be queried by calling <db:link xlink:href="qmetatype.xml#sizeOf">sizeOf</db:link>().</db:para>
<db:para>The rule of thumb for alignment is that a type is aligned to its natural boundary, which is the smallest power of 2 that is bigger than the type, unless that alignment is larger than the maximum useful alignment for the platform. For practical purposes, alignment larger than 2 * sizeof(void*) is only necessary for special hardware instructions (e.g., aligned SSE loads and stores on x86).</db:para>
<db:para>This function was introduced in Qt 5.0.</db:para>
</db:section>
<db:section xml:id="construct-1">
<db:title>[static, since 5.0] void *QMetaType::construct(int <db:emphasis>type</db:emphasis>, void *<db:emphasis>where</db:emphasis>, const void *<db:emphasis>copy</db:emphasis>)</db:title>
<db:para>Constructs a value of the given <db:code role="parameter">type</db:code> in the existing memory addressed by <db:code role="parameter">where</db:code>, that is a copy of <db:code role="parameter">copy</db:code>, and returns <db:code role="parameter">where</db:code>. If <db:code role="parameter">copy</db:code> is zero, the value is default constructed.</db:para>
<db:para>This is a low-level function for explicitly managing the memory used to store the type. Consider calling <db:link xlink:href="qmetatype.xml#create">create</db:link>() if you don't need this level of control (that is, use &quot;new&quot; rather than &quot;placement new&quot;).</db:para>
<db:para>You must ensure that <db:code role="parameter">where</db:code> points to a location that can store a value of type <db:code role="parameter">type</db:code>, and that <db:code role="parameter">where</db:code> is suitably aligned. The type's size can be queried by calling <db:link xlink:href="qmetatype.xml#sizeOf">sizeOf</db:link>().</db:para>
<db:para>The rule of thumb for alignment is that a type is aligned to its natural boundary, which is the smallest power of 2 that is bigger than the type, unless that alignment is larger than the maximum useful alignment for the platform. For practical purposes, alignment larger than 2 * sizeof(void*) is only necessary for special hardware instructions (e.g., aligned SSE loads and stores on x86).</db:para>
<db:para>This function was introduced in Qt 5.0.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qmetatype.xml#destruct">destruct</db:link>()</db:member>
<db:member><db:link xlink:href="qmetatype.xml#sizeOf">sizeOf</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="convert">
<db:title>[static, since 5.2] bool QMetaType::convert(const void *<db:emphasis>from</db:emphasis>, int <db:emphasis>fromTypeId</db:emphasis>, void *<db:emphasis>to</db:emphasis>, int <db:emphasis>toTypeId</db:emphasis>)</db:title>
<db:para>Converts the object at <db:code role="parameter">from</db:code> from <db:code role="parameter">fromTypeId</db:code> to the preallocated space at <db:code role="parameter">to</db:code> typed <db:code role="parameter">toTypeId</db:code>. Returns <db:code>true</db:code>, if the conversion succeeded, otherwise false.</db:para>
<db:para>This function was introduced in Qt 5.2.</db:para>
</db:section>
<db:section xml:id="create">
<db:title>[since 5.0] void *QMetaType::create(const void *<db:emphasis>copy</db:emphasis> = 0) const</db:title>
<db:para>Returns a copy of <db:code role="parameter">copy</db:code>, assuming it is of the type that this <db:link xlink:href="qmetatype.xml">QMetaType</db:link> instance was created for. If <db:code role="parameter">copy</db:code> is null, creates a default constructed instance.</db:para>
<db:para>This function was introduced in Qt 5.0.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qmetatype.xml#destroy">QMetaType::destroy</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="create-1">
<db:title>[static] void *QMetaType::create(int <db:emphasis>type</db:emphasis>, const void *<db:emphasis>copy</db:emphasis> = Q_NULLPTR)</db:title>
<db:para>Returns a copy of <db:code role="parameter">copy</db:code>, assuming it is of type <db:code role="parameter">type</db:code>. If <db:code role="parameter">copy</db:code> is zero, creates a default constructed instance.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qmetatype.xml#destroy">destroy</db:link>()</db:member>
<db:member><db:link xlink:href="qmetatype.xml#isRegistered">isRegistered</db:link>()</db:member>
<db:member><db:link xlink:href="qmetatype.xml#Type-enum">Type</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="debugStream">
<db:title>[static, since 5.2] bool QMetaType::debugStream(QDebug &amp;<db:emphasis>dbg</db:emphasis>, const void *<db:emphasis>rhs</db:emphasis>, int <db:emphasis>typeId</db:emphasis>)</db:title>
<db:para>Streams the object at <db:code role="parameter">rhs</db:code> of type <db:code role="parameter">typeId</db:code> to the debug stream <db:code role="parameter">dbg</db:code>. Returns <db:code>true</db:code> on success, otherwise false.</db:para>
<db:para>This function was introduced in Qt 5.2.</db:para>
</db:section>
<db:section xml:id="destroy">
<db:title>[since 5.0] void QMetaType::destroy(void *<db:emphasis>data</db:emphasis>) const</db:title>
<db:para>Destroys the <db:code role="parameter">data</db:code>, assuming it is of the type that this <db:link xlink:href="qmetatype.xml">QMetaType</db:link> instance was created for.</db:para>
<db:para>This function was introduced in Qt 5.0.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qmetatype.xml#create">QMetaType::create</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="destroy-1">
<db:title>[static] void QMetaType::destroy(int <db:emphasis>type</db:emphasis>, void *<db:emphasis>data</db:emphasis>)</db:title>
<db:para>Destroys the <db:code role="parameter">data</db:code>, assuming it is of the <db:code role="parameter">type</db:code> given.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qmetatype.xml#create">create</db:link>()</db:member>
<db:member><db:link xlink:href="qmetatype.xml#isRegistered">isRegistered</db:link>()</db:member>
<db:member><db:link xlink:href="qmetatype.xml#Type-enum">Type</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="destruct">
<db:title>[since 5.0] void QMetaType::destruct(void *<db:emphasis>data</db:emphasis>) const</db:title>
<db:para>Destructs the value, located at <db:code role="parameter">data</db:code>, assuming that it is of the type for which this <db:link xlink:href="qmetatype.xml">QMetaType</db:link> instance was constructed for.</db:para>
<db:para>Unlike <db:link xlink:href="qmetatype.xml#destroy">destroy</db:link>(), this function only invokes the type's destructor, it doesn't invoke the delete operator.</db:para>
<db:para>This function was introduced in Qt 5.0.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qmetatype.xml#construct">QMetaType::construct</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="destruct-1">
<db:title>[static, since 5.0] void QMetaType::destruct(int <db:emphasis>type</db:emphasis>, void *<db:emphasis>where</db:emphasis>)</db:title>
<db:para>Destructs the value of the given <db:code role="parameter">type</db:code>, located at <db:code role="parameter">where</db:code>.</db:para>
<db:para>Unlike <db:link xlink:href="qmetatype.xml#destroy">destroy</db:link>(), this function only invokes the type's destructor, it doesn't invoke the delete operator.</db:para>
<db:para>This function was introduced in Qt 5.0.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qmetatype.xml#construct">construct</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="equals">
<db:title>[static, since 5.5] bool QMetaType::equals(const void *<db:emphasis>lhs</db:emphasis>, const void *<db:emphasis>rhs</db:emphasis>, int <db:emphasis>typeId</db:emphasis>, int *<db:emphasis>result</db:emphasis>)</db:title>
<db:para>Compares the objects at <db:code role="parameter">lhs</db:code> and <db:code role="parameter">rhs</db:code>. Both objects need to be of type <db:code role="parameter">typeId</db:code>. <db:code role="parameter">result</db:code> is set to zero, if <db:code role="parameter">lhs</db:code> equals to rhs. Returns <db:code>true</db:code>, if the comparison succeeded, otherwise <db:code>false</db:code>.</db:para>
<db:para>This function was introduced in Qt 5.5.</db:para>
</db:section>
<db:section xml:id="flags">
<db:title>[since 5.0] QMetaType::TypeFlags QMetaType::flags() const</db:title>
<db:para>Returns flags of the type for which this <db:link xlink:href="qmetatype.xml">QMetaType</db:link> instance was constructed.</db:para>
<db:para>This function was introduced in Qt 5.0.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qmetatype.xml#TypeFlag-enum">QMetaType::TypeFlags</db:link></db:member>
<db:member><db:link xlink:href="qmetatype.xml#typeFlags">QMetaType::typeFlags</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="hasRegisteredComparators">
<db:title>[static, since 5.2] bool QMetaType::hasRegisteredComparators(int <db:emphasis>typeId</db:emphasis>)</db:title>
<db:para>Returns <db:code>true</db:code>, if the meta type system has registered comparators for type id <db:code role="parameter">typeId</db:code>.</db:para>
<db:para>This function was introduced in Qt 5.2.</db:para>
</db:section>
<db:section xml:id="hasRegisteredConverterFunction">
<db:title>[static, since 5.2] bool QMetaType::hasRegisteredConverterFunction(int <db:emphasis>fromTypeId</db:emphasis>, int <db:emphasis>toTypeId</db:emphasis>)</db:title>
<db:para>Returns <db:code>true</db:code>, if the meta type system has a registered conversion from meta type id <db:code role="parameter">fromTypeId</db:code> to <db:code role="parameter">toTypeId</db:code></db:para>
<db:para>This function was introduced in Qt 5.2.</db:para>
</db:section>
<db:section xml:id="hasRegisteredDebugStreamOperator">
<db:title>[static, since 5.2] bool QMetaType::hasRegisteredDebugStreamOperator(int <db:emphasis>typeId</db:emphasis>)</db:title>
<db:para>Returns <db:code>true</db:code>, if the meta type system has a registered debug stream operator for type id <db:code role="parameter">typeId</db:code>.</db:para>
<db:para>This function was introduced in Qt 5.2.</db:para>
</db:section>
<db:section xml:id="isRegistered">
<db:title>[since 5.0] bool QMetaType::isRegistered() const</db:title>
<db:para>Returns <db:code>true</db:code> if this <db:link xlink:href="qmetatype.xml">QMetaType</db:link> object contains valid information about a type, false otherwise.</db:para>
<db:para>This function was introduced in Qt 5.0.</db:para>
</db:section>
<db:section xml:id="isRegistered-1">
<db:title>[static] bool QMetaType::isRegistered(int <db:emphasis>type</db:emphasis>)</db:title>
<db:para>Returns <db:code>true</db:code> if the datatype with ID <db:code role="parameter">type</db:code> is registered; otherwise returns <db:code>false</db:code>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qmetatype.xml#type">type</db:link>()</db:member>
<db:member><db:link xlink:href="qmetatype.xml#typeName">typeName</db:link>()</db:member>
<db:member><db:link xlink:href="qmetatype.xml#Type-enum">Type</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="isValid">
<db:title>[since 5.0] bool QMetaType::isValid() const</db:title>
<db:para>Returns <db:code>true</db:code> if this <db:link xlink:href="qmetatype.xml">QMetaType</db:link> object contains valid information about a type, false otherwise.</db:para>
<db:para>This function was introduced in Qt 5.0.</db:para>
</db:section>
<db:section xml:id="load">
<db:title>[static] bool QMetaType::load(QDataStream &amp;<db:emphasis>stream</db:emphasis>, int <db:emphasis>type</db:emphasis>, void *<db:emphasis>data</db:emphasis>)</db:title>
<db:para>Reads the object of the specified <db:code role="parameter">type</db:code> from the given <db:code role="parameter">stream</db:code> into <db:code role="parameter">data</db:code>. Returns <db:code>true</db:code> if the object is loaded successfully; otherwise returns <db:code>false</db:code>.</db:para>
<db:para>The type must have been registered with qRegisterMetaType() and qRegisterMetaTypeStreamOperators() beforehand.</db:para>
<db:para>Normally, you should not need to call this function directly. Instead, use <db:link xlink:href="qmetatype.xml#Type-enum">QVariant</db:link>'s <db:code>operator&gt;&gt;()</db:code>, which relies on load() to stream custom types.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qmetatype.xml#save">save</db:link>()</db:member>
<db:member><db:link xlink:href="">qRegisterMetaTypeStreamOperators()</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="metaObject">
<db:title>[since 5.5] const QMetaObject *QMetaType::metaObject() const</db:title>
<db:para>return a <db:link xlink:href="qmetaobject.xml">QMetaObject</db:link> relative to this type.</db:para>
<db:para>If the type is a pointer type to a subclass of <db:link xlink:href="qobject.xml">QObject</db:link>, <db:link xlink:href="qmetatype.xml#flags">flags</db:link>() contains <db:link xlink:href="qmetatype.xml#TypeFlag-enum">QMetaType::PointerToQObject</db:link> and this function returns the corresponding <db:link xlink:href="qmetaobject.xml">QMetaObject</db:link>. This can be used to in combinaison with QMetaObject::construct to create <db:link xlink:href="qobject.xml">QObject</db:link> of this type.</db:para>
<db:para>If the type is a <db:link xlink:href="qobject.xml#Q_GADGET">Q_GADGET</db:link>, <db:link xlink:href="qmetatype.xml#flags">flags</db:link>() contains <db:link xlink:href="qmetatype.xml#TypeFlag-enum">QMetaType::IsGadget</db:link>, and this function returns its <db:link xlink:href="qmetaobject.xml">QMetaObject</db:link>. This can be used to retrieve <db:link xlink:href="qmetamethod.xml">QMetaMethod</db:link> and <db:link xlink:href="qmetaproperty.xml">QMetaProperty</db:link> and use them on a pointer of this type. (given by QVariant::data for example)</db:para>
<db:para>If the type is an enumeration, <db:link xlink:href="qmetatype.xml#flags">flags</db:link>() contains <db:link xlink:href="qmetatype.xml#TypeFlag-enum">QMetaType::IsEnumeration</db:link>, and this function returns the <db:link xlink:href="qmetaobject.xml">QMetaObject</db:link> of the enclosing object if the enum was registered as a <db:link xlink:href="qobject.xml#Q_ENUM">Q_ENUM</db:link> or 0 otherwise</db:para>
<db:para>This function was introduced in Qt 5.5.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qmetatype.xml#metaObjectForType">QMetaType::metaObjectForType</db:link>()</db:member>
<db:member><db:link xlink:href="qmetatype.xml#flags">QMetaType::flags</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="metaObjectForType">
<db:title>[static, since 5.0] const QMetaObject *QMetaType::metaObjectForType(int <db:emphasis>type</db:emphasis>)</db:title>
<db:para>returns <db:link xlink:href="qmetatype.xml#metaObject">QMetaType::metaObject</db:link> for <db:code role="parameter">type</db:code></db:para>
<db:para>This function was introduced in Qt 5.0.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qmetatype.xml#metaObject">metaObject</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="registerConverter-1">
<db:title>[static, since 5.2] bool QMetaType::registerConverter(int <db:emphasis>function</db:emphasis>)</db:title>
<db:para>This is an overloaded function.</db:para>
<db:para>Registers a unary function object <db:code role="parameter">function</db:code> as converter from type From to type To in the meta type system. Returns <db:code>true</db:code> if the registration succeeded, otherwise false.</db:para>
<db:para>This function was introduced in Qt 5.2.</db:para>
</db:section>
<db:section xml:id="save">
<db:title>[static] bool QMetaType::save(QDataStream &amp;<db:emphasis>stream</db:emphasis>, int <db:emphasis>type</db:emphasis>, const void *<db:emphasis>data</db:emphasis>)</db:title>
<db:para>Writes the object pointed to by <db:code role="parameter">data</db:code> with the ID <db:code role="parameter">type</db:code> to the given <db:code role="parameter">stream</db:code>. Returns <db:code>true</db:code> if the object is saved successfully; otherwise returns <db:code>false</db:code>.</db:para>
<db:para>The type must have been registered with qRegisterMetaType() and qRegisterMetaTypeStreamOperators() beforehand.</db:para>
<db:para>Normally, you should not need to call this function directly. Instead, use <db:link xlink:href="qmetatype.xml#Type-enum">QVariant</db:link>'s <db:code>operator&lt;&lt;()</db:code>, which relies on save() to stream custom types.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qmetatype.xml#load">load</db:link>()</db:member>
<db:member><db:link xlink:href="">qRegisterMetaTypeStreamOperators()</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="sizeOf">
<db:title>[since 5.0] int QMetaType::sizeOf() const</db:title>
<db:para>Returns the size of the type in bytes (i.e. sizeof(T), where T is the actual type for which this <db:link xlink:href="qmetatype.xml">QMetaType</db:link> instance was constructed for).</db:para>
<db:para>This function is typically used together with <db:link xlink:href="qmetatype.xml#construct">construct</db:link>() to perform low-level management of the memory used by a type.</db:para>
<db:para>This function was introduced in Qt 5.0.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qmetatype.xml#construct">QMetaType::construct</db:link>()</db:member>
<db:member><db:link xlink:href="">QMetaType::sizeOf</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="sizeOf-1">
<db:title>[static, since 5.0] int QMetaType::sizeOf(int <db:emphasis>type</db:emphasis>)</db:title>
<db:para>Returns the size of the given <db:code role="parameter">type</db:code> in bytes (i.e. sizeof(T), where T is the actual type identified by the <db:code role="parameter">type</db:code> argument).</db:para>
<db:para>This function is typically used together with <db:link xlink:href="qmetatype.xml#construct">construct</db:link>() to perform low-level management of the memory used by a type.</db:para>
<db:para>This function was introduced in Qt 5.0.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qmetatype.xml#construct">construct</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="type">
<db:title>[static] int QMetaType::type(const char *<db:emphasis>typeName</db:emphasis>)</db:title>
<db:para>Returns a handle to the type called <db:code role="parameter">typeName</db:code>, or <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::UnknownType</db:link> if there is no such type.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qmetatype.xml#isRegistered">isRegistered</db:link>()</db:member>
<db:member><db:link xlink:href="qmetatype.xml#typeName">typeName</db:link>()</db:member>
<db:member><db:link xlink:href="qmetatype.xml#Type-enum">Type</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="typeFlags">
<db:title>[static, since 5.0] QMetaType::TypeFlags QMetaType::typeFlags(int <db:emphasis>type</db:emphasis>)</db:title>
<db:para>Returns flags of the given <db:code role="parameter">type</db:code>.</db:para>
<db:para>This function was introduced in Qt 5.0.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qmetatype.xml#TypeFlag-enum">QMetaType::TypeFlags</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="typeName">
<db:title>[static] const char *QMetaType::typeName(int <db:emphasis>typeId</db:emphasis>)</db:title>
<db:para>Returns the type name associated with the given <db:code role="parameter">typeId</db:code>, or 0 if no matching type was found. The returned pointer must not be deleted.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qmetatype.xml#type">type</db:link>()</db:member>
<db:member><db:link xlink:href="qmetatype.xml#isRegistered">isRegistered</db:link>()</db:member>
<db:member><db:link xlink:href="qmetatype.xml#Type-enum">Type</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
</db:section>
<db:section xml:id="macro-documentation">
<db:title>Macro Documentation</db:title>
<db:section xml:id="Q_DECLARE_ASSOCIATIVE_CONTAINER_METATYPE">
<db:title>Q_DECLARE_ASSOCIATIVE_CONTAINER_METATYPE(<db:emphasis>Container</db:emphasis>)</db:title>
<db:para>This macro makes the container <db:code role="parameter">Container</db:code> known to <db:link xlink:href="qmetatype.xml">QMetaType</db:link> as an associative container. This makes it possible to put an instance of Container&lt;T, U&gt; into a <db:link xlink:href="qmetatype.xml#Type-enum">QVariant</db:link>, if T and U are themselves known to <db:link xlink:href="qmetatype.xml">QMetaType</db:link>.</db:para>
<db:para>Note that all of the Qt associative containers already have built-in support, and it is not necessary to use this macro with them. The std::map container also has built-in support.</db:para>
<db:para>This example shows a typical use of Q_DECLARE_ASSOCIATIVE_CONTAINER_METATYPE():</db:para>
<db:programlisting language="cpp">#include &lt;unordered_list&gt;

Q_DECLARE_ASSOCIATIVE_CONTAINER_METATYPE(std::unordered_map)

void someFunc()
{
    std::unordered_map&lt;int, bool&gt; container;
    QVariant var = QVariant::fromValue(container);
    // ...
}

</db:programlisting>
</db:section>
<db:section xml:id="Q_DECLARE_METATYPE">
<db:title>Q_DECLARE_METATYPE(<db:emphasis>Type</db:emphasis>)</db:title>
<db:para>This macro makes the type <db:code role="parameter">Type</db:code> known to <db:link xlink:href="qmetatype.xml">QMetaType</db:link> as long as it provides a public default constructor, a public copy constructor and a public destructor. It is needed to use the type <db:code role="parameter">Type</db:code> as a custom type in <db:link xlink:href="qmetatype.xml#Type-enum">QVariant</db:link>.</db:para>
<db:para>This macro requires that <db:code role="parameter">Type</db:code> is a fully defined type at the point where it is used. For pointer types, it also requires that the pointed to type is fully defined. Use in conjunction with <db:link xlink:href="qmetatype.xml#Q_DECLARE_OPAQUE_POINTER">Q_DECLARE_OPAQUE_POINTER</db:link>() to register pointers to forward declared types.</db:para>
<db:para>Ideally, this macro should be placed below the declaration of the class or struct. If that is not possible, it can be put in a private header file which has to be included every time that type is used in a <db:link xlink:href="qmetatype.xml#Type-enum">QVariant</db:link>.</db:para>
<db:para>Adding a Q_DECLARE_METATYPE() makes the type known to all template based functions, including <db:link xlink:href="qmetatype.xml#Type-enum">QVariant</db:link>. Note that if you intend to use the type in <db:emphasis>queued</db:emphasis> signal and slot connections or in <db:link xlink:href="qobject.xml">QObject</db:link>'s property system, you also have to call qRegisterMetaType() since the names are resolved at runtime.</db:para>
<db:para>This example shows a typical use case of Q_DECLARE_METATYPE():</db:para>
<db:programlisting language="cpp">struct MyStruct
{
    int i;
    ...
};

Q_DECLARE_METATYPE(MyStruct)
</db:programlisting>
<db:para>If <db:code>MyStruct</db:code> is in a namespace, the Q_DECLARE_METATYPE() macro has to be outside the namespace:</db:para>
<db:programlisting language="cpp">namespace MyNamespace
{
    ...
}

Q_DECLARE_METATYPE(MyNamespace::MyStruct)
</db:programlisting>
<db:para>Since <db:code>MyStruct</db:code> is now known to <db:link xlink:href="qmetatype.xml">QMetaType</db:link>, it can be used in <db:link xlink:href="qmetatype.xml#Type-enum">QVariant</db:link>:</db:para>
<db:programlisting language="cpp">MyStruct s;
QVariant var;
var.setValue(s); // copy s into the variant

...

// retrieve the value
MyStruct s2 = var.value&lt;MyStruct&gt;();
</db:programlisting>
<db:para>Some types are registered automatically and do not need this macro:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para>Pointers to classes derived from <db:link xlink:href="qobject.xml">QObject</db:link></db:para>
</db:listitem>
<db:listitem>
<db:para><db:link xlink:href="qlist.xml">QList</db:link>&lt;T&gt;, <db:link xlink:href="qvector.xml">QVector</db:link>&lt;T&gt;, <db:link xlink:href="qqueue.xml">QQueue</db:link>&lt;T&gt;, <db:link xlink:href="qstack.xml">QStack</db:link>&lt;T&gt;, <db:link xlink:href="qset.xml">QSet</db:link>&lt;T&gt; or <db:link xlink:href="qlinkedlist.xml">QLinkedList</db:link>&lt;T&gt; where T is a registered meta type</db:para>
</db:listitem>
<db:listitem>
<db:para><db:link xlink:href="qhash.xml#the-qhash-hashing-function">QHash</db:link>&lt;T1, T2&gt;, <db:link xlink:href="qmap.xml">QMap</db:link>&lt;T1, T2&gt; or <db:link xlink:href="qpair.xml">QPair</db:link>&lt;T1, T2&gt; where T1 and T2 are registered meta types</db:para>
</db:listitem>
<db:listitem>
<db:para><db:link xlink:href="qpointer.xml">QPointer</db:link>&lt;T&gt;, <db:link xlink:href="qsharedpointer.xml">QSharedPointer</db:link>&lt;T&gt;, <db:link xlink:href="qweakpointer.xml">QWeakPointer</db:link>&lt;T&gt;, where T is a class that derives from <db:link xlink:href="qobject.xml">QObject</db:link></db:para>
</db:listitem>
<db:listitem>
<db:para>Enumerations registered with <db:link xlink:href="qobject.xml#Q_ENUM">Q_ENUM</db:link> or <db:link xlink:href="qobject.xml#Q_FLAG">Q_FLAG</db:link></db:para>
</db:listitem>
<db:listitem>
<db:para>Classes that have a <db:link xlink:href="qobject.xml#Q_GADGET">Q_GADGET</db:link> macro</db:para>
</db:listitem>
</db:itemizedlist>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="">qRegisterMetaType()</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="Q_DECLARE_OPAQUE_POINTER">
<db:title>[since 5.0] Q_DECLARE_OPAQUE_POINTER(<db:emphasis>PointerType</db:emphasis>)</db:title>
<db:para>This macro enables pointers to forward-declared types (<db:code role="parameter">PointerType</db:code>) to be registered with <db:link xlink:href="qmetatype.xml">QMetaType</db:link> using either <db:link xlink:href="qmetatype.xml#Q_DECLARE_METATYPE">Q_DECLARE_METATYPE</db:link>() or qRegisterMetaType().</db:para>
<db:para>This macro was introduced in Qt 5.0.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qmetatype.xml#Q_DECLARE_METATYPE">Q_DECLARE_METATYPE</db:link>()</db:member>
<db:member><db:link xlink:href="">qRegisterMetaType()</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="Q_DECLARE_SEQUENTIAL_CONTAINER_METATYPE">
<db:title>Q_DECLARE_SEQUENTIAL_CONTAINER_METATYPE(<db:emphasis>Container</db:emphasis>)</db:title>
<db:para>This macro makes the container <db:code role="parameter">Container</db:code> known to <db:link xlink:href="qmetatype.xml">QMetaType</db:link> as a sequential container. This makes it possible to put an instance of Container&lt;T&gt; into a <db:link xlink:href="qmetatype.xml#Type-enum">QVariant</db:link>, if T itself is known to <db:link xlink:href="qmetatype.xml">QMetaType</db:link>.</db:para>
<db:para>Note that all of the Qt sequential containers already have built-in support, and it is not necessary to use this macro with them. The std::vector and std::list containers also have built-in support.</db:para>
<db:para>This example shows a typical use of Q_DECLARE_SEQUENTIAL_CONTAINER_METATYPE():</db:para>
<db:programlisting language="cpp">#include &lt;deque&gt;

Q_DECLARE_SEQUENTIAL_CONTAINER_METATYPE(std::deque)

void someFunc()
{
    std::deque&lt;QFile*&gt; container;
    QVariant var = QVariant::fromValue(container);
    // ...
}

</db:programlisting>
</db:section>
<db:section xml:id="Q_DECLARE_SMART_POINTER_METATYPE">
<db:title>Q_DECLARE_SMART_POINTER_METATYPE(<db:emphasis>SmartPointer</db:emphasis>)</db:title>
<db:para>This macro makes the smart pointer <db:code role="parameter">SmartPointer</db:code> known to <db:link xlink:href="qmetatype.xml">QMetaType</db:link> as a smart pointer. This makes it possible to put an instance of SmartPointer&lt;T&gt; into a <db:link xlink:href="qmetatype.xml#Type-enum">QVariant</db:link>, if T is a type which inherits <db:link xlink:href="qobject.xml">QObject</db:link>.</db:para>
<db:para>Note that the <db:link xlink:href="qweakpointer.xml">QWeakPointer</db:link>, <db:link xlink:href="qsharedpointer.xml">QSharedPointer</db:link> and <db:link xlink:href="qpointer.xml">QPointer</db:link> already have built-in support, and it is not necessary to use this macro with them.</db:para>
<db:para>This example shows a typical use of Q_DECLARE_SMART_POINTER_METATYPE():</db:para>
<db:programlisting language="cpp">#include &lt;memory&gt;

Q_DECLARE_SMART_POINTER_METATYPE(std::shared_ptr)

void someFunc()
{
    auto smart_ptr = std::make_shared&lt;QFile&gt;();
    QVariant var = QVariant::fromValue(smart_ptr);
    // ...
    if (var.canConvert&lt;QObject*&gt;()) {
        QObject *sp = var.value&lt;QObject*&gt;();
        qDebug() &lt;&lt; sp-&gt;metaObject()-&gt;className(); // Prints 'QFile'.
    }
}

</db:programlisting>
</db:section>
</db:section>
</db:article>
