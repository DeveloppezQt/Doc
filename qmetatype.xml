<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en">
<db:info>
<db:title>QMetaType Class</db:title>
<db:productname>QtCore</db:productname>
<db:edition>Qt 6.8.3 Reference Documentation</db:edition>
<db:titleabbrev>Qt Core Reference Documentation</db:titleabbrev>
<db:abstract>
<db:para>The <db:link xlink:href="qmetatype.xml">QMetaType</db:link> class manages named types in the meta-object system.</db:para>
<db:note>
<db:para>All functions in this class are <db:link xlink:href="">thread-safe</db:link>.</db:para>
</db:note>
<db:para>This class is <db:emphasis>equality-comparable</db:emphasis>.</db:para>
</db:abstract>
<db:pubdate>2025-06-29</db:pubdate>
<db:date>2025-06-29</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:variablelist>
<db:varlistentry>
<db:term>Header</db:term>
<db:listitem>
<db:para>QMetaType</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>CMake</db:term>
<db:listitem>
<db:para>find_package(Qt6 REQUIRED COMPONENTS Core)</db:para>
<db:para>target_link_libraries(mytarget PRIVATE Qt6::Core)</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>qmake</db:term>
<db:listitem>
<db:para>QT += core</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Group</db:term>
<db:listitem>
<db:para>QMetaType is part of <db:simplelist><db:member>objectmodel</db:member></db:simplelist>
</db:para>
</db:listitem>
</db:varlistentry>
</db:variablelist>
<db:section xml:id="details">
<db:title>Detailed Description</db:title>
<db:para>The class is used as a helper to marshall types in <db:link xlink:href="qmetatype.xml#Type-enum">QVariant</db:link> and in queued signals and slots connections. It associates a type name to a type so that it can be created and destructed dynamically at run-time.</db:para>
<db:para>Type names can be registered with <db:link xlink:href="qmetatype.xml">QMetaType</db:link> by using either <db:link xlink:href="qmetatype.xml#qRegisterMetaType">qRegisterMetaType</db:link>() or <db:link xlink:href="qmetatype.xml#registerType">registerType</db:link>(). Registration is not required for most operations; it's only required for operations that attempt to resolve a type name in string form back to a <db:link xlink:href="qmetatype.xml">QMetaType</db:link> object or the type's ID. Those include some old-style signal-slot connections using <db:link xlink:href="qobject.xml#connect">QObject::connect</db:link>(), reading user-types from <db:link xlink:href="qdatastream.xml">QDataStream</db:link> to <db:link xlink:href="qmetatype.xml#Type-enum">QVariant</db:link>, or binding to other languages and IPC mechanisms, like QML, D-Bus, JavaScript, etc.</db:para>
<db:para>The following code allocates and destructs an instance of MyClass by its name, which requires that MyClass have been previously registered:</db:para>
<db:programlisting language="cpp">QMetaType type = QMetaType::fromName(&quot;MyClass&quot;);
if (type.isValid()) {
    void *myClassPtr = type.create();
    ...
    type.destroy(myClassPtr);
    myClassPtr = nullptr;
}
</db:programlisting>
<db:para>If we want the stream operators operator&lt;&lt;() and operator&gt;&gt;() to work on <db:link xlink:href="qmetatype.xml#Type-enum">QVariant</db:link> objects that store custom types, the custom type must provide operator&lt;&lt;() and operator&gt;&gt;() operators.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qmetatype.xml#Q_DECLARE_METATYPE">Q_DECLARE_METATYPE</db:link>()</db:member>
<db:member><db:link xlink:href="qvariant.xml#setValue">QVariant::setValue</db:link>()</db:member>
<db:member><db:link xlink:href="qvariant.xml#value">QVariant::value</db:link>()</db:member>
<db:member><db:link xlink:href="qvariant.xml#fromValue">QVariant::fromValue</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="member-type-documentation">
<db:title>Member Type Documentation</db:title>
<db:section xml:id="Type-enum">
<db:title>enum QMetaType::Type</db:title>
<db:para>These are the built-in types supported by <db:link xlink:href="qmetatype.xml">QMetaType</db:link>:</db:para>
<db:informaltable>
<db:thead>
<db:tr>
<db:th>Constant</db:th>
<db:th>Value</db:th>
<db:th>Description</db:th>
</db:tr>
</db:thead>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::Void</db:code></db:para>
</db:td>
<db:td><db:code>43</db:code></db:td>
<db:td>
<db:para>void</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::Bool</db:code></db:para>
</db:td>
<db:td><db:code>1</db:code></db:td>
<db:td>
<db:para>bool</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::Int</db:code></db:para>
</db:td>
<db:td><db:code>2</db:code></db:td>
<db:td>
<db:para>int</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::UInt</db:code></db:para>
</db:td>
<db:td><db:code>3</db:code></db:td>
<db:td>
<db:para>unsigned int</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::Double</db:code></db:para>
</db:td>
<db:td><db:code>6</db:code></db:td>
<db:td>
<db:para>double</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::QChar</db:code></db:para>
</db:td>
<db:td><db:code>7</db:code></db:td>
<db:td>
<db:para>QChar</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::QString</db:code></db:para>
</db:td>
<db:td><db:code>10</db:code></db:td>
<db:td>
<db:para>QString</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::QByteArray</db:code></db:para>
</db:td>
<db:td><db:code>12</db:code></db:td>
<db:td>
<db:para>QByteArray</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::Nullptr</db:code></db:para>
</db:td>
<db:td><db:code>51</db:code></db:td>
<db:td>
<db:para>std::nullptr_t</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::VoidStar</db:code></db:para>
</db:td>
<db:td><db:code>31</db:code></db:td>
<db:td>
<db:para>void *</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::Long</db:code></db:para>
</db:td>
<db:td><db:code>32</db:code></db:td>
<db:td>
<db:para>long</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::LongLong</db:code></db:para>
</db:td>
<db:td><db:code>4</db:code></db:td>
<db:td>
<db:para>LongLong</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::Short</db:code></db:para>
</db:td>
<db:td><db:code>33</db:code></db:td>
<db:td>
<db:para>short</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::Char</db:code></db:para>
</db:td>
<db:td><db:code>34</db:code></db:td>
<db:td>
<db:para>char</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::Char16</db:code></db:para>
</db:td>
<db:td><db:code>56</db:code></db:td>
<db:td>
<db:para>char16_t</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::Char32</db:code></db:para>
</db:td>
<db:td><db:code>57</db:code></db:td>
<db:td>
<db:para>char32_t</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::ULong</db:code></db:para>
</db:td>
<db:td><db:code>35</db:code></db:td>
<db:td>
<db:para>unsigned long</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::ULongLong</db:code></db:para>
</db:td>
<db:td><db:code>5</db:code></db:td>
<db:td>
<db:para>ULongLong</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::UShort</db:code></db:para>
</db:td>
<db:td><db:code>36</db:code></db:td>
<db:td>
<db:para>unsigned short</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::SChar</db:code></db:para>
</db:td>
<db:td><db:code>40</db:code></db:td>
<db:td>
<db:para>signed char</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::UChar</db:code></db:para>
</db:td>
<db:td><db:code>37</db:code></db:td>
<db:td>
<db:para>unsigned char</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::Float</db:code></db:para>
</db:td>
<db:td><db:code>38</db:code></db:td>
<db:td>
<db:para>float</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::Float16</db:code></db:para>
</db:td>
<db:td><db:code>63</db:code></db:td>
<db:td>
<db:para>qfloat16</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::QObjectStar</db:code></db:para>
</db:td>
<db:td><db:code>39</db:code></db:td>
<db:td>
<db:para><db:link xlink:href="qobject.xml">QObject</db:link> *</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::QCursor</db:code></db:para>
</db:td>
<db:td><db:code>0x100a</db:code></db:td>
<db:td>
<db:para>QCursor</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::QDate</db:code></db:para>
</db:td>
<db:td><db:code>14</db:code></db:td>
<db:td>
<db:para>QDate</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::QSize</db:code></db:para>
</db:td>
<db:td><db:code>21</db:code></db:td>
<db:td>
<db:para>QSize</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::QTime</db:code></db:para>
</db:td>
<db:td><db:code>15</db:code></db:td>
<db:td>
<db:para>QTime</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::QVariantList</db:code></db:para>
</db:td>
<db:td><db:code>9</db:code></db:td>
<db:td>
<db:para>QVariantList</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::QPolygon</db:code></db:para>
</db:td>
<db:td><db:code>0x1007</db:code></db:td>
<db:td>
<db:para>QPolygon</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::QPolygonF</db:code></db:para>
</db:td>
<db:td><db:code>0x1016</db:code></db:td>
<db:td>
<db:para>QPolygonF</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::QColor</db:code></db:para>
</db:td>
<db:td><db:code>0x1003</db:code></db:td>
<db:td>
<db:para>QColor</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::QColorSpace</db:code></db:para>
</db:td>
<db:td><db:code>0x1017</db:code></db:td>
<db:td>
<db:para>QColorSpace (introduced in Qt 5.15)</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::QSizeF</db:code></db:para>
</db:td>
<db:td><db:code>22</db:code></db:td>
<db:td>
<db:para>QSizeF</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::QRectF</db:code></db:para>
</db:td>
<db:td><db:code>20</db:code></db:td>
<db:td>
<db:para>QRectF</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::QLine</db:code></db:para>
</db:td>
<db:td><db:code>23</db:code></db:td>
<db:td>
<db:para>QLine</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::QTextLength</db:code></db:para>
</db:td>
<db:td><db:code>0x100d</db:code></db:td>
<db:td>
<db:para>QTextLength</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::QStringList</db:code></db:para>
</db:td>
<db:td><db:code>11</db:code></db:td>
<db:td>
<db:para>QStringList</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::QVariantMap</db:code></db:para>
</db:td>
<db:td><db:code>8</db:code></db:td>
<db:td>
<db:para>QVariantMap</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::QVariantHash</db:code></db:para>
</db:td>
<db:td><db:code>28</db:code></db:td>
<db:td>
<db:para>QVariantHash</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::QVariantPair</db:code></db:para>
</db:td>
<db:td><db:code>58</db:code></db:td>
<db:td>
<db:para>QVariantPair</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::QIcon</db:code></db:para>
</db:td>
<db:td><db:code>0x1005</db:code></db:td>
<db:td>
<db:para>QIcon</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::QPen</db:code></db:para>
</db:td>
<db:td><db:code>0x100c</db:code></db:td>
<db:td>
<db:para>QPen</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::QLineF</db:code></db:para>
</db:td>
<db:td><db:code>24</db:code></db:td>
<db:td>
<db:para>QLineF</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::QTextFormat</db:code></db:para>
</db:td>
<db:td><db:code>0x100e</db:code></db:td>
<db:td>
<db:para>QTextFormat</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::QRect</db:code></db:para>
</db:td>
<db:td><db:code>19</db:code></db:td>
<db:td>
<db:para>QRect</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::QPoint</db:code></db:para>
</db:td>
<db:td><db:code>25</db:code></db:td>
<db:td>
<db:para>QPoint</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::QUrl</db:code></db:para>
</db:td>
<db:td><db:code>17</db:code></db:td>
<db:td>
<db:para>QUrl</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::QRegularExpression</db:code></db:para>
</db:td>
<db:td><db:code>44</db:code></db:td>
<db:td>
<db:para>QRegularExpression</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::QDateTime</db:code></db:para>
</db:td>
<db:td><db:code>16</db:code></db:td>
<db:td>
<db:para>QDateTime</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::QPointF</db:code></db:para>
</db:td>
<db:td><db:code>26</db:code></db:td>
<db:td>
<db:para>QPointF</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::QPalette</db:code></db:para>
</db:td>
<db:td><db:code>0x1004</db:code></db:td>
<db:td>
<db:para>QPalette</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::QFont</db:code></db:para>
</db:td>
<db:td><db:code>0x1000</db:code></db:td>
<db:td>
<db:para>QFont</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::QBrush</db:code></db:para>
</db:td>
<db:td><db:code>0x1002</db:code></db:td>
<db:td>
<db:para>QBrush</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::QRegion</db:code></db:para>
</db:td>
<db:td><db:code>0x1008</db:code></db:td>
<db:td>
<db:para>QRegion</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::QBitArray</db:code></db:para>
</db:td>
<db:td><db:code>13</db:code></db:td>
<db:td>
<db:para>QBitArray</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::QImage</db:code></db:para>
</db:td>
<db:td><db:code>0x1006</db:code></db:td>
<db:td>
<db:para>QImage</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::QKeySequence</db:code></db:para>
</db:td>
<db:td><db:code>0x100b</db:code></db:td>
<db:td>
<db:para>QKeySequence</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::QSizePolicy</db:code></db:para>
</db:td>
<db:td><db:code>0x2000</db:code></db:td>
<db:td>
<db:para>QSizePolicy</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::QPixmap</db:code></db:para>
</db:td>
<db:td><db:code>0x1001</db:code></db:td>
<db:td>
<db:para>QPixmap</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::QLocale</db:code></db:para>
</db:td>
<db:td><db:code>18</db:code></db:td>
<db:td>
<db:para>QLocale</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::QBitmap</db:code></db:para>
</db:td>
<db:td><db:code>0x1009</db:code></db:td>
<db:td>
<db:para>QBitmap</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::QTransform</db:code></db:para>
</db:td>
<db:td><db:code>0x1010</db:code></db:td>
<db:td>
<db:para>QTransform</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::QMatrix4x4</db:code></db:para>
</db:td>
<db:td><db:code>0x1011</db:code></db:td>
<db:td>
<db:para>QMatrix4x4</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::QVector2D</db:code></db:para>
</db:td>
<db:td><db:code>0x1012</db:code></db:td>
<db:td>
<db:para>QVector2D</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::QVector3D</db:code></db:para>
</db:td>
<db:td><db:code>0x1013</db:code></db:td>
<db:td>
<db:para>QVector3D</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::QVector4D</db:code></db:para>
</db:td>
<db:td><db:code>0x1014</db:code></db:td>
<db:td>
<db:para>QVector4D</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::QQuaternion</db:code></db:para>
</db:td>
<db:td><db:code>0x1015</db:code></db:td>
<db:td>
<db:para>QQuaternion</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::QEasingCurve</db:code></db:para>
</db:td>
<db:td><db:code>29</db:code></db:td>
<db:td>
<db:para>QEasingCurve</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::QJsonValue</db:code></db:para>
</db:td>
<db:td><db:code>45</db:code></db:td>
<db:td>
<db:para>QJsonValue</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::QJsonObject</db:code></db:para>
</db:td>
<db:td><db:code>46</db:code></db:td>
<db:td>
<db:para>QJsonObject</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::QJsonArray</db:code></db:para>
</db:td>
<db:td><db:code>47</db:code></db:td>
<db:td>
<db:para>QJsonArray</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::QJsonDocument</db:code></db:para>
</db:td>
<db:td><db:code>48</db:code></db:td>
<db:td>
<db:para>QJsonDocument</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::QCborValue</db:code></db:para>
</db:td>
<db:td><db:code>53</db:code></db:td>
<db:td>
<db:para>QCborValue</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::QCborArray</db:code></db:para>
</db:td>
<db:td><db:code>54</db:code></db:td>
<db:td>
<db:para>QCborArray</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::QCborMap</db:code></db:para>
</db:td>
<db:td><db:code>55</db:code></db:td>
<db:td>
<db:para>QCborMap</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::QCborSimpleType</db:code></db:para>
</db:td>
<db:td><db:code>52</db:code></db:td>
<db:td>
<db:para>QCborSimpleType</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::QModelIndex</db:code></db:para>
</db:td>
<db:td><db:code>42</db:code></db:td>
<db:td>
<db:para>QModelIndex</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::QPersistentModelIndex</db:code></db:para>
</db:td>
<db:td><db:code>50</db:code></db:td>
<db:td>
<db:para>QPersistentModelIndex (introduced in Qt 5.5)</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::QUuid</db:code></db:para>
</db:td>
<db:td><db:code>30</db:code></db:td>
<db:td>
<db:para>QUuid</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::QByteArrayList</db:code></db:para>
</db:td>
<db:td><db:code>49</db:code></db:td>
<db:td>
<db:para>QByteArrayList</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::QVariant</db:code></db:para>
</db:td>
<db:td><db:code>41</db:code></db:td>
<db:td>
<db:para>QVariant</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::User</db:code></db:para>
</db:td>
<db:td><db:code>65536</db:code></db:td>
<db:td>
<db:para>Base value for user types</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::UnknownType</db:code></db:para>
</db:td>
<db:td><db:code>0</db:code></db:td>
<db:td>
<db:para>This is an invalid type id. It is returned from <db:link xlink:href="qmetatype.xml">QMetaType</db:link> for types that are not registered</db:para>
</db:td>
</db:tr>
</db:informaltable>
<db:para>Additional types can be registered using <db:link xlink:href="qmetatype.xml#qRegisterMetaType">qRegisterMetaType</db:link>() or by calling <db:link xlink:href="qmetatype.xml#registerType">registerType</db:link>().</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qmetatype.xml#type" role="deprecated">type</db:link>()</db:member>
<db:member><db:link xlink:href="qmetatype.xml#typeName" role="deprecated">typeName</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="TypeFlag-enum">
<db:title>enum QMetaType::TypeFlag</db:title>
<db:bridgehead renderas="sect2">flags QMetaType::TypeFlags</db:bridgehead>
<db:para>The enum describes attributes of a type supported by <db:link xlink:href="qmetatype.xml">QMetaType</db:link>.</db:para>
<db:informaltable>
<db:thead>
<db:tr>
<db:th>Constant</db:th>
<db:th>Value</db:th>
<db:th>Description</db:th>
</db:tr>
</db:thead>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::NeedsConstruction</db:code></db:para>
</db:td>
<db:td><db:code>0x1</db:code></db:td>
<db:td>
<db:para>This type has a default constructor. If the flag is not set, instances can be safely initialized with memset to 0.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::NeedsCopyConstruction</db:code></db:para>
</db:td>
<db:td><db:code>0x4000</db:code></db:td>
<db:td>
<db:para>(since 6.5) This type has a non-trivial copy constructor. If the flag is not set, instances can be copied with memcpy.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::NeedsMoveConstruction</db:code></db:para>
</db:td>
<db:td><db:code>0x8000</db:code></db:td>
<db:td>
<db:para>(since 6.5) This type has a non-trivial move constructor. If the flag is not set, instances can be moved with memcpy.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::NeedsDestruction</db:code></db:para>
</db:td>
<db:td><db:code>0x2</db:code></db:td>
<db:td>
<db:para>This type has a non-trivial destructor. If the flag is not set, calls to the destructor are not necessary before discarding objects.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::RelocatableType</db:code></db:para>
</db:td>
<db:td><db:code>0x4</db:code></db:td>
<db:td>
<db:para>An instance of a type having this attribute can be safely moved to a different memory location using memcpy.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::IsEnumeration</db:code></db:para>
</db:td>
<db:td><db:code>0x10</db:code></db:td>
<db:td>
<db:para>This type is an enumeration.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::IsUnsignedEnumeration</db:code></db:para>
</db:td>
<db:td><db:code>0x100</db:code></db:td>
<db:td>
<db:para>If the type is an Enumeration, its underlying type is unsigned.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::PointerToQObject</db:code></db:para>
</db:td>
<db:td><db:code>0x8</db:code></db:td>
<db:td>
<db:para>This type is a pointer to a class derived from <db:link xlink:href="qobject.xml">QObject</db:link>.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::IsPointer</db:code></db:para>
</db:td>
<db:td><db:code>0x800</db:code></db:td>
<db:td>
<db:para>This type is a pointer to another type.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:emphasis>::IsConst</db:code></db:para>
</db:td>
<db:td><db:code>0x2000</db:code></db:td>
<db:td>
<db:para>Indicates that values of this type are immutable; for instance, because they are pointers to const objects.</db:para>
</db:td>
</db:tr>
</db:informaltable>
<db:note>
<db:para>Before Qt 6.5, both the NeedsConstruction and NeedsDestruction flags were incorrectly set if the either copy construtor or destructor were non-trivial (that is, if the type was not trivial).</db:para>
</db:note>
<db:para>Note that the Needs flags may be set but the meta type may not have a publicly-accessible constructor of the relevant type or a publicly-accessible destructor.</db:para>
<db:para>The <db:code>TypeFlags</db:code> type is a typedef for <db:code><db:link xlink:href="qflags.xml">QFlags</db:link>&lt;TypeFlag&gt;. </db:code>It stores an OR combination of <db:code>TypeFlag</db:code> values.</db:para>
</db:section>
</db:section>
<db:section xml:id="member-function-documentation">
<db:title>Member Function Documentation</db:title>
<db:section xml:id="QMetaType">
<db:title>[constexpr noexcept, since 6.0] QMetaType::QMetaType()</db:title>
<db:para>Constructs a default, invalid, <db:link xlink:href="qmetatype.xml">QMetaType</db:link> object.</db:para>
<db:para>This function was introduced in Qt 6.0.</db:para>
</db:section>
<db:section xml:id="QMetaType-1">
<db:title>[explicit] QMetaType::QMetaType(int <db:emphasis>typeId</db:emphasis>)</db:title>
<db:para>Constructs a <db:link xlink:href="qmetatype.xml">QMetaType</db:link> object that contains all information about type <db:code role="parameter">typeId</db:code>.</db:para>
</db:section>
<db:section xml:id="alignOf">
<db:title>[constexpr, since 6.0] qsizetype QMetaType::alignOf() const</db:title>
<db:para>Returns the alignment of the type in bytes (i.e. alignof(T), where T is the actual type for which this <db:link xlink:href="qmetatype.xml">QMetaType</db:link> instance was constructed for).</db:para>
<db:para>This function is typically used together with <db:link xlink:href="qmetatype.xml#construct">construct</db:link>() to perform low-level management of the memory used by a type.</db:para>
<db:para>This function was introduced in Qt 6.0.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qmetatype.xml#construct">QMetaType::construct</db:link>()</db:member>
<db:member><db:link xlink:href="qmetatype.xml#sizeOf">QMetaType::sizeOf</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="canConvert">
<db:title>[static] bool QMetaType::canConvert(QMetaType <db:emphasis>fromType</db:emphasis>, QMetaType <db:emphasis>toType</db:emphasis>)</db:title>
<db:para>Returns true if <db:link xlink:href="qmetatype.xml#convert">QMetaType::convert</db:link> can convert from <db:code role="parameter">fromType</db:code> to <db:code role="parameter">toType</db:code>.</db:para>
<db:para>The following conversions are supported by Qt:</db:para>
<db:informaltable style="generic">
<db:thead>
<db:tr>
<db:th>
<db:para>Type</db:para>
</db:th>
<db:th>
<db:para>Automatically Cast To</db:para>
</db:th>
</db:tr>
</db:thead>
<db:tr valign="top">
<db:td>
<db:para><db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::Bool</db:link></db:para>
</db:td>
<db:td>
<db:para><db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QChar</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::Double</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::Int</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::LongLong</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QString</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::UInt</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::ULongLong</db:link></db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para><db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QByteArray</db:link></db:para>
</db:td>
<db:td>
<db:para><db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::Double</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::Int</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::LongLong</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QString</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::UInt</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::ULongLong</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QUuid</db:link></db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para><db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QChar</db:link></db:para>
</db:td>
<db:td>
<db:para><db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::Bool</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::Int</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::UInt</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::LongLong</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::ULongLong</db:link></db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para><db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QColor</db:link></db:para>
</db:td>
<db:td>
<db:para><db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QString</db:link></db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para><db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QDate</db:link></db:para>
</db:td>
<db:td>
<db:para><db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QDateTime</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QString</db:link></db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para><db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QDateTime</db:link></db:para>
</db:td>
<db:td>
<db:para><db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QDate</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QString</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QTime</db:link></db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para><db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::Double</db:link></db:para>
</db:td>
<db:td>
<db:para><db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::Bool</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::Int</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::LongLong</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QString</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::UInt</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::ULongLong</db:link></db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para><db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QFont</db:link></db:para>
</db:td>
<db:td>
<db:para><db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QString</db:link></db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para><db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::Int</db:link></db:para>
</db:td>
<db:td>
<db:para><db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::Bool</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QChar</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::Double</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::LongLong</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QString</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::UInt</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::ULongLong</db:link></db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para><db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QKeySequence</db:link></db:para>
</db:td>
<db:td>
<db:para><db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::Int</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QString</db:link></db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para><db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QVariantList</db:link></db:para>
</db:td>
<db:td>
<db:para><db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QStringList</db:link> (if the list's items can be converted to QStrings)</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para><db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::LongLong</db:link></db:para>
</db:td>
<db:td>
<db:para><db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::Bool</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QByteArray</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QChar</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::Double</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::Int</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QString</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::UInt</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::ULongLong</db:link></db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para><db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QPoint</db:link></db:para>
</db:td>
<db:td>
<db:para><db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QPointF</db:link></db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para><db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QRect</db:link></db:para>
</db:td>
<db:td>
<db:para><db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QRectF</db:link></db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para><db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QString</db:link></db:para>
</db:td>
<db:td>
<db:para><db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::Bool</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QByteArray</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QChar</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QColor</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QDate</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QDateTime</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::Double</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QFont</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::Int</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QKeySequence</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::LongLong</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QStringList</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QTime</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::UInt</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::ULongLong</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QUuid</db:link></db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para><db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QStringList</db:link></db:para>
</db:td>
<db:td>
<db:para><db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QVariantList</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QString</db:link> (if the list contains exactly one item)</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para><db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QTime</db:link></db:para>
</db:td>
<db:td>
<db:para><db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QString</db:link></db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para><db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::UInt</db:link></db:para>
</db:td>
<db:td>
<db:para><db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::Bool</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QChar</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::Double</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::Int</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::LongLong</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QString</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::ULongLong</db:link></db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para><db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::ULongLong</db:link></db:para>
</db:td>
<db:td>
<db:para><db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::Bool</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QChar</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::Double</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::Int</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::LongLong</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QString</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::UInt</db:link></db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para><db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QUuid</db:link></db:para>
</db:td>
<db:td>
<db:para><db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QByteArray</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::QString</db:link></db:para>
</db:td>
</db:tr>
</db:informaltable>
<db:para>Casting between primitive type (int, float, bool etc.) is supported.</db:para>
<db:para>Converting between pointers of types derived from <db:link xlink:href="qobject.xml">QObject</db:link> will also return true for this function if a <db:link xlink:href="qobject.xml#qobject_cast">qobject_cast</db:link> from the type described by <db:code role="parameter">fromType</db:code> to the type described by <db:code role="parameter">toType</db:code> would succeed.</db:para>
<db:para>A cast from a sequential container will also return true for this function if the <db:code role="parameter">toType</db:code> is <db:link xlink:href="qmetatype.xml#Type-enum">QVariantList</db:link>.</db:para>
<db:para>Similarly, a cast from an associative container will also return true for this function the <db:code role="parameter">toType</db:code> is <db:link xlink:href="qmetatype.xml#Type-enum">QVariantHash</db:link> or <db:link xlink:href="qmetatype.xml#Type-enum">QVariantMap</db:link>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qmetatype.xml#convert">convert</db:link>()</db:member>
<db:member><db:link xlink:href="qsequentialiterable.xml">QSequentialIterable</db:link></db:member>
<db:member><db:link xlink:href="qmetatype.xml#Q_DECLARE_SEQUENTIAL_CONTAINER_METATYPE">Q_DECLARE_SEQUENTIAL_CONTAINER_METATYPE</db:link>()</db:member>
<db:member><db:link xlink:href="qassociativeiterable.xml">QAssociativeIterable</db:link></db:member>
<db:member><db:link xlink:href="qmetatype.xml#Q_DECLARE_ASSOCIATIVE_CONTAINER_METATYPE">Q_DECLARE_ASSOCIATIVE_CONTAINER_METATYPE</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="canView">
<db:title>[static] bool QMetaType::canView(QMetaType <db:emphasis>fromType</db:emphasis>, QMetaType <db:emphasis>toType</db:emphasis>)</db:title>
<db:para>Returns true if <db:link xlink:href="qmetatype.xml#view">QMetaType::view</db:link> can create a mutable view of type <db:code role="parameter">toType</db:code> on type <db:code role="parameter">fromType</db:code>.</db:para>
<db:para>Converting between pointers of types derived from <db:link xlink:href="qobject.xml">QObject</db:link> will return true for this function if a <db:link xlink:href="qobject.xml#qobject_cast">qobject_cast</db:link> from the type described by <db:code role="parameter">fromType</db:code> to the type described by <db:code role="parameter">toType</db:code> would succeed.</db:para>
<db:para>You can create a mutable view of type <db:link xlink:href="qsequentialiterable.xml">QSequentialIterable</db:link> on any container registered with <db:link xlink:href="qmetatype.xml#Q_DECLARE_SEQUENTIAL_CONTAINER_METATYPE">Q_DECLARE_SEQUENTIAL_CONTAINER_METATYPE</db:link>().</db:para>
<db:para>Similarly you can create a mutable view of type <db:link xlink:href="qassociativeiterable.xml">QAssociativeIterable</db:link> on any container registered with <db:link xlink:href="qmetatype.xml#Q_DECLARE_ASSOCIATIVE_CONTAINER_METATYPE">Q_DECLARE_ASSOCIATIVE_CONTAINER_METATYPE</db:link>().</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qmetatype.xml#convert">convert</db:link>()</db:member>
<db:member><db:link xlink:href="qsequentialiterable.xml">QSequentialIterable</db:link></db:member>
<db:member><db:link xlink:href="qmetatype.xml#Q_DECLARE_SEQUENTIAL_CONTAINER_METATYPE">Q_DECLARE_SEQUENTIAL_CONTAINER_METATYPE</db:link>()</db:member>
<db:member><db:link xlink:href="qassociativeiterable.xml">QAssociativeIterable</db:link></db:member>
<db:member><db:link xlink:href="qmetatype.xml#Q_DECLARE_ASSOCIATIVE_CONTAINER_METATYPE">Q_DECLARE_ASSOCIATIVE_CONTAINER_METATYPE</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="compare">
<db:title>[since 6.0] QPartialOrdering QMetaType::compare(const void *<db:emphasis>lhs</db:emphasis>, const void *<db:emphasis>rhs</db:emphasis>) const</db:title>
<db:para>Compares the objects at <db:code role="parameter">lhs</db:code> and <db:code role="parameter">rhs</db:code> for ordering.</db:para>
<db:para>Returns <db:link xlink:href="qpartialordering.xml#Unordered-var">QPartialOrdering::Unordered</db:link> if comparison is not supported or the values are unordered. Otherwise, returns <db:link xlink:href="qpartialordering.xml#Less-var">QPartialOrdering::Less</db:link>, <db:link xlink:href="qpartialordering.xml#Equivalent-var">QPartialOrdering::Equivalent</db:link> or <db:link xlink:href="qpartialordering.xml#Greater-var">QPartialOrdering::Greater</db:link> if <db:code role="parameter">lhs</db:code> is less than, equivalent to or greater than <db:code role="parameter">rhs</db:code>, respectively.</db:para>
<db:para>Both objects must be of the type described by this metatype. If either <db:code role="parameter">lhs</db:code> or <db:code role="parameter">rhs</db:code> is nullptr, the values are unordered. Comparison is only supported if the type's less than operator was visible to the metatype declaration.</db:para>
<db:para>If the type's equality operator was also visible, values will only compare equal if the equality operator says they are. In the absence of an equality operator, when neither value is less than the other, values are considered equal; if equality is also available and two such values are not equal, they are considered unordered, just as NaN (not a number) values of a floating point type lie outside its ordering.</db:para>
<db:note>
<db:para>If no less than operator was visible to the metatype declaration, values are unordered even if an equality operator visible to the declaration considers them equal: compare() == 0 only agrees with <db:link xlink:href="qmetatype.xml#equals">equals</db:link>() if the less than operator was visible.</db:para>
</db:note>
<db:para>This function was introduced in Qt 6.0.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qmetatype.xml#equals">equals</db:link>()</db:member>
<db:member><db:link xlink:href="qmetatype.xml#isOrdered">isOrdered</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="construct">
<db:title>void *QMetaType::construct(void *<db:emphasis>where</db:emphasis>, const void *<db:emphasis>copy</db:emphasis> = nullptr) const</db:title>
<db:para>Constructs a value of the type that this <db:link xlink:href="qmetatype.xml">QMetaType</db:link> instance was constructed for in the existing memory addressed by <db:code role="parameter">where</db:code>, that is a copy of <db:code role="parameter">copy</db:code>, and returns <db:code role="parameter">where</db:code>. If <db:code role="parameter">copy</db:code> is zero, the value is default constructed.</db:para>
<db:para>This is a low-level function for explicitly managing the memory used to store the type. Consider calling <db:link xlink:href="qmetatype.xml#create">create</db:link>() if you don't need this level of control (that is, use &quot;new&quot; rather than &quot;placement new&quot;).</db:para>
<db:para>You must ensure that <db:code role="parameter">where</db:code> points to a location where the new value can be stored and that <db:code role="parameter">where</db:code> is suitably aligned. The type's size can be queried by calling <db:link xlink:href="qmetatype.xml#sizeOf">sizeOf</db:link>().</db:para>
<db:para>The rule of thumb for alignment is that a type is aligned to its natural boundary, which is the smallest power of 2 that is bigger than the type, unless that alignment is larger than the maximum useful alignment for the platform. For practical purposes, alignment larger than 2 * sizeof(void*) is only necessary for special hardware instructions (e.g., aligned SSE loads and stores on x86).</db:para>
</db:section>
<db:section xml:id="convert">
<db:title>[static] bool QMetaType::convert(QMetaType <db:emphasis>fromType</db:emphasis>, const void *<db:emphasis>from</db:emphasis>, QMetaType <db:emphasis>toType</db:emphasis>, void *<db:emphasis>to</db:emphasis>)</db:title>
<db:para>Converts the object at <db:code role="parameter">from</db:code> from <db:code role="parameter">fromType</db:code> to the preallocated space at <db:code role="parameter">to</db:code> typed <db:code role="parameter">toType</db:code>. Returns true, if the conversion succeeded, otherwise false.</db:para>
<db:para>Both <db:code role="parameter">from</db:code> and <db:code role="parameter">to</db:code> have to be valid pointers.</db:para>
</db:section>
<db:section xml:id="create">
<db:title>void *QMetaType::create(const void *<db:emphasis>copy</db:emphasis> = nullptr) const</db:title>
<db:para>Returns a copy of <db:code role="parameter">copy</db:code>, assuming it is of the type that this <db:link xlink:href="qmetatype.xml">QMetaType</db:link> instance was created for. If <db:code role="parameter">copy</db:code> is nullptr, creates a default constructed instance.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qmetatype.xml#destroy">QMetaType::destroy</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="debugStream">
<db:title>bool QMetaType::debugStream(QDebug &amp;<db:emphasis>dbg</db:emphasis>, const void *<db:emphasis>rhs</db:emphasis>)</db:title>
<db:para>Streams the object at <db:code role="parameter">rhs</db:code> to the debug stream <db:code role="parameter">dbg</db:code>. Returns true on success, otherwise false.</db:para>
</db:section>
<db:section xml:id="destroy">
<db:title>void QMetaType::destroy(void *<db:emphasis>data</db:emphasis>) const</db:title>
<db:para>Destroys the <db:code role="parameter">data</db:code>, assuming it is of the type that this <db:link xlink:href="qmetatype.xml">QMetaType</db:link> instance was created for.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qmetatype.xml#create">QMetaType::create</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="destruct">
<db:title>void QMetaType::destruct(void *<db:emphasis>data</db:emphasis>) const</db:title>
<db:para>Destructs the value, located at <db:code role="parameter">data</db:code>, assuming that it is of the type for which this <db:link xlink:href="qmetatype.xml">QMetaType</db:link> instance was constructed for.</db:para>
<db:para>Unlike <db:link xlink:href="qmetatype.xml#destroy">destroy</db:link>(), this function only invokes the type's destructor, it doesn't invoke the delete operator.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qmetatype.xml#construct">QMetaType::construct</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="equals">
<db:title>[since 6.0] bool QMetaType::equals(const void *<db:emphasis>lhs</db:emphasis>, const void *<db:emphasis>rhs</db:emphasis>) const</db:title>
<db:para>Compares the objects at <db:code role="parameter">lhs</db:code> and <db:code role="parameter">rhs</db:code> for equality.</db:para>
<db:para>Both objects must be of the type described by this metatype. Can only compare the two objects if a less than or equality operator for the type was visible to the metatype declaration. Otherwise, the metatype never considers values equal. When an equality operator was visible to the metatype declaration, it is authoritative; otherwise, if less than is visible, when neither value is less than the other, the two are considered equal. If values are unordered (see <db:link xlink:href="qmetatype.xml#compare">compare</db:link>() for details) they are not equal.</db:para>
<db:para>Returns true if the two objects compare equal, otherwise false.</db:para>
<db:para>This function was introduced in Qt 6.0.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qmetatype.xml#isEqualityComparable">isEqualityComparable</db:link>()</db:member>
<db:member><db:link xlink:href="qmetatype.xml#compare">compare</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="flags">
<db:title>[constexpr] QMetaType::TypeFlags QMetaType::flags() const</db:title>
<db:para>Returns flags of the type for which this <db:link xlink:href="qmetatype.xml">QMetaType</db:link> instance was constructed. To inspect specific type traits, prefer using one of the &quot;is-&quot; functions rather than the flags directly.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qmetatype.xml#TypeFlag-enum">QMetaType::TypeFlags</db:link></db:member>
<db:member><db:link xlink:href="">QMetaType::flags</db:link>()</db:member>
<db:member><db:link xlink:href="qmetatype.xml#isDefaultConstructible">isDefaultConstructible</db:link>()</db:member>
<db:member><db:link xlink:href="qmetatype.xml#isCopyConstructible">isCopyConstructible</db:link>()</db:member>
<db:member><db:link xlink:href="qmetatype.xml#isMoveConstructible">isMoveConstructible</db:link>()</db:member>
<db:member><db:link xlink:href="qmetatype.xml#isDestructible">isDestructible</db:link>()</db:member>
<db:member><db:link xlink:href="qmetatype.xml#isEqualityComparable">isEqualityComparable</db:link>()</db:member>
<db:member><db:link xlink:href="qmetatype.xml#isOrdered">isOrdered</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="fromName">
<db:title>[static] QMetaType QMetaType::fromName(QByteArrayView <db:emphasis>typeName</db:emphasis>)</db:title>
<db:para>Returns a <db:link xlink:href="qmetatype.xml">QMetaType</db:link> matching <db:code role="parameter">typeName</db:code>. The returned object is not valid if the typeName is not known to <db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:para>
</db:section>
<db:section xml:id="fromType">
<db:title>[static constexpr] QMetaType QMetaType::fromType()</db:title>
<db:para>Returns the <db:link xlink:href="qmetatype.xml">QMetaType</db:link> corresponding to the type in the template parameter.</db:para>
</db:section>
<db:section xml:id="hasRegisteredConverterFunction">
<db:title>[static] bool QMetaType::hasRegisteredConverterFunction(QMetaType <db:emphasis>fromType</db:emphasis>, QMetaType <db:emphasis>toType</db:emphasis>)</db:title>
<db:para>Returns true, if the meta type system has a registered conversion from meta type id <db:code role="parameter">fromType</db:code> to <db:code role="parameter">toType</db:code></db:para>
</db:section>
<db:section xml:id="hasRegisteredConverterFunction-1">
<db:title>[static] bool QMetaType::hasRegisteredConverterFunction()</db:title>
<db:para>Returns true, if the meta type system has a registered conversion from type From to type To.</db:para>
<db:para>This is an overloaded function.</db:para>
</db:section>
<db:section xml:id="hasRegisteredDataStreamOperators">
<db:title>[since 6.1] bool QMetaType::hasRegisteredDataStreamOperators() const</db:title>
<db:para>Returns true, if the meta type system has registered data stream operators for this meta type.</db:para>
<db:para>This function was introduced in Qt 6.1.</db:para>
</db:section>
<db:section xml:id="hasRegisteredDebugStreamOperator-1">
<db:title>[since 6.0] bool QMetaType::hasRegisteredDebugStreamOperator() const</db:title>
<db:para>Returns true, if the meta type system has a registered debug stream operator for this meta type.</db:para>
<db:para>This function was introduced in Qt 6.0.</db:para>
</db:section>
<db:section xml:id="hasRegisteredMutableViewFunction">
<db:title>[static] bool QMetaType::hasRegisteredMutableViewFunction(QMetaType <db:emphasis>fromType</db:emphasis>, QMetaType <db:emphasis>toType</db:emphasis>)</db:title>
<db:para>Returns true, if the meta type system has a registered mutable view on meta type id <db:code role="parameter">fromType</db:code> of meta type id <db:code role="parameter">toType</db:code>.</db:para>
</db:section>
<db:section xml:id="hasRegisteredMutableViewFunction-1">
<db:title>[static, since 6.0] bool QMetaType::hasRegisteredMutableViewFunction()</db:title>
<db:para>Returns true, if the meta type system has a registered mutable view on type From of type To.</db:para>
<db:para>This is an overloaded function.</db:para>
<db:para>This function was introduced in Qt 6.0.</db:para>
</db:section>
<db:section xml:id="id">
<db:title>int QMetaType::id() const</db:title>
<db:para>Returns id type held by this QMetatype instance.</db:para>
</db:section>
<db:section xml:id="isCopyConstructible">
<db:title>[noexcept, since 6.5] bool QMetaType::isCopyConstructible() const</db:title>
<db:para>Returns true if this type can be copy-constructed. If it can be, then <db:link xlink:href="qmetatype.xml#construct">construct</db:link>() and <db:link xlink:href="qmetatype.xml#create">create</db:link>() can be used with a copy parameter that is not null.</db:para>
<db:para>This function was introduced in Qt 6.5.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qmetatype.xml#flags">flags</db:link>()</db:member>
<db:member><db:link xlink:href="qmetatype.xml#isDefaultConstructible">isDefaultConstructible</db:link>()</db:member>
<db:member><db:link xlink:href="qmetatype.xml#isMoveConstructible">isMoveConstructible</db:link>()</db:member>
<db:member><db:link xlink:href="qmetatype.xml#isDestructible">isDestructible</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="isDefaultConstructible">
<db:title>[noexcept, since 6.5] bool QMetaType::isDefaultConstructible() const</db:title>
<db:para>Returns true if this type can be default-constructed. If it can be, then <db:link xlink:href="qmetatype.xml#construct">construct</db:link>() and <db:link xlink:href="qmetatype.xml#create">create</db:link>() can be used with a copy parameter that is null.</db:para>
<db:para>This function was introduced in Qt 6.5.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qmetatype.xml#flags">flags</db:link>()</db:member>
<db:member><db:link xlink:href="qmetatype.xml#isCopyConstructible">isCopyConstructible</db:link>()</db:member>
<db:member><db:link xlink:href="qmetatype.xml#isMoveConstructible">isMoveConstructible</db:link>()</db:member>
<db:member><db:link xlink:href="qmetatype.xml#isDestructible">isDestructible</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="isDestructible">
<db:title>[noexcept, since 6.5] bool QMetaType::isDestructible() const</db:title>
<db:para>Returns true if this type can be destroyed. If it can be, then <db:link xlink:href="qmetatype.xml#destroy">destroy</db:link>() and <db:link xlink:href="qmetatype.xml#destruct">destruct</db:link>() can be called.</db:para>
<db:para>This function was introduced in Qt 6.5.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qmetatype.xml#flags">flags</db:link>()</db:member>
<db:member><db:link xlink:href="qmetatype.xml#isDefaultConstructible">isDefaultConstructible</db:link>()</db:member>
<db:member><db:link xlink:href="qmetatype.xml#isCopyConstructible">isCopyConstructible</db:link>()</db:member>
<db:member><db:link xlink:href="qmetatype.xml#isMoveConstructible">isMoveConstructible</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="isEqualityComparable">
<db:title>bool QMetaType::isEqualityComparable() const</db:title>
<db:para>Returns true if a less than or equality operator for the type described by this metatype was visible to the metatype declaration, otherwise false.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qmetatype.xml#equals">equals</db:link>()</db:member>
<db:member><db:link xlink:href="qmetatype.xml#isOrdered">isOrdered</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="isMoveConstructible">
<db:title>[noexcept, since 6.5] bool QMetaType::isMoveConstructible() const</db:title>
<db:para>Returns true if this type can be move-constructed. <db:link xlink:href="qmetatype.xml">QMetaType</db:link> currently does not have an API to make use of this trait.</db:para>
<db:para>This function was introduced in Qt 6.5.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qmetatype.xml#flags">flags</db:link>()</db:member>
<db:member><db:link xlink:href="qmetatype.xml#isDefaultConstructible">isDefaultConstructible</db:link>()</db:member>
<db:member><db:link xlink:href="qmetatype.xml#isCopyConstructible">isCopyConstructible</db:link>()</db:member>
<db:member><db:link xlink:href="qmetatype.xml#isDestructible">isDestructible</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="isOrdered">
<db:title>bool QMetaType::isOrdered() const</db:title>
<db:para>Returns true if a less than operator for the type described by this metatype was visible to the metatype declaration, otherwise false.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qmetatype.xml#compare">compare</db:link>()</db:member>
<db:member><db:link xlink:href="qmetatype.xml#isEqualityComparable">isEqualityComparable</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="isRegistered">
<db:title>bool QMetaType::isRegistered() const</db:title>
<db:para>Returns true if this <db:link xlink:href="qmetatype.xml">QMetaType</db:link> object has been registered with the Qt global metatype registry. Registration allows the type to be found by its name (using <db:link xlink:href="qmetatype.xml#fromName">QMetaType::fromName</db:link>()) or by its ID (using the constructor).</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qmetatype.xml#qRegisterMetaType">qRegisterMetaType</db:link>()</db:member>
<db:member><db:link xlink:href="qmetatype.xml#isValid">isValid</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="isRegistered-1">
<db:title>[static] bool QMetaType::isRegistered(int <db:emphasis>type</db:emphasis>)</db:title>
<db:para>Returns true if the datatype with ID <db:code role="parameter">type</db:code> is registered; otherwise returns false.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qmetatype.xml#type" role="deprecated">type</db:link>()</db:member>
<db:member><db:link xlink:href="qmetatype.xml#typeName" role="deprecated">typeName</db:link>()</db:member>
<db:member><db:link xlink:href="qmetatype.xml#Type-enum">Type</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="isValid">
<db:title>bool QMetaType::isValid() const</db:title>
<db:para>Returns true if this <db:link xlink:href="qmetatype.xml">QMetaType</db:link> object contains valid information about a type, false otherwise.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qmetatype.xml#isRegistered">isRegistered</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="load">
<db:title>bool QMetaType::load(QDataStream &amp;<db:emphasis>stream</db:emphasis>, void *<db:emphasis>data</db:emphasis>) const</db:title>
<db:para>Reads the object of this type from the given <db:code role="parameter">stream</db:code> into <db:code role="parameter">data</db:code>. Returns true if the object is loaded successfully; otherwise returns false.</db:para>
<db:para>Normally, you should not need to call this function directly. Instead, use <db:link xlink:href="qmetatype.xml#Type-enum">QVariant</db:link>'s operator&gt;&gt;(), which relies on load() to stream custom types.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qmetatype.xml#save">save</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="metaObject">
<db:title>[constexpr] const QMetaObject *QMetaType::metaObject() const</db:title>
<db:para>Returns a <db:link xlink:href="qmetaobject.xml">QMetaObject</db:link> relative to this type.</db:para>
<db:para>If the type is a pointer type to a subclass of <db:link xlink:href="qobject.xml">QObject</db:link>, <db:link xlink:href="qmetatype.xml#flags">flags</db:link>() contains <db:link xlink:href="qmetatype.xml#TypeFlag-enum">QMetaType::PointerToQObject</db:link> and this function returns the corresponding <db:link xlink:href="qmetaobject.xml">QMetaObject</db:link>. This can be used in combination with <db:link xlink:href="qmetaobject.xml#newInstance">QMetaObject::newInstance</db:link>() to create QObjects of this type.</db:para>
<db:para>If the type is a <db:link xlink:href="qobject.xml#Q_GADGET">Q_GADGET</db:link>, <db:link xlink:href="qmetatype.xml#flags">flags</db:link>() contains <db:link xlink:href="qmetatype.xml#TypeFlag-enum">QMetaType::IsGadget</db:link>. If the type is a pointer to a <db:link xlink:href="qobject.xml#Q_GADGET">Q_GADGET</db:link>, <db:link xlink:href="qmetatype.xml#flags">flags</db:link>() contains <db:link xlink:href="qmetatype.xml#TypeFlag-enum">QMetaType::PointerToGadget</db:link>. In both cases, this function returns its <db:link xlink:href="qmetaobject.xml">QMetaObject</db:link>. This can be used to retrieve <db:link xlink:href="qmetamethod.xml">QMetaMethod</db:link> and <db:link xlink:href="qmetaproperty.xml">QMetaProperty</db:link> and use them on a pointer of this type for example, as given by <db:link xlink:href="qvariant.xml#data">QVariant::data</db:link>().</db:para>
<db:para>If the type is an enumeration, <db:link xlink:href="qmetatype.xml#flags">flags</db:link>() contains <db:link xlink:href="qmetatype.xml#TypeFlag-enum">QMetaType::IsEnumeration</db:link>. In this case, this function returns the <db:link xlink:href="qmetaobject.xml">QMetaObject</db:link> of the enclosing object if the enum was registered as a <db:link xlink:href="qobject.xml#Q_ENUM">Q_ENUM</db:link> or nullptr otherwise.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qmetatype.xml#flags">QMetaType::flags</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="name">
<db:title>[constexpr] const char *QMetaType::name() const</db:title>
<db:para>Returns the type name associated with this <db:link xlink:href="qmetatype.xml">QMetaType</db:link>, or a null pointer if no matching type was found. The returned pointer must not be deleted.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qmetatype.xml#typeName" role="deprecated">typeName</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="registerConverter">
<db:title>[static] bool QMetaType::registerConverter()</db:title>
<db:para>Registers the possibility of an implicit conversion from type From to type To in the meta type system. Returns true if the registration succeeded, otherwise false.</db:para>
<db:programlisting language="cpp">class Counter {
  int number = 0;
public:
  int value() const { return number; }
  operator int() const { return value(); }
  void increment() {++number;}
};
QMetaType::registerConverter&lt;Counter, int&gt;();
</db:programlisting>
</db:section>
<db:section xml:id="registerConverter-1">
<db:title>[static] bool QMetaType::registerConverter(To (From::*)() const <db:emphasis>function</db:emphasis>)</db:title>
<db:para>This is an overloaded function.</db:para>
<db:para>Registers a method <db:code role="parameter">function</db:code> like To From::function() const as converter from type From to type To in the meta type system. Returns true if the registration succeeded, otherwise false.</db:para>
<db:programlisting language="cpp">struct Coordinates {
  int x;
  int y;
  int z;

  QString toString() const { return u&quot;[x: %1; y: %2, z: %3]&quot;_s.arg(QString::number(x),
    QString::number(y),
    QString::number(z)); }
};
QMetaType::registerConverter&lt;Coordinates, QString&gt;(&amp;Coordinates::toString);
</db:programlisting>
</db:section>
<db:section xml:id="registerConverter-2">
<db:title>[static] bool QMetaType::registerConverter(To (From::*)(bool *) const <db:emphasis>function</db:emphasis>)</db:title>
<db:para>This is an overloaded function.</db:para>
<db:para>Registers a method <db:code role="parameter">function</db:code> like To From::function(bool *ok) const as converter from type From to type To in the meta type system. Returns true if the registration succeeded, otherwise false.</db:para>
<db:para>The ok pointer can be used by the function to indicate whether the conversion succeeded.</db:para>
<db:programlisting language="cpp">struct BigNumber {
    long long l;

    int toInt(bool *ok = nullptr) const {
      const bool canConvertSafely = l &lt; std::numeric_limits&lt;int&gt;::max();
      if (ok)
        *ok = canConvertSafely;
      return l;
    }
};
QMetaType::registerConverter&lt;BigNumber, int&gt;(&amp;BigNumber::toInt);
</db:programlisting>
</db:section>
<db:section xml:id="registerConverter-3">
<db:title>[static] bool QMetaType::registerConverter(UnaryFunction <db:emphasis>function</db:emphasis>)</db:title>
<db:para>This is an overloaded function.</db:para>
<db:para>Registers a unary function object <db:code role="parameter">function</db:code> as converter from type From to type To in the meta type system. Returns true if the registration succeeded, otherwise false.</db:para>
<db:para><db:code role="parameter">function</db:code> must take an instance of type From and return an instance of To. It can be a function pointer, a lambda or a functor object. Since Qt 6.5, the <db:code role="parameter">function</db:code> can also return an instance of std::optional&lt;To&gt; to be able to indicate failed conversions.</db:para>
<db:programlisting language="cpp">QMetaType::registerConverter&lt;CustomStringType, QString&gt;([](const CustomStringType &amp;str) {
    return QString::fromUtf8(str.data());
});
QMetaType::registerConverter&lt;QJsonValue, QPointF&gt;(
          [](const QJsonValue &amp;value) -&gt; std::optional&lt;QPointF&gt; {
    const auto object = value.toObject();
    if (!object.contains(&quot;x&quot;) || !object.contains(&quot;y&quot;))
        return std::nullopt;  // The conversion fails if the required properties are missing
    return QPointF{object[&quot;x&quot;].toDouble(), object[&quot;y&quot;].toDouble()};
});
</db:programlisting>
</db:section>
<db:section xml:id="registerMutableView">
<db:title>[static, since 6.0] bool QMetaType::registerMutableView(To (From::*)() <db:emphasis>function</db:emphasis>)</db:title>
<db:para>This is an overloaded function.</db:para>
<db:para>Registers a method <db:code role="parameter">function</db:code> like To From::function() as mutable view of type To on type From in the meta type system. Returns true if the registration succeeded, otherwise false.</db:para>
<db:para>This function was introduced in Qt 6.0.</db:para>
</db:section>
<db:section xml:id="registerMutableView-1">
<db:title>[static, since 6.0] bool QMetaType::registerMutableView(UnaryFunction <db:emphasis>function</db:emphasis>)</db:title>
<db:para>This is an overloaded function.</db:para>
<db:para>Registers a unary function object <db:code role="parameter">function</db:code> as mutable view of type To on type From in the meta type system. Returns true if the registration succeeded, otherwise false.</db:para>
<db:para>This function was introduced in Qt 6.0.</db:para>
</db:section>
<db:section xml:id="registerType">
<db:title>[since 6.5] void QMetaType::registerType() const</db:title>
<db:para>Registers this <db:link xlink:href="qmetatype.xml">QMetaType</db:link> with the type registry so it can be found by name, using <db:link xlink:href="qmetatype.xml#fromName">QMetaType::fromName</db:link>().</db:para>
<db:para>This function was introduced in Qt 6.5.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qmetatype.xml#qRegisterMetaType">qRegisterMetaType</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="save">
<db:title>bool QMetaType::save(QDataStream &amp;<db:emphasis>stream</db:emphasis>, const void *<db:emphasis>data</db:emphasis>) const</db:title>
<db:para>Writes the object pointed to by <db:code role="parameter">data</db:code> to the given <db:code role="parameter">stream</db:code>. Returns true if the object is saved successfully; otherwise returns false.</db:para>
<db:para>Normally, you should not need to call this function directly. Instead, use <db:link xlink:href="qmetatype.xml#Type-enum">QVariant</db:link>'s operator&lt;&lt;(), which relies on save() to stream custom types.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qmetatype.xml#load">load</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="sizeOf">
<db:title>[constexpr] qsizetype QMetaType::sizeOf() const</db:title>
<db:para>Returns the size of the type in bytes (i.e. sizeof(T), where T is the actual type for which this <db:link xlink:href="qmetatype.xml">QMetaType</db:link> instance was constructed for).</db:para>
<db:para>This function is typically used together with <db:link xlink:href="qmetatype.xml#construct">construct</db:link>() to perform low-level management of the memory used by a type.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qmetatype.xml#construct">QMetaType::construct</db:link>()</db:member>
<db:member><db:link xlink:href="">QMetaType::sizeOf</db:link>()</db:member>
<db:member><db:link xlink:href="qmetatype.xml#alignOf">QMetaType::alignOf</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="underlyingType">
<db:title>[since 6.6] QMetaType QMetaType::underlyingType() const</db:title>
<db:para>If this metatype represents an enumeration, this method returns a metatype of a numeric class of the same signedness and size as the enums underlying type. If it represents a <db:link xlink:href="qflags.xml">QFlags</db:link> type, it returns <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::Int</db:link>. In all other cases an invalid <db:link xlink:href="qmetatype.xml">QMetaType</db:link> is returned.</db:para>
<db:para>This function was introduced in Qt 6.6.</db:para>
</db:section>
<db:section xml:id="view">
<db:title>[static, since 6.0] bool QMetaType::view(QMetaType <db:emphasis>fromType</db:emphasis>, void *<db:emphasis>from</db:emphasis>, QMetaType <db:emphasis>toType</db:emphasis>, void *<db:emphasis>to</db:emphasis>)</db:title>
<db:para>Creates a mutable view on the object at <db:code role="parameter">from</db:code> of <db:code role="parameter">fromType</db:code> in the preallocated space at <db:code role="parameter">to</db:code> typed <db:code role="parameter">toType</db:code>. Returns true if the conversion succeeded, otherwise false.</db:para>
<db:para>This function was introduced in Qt 6.0.</db:para>
</db:section>
</db:section>
<db:section xml:id="related-non-members">
<db:title>Related Non-Members</db:title>
<db:section xml:id="qHash-5">
<db:title>[since 6.4] size_t qHash(QMetaType <db:emphasis>key</db:emphasis>, size_t <db:emphasis>seed</db:emphasis> = 0)</db:title>
<db:para>Returns the hash value for <db:code role="parameter">key</db:code>, using <db:code role="parameter">seed</db:code> to seed the calculation.</db:para>
<db:para>This function was introduced in Qt 6.4.</db:para>
</db:section>
<db:section xml:id="qMetaTypeId">
<db:title>[constexpr] int qMetaTypeId()</db:title>
<db:para>Returns the meta type id of type T at compile time. If the type was not declared with <db:link xlink:href="qmetatype.xml#Q_DECLARE_METATYPE">Q_DECLARE_METATYPE</db:link>(), compilation will fail.</db:para>
<db:para>Typical usage:</db:para>
<db:programlisting language="cpp">int id = qMetaTypeId&lt;QString&gt;();    // id is now QMetaType::QString
id = qMetaTypeId&lt;MyStruct&gt;();       // compile error if MyStruct not declared
</db:programlisting>
<db:para>QMetaType::type() returns the same ID as qMetaTypeId(), but does a lookup at runtime based on the name of the type. QMetaType::type() is a bit slower, but compilation succeeds if a type is not registered.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qmetatype.xml#Q_DECLARE_METATYPE">Q_DECLARE_METATYPE</db:link>()</db:member>
<db:member><db:link xlink:href="qmetatype.xml#type" role="deprecated">QMetaType::type</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="qRegisterMetaType">
<db:title>[constexpr] int qRegisterMetaType()</db:title>
<db:para>Call this function to register the type T. Returns the meta type Id.</db:para>
<db:para>Example:</db:para>
<db:programlisting language="cpp">int id = qRegisterMetaType&lt;MyStruct&gt;();
</db:programlisting>
<db:para>This function requires that T is a fully defined type at the point where the function is called. For pointer types, it also requires that the pointed to type is fully defined. Use <db:link xlink:href="qmetatype.xml#Q_DECLARE_OPAQUE_POINTER">Q_DECLARE_OPAQUE_POINTER</db:link>() to be able to register pointers to forward declared types.</db:para>
<db:para>To use the type T in <db:link xlink:href="qmetatype.xml">QMetaType</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QVariant</db:link>, or with the <db:link xlink:href="qobject.xml#property">QObject::property</db:link>() API, registration is not necessary.</db:para>
<db:para>To use the type T in queued signal and slot connections, qRegisterMetaType&lt;T&gt;() must be called before the first connection is established. That is typically done in the constructor of the class that uses T, or in the main() function.</db:para>
<db:para>After a type has been registered, it can be found by its name using <db:link xlink:href="qmetatype.xml#fromName">QMetaType::fromName</db:link>().</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qmetatype.xml#Q_DECLARE_METATYPE">Q_DECLARE_METATYPE</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="qRegisterMetaType-2">
<db:title>[since 6.5] int qRegisterMetaType(QMetaType <db:emphasis>meta</db:emphasis>)</db:title>
<db:para>Registers the meta type <db:code role="parameter">meta</db:code> and returns its type Id.</db:para>
<db:para>This function requires that T is a fully defined type at the point where the function is called. For pointer types, it also requires that the pointed to type is fully defined. Use <db:link xlink:href="qmetatype.xml#Q_DECLARE_OPAQUE_POINTER">Q_DECLARE_OPAQUE_POINTER</db:link>() to be able to register pointers to forward declared types.</db:para>
<db:para>To use the type T in <db:link xlink:href="qmetatype.xml">QMetaType</db:link>, <db:link xlink:href="qmetatype.xml#Type-enum">QVariant</db:link>, or with the <db:link xlink:href="qobject.xml#property">QObject::property</db:link>() API, registration is not necessary.</db:para>
<db:para>To use the type T in queued signal and slot connections, qRegisterMetaType&lt;T&gt;() must be called before the first connection is established. That is typically done in the constructor of the class that uses T, or in the main() function.</db:para>
<db:para>After a type has been registered, it can be found by its name using <db:link xlink:href="qmetatype.xml#fromName">QMetaType::fromName</db:link>().</db:para>
<db:para>This function was introduced in Qt 6.5.</db:para>
</db:section>
<db:section xml:id="operator-not-eq">
<db:title>[noexcept] bool operator!=(const QMetaType &amp;<db:emphasis>lhs</db:emphasis>, const QMetaType &amp;<db:emphasis>rhs</db:emphasis>)</db:title>
<db:para>This is an overloaded function.</db:para>
<db:para>Returns true if the <db:link xlink:href="qmetatype.xml">QMetaType</db:link> <db:code role="parameter">lhs</db:code> represents a different type than the <db:link xlink:href="qmetatype.xml">QMetaType</db:link> <db:code role="parameter">rhs</db:code>, otherwise returns false.</db:para>
</db:section>
<db:section xml:id="operator-lt-lt">
<db:title>[since 6.5] QDebug operator&lt;&lt;(QDebug <db:emphasis>d</db:emphasis>, QMetaType <db:emphasis>m</db:emphasis>)</db:title>
<db:para>Writes the <db:link xlink:href="qmetatype.xml">QMetaType</db:link> <db:code role="parameter">m</db:code> to the stream <db:code role="parameter">d</db:code>, and returns the stream.</db:para>
<db:para>This function was introduced in Qt 6.5.</db:para>
</db:section>
<db:section xml:id="operator-eq-eq">
<db:title>[noexcept] bool operator==(const QMetaType &amp;<db:emphasis>lhs</db:emphasis>, const QMetaType &amp;<db:emphasis>rhs</db:emphasis>)</db:title>
<db:para>This is an overloaded function.</db:para>
<db:para>Returns true if the <db:link xlink:href="qmetatype.xml">QMetaType</db:link> <db:code role="parameter">lhs</db:code> represents the same type as the <db:link xlink:href="qmetatype.xml">QMetaType</db:link> <db:code role="parameter">rhs</db:code>, otherwise returns false.</db:para>
</db:section>
</db:section>
<db:section xml:id="macro-documentation">
<db:title>Macro Documentation</db:title>
<db:section xml:id="Q_DECLARE_ASSOCIATIVE_CONTAINER_METATYPE">
<db:title>Q_DECLARE_ASSOCIATIVE_CONTAINER_METATYPE(<db:emphasis>Container</db:emphasis>)</db:title>
<db:para>This macro makes the container <db:code role="parameter">Container</db:code> known to <db:link xlink:href="qmetatype.xml">QMetaType</db:link> as an associative container. This makes it possible to put an instance of Container&lt;T, U&gt; into a <db:link xlink:href="qmetatype.xml#Type-enum">QVariant</db:link>, if T and U are themselves known to <db:link xlink:href="qmetatype.xml">QMetaType</db:link>.</db:para>
<db:para>Note that all of the Qt associative containers already have built-in support, and it is not necessary to use this macro with them. The std::map container also has built-in support.</db:para>
<db:para>This example shows a typical use of Q_DECLARE_ASSOCIATIVE_CONTAINER_METATYPE():</db:para>
<db:programlisting language="cpp">#include &lt;unordered_list&gt;

Q_DECLARE_ASSOCIATIVE_CONTAINER_METATYPE(std::unordered_map)

void someFunc()
{
    std::unordered_map&lt;int, bool&gt; container;
    QVariant var = QVariant::fromValue(container);
    // ...
}

</db:programlisting>
</db:section>
<db:section xml:id="Q_DECLARE_METATYPE">
<db:title>Q_DECLARE_METATYPE(<db:emphasis>Type</db:emphasis>)</db:title>
<db:para>This macro makes the type <db:code role="parameter">Type</db:code> known to <db:link xlink:href="qmetatype.xml">QMetaType</db:link> as long as it provides a public default constructor, a public copy constructor and a public destructor. It is needed to use the type <db:code role="parameter">Type</db:code> as a custom type in <db:link xlink:href="qmetatype.xml#Type-enum">QVariant</db:link>.</db:para>
<db:para>This macro requires that <db:code role="parameter">Type</db:code> is a fully defined type at the point where it is used. For pointer types, it also requires that the pointed to type is fully defined. Use in conjunction with <db:link xlink:href="qmetatype.xml#Q_DECLARE_OPAQUE_POINTER">Q_DECLARE_OPAQUE_POINTER</db:link>() to register pointers to forward declared types.</db:para>
<db:para>Ideally, this macro should be placed below the declaration of the class or struct. If that is not possible, it can be put in a private header file which has to be included every time that type is used in a <db:link xlink:href="qmetatype.xml#Type-enum">QVariant</db:link>.</db:para>
<db:para>Adding a Q_DECLARE_METATYPE() makes the type known to all template based functions, including <db:link xlink:href="qmetatype.xml#Type-enum">QVariant</db:link>. Note that if you intend to use the type in <db:emphasis>queued</db:emphasis> signal and slot connections or in <db:link xlink:href="qobject.xml">QObject</db:link>'s property system, you also have to call <db:link xlink:href="qmetatype.xml#qRegisterMetaType">qRegisterMetaType</db:link>() since the names are resolved at runtime.</db:para>
<db:para>This example shows a typical use case of Q_DECLARE_METATYPE():</db:para>
<db:programlisting language="cpp">struct MyStruct
{
    int i;
    ...
};

Q_DECLARE_METATYPE(MyStruct)
</db:programlisting>
<db:para>If MyStruct is in a namespace, the Q_DECLARE_METATYPE() macro has to be outside the namespace:</db:para>
<db:programlisting language="cpp">namespace MyNamespace
{
    ...
}

Q_DECLARE_METATYPE(MyNamespace::MyStruct)
</db:programlisting>
<db:para>Since MyStruct is now known to <db:link xlink:href="qmetatype.xml">QMetaType</db:link>, it can be used in <db:link xlink:href="qmetatype.xml#Type-enum">QVariant</db:link>:</db:para>
<db:programlisting language="cpp">MyStruct s;
QVariant var;
var.setValue(s); // copy s into the variant

...

// retrieve the value
MyStruct s2 = var.value&lt;MyStruct&gt;();
</db:programlisting>
<db:para>Some types are registered automatically and do not need this macro:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para>Pointers to classes derived from <db:link xlink:href="qobject.xml">QObject</db:link></db:para>
</db:listitem>
<db:listitem>
<db:para><db:link xlink:href="qlist.xml">QList</db:link>&lt;T&gt;, <db:link xlink:href="qqueue.xml">QQueue</db:link>&lt;T&gt;, <db:link xlink:href="qstack.xml">QStack</db:link>&lt;T&gt; or <db:link xlink:href="qset.xml">QSet</db:link>&lt;T&gt; where T is a registered meta type</db:para>
</db:listitem>
<db:listitem>
<db:para><db:link xlink:href="qhash.xml#the-hashing-function">QHash</db:link>&lt;T1, T2&gt;, <db:link xlink:href="qmap.xml">QMap</db:link>&lt;T1, T2&gt; or std::pair&lt;T1, T2&gt; where T1 and T2 are registered meta types</db:para>
</db:listitem>
<db:listitem>
<db:para><db:link xlink:href="qpointer.xml">QPointer</db:link>&lt;T&gt;, <db:link xlink:href="qsharedpointer.xml">QSharedPointer</db:link>&lt;T&gt;, <db:link xlink:href="qweakpointer.xml">QWeakPointer</db:link>&lt;T&gt;, where T is a class that derives from <db:link xlink:href="qobject.xml">QObject</db:link></db:para>
</db:listitem>
<db:listitem>
<db:para>Enumerations registered with <db:link xlink:href="qobject.xml#Q_ENUM">Q_ENUM</db:link> or <db:link xlink:href="qobject.xml#Q_FLAG">Q_FLAG</db:link></db:para>
</db:listitem>
<db:listitem>
<db:para>Classes that have a <db:link xlink:href="qobject.xml#Q_GADGET">Q_GADGET</db:link> macro</db:para>
</db:listitem>
</db:itemizedlist>
<db:note>
<db:para>This method also registers the stream and debug operators for the type if they are visible at registration time. As this is done automatically in some places, it is strongly recommended to declare the stream operators for a type directly after the type itself. Because of the argument dependent lookup rules of C++, it is also strongly recommended to declare the operators in the same namespace as the type itself.</db:para>
</db:note>
<db:para>The stream operators should have the following signatures:</db:para>
<db:programlisting language="cpp">QDataStream &amp;operator&lt;&lt;(QDataStream &amp;out, const MyClass &amp;myObj);
QDataStream &amp;operator&gt;&gt;(QDataStream &amp;in, MyClass &amp;myObj);
</db:programlisting>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qmetatype.xml#qRegisterMetaType">qRegisterMetaType</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="Q_DECLARE_OPAQUE_POINTER">
<db:title>Q_DECLARE_OPAQUE_POINTER(<db:emphasis>PointerType</db:emphasis>)</db:title>
<db:para>This macro enables pointers to forward-declared types (<db:code role="parameter">PointerType</db:code>) to be registered with <db:link xlink:href="qmetatype.xml">QMetaType</db:link> using either <db:link xlink:href="qmetatype.xml#Q_DECLARE_METATYPE">Q_DECLARE_METATYPE</db:link>() or <db:link xlink:href="qmetatype.xml#qRegisterMetaType">qRegisterMetaType</db:link>().</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qmetatype.xml#Q_DECLARE_METATYPE">Q_DECLARE_METATYPE</db:link>()</db:member>
<db:member><db:link xlink:href="qmetatype.xml#qRegisterMetaType">qRegisterMetaType</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="Q_DECLARE_SEQUENTIAL_CONTAINER_METATYPE">
<db:title>Q_DECLARE_SEQUENTIAL_CONTAINER_METATYPE(<db:emphasis>Container</db:emphasis>)</db:title>
<db:para>This macro makes the container <db:code role="parameter">Container</db:code> known to <db:link xlink:href="qmetatype.xml">QMetaType</db:link> as a sequential container. This makes it possible to put an instance of Container&lt;T&gt; into a <db:link xlink:href="qmetatype.xml#Type-enum">QVariant</db:link>, if T itself is known to <db:link xlink:href="qmetatype.xml">QMetaType</db:link>.</db:para>
<db:para>Note that all of the Qt sequential containers already have built-in support, and it is not necessary to use this macro with them. The std::vector and std::list containers also have built-in support.</db:para>
<db:para>This example shows a typical use of Q_DECLARE_SEQUENTIAL_CONTAINER_METATYPE():</db:para>
<db:programlisting language="cpp">#include &lt;deque&gt;

Q_DECLARE_SEQUENTIAL_CONTAINER_METATYPE(std::deque)

void someFunc()
{
    std::deque&lt;QFile*&gt; container;
    QVariant var = QVariant::fromValue(container);
    // ...
}

</db:programlisting>
</db:section>
<db:section xml:id="Q_DECLARE_SMART_POINTER_METATYPE">
<db:title>Q_DECLARE_SMART_POINTER_METATYPE(<db:emphasis>SmartPointer</db:emphasis>)</db:title>
<db:para>This macro makes the smart pointer <db:code role="parameter">SmartPointer</db:code> known to <db:link xlink:href="qmetatype.xml">QMetaType</db:link> as a smart pointer. This makes it possible to put an instance of SmartPointer&lt;T&gt; into a <db:link xlink:href="qmetatype.xml#Type-enum">QVariant</db:link>, if T is a type which inherits <db:link xlink:href="qobject.xml">QObject</db:link>.</db:para>
<db:para>Note that the <db:link xlink:href="qweakpointer.xml">QWeakPointer</db:link>, <db:link xlink:href="qsharedpointer.xml">QSharedPointer</db:link> and <db:link xlink:href="qpointer.xml">QPointer</db:link> already have built-in support, and it is not necessary to use this macro with them.</db:para>
<db:para>This example shows a typical use of Q_DECLARE_SMART_POINTER_METATYPE():</db:para>
<db:programlisting language="cpp">#include &lt;memory&gt;

Q_DECLARE_SMART_POINTER_METATYPE(std::shared_ptr)

void someFunc()
{
    auto smart_ptr = std::make_shared&lt;QFile&gt;();
    QVariant var = QVariant::fromValue(smart_ptr);
    // ...
    if (var.canConvert&lt;QObject*&gt;()) {
        QObject *sp = var.value&lt;QObject*&gt;();
        qDebug() &lt;&lt; sp-&gt;metaObject()-&gt;className(); // Prints 'QFile'.
    }
}

</db:programlisting>
</db:section>
</db:section>
<db:section xml:id="obsolete">
<db:title>Obsolete Members for QMetaType</db:title>
<db:para><db:emphasis role="bold">The following members of class <db:link xlink:href="qmetatype.xml">QMetaType</db:link> are deprecated.</db:emphasis> We strongly advise against using them in new code.</db:para>
<db:section xml:id="obsolete-member-function-documentation">
<db:title>Obsolete Member Function Documentation</db:title>
<db:section xml:id="compare-1">
<db:title>[static, deprecated] bool QMetaType::compare(const void *<db:emphasis>lhs</db:emphasis>, const void *<db:emphasis>rhs</db:emphasis>, int <db:emphasis>typeId</db:emphasis>, int *<db:emphasis>result</db:emphasis>)</db:title>
<db:para>This function is deprecated. We strongly advise against using it in new code.</db:para>
<db:para>Use the non-static compare method instead</db:para>
<db:para>Compares the objects at <db:code role="parameter">lhs</db:code> and <db:code role="parameter">rhs</db:code>. Both objects need to be of type <db:code role="parameter">typeId</db:code>. <db:code role="parameter">result</db:code> is set to less than, equal to or greater than zero, if <db:code role="parameter">lhs</db:code> is less than, equal to or greater than <db:code role="parameter">rhs</db:code>. Returns true, if the comparison succeeded, otherwise false.</db:para>
</db:section>
<db:section xml:id="construct-1">
<db:title>[static, deprecated] void *QMetaType::construct(int <db:emphasis>type</db:emphasis>, void *<db:emphasis>where</db:emphasis>, const void *<db:emphasis>copy</db:emphasis>)</db:title>
<db:para>This function is deprecated. We strongly advise against using it in new code.</db:para>
<db:para>Constructs a value of the given <db:code role="parameter">type</db:code> in the existing memory addressed by <db:code role="parameter">where</db:code>, that is a copy of <db:code role="parameter">copy</db:code>, and returns <db:code role="parameter">where</db:code>. If <db:code role="parameter">copy</db:code> is zero, the value is default constructed.</db:para>
<db:para>This is a low-level function for explicitly managing the memory used to store the type. Consider calling <db:link xlink:href="qmetatype.xml#create">create</db:link>() if you don't need this level of control (that is, use &quot;new&quot; rather than &quot;placement new&quot;).</db:para>
<db:para>You must ensure that <db:code role="parameter">where</db:code> points to a location that can store a value of type <db:code role="parameter">type</db:code>, and that <db:code role="parameter">where</db:code> is suitably aligned. The type's size can be queried by calling <db:link xlink:href="qmetatype.xml#sizeOf">sizeOf</db:link>().</db:para>
<db:para>The rule of thumb for alignment is that a type is aligned to its natural boundary, which is the smallest power of 2 that is bigger than the type, unless that alignment is larger than the maximum useful alignment for the platform. For practical purposes, alignment larger than 2 * sizeof(void*) is only necessary for special hardware instructions (e.g., aligned SSE loads and stores on x86).</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qmetatype.xml#destruct">destruct</db:link>()</db:member>
<db:member><db:link xlink:href="qmetatype.xml#sizeOf">sizeOf</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="convert-1">
<db:title>[static, deprecated] bool QMetaType::convert(const void *<db:emphasis>from</db:emphasis>, int <db:emphasis>fromTypeId</db:emphasis>, void *<db:emphasis>to</db:emphasis>, int <db:emphasis>toTypeId</db:emphasis>)</db:title>
<db:para>This function is deprecated. We strongly advise against using it in new code.</db:para>
<db:para>Converts the object at <db:code role="parameter">from</db:code> from <db:code role="parameter">fromTypeId</db:code> to the preallocated space at <db:code role="parameter">to</db:code> typed <db:code role="parameter">toTypeId</db:code>. Returns true, if the conversion succeeded, otherwise false.</db:para>
<db:para>Both <db:code role="parameter">from</db:code> and <db:code role="parameter">to</db:code> have to be valid pointers.</db:para>
</db:section>
<db:section xml:id="create-1">
<db:title>[static, deprecated] void *QMetaType::create(int <db:emphasis>type</db:emphasis>, const void *<db:emphasis>copy</db:emphasis> = nullptr)</db:title>
<db:para>This function is deprecated. We strongly advise against using it in new code.</db:para>
<db:para>Returns a copy of <db:code role="parameter">copy</db:code>, assuming it is of type <db:code role="parameter">type</db:code>. If <db:code role="parameter">copy</db:code> is zero, creates a default constructed instance.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qmetatype.xml#destroy">destroy</db:link>()</db:member>
<db:member><db:link xlink:href="qmetatype.xml#isRegistered">isRegistered</db:link>()</db:member>
<db:member><db:link xlink:href="qmetatype.xml#Type-enum">Type</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="debugStream-1">
<db:title>[static, deprecated] bool QMetaType::debugStream(QDebug &amp;<db:emphasis>dbg</db:emphasis>, const void *<db:emphasis>rhs</db:emphasis>, int <db:emphasis>typeId</db:emphasis>)</db:title>
<db:para>This function is deprecated. We strongly advise against using it in new code.</db:para>
<db:para>This is an overloaded function.</db:para>
</db:section>
<db:section xml:id="destroy-1">
<db:title>[static, deprecated] void QMetaType::destroy(int <db:emphasis>type</db:emphasis>, void *<db:emphasis>data</db:emphasis>)</db:title>
<db:para>This function is deprecated. We strongly advise against using it in new code.</db:para>
<db:para>Destroys the <db:code role="parameter">data</db:code>, assuming it is of the <db:code role="parameter">type</db:code> given.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qmetatype.xml#create">create</db:link>()</db:member>
<db:member><db:link xlink:href="qmetatype.xml#isRegistered">isRegistered</db:link>()</db:member>
<db:member><db:link xlink:href="qmetatype.xml#Type-enum">Type</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="destruct-1">
<db:title>[static, deprecated] void QMetaType::destruct(int <db:emphasis>type</db:emphasis>, void *<db:emphasis>where</db:emphasis>)</db:title>
<db:para>This function is deprecated. We strongly advise against using it in new code.</db:para>
<db:para>Destructs the value of the given <db:code role="parameter">type</db:code>, located at <db:code role="parameter">where</db:code>.</db:para>
<db:para>Unlike <db:link xlink:href="qmetatype.xml#destroy">destroy</db:link>(), this function only invokes the type's destructor, it doesn't invoke the delete operator.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qmetatype.xml#construct">construct</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="hasRegisteredDebugStreamOperator">
<db:title>[static, deprecated] bool QMetaType::hasRegisteredDebugStreamOperator()</db:title>
<db:para>This function is deprecated. We strongly advise against using it in new code.</db:para>
<db:para>Returns true, if the meta type system has a registered debug stream operator for type T.</db:para>
</db:section>
<db:section xml:id="hasRegisteredDebugStreamOperator-2">
<db:title>[static, deprecated] bool QMetaType::hasRegisteredDebugStreamOperator(int <db:emphasis>typeId</db:emphasis>)</db:title>
<db:para>This function is deprecated. We strongly advise against using it in new code.</db:para>
<db:para>Use <db:link xlink:href="qmetatype.xml#hasRegisteredDebugStreamOperator">QMetaType::hasRegisteredDebugStreamOperator</db:link>() instead.</db:para>
<db:para>Returns true, if the meta type system has a registered debug stream operator for type id <db:code role="parameter">typeId</db:code>.</db:para>
</db:section>
<db:section xml:id="load-1">
<db:title>[static, deprecated] bool QMetaType::load(QDataStream &amp;<db:emphasis>stream</db:emphasis>, int <db:emphasis>type</db:emphasis>, void *<db:emphasis>data</db:emphasis>)</db:title>
<db:para>This function is deprecated. We strongly advise against using it in new code.</db:para>
<db:para>This is an overloaded function.</db:para>
</db:section>
<db:section xml:id="metaObjectForType">
<db:title>[static, deprecated] const QMetaObject *QMetaType::metaObjectForType(int <db:emphasis>type</db:emphasis>)</db:title>
<db:para>This function is deprecated. We strongly advise against using it in new code.</db:para>
<db:para>returns <db:link xlink:href="qmetatype.xml#metaObject">QMetaType::metaObject</db:link> for <db:code role="parameter">type</db:code></db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qmetatype.xml#metaObject">metaObject</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="save-1">
<db:title>[static, deprecated] bool QMetaType::save(QDataStream &amp;<db:emphasis>stream</db:emphasis>, int <db:emphasis>type</db:emphasis>, const void *<db:emphasis>data</db:emphasis>)</db:title>
<db:para>This function is deprecated. We strongly advise against using it in new code.</db:para>
<db:para>This is an overloaded function.</db:para>
</db:section>
<db:section xml:id="sizeOf-1">
<db:title>[static, deprecated] int QMetaType::sizeOf(int <db:emphasis>type</db:emphasis>)</db:title>
<db:para>This function is deprecated. We strongly advise against using it in new code.</db:para>
<db:para>Returns the size of the given <db:code role="parameter">type</db:code> in bytes (i.e. sizeof(T), where T is the actual type identified by the <db:code role="parameter">type</db:code> argument).</db:para>
<db:para>This function is typically used together with <db:link xlink:href="qmetatype.xml#construct">construct</db:link>() to perform low-level management of the memory used by a type.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qmetatype.xml#construct">construct</db:link>()</db:member>
<db:member><db:link xlink:href="qmetatype.xml#alignOf">QMetaType::alignOf</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="type">
<db:title>[static, deprecated] int QMetaType::type(const char *<db:emphasis>typeName</db:emphasis>)</db:title>
<db:para>This function is deprecated. We strongly advise against using it in new code.</db:para>
<db:para>Returns a handle to the type called <db:code role="parameter">typeName</db:code>, or <db:link xlink:href="qmetatype.xml#Type-enum">QMetaType::UnknownType</db:link> if there is no such type.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qmetatype.xml#isRegistered">isRegistered</db:link>()</db:member>
<db:member><db:link xlink:href="qmetatype.xml#typeName">typeName</db:link>()</db:member>
<db:member><db:link xlink:href="qmetatype.xml#Type-enum">Type</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="type-1">
<db:title>[static, deprecated] int QMetaType::type(const QByteArray &amp;<db:emphasis>typeName</db:emphasis>)</db:title>
<db:para>This function is deprecated. We strongly advise against using it in new code.</db:para>
<db:para>This is an overloaded function.</db:para>
<db:para>Returns a handle to the type called <db:code role="parameter">typeName</db:code>, or 0 if there is no such type.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qmetatype.xml#isRegistered">isRegistered</db:link>()</db:member>
<db:member><db:link xlink:href="qmetatype.xml#typeName">typeName</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="typeFlags">
<db:title>[static, deprecated] QMetaType::TypeFlags QMetaType::typeFlags(int <db:emphasis>type</db:emphasis>)</db:title>
<db:para>This function is deprecated. We strongly advise against using it in new code.</db:para>
<db:para>Returns flags of the given <db:code role="parameter">type</db:code>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qmetatype.xml#TypeFlag-enum">QMetaType::TypeFlags</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="typeName">
<db:title>[static, deprecated] const char *QMetaType::typeName(int <db:emphasis>typeId</db:emphasis>)</db:title>
<db:para>This function is deprecated. We strongly advise against using it in new code.</db:para>
<db:para>Returns the type name associated with the given <db:code role="parameter">typeId</db:code>, or a null pointer if no matching type was found. The returned pointer must not be deleted.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qmetatype.xml#type">type</db:link>()</db:member>
<db:member><db:link xlink:href="qmetatype.xml#isRegistered">isRegistered</db:link>()</db:member>
<db:member><db:link xlink:href="qmetatype.xml#Type-enum">Type</db:link></db:member>
<db:member><db:link xlink:href="qmetatype.xml#name">name</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
</db:section>
<db:section xml:id="obsolete-related-non-members">
<db:title>Obsolete Related Non-Members</db:title>
<db:section xml:id="qRegisterMetaType-3">
<db:title>[deprecated] int qRegisterMetaType(const char *<db:emphasis>typeName</db:emphasis>)</db:title>
<db:para>This function is deprecated. We strongly advise against using it in new code.</db:para>
<db:para>Registers the type name <db:code role="parameter">typeName</db:code> for the type T. Returns the internal ID used by <db:link xlink:href="qmetatype.xml">QMetaType</db:link>. Any class or struct that has a public default constructor, a public copy constructor and a public destructor can be registered.</db:para>
<db:para>This function requires that T is a fully defined type at the point where the function is called. For pointer types, it also requires that the pointed to type is fully defined. Use <db:link xlink:href="qmetatype.xml#Q_DECLARE_OPAQUE_POINTER">Q_DECLARE_OPAQUE_POINTER</db:link>() to be able to register pointers to forward declared types.</db:para>
<db:para>After a type has been registered, you can create and destroy objects of that type dynamically at run-time.</db:para>
<db:para>This example registers the class MyClass:</db:para>
<db:programlisting language="cpp">qRegisterMetaType&lt;MyClass&gt;(&quot;MyClass&quot;);
</db:programlisting>
<db:para>This function is useful to register typedefs so they can be used by <db:link xlink:href="qmetaproperty.xml">QMetaProperty</db:link>, or in QueuedConnections</db:para>
<db:programlisting language="cpp">typedef QString CustomString;
qRegisterMetaType&lt;CustomString&gt;(&quot;CustomString&quot;);
</db:programlisting>
<db:warning>
<db:para>This function is useful only for registering an alias (typedef) for every other use case <db:link xlink:href="qmetatype.xml#Q_DECLARE_METATYPE">Q_DECLARE_METATYPE</db:link> and <db:link xlink:href="qmetatype.xml#qMetaTypeId">qMetaTypeId</db:link>() should be used instead.</db:para>
</db:warning>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qmetatype.xml#isRegistered">isRegistered</db:link>()</db:member>
<db:member><db:link xlink:href="qmetatype.xml#Q_DECLARE_METATYPE">Q_DECLARE_METATYPE</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
</db:section>
</db:section>
</db:article>
