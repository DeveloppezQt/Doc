<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en">
<db:info>
<db:title>Instantiating State Machines</db:title>
<db:productname>QtScxml</db:productname>
<db:edition>Qt 5.12.12 Reference Documentation</db:edition>
<db:titleabbrev>Qt Scxml Reference Documentation</db:titleabbrev>
<db:abstract>
<db:para>Instantiating dynamically created and compiled state machines in C++ and QML.</db:para>
</db:abstract>
<db:pubdate>2024-12-27</db:pubdate>
<db:date>2024-12-27</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:para>Both the dynamically created and the compiled state machines behave in the same way, have the same properties, states, data model, and so on. They only differ in the way they are instantiated. To dynamically create one in C++ from an SCXML file, you can use:</db:para>
<db:programlisting language="cpp">auto *stateMachine = QScxmlStateMachine::fromFile(&quot;MyStatemachine.scxml&quot;);
</db:programlisting>
<db:para>Or, in QML:</db:para>
<db:programlisting language="qml">import QtScxml 5.8

Item {
    property StateMachine stateMachine: scxmlLoader.stateMachine

    StateMachineLoader {
        id: scxmlLoader
        source: &quot;statemachine.scxml&quot;
    }
}
</db:programlisting>
<db:para>A compiled state machine can be instantiated the same way as any C++ object:</db:para>
<db:programlisting language="cpp">auto *stateMachine = new MyStatemachine;
</db:programlisting>
<db:para>Or:</db:para>
<db:programlisting language="cpp">MyStatemachine stateMachine;
</db:programlisting>
<db:para>To use a compiled state machine in QML, you can register it as a QML type:</db:para>
<db:programlisting language="cpp">qmlRegisterType&amp;lt;MyStateMachine&amp;gt;(&quot;MyStateMachine&quot;, 1, 0, &quot;MyStateMachine&quot;);
</db:programlisting>
<db:para>Then you can instantiate it in QML, like this:</db:para>
<db:programlisting language="qml">import MyStateMachine 1.0

MyStateMachine {
    id: stateMachine
}
</db:programlisting>
<db:para>To compile a state machine, the following lines have to be added to a .pro file:</db:para>
<db:programlisting language="cpp" role="bad">QT += scxml
STATECHARTS = MyStatemachine.scxml
</db:programlisting>
<db:para>This will tell qmake to run <db:emphasis>qscxmlc</db:emphasis> which generates MyStatemachine.h and MyStatemachine.cpp, and adds them to <db:link xlink:href="qmake-variable-reference.xml#headers">HEADERS</db:link> and <db:link xlink:href="qmake-variable-reference.xml#sources">SOURCES</db:link> variables. By default, the generated files are saved in the build directory. The <db:emphasis>QSCXMLC_DIR</db:emphasis> variable can be set to specify another directory. The <db:emphasis>QSCXMLC_NAMESPACE</db:emphasis> variable can be set to put the state machine code into a C++ namespace.</db:para>
<db:para>After instantiating a state machine, you can connect to any state's active property as follows. For example, if the state machine for a traffic light has a state indicating that the light is red (which has the convenient id &quot;red&quot; in the scxml file), you can write:</db:para>
<db:programlisting language="cpp">stateMachine-&amp;gt;connectToState(&quot;red&quot;, [](bool active) {
    qDebug() &amp;lt;&amp;lt; (active ? &quot;entered&quot; : &quot;exited&quot;) &amp;lt;&amp;lt; &quot;the red state&quot;;
</db:programlisting>
<db:para>And in QML:</db:para>
<db:programlisting language="qml">Light {
    id: greenLight
    color: &quot;green&quot;
    visible: stateMachine.green
}
</db:programlisting>
<db:para>If you want to be notified when a state machine sends out an event, you can connect to the corresponding signal. For example, for a media player state machine which indicates that playback has stopped by sending an event, you can write:</db:para>
<db:programlisting language="cpp">stateMachine-&amp;gt;connectToEvent(&quot;playbackStopped&quot;, [](const QScxmlEvent &amp;amp;){
    qDebug() &amp;lt;&amp;lt; &quot;Stopped!&quot;;
});
</db:programlisting>
<db:para>And in QML:</db:para>
<db:programlisting language="qml">import QtScxml 5.8

EventConnection {
    stateMachine: stateMachine
    events: [&quot;playbackStopped&quot;]
    onOccurred: console.log(&quot;Stopped!&quot;)
}
</db:programlisting>
<db:para>Sending events to a state machine is equally simple:</db:para>
<db:programlisting language="cpp">stateMachine-&amp;gt;submitEvent(&quot;tap&quot;, QVariantMap({
    { &quot;artist&quot;, &quot;Fatboy Slim&quot; },
    { &quot;title&quot;, &quot;The Rockafeller Skank&quot; }
});
</db:programlisting>
<db:para>This will generate a &quot;tap&quot; event with the map contents available in _event.data inside the state machine. In QML:</db:para>
<db:programlisting language="cpp">stateMachine.submitEvent(&quot;tap&quot;, {
    &quot;artist&quot;: &quot;Fatboy Slim&quot;
    &quot;title&quot;: &quot;The Rockafeller Skank&quot;
})
</db:programlisting>
<db:note>
<db:para>A state machine needs a <db:code>QEventLoop</db:code> to work correctly. The event loop is used to implement the <db:code>delay</db:code> attribute for events and to schedule the processing of a state machine when events are received from nested (or parent) state machines. A QML application or a widget application will always have an event loop running, so nothing extra is needed. For other applications, <db:code>QApplication::run</db:code> will have to be called to start the event loop processing.</db:para>
</db:note>
</db:article>
