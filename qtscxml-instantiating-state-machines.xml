<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en">
<db:info>
<db:title>Instantiating State Machines</db:title>
<db:productname>QtScxml</db:productname>
<db:edition>Qt 5.7.1 Reference Documentation</db:edition>
<db:titleabbrev>Qt Scxml Reference Documentation</db:titleabbrev>
<db:abstract>
<db:para>Instantiating dynamically created and compiled state machines in C++ and QML.</db:para>
</db:abstract>
<db:pubdate>2025-06-29</db:pubdate>
<db:date>2025-06-29</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:para>Both the dynamically created and the compiled state machines behave in the same way, have the same properties, states, data model, and so on. They only differ in the way they are instantiated. To dynamically create one in C++ from an SCXML file, you can use:</db:para>
<db:programlisting language="cpp">auto *stateMachine = QScxmlStateMachine::fromFile(&quot;MyStatemachine.scxml&quot;);
</db:programlisting>
<db:para>Or, in QML:</db:para>
<db:programlisting language="qml">import QtScxml 5.7

Item {
    property QtObject stateMachine: scxmlLoader.stateMachine

    StateMachineLoader {
        id: scxmlLoader
        filename: &quot;statemachine.scxml&quot;
    }
}
</db:programlisting>
<db:para>A compiled state machine can be instantiated the same way as any C++ object:</db:para>
<db:programlisting language="cpp">auto *stateMachine = new MyStatemachine;
</db:programlisting>
<db:para>Or:</db:para>
<db:programlisting language="cpp">MyStatemachine stateMachine;
</db:programlisting>
<db:para>To use a compiled state machine in QML, you can assign it to a context property:</db:para>
<db:programlisting language="cpp">MyStatemachine stateMachine;
QQmlApplicationEngine engine;
engine.rootContext()-&gt;setContextProperty(&quot;stateMachine&quot;, &amp;stateMachine);
</db:programlisting>
<db:para>To compile a state machine, the following lines have to be added to a .pro file:</db:para>
<db:programlisting language="cpp" role="bad">QT += scxml
STATECHARTS = MyStatemachine.scxml
</db:programlisting>
<db:para>This will tell qmake to run <db:emphasis>qscxmlc</db:emphasis> which generates MyStatemachine.h and MyStatemachine.cpp, and adds them to <db:link xlink:href="qmake-variable-reference.xml#headers">HEADERS</db:link> and <db:link xlink:href="qmake-variable-reference.xml#sources">SOURCES</db:link> variables.</db:para>
<db:para>After instantiating a state machine, you can connect to any state's active property as follows. For example, if the state machine for a traffic light has a state indicating that the light is red (which has the convenient id &quot;red&quot; in the scxml file), you can write:</db:para>
<db:programlisting language="cpp">QObject::connect(stateMachine, &amp;TrafficLightStateMachine::redChanged,
    [](bool active) {
   qDebug() &lt;&lt; (active ? &quot;entered&quot; : &quot;exited&quot;) &lt;&lt; &quot;the red state&quot;;
</db:programlisting>
<db:para>And in QML:</db:para>
<db:programlisting language="qml">Light {
    id: greenLight
    color: &quot;green&quot;
    visible: stateMachine.green
}
</db:programlisting>
<db:para>If you want to be notified when a state machine sends out an event, you can connect to the corresponding signal. For example, for a media player state machine which indicates that playback has stopped by sending an event, you can write:</db:para>
<db:programlisting language="cpp">QObject::connect(stateMachine, &amp;MediaPlayer::playbackStopped, [](){
    qDebug() &lt;&lt; &quot;Stopped!&quot;;
});
</db:programlisting>
<db:para>And in QML:</db:para>
<db:programlisting language="qml">Connections {
    target: stateMachine
    onPlaybackStopped: console.log(&quot;Stopped!&quot;)
}
</db:programlisting>
<db:para>Sending events to a state machine is equally simple. You can call (or connect to) the slot:</db:para>
<db:programlisting language="cpp">stateMachine-&gt;tap(QVariantMap({
    std::make_pair(&quot;artist&quot;, &quot;Fatboy Slim&quot;),
    std::make_pair(&quot;title&quot;, &quot;The Rockafeller Skank&quot;)
});
</db:programlisting>
<db:para>This will generate a &quot;tap&quot; event with the map contents available in _event.data inside the state machine. In QML:</db:para>
<db:programlisting language="cpp">stateMacine.tap({
    &quot;artist&quot;: &quot;Fatboy Slim&quot;
    &quot;title&quot;: &quot;The Rockafeller Skank&quot;
})
</db:programlisting>
<db:para>Any invoked state machine with a name property will also show up as a property on its parent state machine.</db:para>
</db:article>
