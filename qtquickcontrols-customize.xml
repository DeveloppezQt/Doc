<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en">
<db:info>
<db:title>Customizing Qt Quick Controls</db:title>
<db:productname>QtQuickControls</db:productname>
<db:edition>Qt 6.6.3 Reference Documentation</db:edition>
<db:titleabbrev>Qt Quick Controls Reference Documentation</db:titleabbrev>
<db:abstract>
<db:para>A set of UI controls to create user interfaces in Qt Quick.</db:para>
</db:abstract>
<db:pubdate>2024-12-27</db:pubdate>
<db:date>2024-12-27</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:para>Qt Quick Controls consist of a hierarchy (tree) of items. In order to provide a custom look and feel, the default QML implementation of each item can be replaced with a custom one.</db:para>
<db:section xml:id="customizing-a-control">
<db:title>Customizing a Control</db:title>
<db:para>Sometimes you'll want to create a &quot;one-off&quot; look for a specific part of your UI, and use a complete style everywhere else. Perhaps you're happy with the style you're using, but there's a certain button that has some special significance.</db:para>
<db:para>The first way to create this button is to simply define it in-place, wherever it is needed. For example, perhaps you're not satisfied with the Basic style's Button having square corners. To make them rounded, you can override the <db:link xlink:href="qml-qtquick-controls-control.xml#background-prop">background</db:link> item and set the radius property of Rectangle:</db:para>
<db:programlisting language="qml">import QtQuick
import QtQuick.Controls

ApplicationWindow {
    width: 400
    height: 400
    visible: true

    Button {
        id: button
        text: &quot;A Special Button&quot;
        background: Rectangle {
            implicitWidth: 100
            implicitHeight: 40
            color: button.down ? &quot;#d6d6d6&quot; : &quot;#f6f6f6&quot;
            border.color: &quot;#26282a&quot;
            border.width: 1
            radius: 4
        }
    }
}
</db:programlisting>
<db:note>
<db:para>as the different items that make up a control in any given style are designed to work together, it may be necessary to override other items to get the look you're after. In addition, not all styles can be customized. See the note in <db:link xlink:href="qtquickcontrols-customize.xml#customization-reference">Customization Reference</db:link> for more information.</db:para>
</db:note>
<db:para>The second way to create the button is good if you plan to use your rounded button in several places. It involves moving the code into its own QML file within your project.</db:para>
<db:para>For this approach, we'll copy the background code from the Basic style's <db:code>Button.qml</db:code>. This file can be found in the following path in your Qt installation:</db:para>
<db:para><db:code>$QTDIR/qml/QtQuick/Controls/Basic/Button.qml</db:code></db:para>
<db:para>After doing that, we'll simply add the following line:</db:para>
<db:programlisting language="cpp">radius: 4
</db:programlisting>
<db:para>To avoid confusion with the controls in the module itself, we'll call the file <db:code>MyButton.qml</db:code>. To use the control in your application, refer to it by its filename:</db:para>
<db:programlisting language="qml">import QtQuick.Controls

ApplicationWindow {
    MyButton {
        text: qsTr(&quot;A Special Button&quot;)
    }
}
</db:programlisting>
<db:para>The third way to create the button is a bit more structured, both in terms of where the file sits in the file system and how it is used in QML. First, copy an existing file as you did above, but this time, put it into a subfolder in your project named (for example) <db:code>controls</db:code>. To use the control, first import the folder into a namespace:</db:para>
<db:programlisting language="qml">import QtQuick.Controls
import &quot;controls&quot; as MyControls

ApplicationWindow {
    MyControls.Button {
        text: qsTr(&quot;A Special Button&quot;)
    }
}
</db:programlisting>
<db:para>As you now have the <db:code>MyControls</db:code> namespace, you can name the controls after their actual counterparts in the Qt Quick Controls module. You can repeat this process for any control that you wish to add.</db:para>
<db:para>An added benefit of these three methods is that it's not necessary to implement the template from scratch.</db:para>
<db:note>
<db:para>the three approaches mentioned here do not work for customizing the attached <db:link xlink:href="qml-qtquick-controls-tooltip.xml">ToolTip</db:link>, as that is a shared item created internally. To do a one-off customization of a <db:code>ToolTip</db:code>, see <db:link xlink:href="qml-qtquick-controls-tooltip.xml#custom-tool-tips">Custom Tool Tips</db:link>. To customize the attached <db:code>ToolTip</db:code>, it must be provided as part of <db:link xlink:href="qtquickcontrols-customize.xml#creating-a-custom-style">your own style</db:link>.</db:para>
</db:note>
</db:section>
<db:section xml:id="creating-a-custom-style">
<db:title>Creating a Custom Style</db:title>
<db:para>There are several ways to go about creating your own styles. Below, we'll explain the various approaches.</db:para>
<db:section xml:id="definition-of-a-style">
<db:title>Definition of a Style</db:title>
<db:para>In Qt Quick Controls, a style is essentially a set of QML files within a single directory. There are four requirements for a style to be <db:link xlink:href="qtquickcontrols-styles.xml#using-styles-in-qt-quick-controls">usable</db:link>:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para>At least one QML file whose name matches a control (for example, <db:code>Button.qml</db:code>) must exist.</db:para>
</db:listitem>
<db:listitem>
<db:para>Each QML file must contain the relevant type from the <db:link xlink:href="qtquicktemplates2-index.xml">QtQuick.Templates</db:link> import as the root item. For example, Button.qml must contain a Button template as its root item.</db:para>
<db:para>If we instead used the corresponding type from the <db:link xlink:href="qtquickcontrols-index.xml">QtQuick.Controls</db:link> import as we did in the previous section, it would not work: the control we were defining would try to derive from itself.</db:para>
</db:listitem>
<db:listitem>
<db:para>A <db:link xlink:href="qtqml-modules-qmldir.xml">qmldir</db:link> file must exist alongside the QML file(s). Below is an example of a simple <db:code>qmldir</db:code> file for a style that provides a button:</db:para>
<db:programlisting language="cpp" role="bad">module MyStyle
Button 2.15 Button.qml
</db:programlisting>
<db:para>If you're using <db:link xlink:href="qtquickcontrols-styles.xml#compile-time-style-selection">compile-time style selection</db:link>, the qmldir should also import the fallback style:</db:para>
<db:programlisting language="cpp" role="bad"># ...
import QtQuick.Controls.Basic auto
</db:programlisting>
<db:para>This can also be done for <db:link xlink:href="qtquickcontrols-styles.xml#run-time-style-selection">run-time style selection</db:link> instead of using, for example, <db:link xlink:href="qquickstyle.xml#setFallbackStyle">QQuickStyle::setFallbackStyle</db:link>().</db:para>
<db:para>The directory structure for such a style looks like this:</db:para>
<db:programlisting language="cpp" role="bad">MyStyle
├─── Button.qml
└─── qmldir
</db:programlisting>
</db:listitem>
<db:listitem>
<db:para>The files must be in a directory that is findable via the <db:link xlink:href="qtqml-syntax-imports.xml#qml-import-path">QML Import Path</db:link>.</db:para>
<db:para>For example, if the path to <db:emphasis>MyStyle</db:emphasis> directory mentioned above was <db:code>/home/user/MyApp/MyStyle</db:code>, then <db:code>/home/user/MyApp</db:code> must be added to the QML import path.</db:para>
<db:para>To <db:link xlink:href="qtquickcontrols-styles.xml#using-styles-in-qt-quick-controls">use</db:link> <db:emphasis>MyStyle</db:emphasis> in <db:emphasis>MyApp</db:emphasis>, refer to it by name:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:code>./MyApp -style MyStyle</db:code></db:para>
</db:listitem>
</db:itemizedlist>
<db:para>The style name must match the casing of the style directory; passing <db:emphasis>mystyle</db:emphasis> or <db:emphasis>MYSTYLE</db:emphasis> is not supported.</db:para>
</db:listitem>
</db:itemizedlist>
<db:para>By default, the styling system uses the Basic style as a fallback for controls that aren't implemented. To customize or extend any other built-in style, it is possible to specify a different fallback style using <db:link xlink:href="qquickstyle.xml">QQuickStyle</db:link>.</db:para>
<db:para>What this means is that you can implement as many controls as you like for your custom style, and place them almost anywhere. It also allows users to create their own styles for your application.</db:para>
<db:section xml:id="previewing-custom-styles-in-qt-quick-designer">
<db:title>Previewing Custom Styles in Qt Quick Designer</db:title>
<db:para>Using the approach above, it is possible to preview a custom style in Qt Quick Designer. In order to do so, ensure that the project has a <db:link xlink:href="qtquickcontrols-configuration.xml">qtquickcontrols2.conf</db:link> file, and that the following entry exists:</db:para>
<db:programlisting language="cpp" role="bad">[Controls]
Style=MyStyle
</db:programlisting>
<db:para>For more information, take a look at the <db:link xlink:href="qtquickcontrols-flatstyle-example.xml">Flat Style example</db:link>.</db:para>
</db:section>
</db:section>
<db:section xml:id="style-specific-c-extensions">
<db:title>Style-specific C++ Extensions</db:title>
<db:para>Sometimes you may need to use C++ to extend your custom style.</db:para>
<db:itemizedlist>
<db:listitem>
<db:para>If the style that uses the type is the only style used by an application, register the type with the QML engine by adding the <db:link xlink:href="qqmlengine.xml#QML_ELEMENT">QML_ELEMENT</db:link> macro and making the file part of your QML module:  </db:para>
<db:bridgehead xml:id="tab-cmake" renderas="sect5" role="tabbed checked tab-group_tabs_expose-cpp-to-qml" xlink:href="#tab-cmake_contents">CMake</db:bridgehead>
<db:bridgehead xml:id="tab-qmake" renderas="sect5" role="tabbed checked tab-group_tabs_expose-cpp-to-qml" xlink:href="#tab-qmake_contents">qmake</db:bridgehead>
<db:sidebar xml:id="tab-cmake_contents">
<db:programlisting language="cpp" role="bad">qt_add_qml_module(ACoolItem
    URI MyItems
    VERSION 1.0
    SOURCES
    acoolcppitem.cpp acoolcppitem.h
    )
</db:programlisting>
</db:sidebar>
<db:sidebar xml:id="tab-qmake_contents">
<db:programlisting language="cpp">CONFIG += qmltypes
    QML_IMPORT_NAME = MyItems
    QML_IMPORT_MAJOR_VERSION = 1
</db:programlisting>
<db:para>If the header the class is declared in is not accessible from your project's include path, you may have to amend the include path so that the generated registration code can be compiled.</db:para>
<db:programlisting language="cpp">INCLUDEPATH += MyItems
</db:programlisting>
</db:sidebar>
<db:para>See <db:link xlink:href="qtqml-cppintegration-definetypes.xml">Defining QML Types from C++</db:link> and <db:link xlink:href="cmake-build-qml-application.xml">Building a QML application</db:link> for more information.</db:para>
</db:listitem>
<db:listitem>
<db:para>If the style that uses the type is one of many styles used by an application, consider putting each style into a separate module. The modules will then be loaded on demand.</db:para>
</db:listitem>
</db:itemizedlist>
<db:section xml:id="considerations-for-custom-styles">
<db:title>Considerations for custom styles</db:title>
<db:para>When implementing your own style and customizing controls, there are some points to keep in mind to ensure that your application is as performant as possible.</db:para>
<db:section xml:id="avoid-assigning-an-id-to-styles-implementations-of-item-delegates">
<db:title>Avoid assigning an id to styles' implementations of item delegates</db:title>
<db:para>As explained in <db:link xlink:href="qtquickcontrols-customize.xml#definition-of-a-style">Definition of a Style</db:link>, when you implement your own style for a control, you start off with the relevant template for that control. For example, a style's <db:code>Button.qml</db:code> will be structured similarly to this:</db:para>
<db:programlisting language="qml">T.Button {
    // ...

    background: Rectangle {
        // ...
    }

    contentItem: Text {
        // ...
    }

    // ...
}
</db:programlisting>
<db:para>When you use a Button in your application, the <db:code>background</db:code> and <db:code>contentItem</db:code> items will be created and parented to the root <db:code>Button</db:code> item:</db:para>
<db:programlisting language="qml">// Creates the Button root item, the Rectangle background,
// and the Text contentItem.
Button {
    text: qsTr(&quot;Confirm&quot;)
}
</db:programlisting>
<db:para>Suppose you then needed to do a one-off customization of the Button (as explained in <db:link xlink:href="qtquickcontrols-customize.xml#customizing-a-control">Customizing a Control</db:link>):</db:para>
<db:programlisting language="qml">import QtQuick
import QtQuick.Controls

ApplicationWindow {
    width: 400
    height: 400
    visible: true

    Button {
        id: button
        text: &quot;A Special Button&quot;
        background: Rectangle {
            implicitWidth: 100
            implicitHeight: 40
            color: button.down ? &quot;#d6d6d6&quot; : &quot;#f6f6f6&quot;
            border.color: &quot;#26282a&quot;
            border.width: 1
            radius: 4
        }
    }
}
</db:programlisting>
<db:para>In QML, this would normally result in both the default <db:code>background</db:code> implementation and the one-off, custom <db:code>background</db:code> items being created. Qt Quick Controls uses a technique that avoids creating both items, and instead only creates the custom <db:code>background</db:code>, greatly improving the creation performance of controls.</db:para>
<db:para>This technique relies on the absence of an <db:link xlink:href="qtqml-syntax-objectattributes.xml#the-id-attribute">id</db:link> in the style's implementation of that item. If an id is assigned, the technique cannot work, and both items will be created. For example, it can be tempting to assign an id to the <db:code>background</db:code> or <db:code>contentItem</db:code> so that other objects within the file can refer to those items:</db:para>
<db:programlisting language="qml">T.Button {
    // ...

    background: Rectangle {
        id: backgroundRect
        // ...
    }

    contentItem: Text {
        // Use backgroundRect in some way...
    }

    // ...
}
</db:programlisting>
<db:para>With this code, every time a Button instance with a customized background is created, both backgrounds will be created, resulting in sub-optimal creation performance.</db:para>
<db:para>Prior to Qt 5.15, the old, unused background would be deleted to release the resources associated with it. However, as the control does not own the items, it should not delete them. As of Qt 5.15, old items are no longer deleted, and so the <db:code>backgroundRect</db:code> item will live longer than it needs to—typically until the application exits. Although the old item will be hidden, visually unparented from the control, and removed from the accessibility tree, it is important to keep the creation time and memory usage of these unused items in mind when assigning an id in this context.</db:para>
</db:section>
<db:section xml:id="avoid-imperative-assignments-of-custom-items">
<db:title>Avoid imperative assignments of custom items</db:title>
<db:para>The technique mentioned in the section above only works when an item is <db:link xlink:href="qtquick-bestpractices.xml#prefer-declarative-bindings-over-imperative-assignments">declaratively</db:link> assigned for the first time, and so imperative assignments will result in orphaned items. Always use declarative bindings to assign custom items when possible.</db:para>
</db:section>
<db:section xml:id="don-t-import-qtquick-controls-in-qml-implementations">
<db:title>Don't import QtQuick.Controls in QML implementations</db:title>
<db:para>When writing the QML for your style's implementation of a control, it's important not to import <db:code>QtQuick.Controls</db:code>. Doing so will prevent the QML from being compiled by the QML compiler.</db:para>
</db:section>
<db:section xml:id="implement-types-used-by-other-types">
<db:title>Implement types used by other types</db:title>
<db:para>Suppose you were using ScrollViews in your application, and decided that you want to customize their scroll bars. It is tempting to just implement a custom <db:link xlink:href="qml-qtquick-controls-scrollbar.xml">ScrollBar</db:link>.qml and have <db:link xlink:href="qml-qtquick-controls-scrollview.xml">ScrollView</db:link> pick up the customized <db:link xlink:href="qml-qtquick-controls-scrollbar.xml">ScrollBar</db:link> automatically. However, this will not work. You must implement both <db:link xlink:href="qml-qtquick-controls-scrollbar.xml">ScrollBar</db:link>.qml <db:emphasis>and</db:emphasis> <db:link xlink:href="qml-qtquick-controls-scrollview.xml">ScrollView</db:link>.qml.</db:para>
</db:section>
</db:section>
<db:section xml:id="attached-properties">
<db:title>Attached properties</db:title>
<db:para>It is common for a style to have certain properties or attributes that apply to all controls. <db:link xlink:href="qtqml-syntax-objectattributes.xml#attached-properties-and-attached-signal-handlers">Attached properties</db:link> are a great way of extending an item in QML without having to modify any existing C++ belonging to that item. For example, both the <db:link xlink:href="qtquickcontrols-material.xml">Material</db:link> and <db:link xlink:href="qtquickcontrols-universal.xml">Universal</db:link> styles have an attached theme property that controls whether an item and its children will be rendered in a light or dark theme.</db:para>
<db:para>As an example, let's add an attached property that controls elevation. Our style will illustrate the elevation with a drop shadow; the higher the elevation, the larger the shadow.</db:para>
<db:para>The first step is to <db:link xlink:href="https://doc.qt.io/qtcreator/creator-project-creating.html#selecting-project-type">create a new Qt Quick Controls application</db:link> in Qt Creator. After that, we <db:link xlink:href="https://doc.qt.io/qtcreator/creator-project-creating.html#creating-c-classes">add a C++ type</db:link> that stores the elevation. Since the type will be used for every control supported by our style, and because we may wish to add other attached properties later on, we'll call it MyStyle. Here is <db:code>MyStyle.h</db:code>:</db:para>
<db:programlisting language="cpp">#ifndef MYSTYLE_H
#define MYSTYLE_H

#include &amp;lt;QObject&amp;gt;
#include &amp;lt;QtQml&amp;gt;

class MyStyle : public QObject
{
    Q_OBJECT
    Q_PROPERTY(int elevation READ elevation WRITE setElevation NOTIFY elevationChanged)

public:
    explicit MyStyle(QObject *parent = nullptr);

    static MyStyle *qmlAttachedProperties(QObject *object);

    int elevation() const;
    void setElevation(int elevation);

signals:
    void elevationChanged();

private:
    int m_elevation;
};

QML_DECLARE_TYPEINFO(MyStyle, QML_HAS_ATTACHED_PROPERTIES)

#endif // MYSTYLE_H
</db:programlisting>
<db:para><db:code>MyStyle.cpp</db:code>:</db:para>
<db:programlisting language="cpp">#include &quot;mystyle.h&quot;

MyStyle::MyStyle(QObject *parent) :
    QObject(parent),
    m_elevation(0)
{
}

MyStyle *MyStyle::qmlAttachedProperties(QObject *object)
{
    return new MyStyle(object);
}

int MyStyle::elevation() const
{
    return m_elevation;
}

void MyStyle::setElevation(int elevation)
{
    if (elevation == m_elevation)
        return;

    m_elevation = elevation;
    emit elevationChanged();
}
</db:programlisting>
<db:para>The <db:code>MyStyle</db:code> type is special in the sense that it shouldn't be instantiated, but rather used for its attached properties. For that reason, we register it in the following manner in <db:code>main.cpp</db:code>:</db:para>
<db:programlisting language="cpp">#include &amp;lt;QGuiApplication&amp;gt;
#include &amp;lt;QQmlApplicationEngine&amp;gt;

#include &quot;mystyle.h&quot;

int main(int argc, char *argv[])
{
    QGuiApplication app(argc, argv);

    qmlRegisterUncreatableType&amp;lt;MyStyle&amp;gt;(&quot;MyStyle&quot;, 1, 0, &quot;MyStyle&quot;, &quot;MyStyle is an attached property&quot;);

    QQmlApplicationEngine engine;
    // Make the directory containing our style known to the QML engine.
    engine.addImportPath(&quot;:/&quot;);
    engine.load(QUrl(QLatin1String(&quot;qrc:/main.qml&quot;)));

    return app.exec();
}
</db:programlisting>
<db:para>We then copy <db:code>Button.qml</db:code> from the Basic style in <db:code>$QTDIR/qml/QtQuick/Controls/Basic/</db:code> into a new <db:code>myproject</db:code> folder in our project directory. Add the newly copied <db:code>Button.qml</db:code> to <db:code>qml.qrc</db:code>, which is the resource file that contains our QML files.</db:para>
<db:para>Next, we add a drop shadow to the <db:link xlink:href="qml-qtquick-controls-control.xml#background-prop">background</db:link> delegate of the Button:</db:para>
<db:programlisting language="cpp">// ...
import QtGraphicalEffects
import MyStyle
// ...

background: Rectangle {
    // ...

    layer.enabled: control.enabled &amp;amp;&amp;amp; control.MyStyle.elevation &amp;gt; 0
    layer.effect: DropShadow {
        verticalOffset: 1
        color: control.visualFocus ? &quot;#330066ff&quot; : &quot;#aaaaaa&quot;
        samples: control.MyStyle.elevation
        spread: 0.5
    }
}
</db:programlisting>
<db:para>Note that we:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para>Don't bother using the drop shadow when the elevation is <db:code>0</db:code></db:para>
</db:listitem>
<db:listitem>
<db:para>Change the shadow's color depending on whether or not the button has focus</db:para>
</db:listitem>
<db:listitem>
<db:para>Make the size of the shadow depend on the elevation</db:para>
</db:listitem>
</db:itemizedlist>
<db:para>To try out the attached property, we create a <db:link xlink:href="qml-qtquick-row.xml">Row</db:link> with two Buttons in <db:code>main.qml</db:code>:</db:para>
<db:programlisting language="qml">import QtQuick
import QtQuick.Controls

import MyStyle 1.0

ApplicationWindow {
    id: window
    width: 400
    height: 400
    visible: true

    Row {
        spacing: 20
        anchors.centerIn: parent

        Button {
            text: &quot;Button 1&quot;
        }
        Button {
            text: &quot;Button 2&quot;
            MyStyle.elevation: 10
        }
    }
}
</db:programlisting>
<db:para>One button has no elevation, and the other has an elevation of <db:code>10</db:code>.</db:para>
<db:para>With that in place, we can run our example. To tell the application to use our new style, we pass <db:code>-style MyStyle</db:code> as an application argument, but there are <db:link xlink:href="qtquickcontrols-styles.xml#using-styles-in-qt-quick-controls">many ways</db:link> to specify the style to use.</db:para>
<db:para>The end result:</db:para>
<db:mediaobject>
<db:imageobject>
<db:imagedata fileref="images/qtquickcontrols-customize-buttons.png"/>
</db:imageobject>
</db:mediaobject>
<db:para>Note that the <db:code>import MyStyle 1.0</db:code> statement is only necessary because we are using the attached property belonging to <db:code>MyStyle</db:code>. Both buttons will use our custom style, even if we were to remove the import.</db:para>
</db:section>
</db:section>
</db:section>
<db:section xml:id="customization-reference">
<db:title>Customization Reference</db:title>
<db:para>The following snippets present examples where the Basic style's controls have been customized using the same approach as the <db:link xlink:href="qtquickcontrols-customize.xml#customizing-a-control">Customizing a Control</db:link> section. The code can be used as a starting point to implement a custom look and feel.</db:para>
<db:note>
<db:para>The <db:link xlink:href="qtquickcontrols-macos.xml">macOS</db:link> and <db:link xlink:href="qtquickcontrols-windows.xml">Windows</db:link> styles are not suitable for customizing. It is instead recommended to always base a customized control on top of a single style that is available on all platforms, e.g <db:link xlink:href="qtquickcontrols-basic.xml">Basic Style</db:link>, <db:link xlink:href="qtquickcontrols-fusion.xml">Fusion Style</db:link>, <db:link xlink:href="qtquickcontrols-imagine.xml">Imagine Style</db:link>, <db:link xlink:href="qtquickcontrols-material.xml">Material Style</db:link>, <db:link xlink:href="qtquickcontrols-universal.xml">Universal Style</db:link>. By doing so, you are guaranteed that it will always look the same, regardless of which style the application is run with. To learn how to use a different style, see <db:link xlink:href="qtquickcontrols-styles.xml#using-styles-in-qt-quick-controls">Using Styles in Qt Quick Controls</db:link>. Alternatively, you can <db:link xlink:href="qtquickcontrols-customize.xml#creating-a-custom-style">create your own style</db:link>.</db:para>
</db:note>
<db:section xml:id="customizing-applicationwindow">
<db:title>Customizing ApplicationWindow</db:title>
<db:para><db:link xlink:href="qml-qtquick-controls-applicationwindow.xml">ApplicationWindow</db:link> consists of one visual item: <db:link xlink:href="qml-qtquick-controls-applicationwindow.xml#background-prop">background</db:link>.</db:para>
<db:programlisting language="cpp">import QtQuick
import QtQuick.Controls

ApplicationWindow {
    visible: true

    background: Rectangle {
        gradient: Gradient {
            GradientStop { position: 0; color: &quot;#ffffff&quot; }
            GradientStop { position: 1; color: &quot;#c1bbf9&quot; }
        }
    }
}
</db:programlisting>
</db:section>
<db:section xml:id="customizing-busyindicator">
<db:title>Customizing BusyIndicator</db:title>
<db:para><db:link xlink:href="qml-qtquick-controls-busyindicator.xml">BusyIndicator</db:link> consists of two visual items: <db:link xlink:href="qml-qtquick-controls-control.xml#background-prop">background</db:link> and <db:link xlink:href="qml-qtquick-controls-control.xml#contentItem-prop">contentItem</db:link>.</db:para>
<db:mediaobject>
<db:imageobject>
<db:imagedata fileref="images/qtquickcontrols-busyindicator-custom.png"/>
</db:imageobject>
</db:mediaobject>
<db:programlisting language="qml">import QtQuick
import QtQuick.Controls

BusyIndicator {
    id: control

    contentItem: Item {
        implicitWidth: 64
        implicitHeight: 64

        Item {
            id: item
            x: parent.width / 2 - 32
            y: parent.height / 2 - 32
            width: 64
            height: 64
            opacity: control.running ? 1 : 0

            Behavior on opacity {
                OpacityAnimator {
                    duration: 250
                }
            }

            RotationAnimator {
                target: item
                running: control.visible &amp;amp;&amp;amp; control.running
                from: 0
                to: 360
                loops: Animation.Infinite
                duration: 1250
            }

            Repeater {
                id: repeater
                model: 6

                Rectangle {
                    id: delegate
                    x: item.width / 2 - width / 2
                    y: item.height / 2 - height / 2
                    implicitWidth: 10
                    implicitHeight: 10
                    radius: 5
                    color: &quot;#21be2b&quot;

                    required property int index

                    transform: [
                        Translate {
                            y: -Math.min(item.width, item.height) * 0.5 + 5
                        },
                        Rotation {
                            angle: delegate.index / repeater.count * 360
                            origin.x: 5
                            origin.y: 5
                        }
                    ]
                }
            }
        }
    }
}
</db:programlisting>
</db:section>
<db:section xml:id="customizing-button">
<db:title>Customizing Button</db:title>
<db:para>Button consists of two visual items: <db:link xlink:href="qml-qtquick-controls-control.xml#background-prop">background</db:link> and <db:link xlink:href="qml-qtquick-controls-control.xml#contentItem-prop">content item</db:link>.</db:para>
<db:mediaobject>
<db:imageobject>
<db:imagedata fileref="images/qtquickcontrols-button-custom.png"/>
</db:imageobject>
</db:mediaobject>
<db:programlisting language="qml">import QtQuick
import QtQuick.Controls

Button {
    id: control
    text: qsTr(&quot;Button&quot;)

    contentItem: Text {
        text: control.text
        font: control.font
        opacity: enabled ? 1.0 : 0.3
        color: control.down ? &quot;#17a81a&quot; : &quot;#21be2b&quot;
        horizontalAlignment: Text.AlignHCenter
        verticalAlignment: Text.AlignVCenter
        elide: Text.ElideRight
    }

    background: Rectangle {
        implicitWidth: 100
        implicitHeight: 40
        opacity: enabled ? 1 : 0.3
        border.color: control.down ? &quot;#17a81a&quot; : &quot;#21be2b&quot;
        border.width: 1
        radius: 2
    }
}
</db:programlisting>
</db:section>
<db:section xml:id="customizing-checkbox">
<db:title>Customizing CheckBox</db:title>
<db:para><db:link xlink:href="qml-qtquick-controls-checkbox.xml">CheckBox</db:link> consists of three visual items: <db:link xlink:href="qml-qtquick-controls-control.xml#background-prop">background</db:link>, <db:link xlink:href="qml-qtquick-controls-control.xml#contentItem-prop">contentItem</db:link> and <db:link xlink:href="qml-qtquick-controls-abstractbutton.xml#indicator-prop">indicator</db:link>.</db:para>
<db:mediaobject>
<db:imageobject>
<db:imagedata fileref="images/qtquickcontrols-checkbox-custom.png"/>
</db:imageobject>
</db:mediaobject>
<db:programlisting language="qml">import QtQuick
import QtQuick.Controls

CheckBox {
    id: control
    text: qsTr(&quot;CheckBox&quot;)
    checked: true

    indicator: Rectangle {
        implicitWidth: 26
        implicitHeight: 26
        x: control.leftPadding
        y: parent.height / 2 - height / 2
        radius: 3
        border.color: control.down ? &quot;#17a81a&quot; : &quot;#21be2b&quot;

        Rectangle {
            width: 14
            height: 14
            x: 6
            y: 6
            radius: 2
            color: control.down ? &quot;#17a81a&quot; : &quot;#21be2b&quot;
            visible: control.checked
        }
    }

    contentItem: Text {
        text: control.text
        font: control.font
        opacity: enabled ? 1.0 : 0.3
        color: control.down ? &quot;#17a81a&quot; : &quot;#21be2b&quot;
        verticalAlignment: Text.AlignVCenter
        leftPadding: control.indicator.width + control.spacing
    }
}
</db:programlisting>
</db:section>
<db:section xml:id="customizing-checkdelegate">
<db:title>Customizing CheckDelegate</db:title>
<db:para><db:link xlink:href="qml-qtquick-controls-checkdelegate.xml">CheckDelegate</db:link> consists of three visual items: <db:link xlink:href="qml-qtquick-controls-control.xml#background-prop">background</db:link>, <db:link xlink:href="qml-qtquick-controls-control.xml#contentItem-prop">contentItem</db:link> and <db:link xlink:href="qml-qtquick-controls-abstractbutton.xml#indicator-prop">indicator</db:link>.</db:para>
<db:mediaobject>
<db:imageobject>
<db:imagedata fileref="images/qtquickcontrols-checkdelegate-custom.png"/>
</db:imageobject>
</db:mediaobject>
<db:programlisting language="qml">import QtQuick
import QtQuick.Controls

CheckDelegate {
    id: control
    text: qsTr(&quot;CheckDelegate&quot;)
    checked: true

    contentItem: Text {
        rightPadding: control.indicator.width + control.spacing
        text: control.text
        font: control.font
        opacity: enabled ? 1.0 : 0.3
        color: control.down ? &quot;#17a81a&quot; : &quot;#21be2b&quot;
        elide: Text.ElideRight
        verticalAlignment: Text.AlignVCenter
    }

    indicator: Rectangle {
        implicitWidth: 26
        implicitHeight: 26
        x: control.width - width - control.rightPadding
        y: control.topPadding + control.availableHeight / 2 - height / 2
        radius: 3
        color: &quot;transparent&quot;
        border.color: control.down ? &quot;#17a81a&quot; : &quot;#21be2b&quot;

        Rectangle {
            width: 14
            height: 14
            x: 6
            y: 6
            radius: 2
            color: control.down ? &quot;#17a81a&quot; : &quot;#21be2b&quot;
            visible: control.checked
        }
    }

    background: Rectangle {
        implicitWidth: 100
        implicitHeight: 40
        visible: control.down || control.highlighted
        color: control.down ? &quot;#bdbebf&quot; : &quot;#eeeeee&quot;
    }
}
</db:programlisting>
</db:section>
<db:section xml:id="customizing-combobox">
<db:title>Customizing ComboBox</db:title>
<db:para><db:link xlink:href="qml-qtquick-controls-combobox.xml">ComboBox</db:link> consists of <db:link xlink:href="qml-qtquick-controls-control.xml#background-prop">background</db:link>, <db:link xlink:href="qml-qtquick-controls-control.xml#contentItem-prop">content item</db:link>, <db:link xlink:href="qml-qtquick-controls-combobox.xml#popup-prop">popup</db:link>, <db:link xlink:href="qml-qtquick-controls-combobox.xml#indicator-prop">indicator</db:link>, and <db:link xlink:href="qml-qtquick-controls-combobox.xml#delegate-prop">delegate</db:link>.</db:para>
<db:mediaobject>
<db:imageobject>
<db:imagedata fileref="images/qtquickcontrols-combobox-custom.png"/>
</db:imageobject>
</db:mediaobject>
<db:programlisting language="qml">pragma ComponentBehavior: Bound

import QtQuick
import QtQuick.Controls

ComboBox {
    id: control
    model: [&quot;First&quot;, &quot;Second&quot;, &quot;Third&quot;]

    delegate: ItemDelegate {
        id: delegate

        required property var model
        required property int index

        width: control.width
        contentItem: Text {
            text: delegate.model[control.textRole]
            color: &quot;#21be2b&quot;
            font: control.font
            elide: Text.ElideRight
            verticalAlignment: Text.AlignVCenter
        }
        highlighted: control.highlightedIndex === index
    }

    indicator: Canvas {
        id: canvas
        x: control.width - width - control.rightPadding
        y: control.topPadding + (control.availableHeight - height) / 2
        width: 12
        height: 8
        contextType: &quot;2d&quot;

        Connections {
            target: control
            function onPressedChanged() { canvas.requestPaint(); }
        }

        onPaint: {
            context.reset();
            context.moveTo(0, 0);
            context.lineTo(width, 0);
            context.lineTo(width / 2, height);
            context.closePath();
            context.fillStyle = control.pressed ? &quot;#17a81a&quot; : &quot;#21be2b&quot;;
            context.fill();
        }
    }

    contentItem: Text {
        leftPadding: 0
        rightPadding: control.indicator.width + control.spacing

        text: control.displayText
        font: control.font
        color: control.pressed ? &quot;#17a81a&quot; : &quot;#21be2b&quot;
        verticalAlignment: Text.AlignVCenter
        elide: Text.ElideRight
    }

    background: Rectangle {
        implicitWidth: 120
        implicitHeight: 40
        border.color: control.pressed ? &quot;#17a81a&quot; : &quot;#21be2b&quot;
        border.width: control.visualFocus ? 2 : 1
        radius: 2
    }

    popup: Popup {
        y: control.height - 1
        width: control.width
        implicitHeight: contentItem.implicitHeight
        padding: 1

        contentItem: ListView {
            clip: true
            implicitHeight: contentHeight
            model: control.popup.visible ? control.delegateModel : null
            currentIndex: control.highlightedIndex

            ScrollIndicator.vertical: ScrollIndicator { }
        }

        background: Rectangle {
            border.color: &quot;#21be2b&quot;
            radius: 2
        }
    }
}
</db:programlisting>
<db:para>As explained in <db:link xlink:href="qml-qtquick-controls-combobox.xml#combobox-model-roles">ComboBox Model Roles</db:link>, <db:link xlink:href="qml-qtquick-controls-combobox.xml">ComboBox</db:link> supports multiple types of models.</db:para>
<db:para>Since <db:link xlink:href="qtquick-modelviewsdata-modelview.xml#qml-data-models">all the models provide an anonymous property</db:link> with <db:code>modelData</db:code>, the following expression retrieves the right text in all cases:</db:para>
<db:programlisting language="cpp">text: model[control.textRole]
</db:programlisting>
<db:para>When you provide a specific <db:code>textRole</db:code> and a model with structured data that provides the selected role, this is expression is a regular property lookup. When you provide a model with singular data, such as a list of strings, and an empty <db:code>textRole</db:code>, this expression retrieves the <db:code>modelData</db:code>.</db:para>
</db:section>
<db:section xml:id="customizing-delaybutton">
<db:title>Customizing DelayButton</db:title>
<db:para><db:link xlink:href="qml-qtquick-controls-delaybutton.xml">DelayButton</db:link> consists of two visual items: <db:link xlink:href="qml-qtquick-controls-control.xml#background-prop">background</db:link> and <db:link xlink:href="qml-qtquick-controls-control.xml#contentItem-prop">content item</db:link>.</db:para>
<db:mediaobject>
<db:imageobject>
<db:imagedata fileref="images/qtquickcontrols-delaybutton-custom.png"/>
</db:imageobject>
</db:mediaobject>
<db:programlisting language="qml">import QtQuick
import QtQuick.Controls

DelayButton {
    id: control
    checked: true
    text: qsTr(&quot;Delay\nButton&quot;)

    contentItem: Text {
        text: control.text
        font: control.font
        opacity: enabled ? 1.0 : 0.3
        color: &quot;white&quot;
        horizontalAlignment: Text.AlignHCenter
        verticalAlignment: Text.AlignVCenter
        elide: Text.ElideRight
    }

    background: Rectangle {
        implicitWidth: 100
        implicitHeight: 100
        opacity: enabled ? 1 : 0.3
        color: control.down ? &quot;#17a81a&quot; : &quot;#21be2b&quot;
        radius: size / 2

        readonly property real size: Math.min(control.width, control.height)
        width: size
        height: size
        anchors.centerIn: parent

        Canvas {
            id: canvas
            anchors.fill: parent

            Connections {
                target: control
                function onProgressChanged() { canvas.requestPaint(); }
            }

            onPaint: {
                var ctx = getContext(&quot;2d&quot;)
                ctx.clearRect(0, 0, width, height)
                ctx.strokeStyle = &quot;white&quot;
                ctx.lineWidth = parent.size / 20
                ctx.beginPath()
                var startAngle = Math.PI / 5 * 3
                var endAngle = startAngle + control.progress * Math.PI / 5 * 9
                ctx.arc(width / 2, height / 2, width / 2 - ctx.lineWidth / 2 - 2, startAngle, endAngle)
                ctx.stroke()
            }
        }
    }
}
</db:programlisting>
</db:section>
<db:section xml:id="customizing-dial">
<db:title>Customizing Dial</db:title>
<db:para>Dial consists of two visual items: <db:link xlink:href="qml-qtquick-controls-control.xml#background-prop">background</db:link> and <db:link xlink:href="qml-qtquick-controls-dial.xml#handle-prop">handle</db:link>.</db:para>
<db:mediaobject>
<db:imageobject>
<db:imagedata fileref="images/qtquickcontrols-dial-custom.png"/>
</db:imageobject>
</db:mediaobject>
<db:programlisting language="qml">import QtQuick
import QtQuick.Controls

Dial {
    id: control
    background: Rectangle {
        x: control.width / 2 - width / 2
        y: control.height / 2 - height / 2
        implicitWidth: 140
        implicitHeight: 140
        width: Math.max(64, Math.min(control.width, control.height))
        height: width
        color: &quot;transparent&quot;
        radius: width / 2
        border.color: control.pressed ? &quot;#17a81a&quot; : &quot;#21be2b&quot;
        opacity: control.enabled ? 1 : 0.3
    }

    handle: Rectangle {
        id: handleItem
        x: control.background.x + control.background.width / 2 - width / 2
        y: control.background.y + control.background.height / 2 - height / 2
        width: 16
        height: 16
        color: control.pressed ? &quot;#17a81a&quot; : &quot;#21be2b&quot;
        radius: 8
        antialiasing: true
        opacity: control.enabled ? 1 : 0.3
        transform: [
            Translate {
                y: -Math.min(control.background.width, control.background.height) * 0.4 + handleItem.height / 2
            },
            Rotation {
                angle: control.angle
                origin.x: handleItem.width / 2
                origin.y: handleItem.height / 2
            }
        ]
    }
}
</db:programlisting>
</db:section>
<db:section xml:id="customizing-drawer">
<db:title>Customizing Drawer</db:title>
<db:para>Drawer can have a visual <db:link xlink:href="qml-qtquick-controls-control.xml#background-prop">background</db:link> item.</db:para>
<db:programlisting language="cpp">background: Rectangle {
    Rectangle {
        x: parent.width - 1
        width: 1
        height: parent.height
        color: &quot;#21be2b&quot;
    }
}
</db:programlisting>
</db:section>
<db:section xml:id="customizing-frame">
<db:title>Customizing Frame</db:title>
<db:para>Frame consists of one visual item: <db:link xlink:href="qml-qtquick-controls-control.xml#background-prop">background</db:link>.</db:para>
<db:mediaobject>
<db:imageobject>
<db:imagedata fileref="images/qtquickcontrols-frame-custom.png"/>
</db:imageobject>
</db:mediaobject>
<db:programlisting language="qml">import QtQuick
import QtQuick.Controls

Frame {
    background: Rectangle {
        color: &quot;transparent&quot;
        border.color: &quot;#21be2b&quot;
        radius: 2
    }

    Label {
        text: qsTr(&quot;Content goes here!&quot;)
    }
}
</db:programlisting>
</db:section>
<db:section xml:id="customizing-groupbox">
<db:title>Customizing GroupBox</db:title>
<db:para><db:link xlink:href="qml-qtquick-controls-groupbox.xml">GroupBox</db:link> consists of two visual items: <db:link xlink:href="qml-qtquick-controls-control.xml#background-prop">background</db:link> and <db:link xlink:href="qml-qtquick-controls-groupbox.xml#label-prop">label</db:link>.</db:para>
<db:mediaobject>
<db:imageobject>
<db:imagedata fileref="images/qtquickcontrols-groupbox-custom.png"/>
</db:imageobject>
</db:mediaobject>
<db:programlisting language="qml">import QtQuick
import QtQuick.Controls

GroupBox {
    id: control
    title: qsTr(&quot;GroupBox&quot;)

    background: Rectangle {
        y: control.topPadding - control.bottomPadding
        width: parent.width
        height: parent.height - control.topPadding + control.bottomPadding
        color: &quot;transparent&quot;
        border.color: &quot;#21be2b&quot;
        radius: 2
    }

    label: Label {
        x: control.leftPadding
        width: control.availableWidth
        text: control.title
        color: &quot;#21be2b&quot;
        elide: Text.ElideRight
    }

    Label {
        text: qsTr(&quot;Content goes here!&quot;)
    }
}
</db:programlisting>
</db:section>
<db:section xml:id="customizing-itemdelegate">
<db:title>Customizing ItemDelegate</db:title>
<db:para><db:link xlink:href="qml-qtquick-controls-itemdelegate.xml">ItemDelegate</db:link> consists of two visual items: <db:link xlink:href="qml-qtquick-controls-control.xml#background-prop">background</db:link> and <db:link xlink:href="qml-qtquick-controls-control.xml#contentItem-prop">content item</db:link>.</db:para>
<db:mediaobject>
<db:imageobject>
<db:imagedata fileref="images/qtquickcontrols-itemdelegate-custom.png"/>
</db:imageobject>
</db:mediaobject>
<db:programlisting language="qml">import QtQuick
import QtQuick.Controls

ItemDelegate {
    id: control
    text: qsTr(&quot;ItemDelegate&quot;)

    contentItem: Text {
        rightPadding: control.spacing
        text: control.text
        font: control.font
        color: control.enabled ? (control.down ? &quot;#17a81a&quot; : &quot;#21be2b&quot;) : &quot;#bdbebf&quot;
        elide: Text.ElideRight
        verticalAlignment: Text.AlignVCenter
    }

    background: Rectangle {
        implicitWidth: 100
        implicitHeight: 40
        opacity: enabled ? 1 : 0.3
        color: control.down ? &quot;#dddedf&quot; : &quot;#eeeeee&quot;

        Rectangle {
            width: parent.width
            height: 1
            color: control.down ? &quot;#17a81a&quot; : &quot;#21be2b&quot;
            anchors.bottom: parent.bottom
        }
    }
}
</db:programlisting>
</db:section>
<db:section xml:id="customizing-label">
<db:title>Customizing Label</db:title>
<db:para>Label can have a visual <db:link xlink:href="qml-qtquick-controls-label.xml#background-prop">background</db:link> item.</db:para>
<db:mediaobject>
<db:imageobject>
<db:imagedata fileref="images/qtquickcontrols-label-custom.png"/>
</db:imageobject>
</db:mediaobject>
<db:programlisting language="qml">import QtQuick
import QtQuick.Controls

Label {
    text: qsTr(&quot;Label&quot;)
    color: &quot;#21be2b&quot;
}
</db:programlisting>
</db:section>
<db:section xml:id="customizing-menu">
<db:title>Customizing Menu</db:title>
<db:itemizedlist>
<db:listitem>
<db:para><db:link xlink:href="qml-qtquick-controls-menu.xml">Menu</db:link> consists of a visual <db:link xlink:href="qml-qtquick-controls-popup.xml#background-prop">background</db:link> item.</db:para>
</db:listitem>
<db:listitem>
<db:para><db:link xlink:href="qml-qtquick-controls-menuitem.xml">MenuItem</db:link> consists of four visual items: <db:link xlink:href="qml-qtquick-controls-control.xml#background-prop">background</db:link>, <db:link xlink:href="qml-qtquick-controls-control.xml#contentItem-prop">content item</db:link>, <db:link xlink:href="qml-qtquick-controls-abstractbutton.xml#indicator-prop">indicator</db:link>, and <db:link xlink:href="qml-qtquick-controls-menuitem.xml#arrow-prop">arrow</db:link>.</db:para>
</db:listitem>
<db:listitem>
<db:para><db:link xlink:href="qml-qtquick-controls-menuseparator.xml">MenuSeparator</db:link> consists of a visual <db:link xlink:href="qml-qtquick-controls-control.xml#background-prop">background</db:link> and <db:link xlink:href="qml-qtquick-controls-control.xml#contentItem-prop">content item</db:link>.</db:para>
</db:listitem>
</db:itemizedlist>
<db:mediaobject>
<db:imageobject>
<db:imagedata fileref="images/qtquickcontrols-menu-custom.png"/>
</db:imageobject>
</db:mediaobject>
<db:programlisting language="cpp">import QtQuick
import QtQuick.Controls

Menu {
    id: menu

    Action { text: qsTr(&quot;Tool Bar&quot;); checkable: true }
    Action { text: qsTr(&quot;Side Bar&quot;); checkable: true; checked: true }
    Action { text: qsTr(&quot;Status Bar&quot;); checkable: true; checked: true }

    MenuSeparator {
        contentItem: Rectangle {
            implicitWidth: 200
            implicitHeight: 1
            color: &quot;#21be2b&quot;
        }
    }

    Menu {
        title: qsTr(&quot;Advanced&quot;)
        // ...
    }

    topPadding: 2
    bottomPadding: 2

    delegate: MenuItem {
        id: menuItem
        implicitWidth: 200
        implicitHeight: 40

        arrow: Canvas {
            x: parent.width - width
            implicitWidth: 40
            implicitHeight: 40
            visible: menuItem.subMenu
            onPaint: {
                var ctx = getContext(&quot;2d&quot;)
                ctx.fillStyle = menuItem.highlighted ? &quot;#ffffff&quot; : &quot;#21be2b&quot;
                ctx.moveTo(15, 15)
                ctx.lineTo(width - 15, height / 2)
                ctx.lineTo(15, height - 15)
                ctx.closePath()
                ctx.fill()
            }
        }

        indicator: Item {
            implicitWidth: 40
            implicitHeight: 40
            Rectangle {
                width: 26
                height: 26
                anchors.centerIn: parent
                visible: menuItem.checkable
                border.color: &quot;#21be2b&quot;
                radius: 3
                Rectangle {
                    width: 14
                    height: 14
                    anchors.centerIn: parent
                    visible: menuItem.checked
                    color: &quot;#21be2b&quot;
                    radius: 2
                }
            }
        }

        contentItem: Text {
            leftPadding: menuItem.indicator.width
            rightPadding: menuItem.arrow.width
            text: menuItem.text
            font: menuItem.font
            opacity: enabled ? 1.0 : 0.3
            color: menuItem.highlighted ? &quot;#ffffff&quot; : &quot;#21be2b&quot;
            horizontalAlignment: Text.AlignLeft
            verticalAlignment: Text.AlignVCenter
            elide: Text.ElideRight
        }

        background: Rectangle {
            implicitWidth: 200
            implicitHeight: 40
            opacity: enabled ? 1 : 0.3
            color: menuItem.highlighted ? &quot;#21be2b&quot; : &quot;transparent&quot;
        }
    }

    background: Rectangle {
        implicitWidth: 200
        implicitHeight: 40
        color: &quot;#ffffff&quot;
        border.color: &quot;#21be2b&quot;
        radius: 2
    }
}
</db:programlisting>
</db:section>
<db:section xml:id="customizing-menubar">
<db:title>Customizing MenuBar</db:title>
<db:para><db:link xlink:href="qml-qtquick-controls-menubar.xml">MenuBar</db:link> can have a visual <db:link xlink:href="qml-qtquick-controls-control.xml#background-prop">background</db:link> item, and <db:link xlink:href="qml-qtquick-controls-menubaritem.xml">MenuBarItem</db:link> consists of two visual items: <db:link xlink:href="qml-qtquick-controls-control.xml#background-prop">background</db:link> and <db:link xlink:href="qml-qtquick-controls-control.xml#contentItem-prop">content item</db:link>.</db:para>
<db:mediaobject>
<db:imageobject>
<db:imagedata fileref="images/qtquickcontrols-menubar-custom.png"/>
</db:imageobject>
</db:mediaobject>
<db:programlisting language="cpp">import QtQuick
import QtQuick.Controls

MenuBar {
    id: menuBar

    Menu { title: qsTr(&quot;File&quot;) }
    Menu { title: qsTr(&quot;Edit&quot;) }
    Menu { title: qsTr(&quot;View&quot;) }
    Menu { title: qsTr(&quot;Help&quot;) }

    delegate: MenuBarItem {
        id: menuBarItem

        contentItem: Text {
            text: menuBarItem.text
            font: menuBarItem.font
            opacity: enabled ? 1.0 : 0.3
            color: menuBarItem.highlighted ? &quot;#ffffff&quot; : &quot;#21be2b&quot;
            horizontalAlignment: Text.AlignLeft
            verticalAlignment: Text.AlignVCenter
            elide: Text.ElideRight
        }

        background: Rectangle {
            implicitWidth: 40
            implicitHeight: 40
            opacity: enabled ? 1 : 0.3
            color: menuBarItem.highlighted ? &quot;#21be2b&quot; : &quot;transparent&quot;
        }
    }

    background: Rectangle {
        implicitWidth: 40
        implicitHeight: 40
        color: &quot;#ffffff&quot;

        Rectangle {
            color: &quot;#21be2b&quot;
            width: parent.width
            height: 1
            anchors.bottom: parent.bottom
        }
    }
}
</db:programlisting>
</db:section>
<db:section xml:id="customizing-pageindicator">
<db:title>Customizing PageIndicator</db:title>
<db:para><db:link xlink:href="qml-qtquick-controls-pageindicator.xml">PageIndicator</db:link> consists of a <db:link xlink:href="qml-qtquick-controls-control.xml#background-prop">background</db:link>, <db:link xlink:href="qml-qtquick-controls-control.xml#contentItem-prop">content item</db:link>, and <db:link xlink:href="qml-qtquick-controls-pageindicator.xml#delegate-prop">delegate</db:link>.</db:para>
<db:mediaobject>
<db:imageobject>
<db:imagedata fileref="images/qtquickcontrols-pageindicator-custom.png"/>
</db:imageobject>
</db:mediaobject>
<db:programlisting language="qml">import QtQuick
import QtQuick.Controls

PageIndicator {
    id: control
    count: 5
    currentIndex: 2

    delegate: Rectangle {
        implicitWidth: 8
        implicitHeight: 8

        radius: width / 2
        color: &quot;#21be2b&quot;

        opacity: index === control.currentIndex ? 0.95 : pressed ? 0.7 : 0.45

        required property int index

        Behavior on opacity {
            OpacityAnimator {
                duration: 100
            }
        }
    }
}
</db:programlisting>
</db:section>
<db:section xml:id="customizing-pane">
<db:title>Customizing Pane</db:title>
<db:para>Pane consists of a <db:link xlink:href="qml-qtquick-controls-control.xml#background-prop">background</db:link>.</db:para>
<db:mediaobject>
<db:imageobject>
<db:imagedata fileref="images/qtquickcontrols-pane-custom.png"/>
</db:imageobject>
</db:mediaobject>
<db:programlisting language="qml">import QtQuick
import QtQuick.Controls

Pane {
    background: Rectangle {
        color: &quot;#eeeeee&quot;
    }

    Label {
        text: qsTr(&quot;Content goes here!&quot;)
    }
}
</db:programlisting>
</db:section>
<db:section xml:id="customizing-popup">
<db:title>Customizing Popup</db:title>
<db:para>Popup consists of a <db:link xlink:href="qml-qtquick-controls-popup.xml#background-prop">background</db:link> and <db:link xlink:href="qml-qtquick-controls-popup.xml#contentItem-prop">content item</db:link>.</db:para>
<db:mediaobject>
<db:imageobject>
<db:imagedata fileref="images/qtquickcontrols-popup-custom.png"/>
</db:imageobject>
</db:mediaobject>
<db:programlisting language="cpp">import QtQuick
import QtQuick.Controls

Popup {
    id: popup
    background: Rectangle {
        implicitWidth: 200
        implicitHeight: 200
        border.color: &quot;#444&quot;
    }
    contentItem: Column {}
}
</db:programlisting>
</db:section>
<db:section xml:id="customizing-progressbar">
<db:title>Customizing ProgressBar</db:title>
<db:para><db:link xlink:href="qml-qtquick-controls-progressbar.xml">ProgressBar</db:link> consists of two visual items: <db:link xlink:href="qml-qtquick-controls-control.xml#background-prop">background</db:link> and <db:link xlink:href="qml-qtquick-controls-control.xml#contentItem-prop">content item</db:link>.</db:para>
<db:mediaobject>
<db:imageobject>
<db:imagedata fileref="images/qtquickcontrols-progressbar-custom.png"/>
</db:imageobject>
</db:mediaobject>
<db:programlisting language="qml">import QtQuick
import QtQuick.Controls

ProgressBar {
    id: control
    value: 0.5
    padding: 2

    background: Rectangle {
        implicitWidth: 200
        implicitHeight: 6
        color: &quot;#e6e6e6&quot;
        radius: 3
    }

    contentItem: Item {
        implicitWidth: 200
        implicitHeight: 4

        // Progress indicator for determinate state.
        Rectangle {
            width: control.visualPosition * parent.width
            height: parent.height
            radius: 2
            color: &quot;#17a81a&quot;
            visible: !control.indeterminate
        }

        // Scrolling animation for indeterminate state.
        Item {
            anchors.fill: parent
            visible: control.indeterminate
            clip: true

            Row {
                spacing: 20

                Repeater {
                    model: control.width / 40 + 1

                    Rectangle {
                        color: &quot;#17a81a&quot;
                        width: 20
                        height: control.height
                    }
                }
                XAnimator on x {
                    from: 0
                    to: -40
                    loops: Animation.Infinite
                    running: control.indeterminate
                }
            }
        }
    }
}
</db:programlisting>
<db:para>Above, the content item is also animated to represent an <db:link xlink:href="qml-qtquick-controls-progressbar.xml#indeterminate-prop">indeterminate</db:link> progress bar state.</db:para>
</db:section>
<db:section xml:id="customizing-radiobutton">
<db:title>Customizing RadioButton</db:title>
<db:para><db:link xlink:href="qml-qtquick-controls-radiobutton.xml">RadioButton</db:link> consists of three visual items: <db:link xlink:href="qml-qtquick-controls-control.xml#background-prop">background</db:link>, <db:link xlink:href="qml-qtquick-controls-control.xml#contentItem-prop">content item</db:link> and <db:link xlink:href="qml-qtquick-controls-abstractbutton.xml#indicator-prop">indicator</db:link>.</db:para>
<db:mediaobject>
<db:imageobject>
<db:imagedata fileref="images/qtquickcontrols-radiobutton-custom.png"/>
</db:imageobject>
</db:mediaobject>
<db:programlisting language="qml">import QtQuick
import QtQuick.Controls

RadioButton {
    id: control
    text: qsTr(&quot;RadioButton&quot;)
    checked: true

    indicator: Rectangle {
        implicitWidth: 26
        implicitHeight: 26
        x: control.leftPadding
        y: parent.height / 2 - height / 2
        radius: 13
        border.color: control.down ? &quot;#17a81a&quot; : &quot;#21be2b&quot;

        Rectangle {
            width: 14
            height: 14
            x: 6
            y: 6
            radius: 7
            color: control.down ? &quot;#17a81a&quot; : &quot;#21be2b&quot;
            visible: control.checked
        }
    }

    contentItem: Text {
        text: control.text
        font: control.font
        opacity: enabled ? 1.0 : 0.3
        color: control.down ? &quot;#17a81a&quot; : &quot;#21be2b&quot;
        verticalAlignment: Text.AlignVCenter
        leftPadding: control.indicator.width + control.spacing
    }
}
</db:programlisting>
</db:section>
<db:section xml:id="customizing-radiodelegate">
<db:title>Customizing RadioDelegate</db:title>
<db:para><db:link xlink:href="qml-qtquick-controls-radiodelegate.xml">RadioDelegate</db:link> consists of three visual items: <db:link xlink:href="qml-qtquick-controls-control.xml#background-prop">background</db:link>, <db:link xlink:href="qml-qtquick-controls-control.xml#contentItem-prop">contentItem</db:link> and <db:link xlink:href="qml-qtquick-controls-abstractbutton.xml#indicator-prop">indicator</db:link>.</db:para>
<db:mediaobject>
<db:imageobject>
<db:imagedata fileref="images/qtquickcontrols-radiodelegate-custom.png"/>
</db:imageobject>
</db:mediaobject>
<db:programlisting language="qml">import QtQuick
import QtQuick.Controls

RadioDelegate {
    id: control
    text: qsTr(&quot;RadioDelegate&quot;)
    checked: true

    contentItem: Text {
        rightPadding: control.indicator.width + control.spacing
        text: control.text
        font: control.font
        opacity: enabled ? 1.0 : 0.3
        color: control.down ? &quot;#17a81a&quot; : &quot;#21be2b&quot;
        elide: Text.ElideRight
        verticalAlignment: Text.AlignVCenter
    }

    indicator: Rectangle {
        implicitWidth: 26
        implicitHeight: 26
        x: control.width - width - control.rightPadding
        y: parent.height / 2 - height / 2
        radius: 13
        color: &quot;transparent&quot;
        border.color: control.down ? &quot;#17a81a&quot; : &quot;#21be2b&quot;

        Rectangle {
            width: 14
            height: 14
            x: 6
            y: 6
            radius: 7
            color: control.down ? &quot;#17a81a&quot; : &quot;#21be2b&quot;
            visible: control.checked
        }
    }

    background: Rectangle {
        implicitWidth: 100
        implicitHeight: 40
        visible: control.down || control.highlighted
        color: control.down ? &quot;#bdbebf&quot; : &quot;#eeeeee&quot;
    }
}
</db:programlisting>
</db:section>
<db:section xml:id="customizing-rangeslider">
<db:title>Customizing RangeSlider</db:title>
<db:para><db:link xlink:href="qml-qtquick-controls-rangeslider.xml">RangeSlider</db:link> consists of three visual items: <db:link xlink:href="qml-qtquick-controls-control.xml#background-prop">background</db:link>, <db:link xlink:href="qml-qtquick-controls-rangeslider.xml#first-prop">first.handle</db:link> and <db:link xlink:href="qml-qtquick-controls-rangeslider.xml#second.handle-prop">second.handle</db:link>.</db:para>
<db:mediaobject>
<db:imageobject>
<db:imagedata fileref="images/qtquickcontrols-rangeslider-custom.png"/>
</db:imageobject>
</db:mediaobject>
<db:programlisting language="qml">import QtQuick
import QtQuick.Controls

RangeSlider {
    id: control
    first.value: 0.25
    second.value: 0.75

    background: Rectangle {
        x: control.leftPadding
        y: control.topPadding + control.availableHeight / 2 - height / 2
        implicitWidth: 200
        implicitHeight: 4
        width: control.availableWidth
        height: implicitHeight
        radius: 2
        color: &quot;#bdbebf&quot;

        Rectangle {
            x: control.first.visualPosition * parent.width
            width: control.second.visualPosition * parent.width - x
            height: parent.height
            color: &quot;#21be2b&quot;
            radius: 2
        }
    }

    first.handle: Rectangle {
        x: control.leftPadding + control.first.visualPosition * (control.availableWidth - width)
        y: control.topPadding + control.availableHeight / 2 - height / 2
        implicitWidth: 26
        implicitHeight: 26
        radius: 13
        color: control.first.pressed ? &quot;#f0f0f0&quot; : &quot;#f6f6f6&quot;
        border.color: &quot;#bdbebf&quot;
    }

    second.handle: Rectangle {
        x: control.leftPadding + control.second.visualPosition * (control.availableWidth - width)
        y: control.topPadding + control.availableHeight / 2 - height / 2
        implicitWidth: 26
        implicitHeight: 26
        radius: 13
        color: control.second.pressed ? &quot;#f0f0f0&quot; : &quot;#f6f6f6&quot;
        border.color: &quot;#bdbebf&quot;
    }
}
</db:programlisting>
</db:section>
<db:section xml:id="customizing-roundbutton">
<db:title>Customizing RoundButton</db:title>
<db:para><db:link xlink:href="qml-qtquick-controls-roundbutton.xml">RoundButton</db:link> can be customized in the same manner as <db:link xlink:href="qtquickcontrols-customize.xml#customizing-button">Button</db:link>.</db:para>
</db:section>
<db:section xml:id="customizing-scrollbar">
<db:title>Customizing ScrollBar</db:title>
<db:para><db:link xlink:href="qml-qtquick-controls-scrollbar.xml">ScrollBar</db:link> consists of two visual items: <db:link xlink:href="qml-qtquick-controls-control.xml#background-prop">background</db:link> and <db:link xlink:href="qml-qtquick-controls-control.xml#contentItem-prop">content item</db:link>.</db:para>
<db:mediaobject>
<db:imageobject>
<db:imagedata fileref="images/qtquickcontrols-scrollbar-custom.png"/>
</db:imageobject>
</db:mediaobject>
<db:programlisting language="qml">import QtQuick
import QtQuick.Controls

ScrollBar {
    id: control
    size: 0.3
    position: 0.2
    active: true
    orientation: Qt.Vertical

    contentItem: Rectangle {
        implicitWidth: 6
        implicitHeight: 100
        radius: width / 2
        color: control.pressed ? &quot;#81e889&quot; : &quot;#c2f4c6&quot;
        // Hide the ScrollBar when it's not needed.
        opacity: control.policy === ScrollBar.AlwaysOn || (control.active &amp;amp;&amp;amp; control.size &amp;lt; 1.0) ? 0.75 : 0

        // Animate the changes in opacity (default duration is 250 ms).
        Behavior on opacity {
            NumberAnimation {}
        }
    }
}
</db:programlisting>
</db:section>
<db:section xml:id="customizing-scrollindicator">
<db:title>Customizing ScrollIndicator</db:title>
<db:para><db:link xlink:href="qml-qtquick-controls-scrollindicator.xml">ScrollIndicator</db:link> consists of two visual items: <db:link xlink:href="qml-qtquick-controls-control.xml#background-prop">background</db:link> and <db:link xlink:href="qml-qtquick-controls-control.xml#contentItem-prop">content item</db:link>.</db:para>
<db:mediaobject>
<db:imageobject>
<db:imagedata fileref="images/qtquickcontrols-scrollindicator-custom.png"/>
</db:imageobject>
</db:mediaobject>
<db:programlisting language="qml">import QtQuick
import QtQuick.Controls

ScrollIndicator {
    id: control
    size: 0.3
    position: 0.2
    active: true
    orientation: Qt.Vertical

    contentItem: Rectangle {
        implicitWidth: 2
        implicitHeight: 100
        color: &quot;#c2f4c6&quot;
    }
}
</db:programlisting>
</db:section>
<db:section xml:id="customizing-scrollview">
<db:title>Customizing ScrollView</db:title>
<db:para><db:link xlink:href="qml-qtquick-controls-scrollview.xml">ScrollView</db:link> consists of a <db:link xlink:href="qml-qtquick-controls-control.xml#background-prop">background</db:link> item, and horizontal and vertical scroll bars.</db:para>
<db:mediaobject>
<db:imageobject>
<db:imagedata fileref="images/qtquickcontrols-scrollview-custom.png"/>
</db:imageobject>
</db:mediaobject>
<db:programlisting language="qml">ScrollView {
    id: control

    width: 200
    height: 200
    focus: true

    Label {
        text: &quot;ABC&quot;
        font.pixelSize: 224
    }

    ScrollBar.vertical: ScrollBar {
        parent: control
        x: control.mirrored ? 0 : control.width - width
        y: control.topPadding
        height: control.availableHeight
        active: control.ScrollBar.horizontal.active
    }

    ScrollBar.horizontal: ScrollBar {
        parent: control
        x: control.leftPadding
        y: control.height - height
        width: control.availableWidth
        active: control.ScrollBar.vertical.active
    }

    background: Rectangle {
        border.color: control.activeFocus ? &quot;#21be2b&quot; : &quot;#bdbebf&quot;
    }
}
</db:programlisting>
</db:section>
<db:section xml:id="customizing-slider">
<db:title>Customizing Slider</db:title>
<db:para>Slider consists of two visual items: <db:link xlink:href="qml-qtquick-controls-control.xml#background-prop">background</db:link>, and <db:link xlink:href="qml-qtquick-controls-slider.xml#handle-prop">handle</db:link>.</db:para>
<db:mediaobject>
<db:imageobject>
<db:imagedata fileref="images/qtquickcontrols-slider-custom.png"/>
</db:imageobject>
</db:mediaobject>
<db:programlisting language="qml">import QtQuick
import QtQuick.Controls

Slider {
    id: control
    value: 0.5

    background: Rectangle {
        x: control.leftPadding
        y: control.topPadding + control.availableHeight / 2 - height / 2
        implicitWidth: 200
        implicitHeight: 4
        width: control.availableWidth
        height: implicitHeight
        radius: 2
        color: &quot;#bdbebf&quot;

        Rectangle {
            width: control.visualPosition * parent.width
            height: parent.height
            color: &quot;#21be2b&quot;
            radius: 2
        }
    }

    handle: Rectangle {
        x: control.leftPadding + control.visualPosition * (control.availableWidth - width)
        y: control.topPadding + control.availableHeight / 2 - height / 2
        implicitWidth: 26
        implicitHeight: 26
        radius: 13
        color: control.pressed ? &quot;#f0f0f0&quot; : &quot;#f6f6f6&quot;
        border.color: &quot;#bdbebf&quot;
    }
}
</db:programlisting>
</db:section>
<db:section xml:id="customizing-spinbox">
<db:title>Customizing SpinBox</db:title>
<db:para><db:link xlink:href="qml-qtquick-controls-spinbox.xml">SpinBox</db:link> consists of four visual items: <db:link xlink:href="qml-qtquick-controls-control.xml#background-prop">background</db:link>, <db:link xlink:href="qml-qtquick-controls-control.xml#contentItem-prop">contentItem</db:link>, <db:link xlink:href="qml-qtquick-controls-spinbox.xml#up.indicator-prop">up indicator</db:link>, and <db:link xlink:href="qml-qtquick-controls-spinbox.xml#down.indicator-prop">down indicator</db:link>.</db:para>
<db:mediaobject>
<db:imageobject>
<db:imagedata fileref="images/qtquickcontrols-spinbox-custom.png"/>
</db:imageobject>
</db:mediaobject>
<db:programlisting language="qml">import QtQuick
import QtQuick.Controls

SpinBox {
    id: control
    value: 50
    editable: true

    contentItem: TextInput {
        z: 2
        text: control.textFromValue(control.value, control.locale)

        font: control.font
        color: &quot;#21be2b&quot;
        selectionColor: &quot;#21be2b&quot;
        selectedTextColor: &quot;#ffffff&quot;
        horizontalAlignment: Qt.AlignHCenter
        verticalAlignment: Qt.AlignVCenter

        readOnly: !control.editable
        validator: control.validator
        inputMethodHints: Qt.ImhFormattedNumbersOnly
    }

    up.indicator: Rectangle {
        x: control.mirrored ? 0 : parent.width - width
        height: parent.height
        implicitWidth: 40
        implicitHeight: 40
        color: control.up.pressed ? &quot;#e4e4e4&quot; : &quot;#f6f6f6&quot;
        border.color: enabled ? &quot;#21be2b&quot; : &quot;#bdbebf&quot;

        Text {
            text: &quot;+&quot;
            font.pixelSize: control.font.pixelSize * 2
            color: &quot;#21be2b&quot;
            anchors.fill: parent
            fontSizeMode: Text.Fit
            horizontalAlignment: Text.AlignHCenter
            verticalAlignment: Text.AlignVCenter
        }
    }

    down.indicator: Rectangle {
        x: control.mirrored ? parent.width - width : 0
        height: parent.height
        implicitWidth: 40
        implicitHeight: 40
        color: control.down.pressed ? &quot;#e4e4e4&quot; : &quot;#f6f6f6&quot;
        border.color: enabled ? &quot;#21be2b&quot; : &quot;#bdbebf&quot;

        Text {
            text: &quot;-&quot;
            font.pixelSize: control.font.pixelSize * 2
            color: &quot;#21be2b&quot;
            anchors.fill: parent
            fontSizeMode: Text.Fit
            horizontalAlignment: Text.AlignHCenter
            verticalAlignment: Text.AlignVCenter
        }
    }

    background: Rectangle {
        implicitWidth: 140
        border.color: &quot;#bdbebf&quot;
    }
}
</db:programlisting>
</db:section>
<db:section xml:id="customizing-splitview">
<db:title>Customizing SplitView</db:title>
<db:para><db:link xlink:href="qml-qtquick-controls-splitview.xml">SplitView</db:link> consists of a visual <db:link xlink:href="qml-qtquick-controls-splitview.xml#handle-prop">handle</db:link> delegate.</db:para>
<db:mediaobject>
<db:imageobject>
<db:imagedata fileref="images/qtquickcontrols-splitview-custom.png"/>
</db:imageobject>
</db:mediaobject>
<db:programlisting language="qml">SplitView {
    id: splitView
    anchors.fill: parent

    handle: Rectangle {
        implicitWidth: 4
        implicitHeight: 4
        color: SplitHandle.pressed ? &quot;#81e889&quot;
            : (SplitHandle.hovered ? Qt.lighter(&quot;#c2f4c6&quot;, 1.1) : &quot;#c2f4c6&quot;)
    }

    Rectangle {
        implicitWidth: 150
        color: &quot;#444&quot;
    }
    Rectangle {
        implicitWidth: 50
        color: &quot;#666&quot;
    }
}
</db:programlisting>
</db:section>
<db:section xml:id="customizing-stackview">
<db:title>Customizing StackView</db:title>
<db:para><db:link xlink:href="qml-qtquick-controls-stackview.xml">StackView</db:link> can have a visual <db:link xlink:href="qml-qtquick-controls-control.xml#background-prop">background</db:link> item, and it allows customizing the transitions that are used for push, pop, and replace operations.</db:para>
<db:programlisting language="qml">import QtQuick
import QtQuick.Controls

StackView {
    id: control

    popEnter: Transition {
        XAnimator {
            from: (control.mirrored ? -1 : 1) * -control.width
            to: 0
            duration: 400
            easing.type: Easing.OutCubic
        }
    }

    popExit: Transition {
        XAnimator {
            from: 0
            to: (control.mirrored ? -1 : 1) * control.width
            duration: 400
            easing.type: Easing.OutCubic
        }
    }
}
</db:programlisting>
</db:section>
<db:section xml:id="customizing-swipedelegate">
<db:title>Customizing SwipeDelegate</db:title>
<db:para><db:link xlink:href="qml-qtquick-controls-swipedelegate.xml">SwipeDelegate</db:link> consists of six visual items: <db:link xlink:href="qml-qtquick-controls-control.xml#background-prop">background</db:link>, <db:link xlink:href="qml-qtquick-controls-control.xml#contentItem-prop">content item</db:link>, <db:link xlink:href="qml-qtquick-controls-abstractbutton.xml#indicator-prop">indicator</db:link>, <db:code>swipe.left</db:code>, <db:code>swipe.right</db:code>, and <db:code>swipe.behind</db:code>.</db:para>
<db:mediaobject>
<db:imageobject>
<db:imagedata fileref="images/qtquickcontrols-swipedelegate-custom.png"/>
</db:imageobject>
</db:mediaobject>
<db:programlisting language="qml">import QtQuick
import QtQuick.Controls

SwipeDelegate {
    id: control
    text: qsTr(&quot;SwipeDelegate&quot;)

    Component {
        id: component

        Rectangle {
            color: SwipeDelegate.pressed ? &quot;#333&quot; : &quot;#444&quot;
            width: parent.width
            height: parent.height
            clip: true

            Label {
                text: qsTr(&quot;Press me!&quot;)
                color: &quot;#21be2b&quot;
                anchors.centerIn: parent
            }
        }
    }

    swipe.left: component
    swipe.right: component

    contentItem: Text {
        text: control.text
        font: control.font
        color: control.enabled ? (control.down ? &quot;#17a81a&quot; : &quot;#21be2b&quot;) : &quot;#bdbebf&quot;
        elide: Text.ElideRight
        verticalAlignment: Text.AlignVCenter

        Behavior on x {
            enabled: !control.down
            NumberAnimation {
                easing.type: Easing.InOutCubic
                duration: 400
            }
        }
    }
}
</db:programlisting>
</db:section>
<db:section xml:id="customizing-swipeview">
<db:title>Customizing SwipeView</db:title>
<db:para><db:link xlink:href="qml-qtquick-controls-swipeview.xml">SwipeView</db:link> can have a visual <db:link xlink:href="qml-qtquick-controls-control.xml#background-prop">background</db:link> item. The navigation is implemented by the <db:link xlink:href="qml-qtquick-controls-control.xml#contentItem-prop">content item</db:link>.</db:para>
<db:programlisting language="qml">import QtQuick
import QtQuick.Controls

SwipeView {
    id: control

    background: Rectangle {
        color: &quot;#eeeeee&quot;
    }
}
</db:programlisting>
</db:section>
<db:section xml:id="customizing-switch">
<db:title>Customizing Switch</db:title>
<db:para>Switch consists of three visual items: <db:link xlink:href="qml-qtquick-controls-control.xml#background-prop">background</db:link>, <db:link xlink:href="qml-qtquick-controls-control.xml#contentItem-prop">content item</db:link> and <db:link xlink:href="qml-qtquick-controls-abstractbutton.xml#indicator-prop">indicator</db:link>.</db:para>
<db:mediaobject>
<db:imageobject>
<db:imagedata fileref="images/qtquickcontrols-switch-custom.png"/>
</db:imageobject>
</db:mediaobject>
<db:programlisting language="qml">import QtQuick
import QtQuick.Controls

Switch {
    id: control
    text: qsTr(&quot;Switch&quot;)

    indicator: Rectangle {
        implicitWidth: 48
        implicitHeight: 26
        x: control.leftPadding
        y: parent.height / 2 - height / 2
        radius: 13
        color: control.checked ? &quot;#17a81a&quot; : &quot;#ffffff&quot;
        border.color: control.checked ? &quot;#17a81a&quot; : &quot;#cccccc&quot;

        Rectangle {
            x: control.checked ? parent.width - width : 0
            width: 26
            height: 26
            radius: 13
            color: control.down ? &quot;#cccccc&quot; : &quot;#ffffff&quot;
            border.color: control.checked ? (control.down ? &quot;#17a81a&quot; : &quot;#21be2b&quot;) : &quot;#999999&quot;
        }
    }

    contentItem: Text {
        text: control.text
        font: control.font
        opacity: enabled ? 1.0 : 0.3
        color: control.down ? &quot;#17a81a&quot; : &quot;#21be2b&quot;
        verticalAlignment: Text.AlignVCenter
        leftPadding: control.indicator.width + control.spacing
    }
}
</db:programlisting>
</db:section>
<db:section xml:id="customizing-switchdelegate">
<db:title>Customizing SwitchDelegate</db:title>
<db:para><db:link xlink:href="qml-qtquick-controls-switchdelegate.xml">SwitchDelegate</db:link> consists of three visual items: <db:link xlink:href="qml-qtquick-controls-control.xml#background-prop">background</db:link>, <db:link xlink:href="qml-qtquick-controls-control.xml#contentItem-prop">contentItem</db:link> and <db:link xlink:href="qml-qtquick-controls-abstractbutton.xml#indicator-prop">indicator</db:link>.</db:para>
<db:mediaobject>
<db:imageobject>
<db:imagedata fileref="images/qtquickcontrols-switchdelegate-custom.png"/>
</db:imageobject>
</db:mediaobject>
<db:programlisting language="qml">import QtQuick
import QtQuick.Controls

SwitchDelegate {
    id: control
    text: qsTr(&quot;SwitchDelegate&quot;)
    checked: true

    contentItem: Text {
        rightPadding: control.indicator.width + control.spacing
        text: control.text
        font: control.font
        opacity: enabled ? 1.0 : 0.3
        color: control.down ? &quot;#17a81a&quot; : &quot;#21be2b&quot;
        elide: Text.ElideRight
        verticalAlignment: Text.AlignVCenter
    }

    indicator: Rectangle {
        implicitWidth: 48
        implicitHeight: 26
        x: control.width - width - control.rightPadding
        y: parent.height / 2 - height / 2
        radius: 13
        color: control.checked ? &quot;#17a81a&quot; : &quot;transparent&quot;
        border.color: control.checked ? &quot;#17a81a&quot; : &quot;#cccccc&quot;

        Rectangle {
            x: control.checked ? parent.width - width : 0
            width: 26
            height: 26
            radius: 13
            color: control.down ? &quot;#cccccc&quot; : &quot;#ffffff&quot;
            border.color: control.checked ? (control.down ? &quot;#17a81a&quot; : &quot;#21be2b&quot;) : &quot;#999999&quot;
        }
    }

    background: Rectangle {
        implicitWidth: 100
        implicitHeight: 40
        visible: control.down || control.highlighted
        color: control.down ? &quot;#bdbebf&quot; : &quot;#eeeeee&quot;
    }
}
</db:programlisting>
</db:section>
<db:section xml:id="customizing-tabbar">
<db:title>Customizing TabBar</db:title>
<db:para><db:link xlink:href="qml-qtquick-controls-tabbar.xml">TabBar</db:link> consists of two visual items: <db:link xlink:href="qml-qtquick-controls-control.xml#background-prop">background</db:link>, and <db:link xlink:href="qml-qtquick-controls-control.xml#contentItem-prop">contentItem</db:link>.</db:para>
<db:mediaobject>
<db:imageobject>
<db:imagedata fileref="images/qtquickcontrols-tabbar-custom.png"/>
</db:imageobject>
</db:mediaobject>
<db:programlisting language="qml">import QtQuick
import QtQuick.Controls

TabBar {
    id: control

    background: Rectangle {
        color: &quot;#eeeeee&quot;
    }

    TabButton {
        text: qsTr(&quot;Home&quot;)
    }
    TabButton {
        text: qsTr(&quot;Discover&quot;)
    }
    TabButton {
        text: qsTr(&quot;Activity&quot;)
    }
}
</db:programlisting>
</db:section>
<db:section xml:id="customizing-tabbutton">
<db:title>Customizing TabButton</db:title>
<db:para><db:link xlink:href="qml-qtquick-controls-tabbutton.xml">TabButton</db:link> can be customized in the same manner as <db:link xlink:href="qtquickcontrols-customize.xml#customizing-button">Button</db:link>.</db:para>
</db:section>
<db:section xml:id="customizing-textarea">
<db:title>Customizing TextArea</db:title>
<db:para><db:link xlink:href="qml-qtquick-controls-textarea.xml">TextArea</db:link> consists of a <db:link xlink:href="qml-qtquick-controls-textarea.xml#background-prop">background</db:link> item.</db:para>
<db:mediaobject>
<db:imageobject>
<db:imagedata fileref="images/qtquickcontrols-textarea-custom.png"/>
</db:imageobject>
</db:mediaobject>
<db:programlisting language="qml">import QtQuick
import QtQuick.Controls

TextArea {
    id: control
    placeholderText: qsTr(&quot;Enter description&quot;)

    background: Rectangle {
        implicitWidth: 200
        implicitHeight: 40
        border.color: control.enabled ? &quot;#21be2b&quot; : &quot;transparent&quot;
    }
}
</db:programlisting>
</db:section>
<db:section xml:id="customizing-textfield">
<db:title>Customizing TextField</db:title>
<db:para><db:link xlink:href="qml-qtquick-controls-textfield.xml">TextField</db:link> consists of a <db:link xlink:href="qml-qtquick-controls-textfield.xml#background-prop">background</db:link> item.</db:para>
<db:mediaobject>
<db:imageobject>
<db:imagedata fileref="images/qtquickcontrols-textfield-custom.png"/>
</db:imageobject>
</db:mediaobject>
<db:programlisting language="qml">import QtQuick
import QtQuick.Controls

TextField {
    id: control
    placeholderText: qsTr(&quot;Enter description&quot;)

    background: Rectangle {
        implicitWidth: 200
        implicitHeight: 40
        color: control.enabled ? &quot;transparent&quot; : &quot;#353637&quot;
        border.color: control.enabled ? &quot;#21be2b&quot; : &quot;transparent&quot;
    }
}
</db:programlisting>
</db:section>
<db:section xml:id="customizing-toolbar">
<db:title>Customizing ToolBar</db:title>
<db:para><db:link xlink:href="qml-qtquick-controls-toolbar.xml">ToolBar</db:link> consists of one visual item: <db:link xlink:href="qml-qtquick-controls-control.xml#background-prop">background</db:link>.</db:para>
<db:mediaobject>
<db:imageobject>
<db:imagedata fileref="images/qtquickcontrols-toolbar-custom.png"/>
</db:imageobject>
</db:mediaobject>
<db:programlisting language="qml">ToolBar {
    id: control

    background: Rectangle {
        implicitHeight: 40
        color: &quot;#eeeeee&quot;

        Rectangle {
            width: parent.width
            height: 1
            anchors.bottom: parent.bottom
            color: &quot;transparent&quot;
            border.color: &quot;#21be2b&quot;
        }
    }

    RowLayout {
        anchors.fill: parent
        ToolButton {
            text: qsTr(&quot;Undo&quot;)
        }
        ToolButton {
            text: qsTr(&quot;Redo&quot;)
        }
    }
}
</db:programlisting>
</db:section>
<db:section xml:id="customizing-toolbutton">
<db:title>Customizing ToolButton</db:title>
<db:para><db:link xlink:href="qml-qtquick-controls-toolbutton.xml">ToolButton</db:link> consists of two visual items: <db:link xlink:href="qml-qtquick-controls-control.xml#background-prop">background</db:link> and <db:link xlink:href="qml-qtquick-controls-control.xml#contentItem-prop">content item</db:link>.</db:para>
<db:mediaobject>
<db:imageobject>
<db:imagedata fileref="images/qtquickcontrols-toolbutton-custom.png"/>
</db:imageobject>
</db:mediaobject>
<db:programlisting language="qml">import QtQuick
import QtQuick.Controls

ToolButton {
    id: control
    text: qsTr(&quot;ToolButton&quot;)
    width: 120

    contentItem: Text {
        text: control.text
        font: control.font
        opacity: enabled ? 1.0 : 0.3
        color: control.down ? &quot;#17a81a&quot; : &quot;#21be2b&quot;
        horizontalAlignment: Text.AlignHCenter
        verticalAlignment: Text.AlignVCenter
        elide: Text.ElideRight
    }

    background: Rectangle {
        implicitWidth: 40
        implicitHeight: 40
        color: Qt.darker(&quot;#33333333&quot;, control.enabled &amp;amp;&amp;amp; (control.checked || control.highlighted) ? 1.5 : 1.0)
        opacity: enabled ? 1 : 0.3
        visible: control.down || (control.enabled &amp;amp;&amp;amp; (control.checked || control.highlighted))
    }
}
</db:programlisting>
</db:section>
<db:section xml:id="customizing-toolseparator">
<db:title>Customizing ToolSeparator</db:title>
<db:para><db:link xlink:href="qml-qtquick-controls-toolseparator.xml">ToolSeparator</db:link> consists of two visual items: <db:link xlink:href="qml-qtquick-controls-control.xml#background-prop">background</db:link> and <db:link xlink:href="qml-qtquick-controls-control.xml#contentItem-prop">content item</db:link>.</db:para>
<db:mediaobject>
<db:imageobject>
<db:imagedata fileref="images/qtquickcontrols-toolseparator-custom.png"/>
</db:imageobject>
</db:mediaobject>
<db:programlisting language="qml">ToolBar {
    RowLayout {
        anchors.fill: parent

        ToolButton {
            text: qsTr(&quot;Action 1&quot;)
        }
        ToolButton {
            text: qsTr(&quot;Action 2&quot;)
        }

        ToolSeparator {
            padding: vertical ? 10 : 2
            topPadding: vertical ? 2 : 10
            bottomPadding: vertical ? 2 : 10

            contentItem: Rectangle {
                implicitWidth: parent.vertical ? 1 : 24
                implicitHeight: parent.vertical ? 24 : 1
                color: &quot;#c3c3c3&quot;
            }
        }

        ToolButton {
            text: qsTr(&quot;Action 3&quot;)
        }
        ToolButton {
            text: qsTr(&quot;Action 4&quot;)
        }

        Item {
            Layout.fillWidth: true
        }
    }
}
</db:programlisting>
</db:section>
<db:section xml:id="customizing-tooltip">
<db:title>Customizing ToolTip</db:title>
<db:para><db:link xlink:href="qml-qtquick-controls-tooltip.xml">ToolTip</db:link> consists of two visual items: <db:link xlink:href="qml-qtquick-controls-popup.xml#background-prop">background</db:link> and <db:link xlink:href="qml-qtquick-controls-popup.xml#contentItem-prop">content item</db:link>.</db:para>
<db:programlisting language="cpp">import QtQuick
import QtQuick.Controls

ToolTip {
    id: control
    text: qsTr(&quot;A descriptive tool tip of what the button does&quot;)

    contentItem: Text {
        text: control.text
        font: control.font
        color: &quot;#21be2b&quot;
    }

    background: Rectangle {
        border.color: &quot;#21be2b&quot;
    }
}
</db:programlisting>
<db:note>
<db:para>to customize the <db:link xlink:href="qml-qtquick-controls-tooltip.xml#attached-tool-tips">attached ToolTip</db:link>, it must be provided as part of <db:link xlink:href="qtquickcontrols-customize.xml#creating-a-custom-style">your own style</db:link>. To do a one-off customization of a <db:code>ToolTip</db:code>, see <db:link xlink:href="qml-qtquick-controls-tooltip.xml#custom-tool-tips">Custom Tool Tips</db:link>.</db:para>
</db:note>
</db:section>
<db:section xml:id="customizing-tumbler">
<db:title>Customizing Tumbler</db:title>
<db:para>Tumbler consists of three visual items: <db:link xlink:href="qml-qtquick-controls-control.xml#background-prop">background</db:link>, <db:link xlink:href="qml-qtquick-controls-control.xml#contentItem-prop">contentItem</db:link>, and <db:link xlink:href="qml-qtquick-controls-tumbler.xml#delegate-prop">delegate</db:link>.</db:para>
<db:mediaobject>
<db:imageobject>
<db:imagedata fileref="images/qtquickcontrols-tumbler-custom.png"/>
</db:imageobject>
</db:mediaobject>
<db:programlisting language="qml">import QtQuick
import QtQuick.Controls

Tumbler {
    id: control
    model: 15

    background: Item {
        Rectangle {
            opacity: control.enabled ? 0.2 : 0.1
            border.color: &quot;#000000&quot;
            width: parent.width
            height: 1
            anchors.top: parent.top
        }

        Rectangle {
            opacity: control.enabled ? 0.2 : 0.1
            border.color: &quot;#000000&quot;
            width: parent.width
            height: 1
            anchors.bottom: parent.bottom
        }
    }

    delegate: Text {
        text: qsTr(&quot;Item %1&quot;).arg(modelData + 1)
        font: control.font
        horizontalAlignment: Text.AlignHCenter
        verticalAlignment: Text.AlignVCenter
        opacity: 1.0 - Math.abs(Tumbler.displacement) / (control.visibleItemCount / 2)

        required property var modelData
        required property int index
    }

    Rectangle {
        anchors.horizontalCenter: control.horizontalCenter
        y: control.height * 0.4
        width: 40
        height: 1
        color: &quot;#21be2b&quot;
    }

    Rectangle {
        anchors.horizontalCenter: control.horizontalCenter
        y: control.height * 0.6
        width: 40
        height: 1
        color: &quot;#21be2b&quot;
    }
}
</db:programlisting>
<db:para>If you want to define your own contentItem, use either a <db:link xlink:href="qml-qtquick-listview.xml">ListView</db:link> or <db:link xlink:href="qml-qtquick-pathview.xml">PathView</db:link> as the root item. For a wrapping Tumbler, use <db:link xlink:href="qml-qtquick-pathview.xml">PathView</db:link>:</db:para>
<db:programlisting language="qml">Tumbler {
    id: tumbler

    contentItem: PathView {
        id: pathView
        model: tumbler.model
        delegate: tumbler.delegate
        clip: true
        pathItemCount: tumbler.visibleItemCount + 1
        preferredHighlightBegin: 0.5
        preferredHighlightEnd: 0.5
        dragMargin: width / 2

        path: Path {
            startX: pathView.width / 2
            startY: -pathView.delegateHeight / 2
            PathLine {
                x: pathView.width / 2
                y: pathView.pathItemCount * pathView.delegateHeight - pathView.delegateHeight / 2
            }
        }

        property real delegateHeight: tumbler.availableHeight / tumbler.visibleItemCount
    }
}
</db:programlisting>
<db:para>For a non-wrapping Tumbler, use <db:link xlink:href="qml-qtquick-listview.xml">ListView</db:link>:</db:para>
<db:programlisting language="qml">Tumbler {
    id: tumbler

    contentItem: ListView {
        model: tumbler.model
        delegate: tumbler.delegate

        snapMode: ListView.SnapToItem
        highlightRangeMode: ListView.StrictlyEnforceRange
        preferredHighlightBegin: height / 2 - (height / tumbler.visibleItemCount / 2)
        preferredHighlightEnd: height / 2 + (height / tumbler.visibleItemCount / 2)
        clip: true
    }
}
</db:programlisting>
</db:section>
</db:section>
</db:article>
