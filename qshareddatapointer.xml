<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en">
<db:info>
<db:title>QSharedDataPointer Class</db:title>
<db:subtitle>template &lt;typename T&gt; class QSharedDataPointer</db:subtitle>
<db:productname>QtCore</db:productname>
<db:edition>Qt 5.4.2 Reference Documentation</db:edition>
<db:titleabbrev>Qt Core Reference Documentation</db:titleabbrev>
<db:abstract>
<db:para>The <db:link xlink:href="qshareddatapointer.xml">QSharedDataPointer</db:link> class represents a pointer to an implicitly shared object.</db:para>
<db:para>This class was introduced in Qt 4.0.</db:para>
<db:note>
<db:para>All functions in this class are reentrant.</db:para>
</db:note>
</db:abstract>
<db:pubdate>2025-06-29</db:pubdate>
<db:date>2025-06-29</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:variablelist>
<db:varlistentry>
<db:term>Header</db:term>
<db:listitem>
<db:para>QSharedDataPointer</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Since</db:term>
<db:listitem>
<db:para>Qt 4.0</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>qmake</db:term>
<db:listitem>
<db:para>QT += core</db:para>
</db:listitem>
</db:varlistentry>
</db:variablelist>
<db:section xml:id="details">
<db:title>Detailed Description</db:title>
<db:para><db:link xlink:href="qshareddatapointer.xml">QSharedDataPointer</db:link>&lt;T&gt; makes writing your own <db:link xlink:href="implicit-sharing.xml">implicitly shared</db:link> classes easy. <db:link xlink:href="qshareddatapointer.xml">QSharedDataPointer</db:link> implements <db:link xlink:href="">thread-safe</db:link> reference counting, ensuring that adding QSharedDataPointers to your reentrant classes won't make them non-reentrant.</db:para>
<db:para><db:link xlink:href="implicit-sharing.xml">Implicit sharing</db:link> is used by many Qt classes to combine the speed and memory efficiency of pointers with the ease of use of classes. See the <db:link xlink:href="implicit-sharing.xml">Shared Classes</db:link> page for more information.</db:para>
<db:anchor xml:id="employee-example"/>
<db:para>Suppose you want to make an Employee class implicitly shared. The procedure is:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para>Define the class Employee to have a single data member of type QSharedDataPointer&lt;EmployeeData&gt;.</db:para>
</db:listitem>
<db:listitem>
<db:para>Define the EmployeeData class derived from <db:link xlink:href="qshareddata.xml">QSharedData</db:link> to contain all the data members you would normally have put in the Employee class.</db:para>
</db:listitem>
</db:itemizedlist>
<db:para>To show this in practice, we review the source code for the implicitly shared Employee class. In the header file we define the two classes Employee and EmployeeData.</db:para>
<db:programlisting language="cpp">#include &lt;QSharedData&gt;
#include &lt;QString&gt;

class EmployeeData : public QSharedData
{
  public:
    EmployeeData() : id(-1) { }
    EmployeeData(const EmployeeData &amp;other)
        : QSharedData(other), id(other.id), name(other.name) { }
    ~EmployeeData() { }

    int id;
    QString name;
};

class Employee
{
  public:
    Employee() { d = new EmployeeData; }
    Employee(int id, QString name) {
        d = new EmployeeData;
        setId(id);
        setName(name);
    }
    Employee(const Employee &amp;other)
          : d (other.d)
    {
    }
    void setId(int id) { d-&gt;id = id; }
    void setName(QString name) { d-&gt;name = name; }

    int id() const { return d-&gt;id; }
    QString name() const { return d-&gt;name; }

  private:
    QSharedDataPointer&lt;EmployeeData&gt; d;
};
</db:programlisting>
<db:para>In class Employee, note the single data member, a <db:emphasis>d pointer</db:emphasis> of type QSharedDataPointer&lt;EmployeeData&gt;. All accesses of employee data must go through the <db:emphasis>d pointer's</db:emphasis> operator-&gt;(). For write accesses, operator-&gt;() will automatically call detach(), which creates a copy of the shared data object if the shared data object's reference count is greater than 1. This ensures that writes to one Employee object don't affect any other Employee objects that share the same EmployeeData object.</db:para>
<db:para>Class EmployeeData inherits <db:link xlink:href="qshareddata.xml">QSharedData</db:link>, which provides the <db:emphasis>behind the scenes</db:emphasis> reference counter. EmployeeData has a default constructor, a copy constructor, and a destructor. Normally, trivial implementations of these are all that is needed in the <db:emphasis>data</db:emphasis> class for an implicitly shared class.</db:para>
<db:para>Implementing the two constructors for class Employee is also straightforward. Both create a new instance of EmployeeData and assign it to the <db:emphasis>d pointer</db:emphasis> .</db:para>
<db:programlisting language="cpp">    Employee() { d = new EmployeeData; }

    Employee(int id, QString name) {
        d = new EmployeeData;
        setId(id);
        setName(name);
    }
</db:programlisting>
<db:para>Note that class Employee also has a trivial copy constructor defined, which is not strictly required in this case.</db:para>
<db:programlisting language="cpp">    Employee(const Employee &amp;other)
          : d (other.d)
    {
    }
</db:programlisting>
<db:para>The copy constructor is not strictly required here, because class EmployeeData is included in the same file as class Employee (employee.h). However, including the private subclass of <db:link xlink:href="qshareddata.xml">QSharedData</db:link> in the same file as the public class containing the <db:link xlink:href="qshareddatapointer.xml">QSharedDataPointer</db:link> is not typical. Normally, the idea is to hide the private subclass of <db:link xlink:href="qshareddata.xml">QSharedData</db:link> from the user by putting it in a separate file which would not be included in the public file. In this case, we would normally put class EmployeeData in a separate file, which would <db:emphasis>not</db:emphasis> be included in employee.h. Instead, we would just predeclare the private subclass EmployeeData in employee.h this way:</db:para>
<db:programlisting language="cpp">class EmployeeData;
</db:programlisting>
<db:para>If we had done it that way here, the copy constructor shown would be required. Since the copy constructor is trivial, you might as well just always include it.</db:para>
<db:para>Behind the scenes, <db:link xlink:href="qshareddatapointer.xml">QSharedDataPointer</db:link> automatically increments the reference count whenever an Employee object is copied, assigned, or passed as a parameter. It decrements the reference count whenever an Employee object is deleted or goes out of scope. The shared EmployeeData object is deleted automatically if and when the reference count reaches 0.</db:para>
<db:para>In a non-const member function of Employee, whenever the <db:emphasis>d pointer</db:emphasis> is dereferenced, <db:link xlink:href="qshareddatapointer.xml">QSharedDataPointer</db:link> automatically calls detach() to ensure that the function operates on its own copy of the data.</db:para>
<db:programlisting language="cpp">    void setId(int id) { d-&gt;id = id; }

    void setName(QString name) { d-&gt;name = name; }
</db:programlisting>
<db:para>Note that if detach() is called more than once in a member function due to multiple dereferences of the <db:emphasis>d pointer</db:emphasis>, detach() will only create a copy of the shared data the first time it is called, if at all, because on the second and subsequent calls of detach(), the reference count will be 1 again.</db:para>
<db:para>But note that in the second Employee constructor, which takes an employee ID and a name, both setId() and setName() are called, but they don't cause <db:emphasis>copy on write</db:emphasis>, because the reference count for the newly constructed EmployeeData object has just been set to 1.</db:para>
<db:para>In Employee's <db:emphasis>const</db:emphasis> member functions, dereferencing the <db:emphasis>d pointer</db:emphasis> does <db:emphasis>not</db:emphasis> cause detach() to be called.</db:para>
<db:programlisting language="cpp">    int id() const { return d-&gt;id; }

    QString name() const { return d-&gt;name; }
</db:programlisting>
<db:para>Notice that there is no need to implement a copy constructor or an assignment operator for the Employee class, because the copy constructor and assignment operator provided by the C++ compiler will do the <db:emphasis>member by member</db:emphasis> shallow copy required. The only member to copy is the <db:emphasis>d pointer</db:emphasis>, which is a <db:link xlink:href="qshareddatapointer.xml">QSharedDataPointer</db:link>, whose operator=() just increments the reference count of the shared EmployeeData object.</db:para>
<db:section xml:id="implicit-vs-explicit-sharing">
<db:title>Implicit vs Explicit Sharing</db:title>
<db:para>Implicit sharing might not be right for the Employee class. Consider a simple example that creates two instances of the implicitly shared Employee class.</db:para>
<db:programlisting language="cpp">#include &quot;employee.h&quot;

int main()
{
    Employee e1(1001, &quot;Albrecht Durer&quot;);
    Employee e2 = e1;
    e1.setName(&quot;Hans Holbein&quot;);
}
</db:programlisting>
<db:para>After the second employee e2 is created and e1 is assigned to it, both e1 and e2 refer to Albrecht Durer, employee 1001. Both Employee objects point to the same instance of EmployeeData, which has reference count 2. Then e1.setName(&quot;Hans Holbein&quot;) is called to change the employee name, but because the reference count is greater than 1, a <db:emphasis>copy on write</db:emphasis> is performed before the name is changed. Now e1 and e2 point to different EmployeeData objects. They have different names, but both have ID 1001, which is probably not what you want. You can, of course, just continue with e1.setId(1002), if you really mean to create a second, unique employee, but if you only want to change the employee's name everywhere, consider using <db:link xlink:href="qexplicitlyshareddatapointer.xml">explicit sharing</db:link> in the Employee class instead of implicit sharing.</db:para>
<db:para>If you declare the <db:emphasis>d pointer</db:emphasis> in the Employee class to be QExplicitlySharedDataPointer&lt;EmployeeData&gt;, then explicit sharing is used and <db:emphasis>copy on write</db:emphasis> operations are not performed automatically (i.e. detach() is not called in non-const functions). In that case, after e1.setName(&quot;Hans Holbein&quot;), the employee's name has been changed, but both e1 and e2 still refer to the same instance of EmployeeData, so there is only one employee with ID 1001.</db:para>
<db:para>In the member function documentation, <db:emphasis>d pointer</db:emphasis> always refers to the internal pointer to the shared data object.</db:para>
</db:section>
<db:section xml:id="optimize-performance-for-usage-in-qt-containers">
<db:title>Optimize Performance for Usage in Qt Containers</db:title>
<db:para>You should consider marking your implicitly shared class as a movable type using the <db:link xlink:href="qtglobal.xml#Q_DECLARE_TYPEINFO">Q_DECLARE_TYPEINFO</db:link>() macro if it resembles the Employee class above and uses a <db:link xlink:href="qshareddatapointer.xml">QSharedDataPointer</db:link> or <db:link xlink:href="qexplicitlyshareddatapointer.xml">QExplicitlySharedDataPointer</db:link> as the only member. This can improve performance and memory efficiency when using Qt's <db:link xlink:href="containers.xml">container classes</db:link>.</db:para>
</db:section>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qshareddata.xml">QSharedData</db:link></db:member>
<db:member><db:link xlink:href="qexplicitlyshareddatapointer.xml">QExplicitlySharedDataPointer</db:link></db:member>
<db:member><db:link xlink:href="qscopedpointer.xml">QScopedPointer</db:link></db:member>
<db:member><db:link xlink:href="qsharedpointer.xml">QSharedPointer</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="member-type-documentation">
<db:title>Member Type Documentation</db:title>
<db:section xml:id="Type-typedef">
<db:title>QSharedDataPointer::Type</db:title>
<db:para>This is the type of the shared data object. The <db:emphasis>d pointer</db:emphasis> points to an object of this type.</db:para>
</db:section>
</db:section>
</db:article>
