<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en">
<db:info>
<db:title>Vector Image Example</db:title>
<db:productname>QtQuick</db:productname>
<db:edition>Qt 6.9.1 Reference Documentation</db:edition>
<db:titleabbrev>Qt Quick Reference Documentation</db:titleabbrev>
<db:abstract>
<db:para>A Qt Quick example demonstrating the differences of <db:link xlink:href="">Qt SVG</db:link>, <db:link xlink:href="qml-qtquick-vectorimage-vectorimage.xml">VectorImage</db:link> and <db:link xlink:href="qtqml-tooling-svgtoqml.xml">svgtoqml</db:link>.</db:para>
</db:abstract>
<db:pubdate>2025-06-29</db:pubdate>
<db:date>2025-06-29</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:mediaobject>
<db:imageobject>
<db:imagedata fileref="images/qml-vectorimage-example.png"/>
</db:imageobject>
</db:mediaobject>
<db:para>There are several different ways you can include two-dimensional vector graphics in your Qt application. This example focuses on the <db:code>SVG</db:code> format and how this can be used with Qt. As a baseline, Qt supports the static features of the <db:code>SVG Tiny 1.2</db:code> profile. In addition, <db:link xlink:href="">Qt SVG</db:link> optionally supports some features from the full profile, but those are not used in this example.</db:para>
<db:para>The example shows a grid of 3x3 cells, each containing the same vector image of a heart. The heart image is provided as an <db:code>SVG</db:code> file with the example.</db:para>
<db:para>In the grid, each row shows the image at a different scale factor (1x, 2.5x and 4x respectively).</db:para>
<db:para>Each column represents a different way to render the vector graphics in Qt. The left-most column is an <db:link xlink:href="qml-qtquick-image.xml">Image</db:link> component, the center column is a <db:link xlink:href="qml-qtquick-vectorimage-vectorimage.xml">VectorImage</db:link> component and the right-most column is a pregenerated <db:code>QML</db:code> representation created using the <db:link xlink:href="qtqml-tooling-svgtoqml.xml">svgtoqml</db:link> tool.</db:para>
<db:para>Each method of rendering the vector graphics has its own benefits and drawbacks, and caters to different use cases. To make an informed decision about which one to use, it can be useful to understand the details of how they differ.</db:para>
<db:section xml:id="the-image-component-and-qt-svg">
<db:title>The <db:link xlink:href="qml-qtquick-image.xml">Image</db:link> component and <db:link xlink:href="">Qt SVG</db:link></db:title>
<db:para>When you use the <db:link xlink:href="qml-qtquick-image.xml">Image</db:link> element and set an <db:code>SVG</db:code> file as source, this will invoke the image format plugin in <db:link xlink:href="">Qt SVG</db:link>. The plugin will parse the <db:code>SVG</db:code> file, rasterize it using the software rasterizer in <db:link xlink:href="qpainter.xml">QPainter</db:link> and then provide it to Qt Quick as a pixmap image. This is equivalent to using the QSvgRenderer class to draw the image.</db:para>
<db:programlisting language="qml">        Image {
            sourceSize: Qt.size(topLevel.sourceSize, topLevel.sourceSize)
            source: &quot;heart.svg&quot;
        }
</db:programlisting>
<db:para>Since the vector image is rasterized at a specific size, any transformation we apply to the <db:link xlink:href="qml-qtquick-image.xml">Image</db:link> will be applied to the <db:emphasis>rasterized image</db:emphasis>. This can result in pixelation artifacts and uneven curves.</db:para>
<db:para>Loading a vector image through <db:link xlink:href="qml-qtquick-image.xml">Image</db:link> works best if you request the image at the exact size that you intend to display. When the <db:link xlink:href="qml-qtquick-image.xml">Image</db:link> is displayed at a 1x scale in the top-most row, it looks identical to the others, but at higher scale factors it starts to look fuzzy.</db:para>
<db:para>If the image will ever only be displayed with a single size, then this will typically be the most performant option. There is a start-up cost for rasterizing the image at the specified size, but after this, the cost of copying the data onto the screen is very low.</db:para>
<db:para>But as the image is requested at multiple different sizes, the start-up cost will grow, as will the accumulated memory consumption. Animated zooms of the image can often get too expensive to run at full frame rate on lower end devices. These are the use cases for which <db:link xlink:href="qml-qtquick-vectorimage-vectorimage.xml">VectorImage</db:link> and <db:link xlink:href="qtqml-tooling-svgtoqml.xml">svgtoqml</db:link> should be considered.</db:para>
</db:section>
<db:section xml:id="the-vectorimage-component">
<db:title>The <db:link xlink:href="qml-qtquick-vectorimage-vectorimage.xml">VectorImage</db:link> component</db:title>
<db:para>As an alternative to <db:link xlink:href="qml-qtquick-image.xml">Image</db:link>, Qt provides the <db:link xlink:href="qml-qtquick-vectorimage-vectorimage.xml">VectorImage</db:link> component. This converts the <db:code>SVG</db:code> image to a vector graphics representation in Qt Quick, and rasterization happens on demand, on the graphics HW, as it is rendered to the screen.</db:para>
<db:programlisting language="qml">        VectorImage {
            width: topLevel.sourceSize
            height: topLevel.sourceSize
            preferredRendererType: VectorImage.CurveRenderer
            source: &quot;heart.svg&quot;
        }
</db:programlisting>
<db:para>Since the image is not pre-rasterized, we can apply transformations to it without losing fidelity to the original shapes. Note that the example uses the <db:code>VectorImage.CurveRenderer</db:code> renderer type. This is recommended for use cases where the image will be transformed and antialiasing is needed.</db:para>
<db:para>This means that we can display the image at any size and even animate the scale of the image, and all the work will be done by the graphics hardware. However, when the <db:link xlink:href="qml-qtquick-vectorimage-vectorimage.xml">VectorImage</db:link> is rendered onto the screen, it will come at a slightly higher cost than rendering an <db:link xlink:href="qml-qtquick-image.xml">Image</db:link>. This is because the rasterization of curves happens every time the component is rendered and not ahead of time.</db:para>
<db:para>Therefore, <db:link xlink:href="qml-qtquick-vectorimage-vectorimage.xml">VectorImage</db:link> is most suitable for vector graphics where the size will change frequently. It can also be suitable when the destination size of the image is very large and memory consumption is a concern. When using <db:link xlink:href="qml-qtquick-image.xml">Image</db:link>, the full rasterized image has to be stored in graphics memory. Thus, the memory consumption will scale with the size of the image. The memory consumed by <db:link xlink:href="qml-qtquick-vectorimage-vectorimage.xml">VectorImage</db:link> will be the same, regardless of the destination size it is rendered at.</db:para>
</db:section>
<db:section xml:id="the-svgtoqml-tool">
<db:title>The <db:link xlink:href="qtqml-tooling-svgtoqml.xml">svgtoqml</db:link> tool</db:title>
<db:para>The <db:link xlink:href="qml-qtquick-vectorimage-vectorimage.xml">VectorImage</db:link> component parses the <db:code>SVG</db:code> file and builds up an equivalent scene of Qt Quick items at run-time.</db:para>
<db:para>If the <db:code>SVG</db:code> is part of the application assets, then some of the work can be done ahead of time instead, by using the <db:link xlink:href="qtqml-tooling-svgtoqml.xml">svgtoqml</db:link> tool. This tool produces the same scene as <db:link xlink:href="qml-qtquick-vectorimage-vectorimage.xml">VectorImage</db:link>, but instead of building it at run-time, it creates a <db:code>QML</db:code> file which can be included in the application project.</db:para>
<db:para>In this example, the <db:code>heart.svg</db:code> file has been pre-converted to a file called <db:code>Heart.qml</db:code>. This can be instantiated in the scene as any other Qt Quick item.</db:para>
<db:programlisting language="qml">        Heart {
            width: topLevel.sourceSize
            height: topLevel.sourceSize
        }
</db:programlisting>
<db:para>By using this approach, we do not need to parse the <db:code>SVG</db:code> file every time the application is started. In addition, the <db:code>svgtoqml</db:code> tool can optimize and analyze the shapes, in order to provide the renderer with hints that will further speed up its run-time processing.</db:para>
<db:para>The <db:link xlink:href="qtqml-tooling-svgtoqml.xml">svgtoqml</db:link> tool should be considered for the same use cases as <db:link xlink:href="qml-qtquick-vectorimage-vectorimage.xml">VectorImage</db:link> and should be preferred whenever the <db:code>SVG</db:code> file is available as an asset when the application is built and is not provided by the end-user of the application.</db:para>
</db:section>
<db:section>
<db:title>Example project</db:title>
<db:para><db:link xlink:href="https://code.qt.io/cgit/qt/qtdeclarative.git/tree/examples/quick/vectorimage?h=6.9">Example project @ code.qt.io</db:link></db:para>
</db:section>
</db:article>
