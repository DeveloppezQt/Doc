<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en">
<db:info>
<db:title>QBuffer Class</db:title>
<db:productname>QtCore</db:productname>
<db:edition>Qt 5.4.2 Reference Documentation</db:edition>
<db:titleabbrev>Qt Core Reference Documentation</db:titleabbrev>
<db:abstract>
<db:para>The <db:link xlink:href="qbuffer.xml">QBuffer</db:link> class provides a <db:link xlink:href="qiodevice.xml">QIODevice</db:link> interface for a <db:link xlink:href="qbytearray.xml">QByteArray</db:link>.</db:para>
<db:note>
<db:para>All functions in this class are reentrant.</db:para>
</db:note>
</db:abstract>
<db:pubdate>2025-06-29</db:pubdate>
<db:date>2025-06-29</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:variablelist>
<db:varlistentry>
<db:term>Header</db:term>
<db:listitem>
<db:para>QBuffer</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>qmake</db:term>
<db:listitem>
<db:para>QT += core</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Group</db:term>
<db:listitem>
<db:para>QBuffer is part of <db:simplelist><db:member><db:link xlink:href="io.xml">Input/Output and Networking</db:link></db:member></db:simplelist>
</db:para>
</db:listitem>
</db:varlistentry>
</db:variablelist>
<db:section xml:id="details">
<db:title>Detailed Description</db:title>
<db:para><db:link xlink:href="qbuffer.xml">QBuffer</db:link> allows you to access a <db:link xlink:href="qbytearray.xml">QByteArray</db:link> using the <db:link xlink:href="qiodevice.xml">QIODevice</db:link> interface. The <db:link xlink:href="qbytearray.xml">QByteArray</db:link> is treated just as a standard random-accessed file. Example:</db:para>
<db:programlisting language="cpp">    QBuffer buffer;
    char ch;

    buffer.open(QBuffer::ReadWrite);
    buffer.write(&quot;Qt rocks!&quot;);
    buffer.seek(0);
    buffer.getChar(&amp;ch);  // ch == 'Q'
    buffer.getChar(&amp;ch);  // ch == 't'
    buffer.getChar(&amp;ch);  // ch == ' '
    buffer.getChar(&amp;ch);  // ch == 'r'
</db:programlisting>
<db:para>By default, an internal <db:link xlink:href="qbytearray.xml">QByteArray</db:link> buffer is created for you when you create a <db:link xlink:href="qbuffer.xml">QBuffer</db:link>. You can access this buffer directly by calling buffer(). You can also use <db:link xlink:href="qbuffer.xml">QBuffer</db:link> with an existing <db:link xlink:href="qbytearray.xml">QByteArray</db:link> by calling setBuffer(), or by passing your array to <db:link xlink:href="qbuffer.xml">QBuffer</db:link>'s constructor.</db:para>
<db:para>Call open() to open the buffer. Then call write() or putChar() to write to the buffer, and read(), readLine(), readAll(), or getChar() to read from it. size() returns the current size of the buffer, and you can seek to arbitrary positions in the buffer by calling seek(). When you are done with accessing the buffer, call close().</db:para>
<db:para>The following code snippet shows how to write data to a <db:link xlink:href="qbytearray.xml">QByteArray</db:link> using <db:link xlink:href="qdatastream.xml">QDataStream</db:link> and <db:link xlink:href="qbuffer.xml">QBuffer</db:link>:</db:para>
<db:programlisting language="cpp">    QByteArray byteArray;
    QBuffer buffer(&amp;byteArray);
    buffer.open(QIODevice::WriteOnly);

    QDataStream out(&amp;buffer);
    out &lt;&lt; QApplication::palette();
</db:programlisting>
<db:para>Effectively, we convert the application's QPalette into a byte array. Here's how to read the data from the <db:link xlink:href="qbytearray.xml">QByteArray</db:link>:</db:para>
<db:programlisting language="cpp">    QPalette palette;
    QBuffer buffer(&amp;byteArray);
    buffer.open(QIODevice::ReadOnly);

    QDataStream in(&amp;buffer);
    in &gt;&gt; palette;
</db:programlisting>
<db:para><db:link xlink:href="qtextstream.xml">QTextStream</db:link> and <db:link xlink:href="qdatastream.xml">QDataStream</db:link> also provide convenience constructors that take a <db:link xlink:href="qbytearray.xml">QByteArray</db:link> and that create a <db:link xlink:href="qbuffer.xml">QBuffer</db:link> behind the scenes.</db:para>
<db:para><db:link xlink:href="qbuffer.xml">QBuffer</db:link> emits readyRead() when new data has arrived in the buffer. By connecting to this signal, you can use <db:link xlink:href="qbuffer.xml">QBuffer</db:link> to store temporary data before processing it. <db:link xlink:href="qbuffer.xml">QBuffer</db:link> also emits bytesWritten() every time new data has been written to the buffer.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qfile.xml">QFile</db:link></db:member>
<db:member><db:link xlink:href="qdatastream.xml">QDataStream</db:link></db:member>
<db:member><db:link xlink:href="qtextstream.xml">QTextStream</db:link></db:member>
<db:member><db:link xlink:href="qbytearray.xml">QByteArray</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="member-function-documentation">
<db:title>Member Function Documentation</db:title>
<db:section xml:id="readData">
<db:title>[protected] qint64 QBuffer::readData(char *<db:emphasis>data</db:emphasis>, qint64 <db:emphasis>len</db:emphasis>)</db:title>
</db:section>
<db:section xml:id="writeData">
<db:title>[protected] qint64 QBuffer::writeData(const char *<db:emphasis>data</db:emphasis>, qint64 <db:emphasis>len</db:emphasis>)</db:title>
</db:section>
</db:section>
</db:article>
