<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en">
<db:info>
<db:title>QXmlQuery Class</db:title>
<db:productname>QtXmlPatterns</db:productname>
<db:edition>Qt 5.8.0 Reference Documentation</db:edition>
<db:titleabbrev>Qt XML Patterns Reference Documentation</db:titleabbrev>
<db:abstract>
<db:para>The <db:link xlink:href="qxmlquery.xml">QXmlQuery</db:link> class performs XQueries on XML data, or on non-XML data modeled to look like XML.</db:para>
<db:para>This class was introduced in Qt 4.4.</db:para>
<db:note>
<db:para>All functions in this class are <db:link xlink:href="threads-reentrancy.xml">reentrant</db:link>.</db:para>
</db:note>
</db:abstract>
<db:pubdate>2025-06-29</db:pubdate>
<db:date>2025-06-29</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:variablelist>
<db:varlistentry>
<db:term>Header</db:term>
<db:listitem>
<db:para>QXmlQuery</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Since</db:term>
<db:listitem>
<db:para>Qt 4.4</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>qmake</db:term>
<db:listitem>
<db:para>QT += xmlpatterns</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Group</db:term>
<db:listitem>
<db:para>QXmlQuery is part of <db:simplelist><db:member>xml-tools</db:member></db:simplelist>
</db:para>
</db:listitem>
</db:varlistentry>
</db:variablelist>
<db:section xml:id="details">
<db:title>Detailed Description</db:title>
<db:para>The <db:link xlink:href="qxmlquery.xml">QXmlQuery</db:link> class compiles and executes queries written in the <db:link xlink:href="http://www.w3.org/TR/xquery/">XQuery language</db:link>. <db:link xlink:href="qxmlquery.xml">QXmlQuery</db:link> is typically used to query XML data, but it can also query non-XML data that has been modeled to look like XML.</db:para>
<db:para>Using <db:link xlink:href="qxmlquery.xml">QXmlQuery</db:link> to query XML data, as in the snippet below, is simple because it can use the built-in <db:link xlink:href="qabstractxmlnodemodel.xml">XML data model</db:link> as its delegate to the underlying query engine for traversing the data. The built-in data model is specified in <db:link xlink:href="http://www.w3.org/TR/xpath-datamodel/">XQuery 1.0 and XPath 2.0 Data Model</db:link>.</db:para>
<db:programlisting language="cpp">QXmlQuery query;
query.setQuery(&quot;doc('index.html')/html/body/p[1]&quot;);

QXmlSerializer serializer(query, myOutputDevice);
query.evaluateTo(&amp;serializer);
</db:programlisting>
<db:para>The example uses <db:link xlink:href="qxmlquery.xml">QXmlQuery</db:link> to match the first paragraph of an XML document and then <db:link xlink:href="qxmlserializer.xml">output the result</db:link> to a device as XML.</db:para>
<db:para>Using <db:link xlink:href="qxmlquery.xml">QXmlQuery</db:link> to query <db:emphasis>non-XML</db:emphasis> data requires writing a subclass of <db:link xlink:href="qabstractxmlnodemodel.xml">QAbstractXmlNodeModel</db:link> to use as a replacement for the built-in XML data model. The custom data model will be able to traverse the non-XML data as required by the <db:link xlink:href="qabstractxmlnodemodel.xml">QAbstractXmlNodeModel</db:link> interface. An instance of this custom data model then becomes the delegate used by the query engine to traverse the non-XML data. For an example of how to use <db:link xlink:href="qxmlquery.xml">QXmlQuery</db:link> to query non-XML data, see the documentation for <db:link xlink:href="qabstractxmlnodemodel.xml">QAbstractXmlNodeModel</db:link>.</db:para>
<db:section xml:id="running-xqueries">
<db:title>Running XQueries</db:title>
<db:para>To run a query set up with <db:link xlink:href="qxmlquery.xml">QXmlQuery</db:link>, call one of the evaluation functions.</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:link xlink:href="qxmlquery.xml#evaluateTo">evaluateTo</db:link>(<db:link xlink:href="qabstractxmlreceiver.xml">QAbstractXmlReceiver</db:link> *) is called with a pointer to an XML <db:link xlink:href="qabstractxmlreceiver.xml">receiver</db:link>, which receives the query results as a sequence of callbacks. The receiver callback class is like the callback class used for translating the output of a SAX parser. <db:link xlink:href="qxmlserializer.xml">QXmlSerializer</db:link>, for example, is a receiver callback class for translating the sequence of callbacks for output as unformatted XML text.</db:para>
</db:listitem>
</db:itemizedlist>
<db:itemizedlist>
<db:listitem>
<db:para><db:link xlink:href="qxmlquery.xml#evaluateTo">evaluateTo</db:link>(<db:link xlink:href="qxmlresultitems.xml">QXmlResultItems</db:link> *) is called with a pointer to an iterator for an empty sequence of query <db:link xlink:href="qxmlresultitems.xml">result items</db:link>. The Java-like iterator allows the query results to be accessed sequentially.</db:para>
</db:listitem>
</db:itemizedlist>
<db:itemizedlist>
<db:listitem>
<db:para><db:link xlink:href="qxmlquery.xml#evaluateTo">evaluateTo</db:link>(<db:link xlink:href="qstringlist.xml">QStringList</db:link> *) is like <db:link xlink:href="qxmlquery.xml#evaluateTo">evaluateTo</db:link>(<db:link xlink:href="qxmlresultitems.xml">QXmlResultItems</db:link> *), but the query must evaluate to a sequence of strings.</db:para>
</db:listitem>
</db:itemizedlist>
</db:section>
<db:section xml:id="running-xpath-expressions">
<db:title>Running XPath Expressions</db:title>
<db:para>The XPath language is a subset of the XQuery language, so running an XPath expression is the same as running an XQuery query. Pass the XPath expression to <db:link xlink:href="qxmlquery.xml">QXmlQuery</db:link> using <db:link xlink:href="qxmlquery.xml#setQuery">setQuery</db:link>().</db:para>
</db:section>
<db:section xml:id="running-xslt-stylesheets">
<db:title>Running XSLT Stylesheets</db:title>
<db:para>Running an XSLT stylesheet is like running an XQuery, except that when you construct your <db:link xlink:href="qxmlquery.xml">QXmlQuery</db:link>, you must pass <db:link xlink:href="qxmlquery.xml#QueryLanguage-enum">QXmlQuery::XSLT20</db:link> to tell <db:link xlink:href="qxmlquery.xml">QXmlQuery</db:link> to interpret whatever it gets from <db:link xlink:href="qxmlquery.xml#setQuery">setQuery</db:link>() as an XSLT stylesheet instead of as an XQuery. You must also set the input document by calling <db:link xlink:href="qxmlquery.xml#setFocus">setFocus</db:link>().</db:para>
<db:programlisting language="cpp">    QXmlQuery query(QXmlQuery::XSLT20);
    query.setFocus(QUrl(&quot;myInput.xml&quot;));
    query.setQuery(QUrl(&quot;myStylesheet.xsl&quot;));
    query.evaluateTo(out);
</db:programlisting>
<db:note>
<db:para>Currently, <db:link xlink:href="qxmlquery.xml#setFocus">setFocus</db:link>() must be called <db:emphasis>before</db:emphasis> <db:link xlink:href="qxmlquery.xml#setQuery">setQuery</db:link>() when using XSLT.</db:para>
</db:note>
<db:para>Another way to run an XSLT stylesheet is to use the <db:code>xmlpatterns</db:code> command line utility.</db:para>
<db:programlisting language="cpp">xmlpatterns myStylesheet.xsl myInput.xml
</db:programlisting>
<db:note>
<db:para>For the current release, XSLT support should be considered experimental. See section <db:link xlink:href="xmlprocessing.xml#xslt-2-0">XSLT conformance</db:link> for details.</db:para>
</db:note>
<db:para>Stylesheet parameters are bound using <db:link xlink:href="qxmlquery.xml#bindVariable">bindVariable</db:link>().</db:para>
</db:section>
<db:section xml:id="binding-a-query-to-a-starting-node">
<db:title>Binding A Query To A Starting Node</db:title>
<db:para>When a query is run on XML data, as in the snippet above, the <db:code>doc()</db:code> function returns the node in the built-in data model where the query evaluation will begin. But when a query is run on a custom node model containing non-XML data, one of the <db:link xlink:href="qxmlquery.xml#bindVariable">bindVariable</db:link>() functions must be called to bind a variable name to a starting node in the custom model. A $variable reference is used in the XQuery text to access the starting node in the custom model. It is not necessary to declare the variable name external in the query. See the example in the documentation for <db:link xlink:href="qabstractxmlnodemodel.xml">QAbstractXmlNodeModel</db:link>.</db:para>
</db:section>
<db:section xml:id="reentrancy-and-thread-safety">
<db:title>Reentrancy and Thread-Safety</db:title>
<db:para><db:link xlink:href="qxmlquery.xml">QXmlQuery</db:link> is reentrant but not thread-safe. It is safe to use the QxmlQuery copy constructor to create a copy of a query and run the same query multiple times. Behind the scenes, <db:link xlink:href="qxmlquery.xml">QXmlQuery</db:link> will reuse resources such as opened files and compiled queries to the extent possible. But it is not safe to use the same instance of <db:link xlink:href="qxmlquery.xml">QXmlQuery</db:link> in multiple threads.</db:para>
</db:section>
<db:section xml:id="error-handling">
<db:title>Error Handling</db:title>
<db:para>Errors can occur during query evaluation. Examples include type errors and file loading errors. When an error occurs:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para>The error message is sent to the <db:link xlink:href="qxmlquery.xml#messageHandler">messageHandler</db:link>().</db:para>
</db:listitem>
<db:listitem>
<db:para><db:link xlink:href="qxmlresultitems.xml#hasError">QXmlResultItems::hasError</db:link>() will return <db:code>true</db:code>, or <db:link xlink:href="qxmlquery.xml#evaluateTo">evaluateTo</db:link>() will return <db:code>false</db:code>;</db:para>
</db:listitem>
<db:listitem>
<db:para>The results of the evaluation are undefined.</db:para>
</db:listitem>
</db:itemizedlist>
</db:section>
<db:section xml:id="resource-management">
<db:title>Resource Management</db:title>
<db:para>When a query runs, it parses documents, allocating internal data structures to hold them, and it may load other resources over the network. It reuses these allocated resources when possible, to avoid having to reload and reparse them.</db:para>
<db:para>When <db:link xlink:href="qxmlquery.xml#setQuery">setQuery</db:link>() is called, the query text is compiled into an internal data structure and optimized. The optimized form can then be reused for multiple evaluations of the query. Since the compile-and-optimize process can be expensive, repeating it for the same query should be avoided by using a separate instance of <db:link xlink:href="qxmlquery.xml">QXmlQuery</db:link> for each query text.</db:para>
<db:para>Once a document has been parsed, its internal representation is maintained in the <db:link xlink:href="qxmlquery.xml">QXmlQuery</db:link> instance and shared among multiple <db:link xlink:href="qxmlquery.xml">QXmlQuery</db:link> instances.</db:para>
<db:para>An instance of <db:link xlink:href="qcoreapplication.xml">QCoreApplication</db:link> must exist before <db:link xlink:href="qxmlquery.xml">QXmlQuery</db:link> can be used.</db:para>
</db:section>
<db:section xml:id="event-handling">
<db:title>Event Handling</db:title>
<db:para>When <db:link xlink:href="qxmlquery.xml">QXmlQuery</db:link> accesses resources (e.g., calling <db:code>fn:doc()</db:code> to load a file, or accessing a device via a bound variable), the event loop is used, which means events will be processed. To avoid processing events when <db:link xlink:href="qxmlquery.xml">QXmlQuery</db:link> accesses resources, create your <db:link xlink:href="qxmlquery.xml">QXmlQuery</db:link> instance in a separate thread.</db:para>
</db:section>
</db:section>
<db:section xml:id="member-type-documentation">
<db:title>Member Type Documentation</db:title>
<db:section xml:id="QueryLanguage-enum">
<db:title>[since 4.5] enum QXmlQuery::QueryLanguage</db:title>
<db:para>Specifies whether you want <db:link xlink:href="qxmlquery.xml">QXmlQuery</db:link> to interpret the input to <db:link xlink:href="qxmlquery.xml#setQuery">setQuery</db:link>() as an XQuery or as an XSLT stylesheet.</db:para>
<db:informaltable>
<db:thead>
<db:tr>
<db:th>Constant</db:th>
<db:th>Value</db:th>
<db:th>Description</db:th>
</db:tr>
</db:thead>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qxmlquery.xml">QXmlQuery</db:link></db:emphasis>::XQuery10</db:code></db:para>
</db:td>
<db:td><db:code>1</db:code></db:td>
<db:td>
<db:para>XQuery 1.0.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qxmlquery.xml">QXmlQuery</db:link></db:emphasis>::XSLT20</db:code></db:para>
</db:td>
<db:td><db:code>2</db:code></db:td>
<db:td>
<db:para>XSLT 2.0</db:para>
</db:td>
</db:tr>
</db:informaltable>
<db:para>This enum was introduced in Qt 4.5.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qxmlquery.xml#setQuery">setQuery</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
</db:section>
<db:section xml:id="member-function-documentation">
<db:title>Member Function Documentation</db:title>
<db:section xml:id="QXmlQuery">
<db:title>QXmlQuery::QXmlQuery()</db:title>
<db:para>Constructs an invalid, empty query that cannot be used until <db:link xlink:href="qxmlquery.xml#setQuery">setQuery</db:link>() is called.</db:para>
<db:note>
<db:para>This constructor must not be used if you intend to use this <db:link xlink:href="qxmlquery.xml">QXmlQuery</db:link> to process XSL-T stylesheets. The other constructor must be used in that case.</db:para>
</db:note>
</db:section>
<db:section xml:id="QXmlQuery-1">
<db:title>QXmlQuery::QXmlQuery(const QXmlNamePool &amp;<db:emphasis>np</db:emphasis>)</db:title>
<db:para>Constructs a query that will use <db:code role="parameter">np</db:code> as its name pool. The query cannot be evaluated until <db:link xlink:href="qxmlquery.xml#setQuery">setQuery</db:link>() has been called.</db:para>
</db:section>
<db:section xml:id="QXmlQuery-3">
<db:title>[since 4.5] QXmlQuery::QXmlQuery(QXmlQuery::QueryLanguage <db:emphasis>queryLanguage</db:emphasis>, const QXmlNamePool &amp;<db:emphasis>np</db:emphasis> = QXmlNamePool())</db:title>
<db:para>Constructs a query that will be used to run Xqueries or XSL-T stylesheets, depending on the value of <db:code role="parameter">queryLanguage</db:code>. It will use <db:code role="parameter">np</db:code> as its name pool.</db:para>
<db:note>
<db:para>If your <db:link xlink:href="qxmlquery.xml">QXmlQuery</db:link> will process XSL-T stylesheets, this constructor must be used. The default constructor can only create instances of <db:link xlink:href="qxmlquery.xml">QXmlQuery</db:link> for running XQueries.</db:para>
</db:note>
<db:note>
<db:para>The XSL-T support in this release is considered experimental. See the <db:link xlink:href="xmlprocessing.xml#xslt-2-0">XSLT conformance</db:link> for details.</db:para>
</db:note>
<db:para>This function was introduced in Qt 4.5.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qxmlquery.xml#queryLanguage">queryLanguage</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="QXmlQuery-2">
<db:title>QXmlQuery::QXmlQuery(const QXmlQuery &amp;<db:emphasis>other</db:emphasis>)</db:title>
<db:para>Constructs a <db:link xlink:href="qxmlquery.xml">QXmlQuery</db:link> that is a copy of <db:code role="parameter">other</db:code>. The new instance will share resources with the existing query to the extent possible.</db:para>
</db:section>
<db:section xml:id="dtor.QXmlQuery">
<db:title>[noexcept] QXmlQuery::~QXmlQuery()</db:title>
<db:para>Destroys this <db:link xlink:href="qxmlquery.xml">QXmlQuery</db:link>.</db:para>
</db:section>
<db:section xml:id="bindVariable">
<db:title>void QXmlQuery::bindVariable(const QXmlName &amp;<db:emphasis>name</db:emphasis>, QIODevice *<db:emphasis>device</db:emphasis>)</db:title>
<db:para>Binds the variable <db:code role="parameter">name</db:code> to the <db:code role="parameter">device</db:code> so that $<db:code role="parameter">name</db:code> can be used from within the query to refer to the <db:code role="parameter">device</db:code>. The <db:link xlink:href="qiodevice.xml">QIODevice</db:link> <db:code role="parameter">device</db:code> is exposed to the query as a URI of type <db:code>xs:anyURI</db:code>, which can be passed to the <db:code>fn:doc()</db:code> function to be read. E.g., this function can be used to pass an XML document in memory to <db:code>fn:doc</db:code>.</db:para>
<db:programlisting language="cpp">    QByteArray myDocument;
    QBuffer buffer(&amp;myDocument); // This is a QIODevice.
    buffer.open(QIODevice::ReadOnly);
    QXmlQuery query;
    query.bindVariable(&quot;myDocument&quot;, &amp;buffer);
    query.setQuery(&quot;doc($myDocument)&quot;);
</db:programlisting>
<db:para>The caller must ensure that <db:code role="parameter">device</db:code> has been opened with at least <db:link xlink:href="qiodevice.xml#OpenModeFlag-enum">QIODevice::ReadOnly</db:link> prior to this binding. Otherwise, behavior is undefined.</db:para>
<db:para>If the query will access an XML document contained in a <db:link xlink:href="qstring.xml">QString</db:link>, use a <db:link xlink:href="qbuffer.xml">QBuffer</db:link> as shown in the following snippet. Suppose <db:emphasis>myQString</db:emphasis> contains <db:code>&lt;document&gt;content&lt;/document&gt;</db:code></db:para>
<db:programlisting language="cpp">    QBuffer device;
    device.setData(myQString.toUtf8());
    device.open(QIODevice::ReadOnly);

    QXmlQuery query;
    query.setQuery(&quot;doc($inputDocument)/query[theDocument]&quot;);
    query.bindVariable(&quot;inputDocument&quot;, &amp;device);
</db:programlisting>
<db:para><db:code role="parameter">name</db:code> must not be <db:emphasis>null</db:emphasis>. <db:code role="parameter">name</db:code>.isNull() must return false. If <db:code role="parameter">name</db:code> has already been bound, its previous binding will be overridden. The URI that <db:code role="parameter">name</db:code> evaluates to is arbitrary and may change.</db:para>
<db:para>If the type of the variable binding changes (e.g., if a previous binding by the same name was a <db:link xlink:href="qvariant.xml">QVariant</db:link>, or if there was no previous binding), <db:link xlink:href="qxmlquery.xml#isValid">isValid</db:link>() will return <db:code>false</db:code>, and recompilation of the query text is required. To recompile the query, call <db:link xlink:href="qxmlquery.xml#setQuery">setQuery</db:link>(). For this reason, bindVariable() should be called before <db:link xlink:href="qxmlquery.xml#setQuery">setQuery</db:link>(), if possible.</db:para>
<db:note>
<db:para><db:code role="parameter">device</db:code> must not be deleted while this <db:link xlink:href="qxmlquery.xml">QXmlQuery</db:link> exists.</db:para>
</db:note>
</db:section>
<db:section xml:id="bindVariable-1">
<db:title>void QXmlQuery::bindVariable(const QXmlName &amp;<db:emphasis>name</db:emphasis>, const QXmlItem &amp;<db:emphasis>value</db:emphasis>)</db:title>
<db:para>Binds the variable <db:code role="parameter">name</db:code> to the <db:code role="parameter">value</db:code> so that $<db:code role="parameter">name</db:code> can be used from within the query to refer to the <db:code role="parameter">value</db:code>.</db:para>
<db:para><db:code role="parameter">name</db:code> must not be <db:emphasis>null</db:emphasis>. <db:code role="parameter">name</db:code>.isNull() must return false. If <db:code role="parameter">name</db:code> has already been bound by a previous <db:link xlink:href="qxmlquery.xml#bindVariable">bindVariable</db:link>() call, its previous binding will be overridden.</db:para>
<db:para>If <db:code role="parameter">value</db:code> is null so that <db:code role="parameter">value</db:code>.isNull() returns true, and <db:code role="parameter">name</db:code> already has a binding, the effect is to remove the existing binding for <db:code role="parameter">name</db:code>.</db:para>
<db:para>To bind a value of type <db:link xlink:href="qstring.xml">QString</db:link> or <db:link xlink:href="qurl.xml">QUrl</db:link>, wrap the value in a <db:link xlink:href="qvariant.xml">QVariant</db:link> such that <db:link xlink:href="qxmlitem.xml">QXmlItem</db:link>'s <db:link xlink:href="qvariant.xml">QVariant</db:link> constructor is called.</db:para>
<db:para>All strings processed by the query must be valid XQuery strings, which means they must contain only XML 1.0 characters. However, this requirement is not checked. If the query processes an invalid string, the behavior is undefined.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qvariant.xml#isValid">QVariant::isValid</db:link>()</db:member>
<db:member><db:link xlink:href="xmlprocessing.xml#the-xquery-data-model">How QVariant maps to XQuery's Data Model</db:link></db:member>
<db:member><db:link xlink:href="qxmlitem.xml#isNull">QXmlItem::isNull</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="bindVariable-2">
<db:title>[since 4.5] void QXmlQuery::bindVariable(const QXmlName &amp;<db:emphasis>name</db:emphasis>, const QXmlQuery &amp;<db:emphasis>query</db:emphasis>)</db:title>
<db:para>Binds the result of the query <db:code role="parameter">query</db:code>, to a variable by name <db:code role="parameter">name</db:code>.</db:para>
<db:para>Evaluation of <db:code role="parameter">query</db:code> will be commenced when this function is called.</db:para>
<db:para>If <db:code role="parameter">query</db:code> is invalid, behavior is undefined. <db:code role="parameter">query</db:code> will be copied.</db:para>
<db:para>This function was introduced in Qt 4.5.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qxmlquery.xml#isValid">isValid</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="bindVariable-3">
<db:title>void QXmlQuery::bindVariable(const QString &amp;<db:emphasis>localName</db:emphasis>, QIODevice *<db:emphasis>device</db:emphasis>)</db:title>
<db:para>This is an overloaded function.</db:para>
<db:para>If <db:code role="parameter">localName</db:code> is a valid <db:link xlink:href="qxmlname.xml#isNCName">NCName</db:link>, this function is equivalent to the following snippet.</db:para>
<db:programlisting language="cpp">    QXmlNamePool namePool(query.namePool());
    query.bindVariable(QXmlName(namePool, localName), device);
</db:programlisting>
<db:para>A <db:link xlink:href="qxmlname.xml">QXmlName</db:link> is constructed from <db:code role="parameter">localName</db:code>, and is passed to the appropriate overload along with <db:code role="parameter">device</db:code>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qxmlname.xml#isNCName">QXmlName::isNCName</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="bindVariable-4">
<db:title>void QXmlQuery::bindVariable(const QString &amp;<db:emphasis>localName</db:emphasis>, const QXmlItem &amp;<db:emphasis>value</db:emphasis>)</db:title>
<db:para>This is an overloaded function.</db:para>
<db:para>This function constructs a <db:link xlink:href="qxmlname.xml">QXmlName</db:link> from <db:code role="parameter">localName</db:code> using the query's <db:link xlink:href="qxmlnamepool.xml">namespace</db:link>. The function then behaves as the overloaded function. It is equivalent to the following snippet.</db:para>
<db:programlisting language="cpp">    QXmlNamePool namePool(query.namePool());
    query.bindVariable(QXmlName(namePool, localName), value);
</db:programlisting>
</db:section>
<db:section xml:id="bindVariable-5">
<db:title>[since 4.5] void QXmlQuery::bindVariable(const QString &amp;<db:emphasis>localName</db:emphasis>, const QXmlQuery &amp;<db:emphasis>query</db:emphasis>)</db:title>
<db:para>This is an overloaded function.</db:para>
<db:para>Has the same behavior and effects as the function being overloaded, but takes the variable name <db:code role="parameter">localName</db:code> as a <db:link xlink:href="qstring.xml">QString</db:link>. <db:code role="parameter">query</db:code> is used as in the overloaded function.</db:para>
<db:para>This function was introduced in Qt 4.5.</db:para>
</db:section>
<db:section xml:id="evaluateTo">
<db:title>bool QXmlQuery::evaluateTo(QAbstractXmlReceiver *<db:emphasis>callback</db:emphasis>) const</db:title>
<db:para>Evaluates this query and sends the result as a sequence of callbacks to the <db:link xlink:href="qabstractxmlreceiver.xml">receiver</db:link> <db:code role="parameter">callback</db:code>. <db:link xlink:href="qxmlquery.xml">QXmlQuery</db:link> does not take ownership of <db:code role="parameter">callback</db:code>.</db:para>
<db:para>If an error occurs during the evaluation, error messages are sent to <db:link xlink:href="qxmlquery.xml#messageHandler">messageHandler</db:link>() and <db:code>false</db:code> is returned.</db:para>
<db:para>If this query <db:link xlink:href="qxmlquery.xml#isValid">is invalid</db:link>, <db:code>false</db:code> is returned and the behavior is undefined. If <db:code role="parameter">callback</db:code> is null, behavior is undefined.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qabstractxmlreceiver.xml">QAbstractXmlReceiver</db:link></db:member>
<db:member><db:link xlink:href="qxmlquery.xml#isValid">isValid</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="evaluateTo-1">
<db:title>[since 4.5] bool QXmlQuery::evaluateTo(QString *<db:emphasis>output</db:emphasis>) const</db:title>
<db:para>Evaluates the query, and serializes the output as XML to <db:code role="parameter">output</db:code>.</db:para>
<db:para>If an error occurs during the evaluation, error messages are sent to <db:link xlink:href="qxmlquery.xml#messageHandler">messageHandler</db:link>(), the content of <db:code role="parameter">output</db:code> is undefined and <db:code>false</db:code> is returned, otherwise <db:code>true</db:code> is returned.</db:para>
<db:para>If <db:code role="parameter">output</db:code> is <db:code>null</db:code> behavior is undefined. <db:link xlink:href="qxmlquery.xml">QXmlQuery</db:link> does not take ownership of <db:code role="parameter">output</db:code>.</db:para>
<db:para>Internally, the class <db:link xlink:href="qxmlformatter.xml">QXmlFormatter</db:link> is used for this.</db:para>
<db:para>This function was introduced in Qt 4.5.</db:para>
</db:section>
<db:section xml:id="evaluateTo-2">
<db:title>bool QXmlQuery::evaluateTo(QStringList *<db:emphasis>target</db:emphasis>) const</db:title>
<db:para>Attempts to evaluate the query and returns the results in the <db:code role="parameter">target</db:code> <db:link xlink:href="qstringlist.xml">string list</db:link>.</db:para>
<db:para>If the query <db:link xlink:href="qxmlquery.xml#isValid">is valid</db:link> and the evaluation succeeds, true is returned. Otherwise, false is returned and the contents of <db:code role="parameter">target</db:code> are undefined.</db:para>
<db:para>The query must evaluate to a sequence of <db:code>xs:string</db:code> values. If the query does not evaluate to a sequence of strings, the values can often be converted by adding a call to <db:code>string()</db:code> at the end of the XQuery.</db:para>
<db:para>If <db:code role="parameter">target</db:code> is null, the behavior is undefined.</db:para>
</db:section>
<db:section xml:id="evaluateTo-3">
<db:title>void QXmlQuery::evaluateTo(QXmlResultItems *<db:emphasis>result</db:emphasis>) const</db:title>
<db:para>Starts the evaluation and makes it available in <db:code role="parameter">result</db:code>. If <db:code role="parameter">result</db:code> is null, the behavior is undefined. The evaluation takes place incrementally (lazy evaluation), as the caller uses <db:link xlink:href="qxmlresultitems.xml#next">QXmlResultItems::next</db:link>() to get the next result.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qxmlresultitems.xml#next">QXmlResultItems::next</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="evaluateTo-4">
<db:title>[since 4.5] bool QXmlQuery::evaluateTo(QIODevice *<db:emphasis>target</db:emphasis>) const</db:title>
<db:para>Evaluates the query or stylesheet, and writes the output to <db:code role="parameter">target</db:code>.</db:para>
<db:para><db:link xlink:href="qxmlserializer.xml">QXmlSerializer</db:link> is used to write the output to <db:code role="parameter">target</db:code>. In a future release, it is expected that this function will be changed to respect serialization options set in the stylesheet.</db:para>
<db:para>If an error occurs during the evaluation, error messages are sent to <db:link xlink:href="qxmlquery.xml#messageHandler">messageHandler</db:link>() and <db:code>false</db:code> is returned.</db:para>
<db:para>If <db:code role="parameter">target</db:code> is <db:code>null</db:code>, or is not opened in at least <db:link xlink:href="qiodevice.xml#OpenModeFlag-enum">QIODevice::WriteOnly</db:link> mode, the behavior is undefined. <db:link xlink:href="qxmlquery.xml">QXmlQuery</db:link> does not take ownership of <db:code role="parameter">target</db:code>.</db:para>
<db:para>This is an overloaded function.</db:para>
<db:para>This function was introduced in Qt 4.5.</db:para>
</db:section>
<db:section xml:id="initialTemplateName">
<db:title>[since 4.5] QXmlName QXmlQuery::initialTemplateName() const</db:title>
<db:para>Returns the name of the XSL-T stylesheet template that the processor will call first when running an XSL-T stylesheet. This function only applies when using <db:link xlink:href="qxmlquery.xml">QXmlQuery</db:link> to process XSL-T stylesheets. By default, no initial template is set. In that case, a default constructed <db:link xlink:href="qxmlname.xml">QXmlName</db:link> is returned.</db:para>
<db:para>This function was introduced in Qt 4.5.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qxmlquery.xml#setInitialTemplateName">setInitialTemplateName</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="isValid">
<db:title>bool QXmlQuery::isValid() const</db:title>
<db:para>Returns true if this query is valid. Examples of invalid queries are ones that contain syntax errors or that have not had <db:link xlink:href="qxmlquery.xml#setQuery">setQuery</db:link>() called for them yet.</db:para>
</db:section>
<db:section xml:id="messageHandler">
<db:title>QAbstractMessageHandler *QXmlQuery::messageHandler() const</db:title>
<db:para>Returns the message handler that handles compile and runtime messages for this <db:link xlink:href="qxmlquery.xml">QXmlQuery</db:link>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qxmlquery.xml#setMessageHandler">setMessageHandler</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="namePool">
<db:title>QXmlNamePool QXmlQuery::namePool() const</db:title>
<db:para>Returns the name pool used by this <db:link xlink:href="qxmlquery.xml">QXmlQuery</db:link> for constructing <db:link xlink:href="qxmlname.xml">names</db:link>. There is no setter for the name pool, because mixing name pools causes errors due to name confusion.</db:para>
</db:section>
<db:section xml:id="networkAccessManager">
<db:title>[since 4.5] QNetworkAccessManager *QXmlQuery::networkAccessManager() const</db:title>
<db:para>Returns the network manager, or 0 if it has not been set.</db:para>
<db:para>This function was introduced in Qt 4.5.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qxmlquery.xml#setNetworkAccessManager">setNetworkAccessManager</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="queryLanguage">
<db:title>[since 4.5] QXmlQuery::QueryLanguage QXmlQuery::queryLanguage() const</db:title>
<db:para>Returns a value indicating what this <db:link xlink:href="qxmlquery.xml">QXmlQuery</db:link> is being used for. The default is <db:link xlink:href="qxmlquery.xml#QueryLanguage-enum">QXmlQuery::XQuery10</db:link>, which means the <db:link xlink:href="qxmlquery.xml">QXmlQuery</db:link> is being used for running XQuery and XPath queries. <db:link xlink:href="qxmlquery.xml#QueryLanguage-enum">QXmlQuery::XSLT20</db:link> can also be returned, which indicates the <db:link xlink:href="qxmlquery.xml">QXmlQuery</db:link> is for running XSL-T spreadsheets.</db:para>
<db:para>This function was introduced in Qt 4.5.</db:para>
</db:section>
<db:section xml:id="setFocus">
<db:title>void QXmlQuery::setFocus(const QXmlItem &amp;<db:emphasis>item</db:emphasis>)</db:title>
<db:para>Sets the focus to <db:code role="parameter">item</db:code>. The focus is the set of items that the context item expression and path expressions navigate from. For example, in the expression <db:emphasis>p/span</db:emphasis>, the element that <db:emphasis>p</db:emphasis> evaluates to is the focus for the following expression, <db:emphasis>span</db:emphasis>.</db:para>
<db:para>The focus can be accessed using the context item expression, i.e., dot (&quot;.&quot;).</db:para>
<db:para>By default, the focus is not set and is undefined. It will therefore result in a dynamic error, <db:code>XPDY0002</db:code>, if the focus is attempted to be accessed. The focus must be set before the query is set with <db:link xlink:href="qxmlquery.xml#setQuery">setQuery</db:link>().</db:para>
<db:para>There is no behavior defined for setting an item which is null.</db:para>
</db:section>
<db:section xml:id="setFocus-1">
<db:title>[since 4.5] bool QXmlQuery::setFocus(QIODevice *<db:emphasis>document</db:emphasis>)</db:title>
<db:para>Sets the focus to be the <db:code role="parameter">document</db:code> read from the <db:link xlink:href="qiodevice.xml">QIODevice</db:link> and returns true. If <db:code role="parameter">document</db:code> cannot be loaded, false is returned.</db:para>
<db:para><db:link xlink:href="qxmlquery.xml">QXmlQuery</db:link> does not take ownership of <db:code role="parameter">document</db:code>. The user guarantees that a document is available from the <db:code role="parameter">document</db:code> device and that the document is not empty. The device must be opened in at least read-only mode. <db:code role="parameter">document</db:code> must stay in scope as long as the current query is active.</db:para>
<db:para>This is an overloaded function.</db:para>
<db:para>This function was introduced in Qt 4.5.</db:para>
</db:section>
<db:section xml:id="setFocus-2">
<db:title>[since 4.6] bool QXmlQuery::setFocus(const QString &amp;<db:emphasis>focus</db:emphasis>)</db:title>
<db:para>This function behaves identically to calling the <db:link xlink:href="qxmlquery.xml#setFocus">setFocus</db:link>() overload with a <db:link xlink:href="qiodevice.xml">QIODevice</db:link> whose content is <db:code role="parameter">focus</db:code> encoded as UTF-8. That is, <db:code role="parameter">focus</db:code> is treated as if it contained an XML document.</db:para>
<db:para>Returns the same result as the overload.</db:para>
<db:para>This is an overloaded function.</db:para>
<db:para>This function was introduced in Qt 4.6.</db:para>
</db:section>
<db:section xml:id="setFocus-3">
<db:title>[since 4.5] bool QXmlQuery::setFocus(const QUrl &amp;<db:emphasis>documentURI</db:emphasis>)</db:title>
<db:para>This is an overloaded function.</db:para>
<db:para>Sets the focus to be the document located at <db:code role="parameter">documentURI</db:code> and returns true. If <db:code role="parameter">documentURI</db:code> cannot be loaded, false is returned. It is undefined at what time the document may be loaded. When loading the document, the message handler and URI resolver set on this <db:link xlink:href="qxmlquery.xml">QXmlQuery</db:link> are used.</db:para>
<db:para>If <db:code role="parameter">documentURI</db:code> is empty or is not a valid URI, the behavior of this function is undefined.</db:para>
<db:para>This function was introduced in Qt 4.5.</db:para>
</db:section>
<db:section xml:id="setInitialTemplateName">
<db:title>[since 4.5] void QXmlQuery::setInitialTemplateName(const QXmlName &amp;<db:emphasis>name</db:emphasis>)</db:title>
<db:para>Sets the <db:code role="parameter">name</db:code> of the initial template. The initial template is the one the processor calls first, instead of attempting to match a template to the context node (if any). If an initial template is not set, the standard order of template invocation will be used.</db:para>
<db:para>This function only applies when using <db:link xlink:href="qxmlquery.xml">QXmlQuery</db:link> to process XSL-T stylesheets. The name becomes part of the compiled stylesheet. Therefore, this function must be called before calling <db:link xlink:href="qxmlquery.xml#setQuery">setQuery</db:link>().</db:para>
<db:para>If the stylesheet has no template named <db:code role="parameter">name</db:code>, the processor will use the standard order of template invocation.</db:para>
<db:para>This function was introduced in Qt 4.5.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qxmlquery.xml#initialTemplateName">initialTemplateName</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setInitialTemplateName-1">
<db:title>[since 4.5] void QXmlQuery::setInitialTemplateName(const QString &amp;<db:emphasis>localName</db:emphasis>)</db:title>
<db:para>This is an overloaded function.</db:para>
<db:para>Sets the name of the initial template to <db:code role="parameter">localName</db:code>, which must be a valid <db:link xlink:href="qxmlname.xml#localName">local name</db:link>. The initial template is the one the processor calls first, instead of attempting to match a template to the context node (if any). If an initial template is not set, the standard order of template invocation will be used.</db:para>
<db:para>This function only applies when using <db:link xlink:href="qxmlquery.xml">QXmlQuery</db:link> to process XSL-T stylesheets. The name becomes part of the compiled stylesheet. Therefore, this function must be called before calling <db:link xlink:href="qxmlquery.xml#setQuery">setQuery</db:link>().</db:para>
<db:para>If <db:code role="parameter">localName</db:code> is not a valid <db:link xlink:href="qxmlname.xml#localName">local name</db:link>, the effect is undefined. If the stylesheet has no template named <db:code role="parameter">localName</db:code>, the processor will use the standard order of template invocation.</db:para>
<db:para>This function was introduced in Qt 4.5.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qxmlquery.xml#initialTemplateName">initialTemplateName</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setMessageHandler">
<db:title>void QXmlQuery::setMessageHandler(QAbstractMessageHandler *<db:emphasis>aMessageHandler</db:emphasis>)</db:title>
<db:para>Changes the <db:link xlink:href="qabstractmessagehandler.xml">message handler</db:link> for this <db:link xlink:href="qxmlquery.xml">QXmlQuery</db:link> to <db:code role="parameter">aMessageHandler</db:code>. The query sends all compile and runtime messages to this message handler. <db:link xlink:href="qxmlquery.xml">QXmlQuery</db:link> does not take ownership of <db:code role="parameter">aMessageHandler</db:code>.</db:para>
<db:para>Normally, the default message handler is sufficient. It writes compile and runtime messages to <db:emphasis>stderr</db:emphasis>. The default message handler includes color codes if <db:emphasis>stderr</db:emphasis> can render colors.</db:para>
<db:para>Note that changing the message handler after the query has been compiled has no effect, i.e. the query uses the same message handler at runtime that it uses at compile time.</db:para>
<db:para>When <db:link xlink:href="qxmlquery.xml">QXmlQuery</db:link> calls <db:link xlink:href="qabstractmessagehandler.xml#message">QAbstractMessageHandler::message</db:link>(), the arguments are as follows:</db:para>
<db:informaltable style="generic">
<db:thead>
<db:tr>
<db:th>
<db:para>message() argument</db:para>
</db:th>
<db:th>
<db:para>Semantics</db:para>
</db:th>
</db:tr>
</db:thead>
<db:tr valign="top">
<db:td>
<db:para><db:link xlink:href="qtglobal.xml#QtMsgType-enum">QtMsgType</db:link> type</db:para>
</db:td>
<db:td>
<db:para>Only <db:link xlink:href="qtglobal.xml#QtMsgType-enum">QtWarningMsg</db:link> and <db:link xlink:href="qtglobal.xml#QtMsgType-enum">QtFatalMsg</db:link> are used. The former identifies a compile or runtime warning, while the latter identifies a dynamic or static error.</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>const <db:link xlink:href="qstring.xml">QString</db:link> &amp; description</db:para>
</db:td>
<db:td>
<db:para>An XHTML document which is the actual message. It is translated into the current language.</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>const <db:link xlink:href="qurl.xml">QUrl</db:link> &amp;identifier</db:para>
</db:td>
<db:td>
<db:para>Identifies the error with a URI, where the fragment is the error code, and the rest of the URI is the error namespace.</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>const <db:link xlink:href="qsourcelocation.xml">QSourceLocation</db:link> &amp; sourceLocation</db:para>
</db:td>
<db:td>
<db:para>Identifies where the error occurred.</db:para>
</db:td>
</db:tr>
</db:informaltable>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qxmlquery.xml#messageHandler">messageHandler</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setNetworkAccessManager">
<db:title>[since 4.5] void QXmlQuery::setNetworkAccessManager(QNetworkAccessManager *<db:emphasis>newManager</db:emphasis>)</db:title>
<db:para>Sets the network manager to <db:code role="parameter">newManager</db:code>. <db:link xlink:href="qxmlquery.xml">QXmlQuery</db:link> does not take ownership of <db:code role="parameter">newManager</db:code>.</db:para>
<db:para>This function was introduced in Qt 4.5.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qxmlquery.xml#networkAccessManager">networkAccessManager</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setQuery">
<db:title>void QXmlQuery::setQuery(QIODevice *<db:emphasis>sourceCode</db:emphasis>, const QUrl &amp;<db:emphasis>documentURI</db:emphasis> = QUrl())</db:title>
<db:para>Sets this <db:link xlink:href="qxmlquery.xml">QXmlQuery</db:link> to an XQuery read from the <db:code role="parameter">sourceCode</db:code> device. The device must have been opened with at least <db:link xlink:href="qiodevice.xml#OpenModeFlag-enum">QIODevice::ReadOnly</db:link>.</db:para>
<db:para><db:code role="parameter">documentURI</db:code> represents the query obtained from the <db:code role="parameter">sourceCode</db:code> device. It is the base URI of the static context, as defined in the <db:link xlink:href="http://www.w3.org/TR/xquery/">XQuery language</db:link>. It is used internally to resolve relative URIs that appear in the query, and for message reporting. <db:code role="parameter">documentURI</db:code> can be empty. If it is empty, the <db:link xlink:href="qcoreapplication.xml#applicationFilePath">application file path</db:link> is used. If it is not empty, it may be either relative or absolute. If it is relative, it is resolved itself against the <db:link xlink:href="qcoreapplication.xml#applicationFilePath">application file path</db:link> before it is used. If <db:code role="parameter">documentURI</db:code> is neither a valid URI nor empty, the result is undefined.</db:para>
<db:para>If the query contains a static error (e.g. syntax error), an error message is sent to the <db:link xlink:href="qxmlquery.xml#messageHandler">messageHandler</db:link>(), and <db:link xlink:href="qxmlquery.xml#isValid">isValid</db:link>() will return <db:emphasis>false</db:emphasis>.</db:para>
<db:para>Variables must be bound before setQuery() is called.</db:para>
<db:para>The encoding of the XQuery in <db:code role="parameter">sourceCode</db:code> is detected internally using the rules for setting and detecting encoding of XQuery files, which are explained in the <db:link xlink:href="http://www.w3.org/TR/xquery/">XQuery language</db:link>.</db:para>
<db:para>If <db:code role="parameter">sourceCode</db:code> is <db:code>null</db:code> or not readable, or if <db:code role="parameter">documentURI</db:code> is not a valid URI, behavior is undefined.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qxmlquery.xml#isValid">isValid</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setQuery-1">
<db:title>void QXmlQuery::setQuery(const QUrl &amp;<db:emphasis>queryURI</db:emphasis>, const QUrl &amp;<db:emphasis>baseURI</db:emphasis> = QUrl())</db:title>
<db:para>Sets this <db:link xlink:href="qxmlquery.xml">QXmlQuery</db:link> to the XQuery read from the <db:code role="parameter">queryURI</db:code>. Use <db:link xlink:href="qxmlquery.xml#isValid">isValid</db:link>() after calling this function. If an error occurred reading <db:code role="parameter">queryURI</db:code>, e.g., the query does not exist, cannot be read, or is invalid, <db:link xlink:href="qxmlquery.xml#isValid">isValid</db:link>() will return <db:emphasis>false</db:emphasis>.</db:para>
<db:para>The supported URI schemes are the same as those in the XQuery function <db:code>fn:doc</db:code>, except that queryURI can be the object of a variable binding.</db:para>
<db:para><db:code role="parameter">baseURI</db:code> is the Base URI of the static context, as defined in the <db:link xlink:href="http://www.w3.org/TR/xquery/">XQuery language</db:link>. It is used internally to resolve relative URIs that appear in the query, and for message reporting. If <db:code role="parameter">baseURI</db:code> is empty, <db:code role="parameter">queryURI</db:code> is used. Otherwise, <db:code role="parameter">baseURI</db:code> is used, and it is resolved against the <db:link xlink:href="qcoreapplication.xml#applicationFilePath">application file path</db:link> if it is relative.</db:para>
<db:para>If <db:code role="parameter">queryURI</db:code> is empty or invalid, or if <db:code role="parameter">baseURI</db:code> is invalid, the behavior of this function is undefined.</db:para>
</db:section>
<db:section xml:id="setQuery-2">
<db:title>void QXmlQuery::setQuery(const QString &amp;<db:emphasis>sourceCode</db:emphasis>, const QUrl &amp;<db:emphasis>documentURI</db:emphasis> = QUrl())</db:title>
<db:para>This is an overloaded function.</db:para>
<db:para>The behavior and requirements of this function are the same as for <db:link xlink:href="qxmlquery.xml#setQuery">setQuery</db:link>(<db:link xlink:href="qiodevice.xml">QIODevice</db:link>*, const <db:link xlink:href="qurl.xml">QUrl</db:link>&amp;), after the XQuery has been read from the IO device into a string. Because <db:code role="parameter">sourceCode</db:code> is already a Unicode string, detection of its encoding is unnecessary.</db:para>
</db:section>
<db:section xml:id="setUriResolver">
<db:title>void QXmlQuery::setUriResolver(const QAbstractUriResolver *<db:emphasis>resolver</db:emphasis>)</db:title>
<db:para>Sets the URI resolver to <db:code role="parameter">resolver</db:code>. <db:link xlink:href="qxmlquery.xml">QXmlQuery</db:link> does not take ownership of <db:code role="parameter">resolver</db:code>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qxmlquery.xml#uriResolver">uriResolver</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="uriResolver">
<db:title>const QAbstractUriResolver *QXmlQuery::uriResolver() const</db:title>
<db:para>Returns the query's URI resolver. If no URI resolver has been set, Qt XML Patterns will use the URIs in queries as they are.</db:para>
<db:para>The URI resolver provides a level of abstraction, or <db:emphasis>polymorphic URIs</db:emphasis>. A resolver can rewrite <db:emphasis>logical</db:emphasis> URIs to physical ones, or it can translate obsolete or invalid URIs to valid ones.</db:para>
<db:para>Qt XML Patterns calls the URI resolver for all URIs it encounters, except for namespaces. Specifically, all builtin functions that deal with URIs (<db:code>fn:doc()</db:code>, and <db:code>fn:doc-available()</db:code>).</db:para>
<db:para>In the case of <db:code>fn:doc()</db:code>, the absolute URI is the base URI in the static context (which most likely is the location of the query). Rather than use the URI the user specified, the return value of <db:link xlink:href="qabstracturiresolver.xml#resolve">QAbstractUriResolver::resolve</db:link>() will be used.</db:para>
<db:para>When Qt XML Patterns calls <db:link xlink:href="qabstracturiresolver.xml#resolve">QAbstractUriResolver::resolve</db:link>() the absolute URI is the URI mandated by the XQuery language, and the relative URI is the URI specified by the user.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qxmlquery.xml#setUriResolver">setUriResolver</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="operator-eq">
<db:title>QXmlQuery &amp;QXmlQuery::operator=(const QXmlQuery &amp;<db:emphasis>other</db:emphasis>)</db:title>
<db:para>Assigns <db:code role="parameter">other</db:code> to this <db:link xlink:href="qxmlquery.xml">QXmlQuery</db:link> instance.</db:para>
</db:section>
</db:section>
</db:article>
