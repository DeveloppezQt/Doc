<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en">
<db:info>
<db:title>&lt;QtCompilerDetection&gt; - Compiler-specific Macro Definitions</db:title>
<db:productname>QtCore</db:productname>
<db:edition>Qt 6.9.1 Reference Documentation</db:edition>
<db:titleabbrev>Qt Core Reference Documentation</db:titleabbrev>
<db:abstract>
<db:para>The &lt;QtCompilerDetection&gt; header file includes various compiler-specific macros.</db:para>
</db:abstract>
<db:pubdate>2025-06-29</db:pubdate>
<db:date>2025-06-29</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:variablelist>
<db:varlistentry>
<db:term>Header</db:term>
<db:listitem>
<db:para>QtCompilerDetection</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Group</db:term>
<db:listitem>
<db:para>&lt;QtCompilerDetection&gt; is part of <db:simplelist><db:member>funclists</db:member></db:simplelist>
</db:para>
</db:listitem>
</db:varlistentry>
</db:variablelist>
<db:section xml:id="details">
<db:title>Detailed Description</db:title>
<db:para>The &lt;QtCompilerDetection&gt; header file provides a range of macros (Q_CC_*) that are defined if the application is compiled using the specified compiler. For example, the <db:link xlink:href="qtcompilerdetection.xml#Q_CC_SUN">Q_CC_SUN</db:link> macro is defined if the application is compiled using Forte Developer, or Sun Studio C++.</db:para>
<db:para>The purpose of these macros is to enable programmers to add compiler-specific code to their application.</db:para>
</db:section>
<db:section xml:id="macro-documentation">
<db:title>Macro Documentation</db:title>
<db:section xml:id="Q_NODISCARD_CTOR_X">
<db:title>[since 6.7] Q_NODISCARD_CTOR_X(<db:emphasis>message</db:emphasis>)</db:title>
<db:bridgehead renderas="sect2" xml:id="Q_NODISCARD_X">[since 6.7] Q_NODISCARD_X(<db:emphasis>message</db:emphasis>)</db:bridgehead>
<db:para>Expand to [[nodiscard(message)]] on compilers that support the feature.</db:para>
<db:para>Otherwise they expand to [[nodiscard]] and <db:link xlink:href="qtcompilerdetection.xml#Q_NODISCARD_CTOR">Q_NODISCARD_CTOR</db:link>, respectively.</db:para>
<db:para>This function was introduced in Qt 6.7.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtcompilerdetection.xml#Q_NODISCARD_CTOR">Q_NODISCARD_CTOR</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="Q_CC_BOR">
<db:title>Q_CC_BOR</db:title>
<db:para>Defined if the application is compiled using Borland/Turbo C++.</db:para>
</db:section>
<db:section xml:id="Q_CC_CDS">
<db:title>Q_CC_CDS</db:title>
<db:para>Defined if the application is compiled using Reliant C++.</db:para>
</db:section>
<db:section xml:id="Q_CC_CLANG">
<db:title>Q_CC_CLANG</db:title>
<db:para>Defined if the application is compiled using Clang.</db:para>
</db:section>
<db:section xml:id="Q_CC_COMEAU">
<db:title>Q_CC_COMEAU</db:title>
<db:para>Defined if the application is compiled using Comeau C++.</db:para>
</db:section>
<db:section xml:id="Q_CC_DEC">
<db:title>Q_CC_DEC</db:title>
<db:para>Defined if the application is compiled using DEC C++.</db:para>
</db:section>
<db:section xml:id="Q_CC_EDG">
<db:title>Q_CC_EDG</db:title>
<db:para>Defined if the application is compiled using Edison Design Group C++.</db:para>
</db:section>
<db:section xml:id="Q_CC_GHS">
<db:title>Q_CC_GHS</db:title>
<db:para>Defined if the application is compiled using Green Hills Optimizing C++ Compilers.</db:para>
</db:section>
<db:section xml:id="Q_CC_GNU">
<db:title>Q_CC_GNU</db:title>
<db:para>Defined if the application is compiled using GNU Compiler Collection (GCC).</db:para>
</db:section>
<db:section xml:id="Q_CC_HIGHC">
<db:title>Q_CC_HIGHC</db:title>
<db:para>Defined if the application is compiled using MetaWare High C/C++.</db:para>
</db:section>
<db:section xml:id="Q_CC_HPACC">
<db:title>Q_CC_HPACC</db:title>
<db:para>Defined if the application is compiled using HP aC++.</db:para>
</db:section>
<db:section xml:id="Q_CC_KAI">
<db:title>Q_CC_KAI</db:title>
<db:para>Defined if the application is compiled using KAI C++.</db:para>
</db:section>
<db:section xml:id="Q_CC_MIPS">
<db:title>Q_CC_MIPS</db:title>
<db:para>Defined if the application is compiled using MIPSpro C++.</db:para>
</db:section>
<db:section xml:id="Q_CC_MSVC">
<db:title>Q_CC_MSVC</db:title>
<db:para>Defined if the application is compiled using Microsoft Visual C/C++, Intel C++ for Windows.</db:para>
</db:section>
<db:section xml:id="Q_CC_OC">
<db:title>Q_CC_OC</db:title>
<db:para>Defined if the application is compiled using CenterLine C++.</db:para>
</db:section>
<db:section xml:id="Q_CC_PGI">
<db:title>Q_CC_PGI</db:title>
<db:para>Defined if the application is compiled using Portland Group C++.</db:para>
</db:section>
<db:section xml:id="Q_CC_SUN">
<db:title>Q_CC_SUN</db:title>
<db:para>Defined if the application is compiled using Forte Developer, or Sun Studio C++.</db:para>
</db:section>
<db:section xml:id="Q_CC_SYM">
<db:title>Q_CC_SYM</db:title>
<db:para>Defined if the application is compiled using Digital Mars C/C++ (used to be Symantec C++).</db:para>
</db:section>
<db:section xml:id="Q_CC_USLC">
<db:title>Q_CC_USLC</db:title>
<db:para>Defined if the application is compiled using SCO OUDK and UDK.</db:para>
</db:section>
<db:section xml:id="Q_CC_WAT">
<db:title>Q_CC_WAT</db:title>
<db:para>Defined if the application is compiled using Watcom C++.</db:para>
</db:section>
<db:section xml:id="Q_CONSTEXPR_DTOR">
<db:title>[since 6.9] Q_CONSTEXPR_DTOR</db:title>
<db:para>Expands to constexpr on compilers that support C++20, where __cpp_constexpr has a value greater than or equal to 201907L. Otherwise, it expands to const.</db:para>
<db:para>Use this macro to declare a variable that can be constructed at compile-time in C++20 or later.</db:para>
<db:para>This macro was introduced in Qt 6.9.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtcompilerdetection.xml#Q_DECL_CONSTEXPR_DTOR">Q_DECL_CONSTEXPR_DTOR</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="Q_CONSTINIT">
<db:title>[since 6.4] Q_CONSTINIT</db:title>
<db:para>Enforces constant initialization when supported by the compiler.</db:para>
<db:para>If the compiler supports the C++20 constinit keyword, Clang's [[clang::require_constant_initialization]] or GCC's __constinit, then this macro expands to the first one of these that is available, otherwise it expands to nothing.</db:para>
<db:para>Variables marked as constinit cause a compile-error if their initialization would have to be performed at runtime.</db:para>
<db:note>
<db:para>Constant-initialized variables may still have load-time impact if they have non-trivial destruction.</db:para>
</db:note>
<db:para>For constants, you can use constexpr since C++11, but constexpr makes variables const, too, whereas constinit ensures constant initialization, but doesn't make the variable const:</db:para>
<db:informaltable style="generic">
<db:thead>
<db:tr>
<db:th>
<db:para>Keyword</db:para>
</db:th>
<db:th>
<db:para>Added</db:para>
</db:th>
<db:th>
<db:para>immutable</db:para>
</db:th>
<db:th>
<db:para>constant-initialized</db:para>
</db:th>
</db:tr>
</db:thead>
<db:tr valign="top">
<db:td>
<db:para>const</db:para>
</db:td>
<db:td>
<db:para>C++98</db:para>
</db:td>
<db:td>
<db:para>yes</db:para>
</db:td>
<db:td>
<db:para>not required</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>constexpr</db:para>
</db:td>
<db:td>
<db:para>C++11</db:para>
</db:td>
<db:td>
<db:para>yes</db:para>
</db:td>
<db:td>
<db:para>required</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>constinit</db:para>
</db:td>
<db:td>
<db:para>C++20</db:para>
</db:td>
<db:td>
<db:para>no</db:para>
</db:td>
<db:td>
<db:para>required</db:para>
</db:td>
</db:tr>
</db:informaltable>
<db:para>This macro was introduced in Qt 6.4.</db:para>
</db:section>
<db:section xml:id="Q_DECL_CONSTEXPR_DTOR">
<db:title>[since 6.9] Q_DECL_CONSTEXPR_DTOR</db:title>
<db:para>Expands to constexpr on compilers that support C++20, where __cpp_constexpr has a value greater than or equal to 201907L. Otherwise, it expands to inline.</db:para>
<db:para>Use this macro to declare a destructor that can be computed at compile-time in C++20 or later.</db:para>
<db:para>This macro was introduced in Qt 6.9.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtcompilerdetection.xml#Q_CONSTEXPR_DTOR">Q_CONSTEXPR_DTOR</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="Q_DECL_EQ_DELETE_X">
<db:title>[since 6.9] Q_DECL_EQ_DELETE_X(<db:emphasis>reason</db:emphasis>)</db:title>
<db:para>Expands to = delete(reason) on compilers that support C++26, where __cpp_deleted_function has a value greater than or equal to 202403L. Otherwise, it expands to = delete.</db:para>
<db:para>Use this macro to declare a deleted function and also supply an error message (the <db:code role="parameter">reason</db:code>) to the user in case the function gets used (explaining why the function was deleted).</db:para>
<db:para>This macro was introduced in Qt 6.9.</db:para>
</db:section>
<db:section xml:id="Q_DECL_EXPORT">
<db:title>Q_DECL_EXPORT</db:title>
<db:para>This macro marks a symbol for shared library export (see <db:link xlink:href="">Creating Shared Libraries</db:link>).</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtcompilerdetection.xml#Q_DECL_IMPORT">Q_DECL_IMPORT</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="Q_DECL_IMPORT">
<db:title>Q_DECL_IMPORT</db:title>
<db:para>This macro declares a symbol to be an import from a shared library (see <db:link xlink:href="">Creating Shared Libraries</db:link>).</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtcompilerdetection.xml#Q_DECL_EXPORT">Q_DECL_EXPORT</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="Q_FALLTHROUGH">
<db:title>void Q_FALLTHROUGH</db:title>
<db:para>Can be used in switch statements at the end of case block to tell the compiler and other developers that the lack of a break statement is intentional.</db:para>
<db:para>This is useful since a missing break statement is often a bug, and some compilers can be configured to emit warnings when one is not found.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtassert-qtcore-proxy.xml#Q_UNREACHABLE">Q_UNREACHABLE</db:link>()</db:member>
<db:member><db:link xlink:href="qtassert-qtcore-proxy.xml#Q_UNREACHABLE_RETURN">Q_UNREACHABLE_RETURN</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="Q_FUNC_INFO">
<db:title>const char*Q_FUNC_INFO</db:title>
<db:para>Expands to a string that describe the function the macro resides in. How this string looks more specifically is compiler dependent. With GNU GCC it is typically the function signature, while with other compilers it might be the line and column number.</db:para>
<db:para>Q_FUNC_INFO can be conveniently used with <db:link xlink:href="qtlogging.xml#qDebug">qDebug</db:link>(). For example, this function:</db:para>
<db:programlisting language="cpp">template&lt;typename TInputType&gt;
const TInputType &amp;myMin(const TInputType &amp;value1, const TInputType &amp;value2)
{
    qDebug() &lt;&lt; Q_FUNC_INFO &lt;&lt; &quot;was called with value1:&quot; &lt;&lt; value1 &lt;&lt; &quot;value2:&quot; &lt;&lt; value2;

    if(value1 &lt; value2)
        return value1;
    else
        return value2;
}
</db:programlisting>
<db:para>when instantiated with the integer type, will with the GCC compiler produce:</db:para>
<db:para><db:code>const TInputType&amp; myMin(const TInputType&amp;, const TInputType&amp;) [with TInputType = int] was called with value1: 3 value2: 4</db:code></db:para>
<db:para>If this macro is used outside a function, the behavior is undefined.</db:para>
</db:section>
<db:section xml:id="Q_LIKELY">
<db:title>Q_LIKELY(<db:emphasis>expr</db:emphasis>)</db:title>
<db:para>Hints to the compiler that the enclosed condition, <db:code role="parameter">expr</db:code>, is likely to evaluate to true.</db:para>
<db:para>Use of this macro can help the compiler to optimize the code.</db:para>
<db:para>Example:</db:para>
<db:programlisting language="cpp">    // the condition inside the &quot;if&quot; will be successful most of the times
    for (int i = 1; i &lt;= 365; i++) {
        if (Q_LIKELY(isWorkingDay(i))) {
            ...
        }
        ...
    }
</db:programlisting>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtcompilerdetection.xml#Q_UNLIKELY">Q_UNLIKELY</db:link>()</db:member>
<db:member><db:link xlink:href="qtcompilerdetection.xml#Q_LIKELY_BRANCH">Q_LIKELY_BRANCH</db:link></db:member>
<db:member><db:link xlink:href="qtcompilerdetection.xml#Q_UNLIKELY_BRANCH">Q_UNLIKELY_BRANCH</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="Q_LIKELY_BRANCH">
<db:title>[since 6.9] Q_LIKELY_BRANCH</db:title>
<db:para>Hints to the compiler that the following block is likely to be executed.</db:para>
<db:para>Use of this macro can help the compiler to optimize the code.</db:para>
<db:para>It is defined as the C++20 attribute [[likely]], and is a no-op on compilers that don't support it.</db:para>
<db:para>This macro was introduced in Qt 6.9.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtcompilerdetection.xml#Q_LIKELY">Q_LIKELY</db:link>()</db:member>
<db:member><db:link xlink:href="qtcompilerdetection.xml#Q_UNLIKELY">Q_UNLIKELY</db:link>()</db:member>
<db:member><db:link xlink:href="qtcompilerdetection.xml#Q_UNLIKELY_BRANCH">Q_UNLIKELY_BRANCH</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="Q_NODISCARD_CTOR">
<db:title>[since 6.6] Q_NODISCARD_CTOR</db:title>
<db:para>Expands to [[nodiscard]] on compilers that accept it on constructors.</db:para>
<db:para>Otherwise it expands to nothing.</db:para>
<db:para>Constructors marked as Q_NODISCARD_CTOR cause a compiler warning if a call site doesn't use the resulting object.</db:para>
<db:para>This macro is exists solely to prevent warnings on compilers that don't implement the feature. If your supported platforms all allow [[nodiscard]] on constructors, we strongly recommend you use the C++ attribute directly instead of this macro.</db:para>
<db:para>This macro was introduced in Qt 6.6.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtcompilerdetection.xml#Q_NODISCARD_CTOR_X">Q_NODISCARD_CTOR_X</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="Q_UNLIKELY">
<db:title>Q_UNLIKELY(<db:emphasis>expr</db:emphasis>)</db:title>
<db:para>Hints to the compiler that the enclosed condition, <db:code role="parameter">expr</db:code>, is likely to evaluate to false.</db:para>
<db:para>Use of this macro can help the compiler to optimize the code.</db:para>
<db:para>Example:</db:para>
<db:programlisting language="cpp">bool readConfiguration(const QFile &amp;file)
{
    // We expect to be asked to read an existing file
    if (Q_UNLIKELY(!file.exists())) {
        qWarning() &lt;&lt; &quot;File not found&quot;;
        return false;
    }

    ...
    return true;
}
</db:programlisting>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtcompilerdetection.xml#Q_LIKELY">Q_LIKELY</db:link>()</db:member>
<db:member><db:link xlink:href="qtcompilerdetection.xml#Q_LIKELY_BRANCH">Q_LIKELY_BRANCH</db:link></db:member>
<db:member><db:link xlink:href="qtcompilerdetection.xml#Q_UNLIKELY_BRANCH">Q_UNLIKELY_BRANCH</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="Q_UNLIKELY_BRANCH">
<db:title>[since 6.9] Q_UNLIKELY_BRANCH</db:title>
<db:para>Hints to the compiler that the following block is unlikely to be executed.</db:para>
<db:para>Use of this macro can help the compiler to optimize the code.</db:para>
<db:para>It is defined as the C++20 attribute [[unlikely]], and is a no-op on compilers that don't support it.</db:para>
<db:para>This macro was introduced in Qt 6.9.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtcompilerdetection.xml#Q_LIKELY">Q_LIKELY</db:link>()</db:member>
<db:member><db:link xlink:href="qtcompilerdetection.xml#Q_UNLIKELY">Q_UNLIKELY</db:link>()</db:member>
<db:member><db:link xlink:href="qtcompilerdetection.xml#Q_LIKELY_BRANCH">Q_LIKELY_BRANCH</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
</db:section>
<db:section xml:id="obsolete">
<db:title>Obsolete Members for &lt;QtCompilerDetection&gt;</db:title>
<db:para><db:emphasis role="bold">The following members of class <db:link xlink:href="qtcompilerdetection.xml">&lt;QtCompilerDetection&gt;</db:link> are deprecated.</db:emphasis> We strongly advise against using them in new code.</db:para>
<db:section xml:id="obsolete-macro-documentation">
<db:title>Obsolete Macro Documentation</db:title>
<db:section xml:id="Q_CC_INTEL">
<db:title>[deprecated] Q_CC_INTEL</db:title>
<db:para>This macro is deprecated. We strongly advise against using it in new code.</db:para>
<db:para>This macro used to be defined if the application was compiled with the old Intel C++ compiler for Linux, macOS or Windows. The new oneAPI C++ compiler is just a build of Clang and therefore does not define this macro.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtcompilerdetection.xml#Q_CC_CLANG">Q_CC_CLANG</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="Q_DECL_CONSTEXPR">
<db:title>[deprecated in 6.4] Q_DECL_CONSTEXPR</db:title>
<db:para>This macro is deprecated since 6.4. We strongly advise against using it in new code.</db:para>
<db:para>Use the constexpr keyword instead.</db:para>
<db:para>This macro can be used to declare variable that should be constructed at compile-time, or an inline function that can be computed at compile-time.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtcompilerdetection.xml#Q_DECL_RELAXED_CONSTEXPR">Q_DECL_RELAXED_CONSTEXPR</db:link></db:member>
<db:member><db:link xlink:href="qtcompilerdetection.xml#Q_DECL_CONSTEXPR_DTOR">Q_DECL_CONSTEXPR_DTOR</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="Q_DECL_FINAL">
<db:title>[deprecated] Q_DECL_FINAL</db:title>
<db:para>This macro is deprecated. We strongly advise against using it in new code.</db:para>
<db:para>This macro can be used to declare an overriding virtual or a class as &quot;final&quot;, with Java semantics. Further-derived classes can then no longer override this virtual function, or inherit from this class, respectively.</db:para>
<db:para>It expands to &quot;final&quot;.</db:para>
<db:para>The macro goes at the end of the function, usually after the const, if any:</db:para>
<db:programlisting language="cpp">    // more-derived classes no longer permitted to override this:
    virtual void MyWidget::paintEvent(QPaintEvent*) final;
</db:programlisting>
<db:para>For classes, it goes in front of the : in the class definition, if any:</db:para>
<db:programlisting language="cpp">    class QRect final { // cannot be derived from
        // ...
    };
</db:programlisting>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtcompilerdetection.xml#Q_DECL_OVERRIDE">Q_DECL_OVERRIDE</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="Q_DECL_NOEXCEPT">
<db:title>[deprecated in 6.4] Q_DECL_NOEXCEPT</db:title>
<db:para>This macro is deprecated since 6.4. We strongly advise against using it in new code.</db:para>
<db:para>Use the noexcept keyword instead.</db:para>
<db:para>This macro marks a function as never throwing. If the function does nevertheless throw, the behavior is defined: std::terminate() is called.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtcompilerdetection.xml#Q_DECL_NOTHROW">Q_DECL_NOTHROW</db:link></db:member>
<db:member><db:link xlink:href="qtcompilerdetection.xml#Q_DECL_NOEXCEPT_EXPR">Q_DECL_NOEXCEPT_EXPR</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="Q_DECL_NOEXCEPT_EXPR">
<db:title>[deprecated in 6.4] Q_DECL_NOEXCEPT_EXPR(<db:emphasis>x</db:emphasis>)</db:title>
<db:para>This macro is deprecated since 6.4. We strongly advise against using it in new code.</db:para>
<db:para>Use the noexcept keyword instead.</db:para>
<db:para>This macro marks a function as non-throwing if <db:code role="parameter">x</db:code> is true. If the function does nevertheless throw, the behavior is defined: std::terminate() is called.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtcompilerdetection.xml#Q_DECL_NOTHROW">Q_DECL_NOTHROW</db:link></db:member>
<db:member><db:link xlink:href="qtcompilerdetection.xml#Q_DECL_NOEXCEPT">Q_DECL_NOEXCEPT</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="Q_DECL_NOTHROW">
<db:title>[deprecated in 6.4] Q_DECL_NOTHROW</db:title>
<db:para>This macro is deprecated since 6.4. We strongly advise against using it in new code.</db:para>
<db:para>Use the noexcept keyword instead.</db:para>
<db:para>This macro marks a function as never throwing, under no circumstances. If the function does nevertheless throw, the behavior is undefined.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtcompilerdetection.xml#Q_DECL_NOEXCEPT">Q_DECL_NOEXCEPT</db:link></db:member>
<db:member><db:link xlink:href="qtcompilerdetection.xml#Q_DECL_NOEXCEPT_EXPR">Q_DECL_NOEXCEPT_EXPR</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="Q_DECL_OVERRIDE">
<db:title>[deprecated] Q_DECL_OVERRIDE</db:title>
<db:para>This macro is deprecated. We strongly advise against using it in new code.</db:para>
<db:para>This macro can be used to declare an overriding virtual function. Use of this markup will allow the compiler to generate an error if the overriding virtual function does not in fact override anything.</db:para>
<db:para>It expands to &quot;override&quot;.</db:para>
<db:para>The macro goes at the end of the function, usually after the const, if any:</db:para>
<db:programlisting language="cpp">    // generate error if this doesn't actually override anything:
    virtual void MyWidget::paintEvent(QPaintEvent*) override;
</db:programlisting>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtcompilerdetection.xml#Q_DECL_FINAL">Q_DECL_FINAL</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="Q_DECL_RELAXED_CONSTEXPR">
<db:title>[deprecated in 6.4] Q_DECL_RELAXED_CONSTEXPR</db:title>
<db:para>This macro is deprecated since 6.4. We strongly advise against using it in new code.</db:para>
<db:para>Use the constexpr keyword instead.</db:para>
<db:para>This macro can be used to declare an inline function that can be computed at compile-time according to the relaxed rules from C++14.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtcompilerdetection.xml#Q_DECL_CONSTEXPR">Q_DECL_CONSTEXPR</db:link></db:member>
<db:member><db:link xlink:href="qtcompilerdetection.xml#Q_DECL_CONSTEXPR_DTOR">Q_DECL_CONSTEXPR_DTOR</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
</db:section>
</db:section>
</db:article>
