<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en">
<db:info>
<db:title>QQuickWindow Class</db:title>
<db:productname>QtQuick</db:productname>
<db:edition>Qt 5.8.0 Reference Documentation</db:edition>
<db:titleabbrev>Qt Quick Reference Documentation</db:titleabbrev>
<db:abstract>
<db:para>The <db:link xlink:href="qquickwindow.xml">QQuickWindow</db:link> class provides the window for displaying a graphical QML scene.</db:para>
<db:para>This class was introduced in Qt 5.0.</db:para>
</db:abstract>
<db:pubdate>2025-06-29</db:pubdate>
<db:date>2025-06-29</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:variablelist>
<db:varlistentry>
<db:term>Header</db:term>
<db:listitem>
<db:para>QQuickWindow</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Since</db:term>
<db:listitem>
<db:para>Qt 5.0</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>qmake</db:term>
<db:listitem>
<db:para>QT += quick</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>In QML</db:term>
<db:listitem>
<db:para><db:link xlink:href="qml-qtquick-window-window.xml" xlink:role="">Window</db:link></db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Inherits</db:term>
<db:listitem>
<db:para><db:link xlink:href="qwindow.xml" xlink:role="class">QWindow</db:link></db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Inherited By</db:term>
<db:listitem>
<db:para><db:link xlink:href="qquickview.xml" xlink:role="class">QQuickView</db:link></db:para>
</db:listitem>
</db:varlistentry>
</db:variablelist>
<db:section xml:id="details">
<db:title>Detailed Description</db:title>
<db:para><db:link xlink:href="qquickwindow.xml">QQuickWindow</db:link> provides the graphical scene management needed to interact with and display a scene of QQuickItems.</db:para>
<db:para>A <db:link xlink:href="qquickwindow.xml">QQuickWindow</db:link> always has a single invisible root item. To add items to this window, reparent the items to the root item or to an existing item in the scene.</db:para>
<db:para>For easily displaying a scene from a QML file, see <db:link xlink:href="qquickview.xml">QQuickView</db:link>.</db:para>
<db:section xml:id="rendering">
<db:title>Rendering</db:title>
<db:para><db:link xlink:href="qquickwindow.xml">QQuickWindow</db:link> uses a scene graph to represent what needs to be rendered. This scene graph is disconnected from the QML scene and potentially lives in another thread, depending on the platform implementation. Since the rendering scene graph lives independently from the QML scene, it can also be completely released without affecting the state of the QML scene.</db:para>
<db:para>The <db:link xlink:href="qquickwindow.xml#sceneGraphInitialized">sceneGraphInitialized</db:link>() signal is emitted on the rendering thread before the QML scene is rendered to the screen for the first time. If the rendering scene graph has been released, the signal will be emitted again before the next frame is rendered.</db:para>
<db:section xml:id="integration-with-opengl">
<db:title>Integration with OpenGL</db:title>
<db:para>When using the default OpenGL adaptation, it is possible to integrate OpenGL calls directly into the <db:link xlink:href="qquickwindow.xml">QQuickWindow</db:link> using the same OpenGL context as the Qt Quick Scene Graph. This is done by connecting to the <db:link xlink:href="qquickwindow.xml#beforeRendering">QQuickWindow::beforeRendering</db:link>() or <db:link xlink:href="qquickwindow.xml#afterRendering">QQuickWindow::afterRendering</db:link>() signal.</db:para>
<db:note>
<db:para>When using <db:link xlink:href="qquickwindow.xml#beforeRendering">QQuickWindow::beforeRendering</db:link>(), make sure to disable clearing before rendering with <db:link xlink:href="qquickwindow.xml#setClearBeforeRendering">QQuickWindow::setClearBeforeRendering</db:link>().</db:para>
</db:note>
</db:section>
<db:section xml:id="exposure-and-visibility">
<db:title>Exposure and Visibility</db:title>
<db:para>When a <db:link xlink:href="qquickwindow.xml">QQuickWindow</db:link> instance is deliberately hidden with <db:link xlink:href="qwindow.xml#hide">hide</db:link>() or setVisible(false), it will stop rendering and its scene graph and graphics context might be released. The <db:link xlink:href="qquickwindow.xml#sceneGraphInvalidated">sceneGraphInvalidated</db:link>() signal will be emitted when this happens.</db:para>
<db:warning>
<db:para>It is crucial that graphics operations and interaction with the scene graph happens exclusively on the rendering thread, primarily during the updatePaintNode() phase.</db:para>
</db:warning>
<db:warning>
<db:para>As signals related to rendering might be emitted from the rendering thread, connections should be made using <db:link xlink:href="qt.xml#ConnectionType-enum">Qt::DirectConnection</db:link>.</db:para>
</db:warning>
</db:section>
<db:section xml:id="resource-management">
<db:title>Resource Management</db:title>
<db:para>QML will try to cache images and scene graph nodes to improve performance, but in some low-memory scenarios it might be required to aggressively release these resources. The <db:link xlink:href="qquickwindow.xml#releaseResources">releaseResources</db:link>() can be used to force the clean up of certain resources. Calling <db:link xlink:href="qquickwindow.xml#releaseResources">releaseResources</db:link>() may result in the entire scene graph and in the case of the OpenGL adaptation the associated context will be deleted. The <db:link xlink:href="qquickwindow.xml#sceneGraphInvalidated">sceneGraphInvalidated</db:link>() signal will be emitted when this happens.</db:para>
<db:note>
<db:para>All classes with QSG prefix should be used solely on the scene graph's rendering thread. See <db:link xlink:href="qtquick-visualcanvas-scenegraph.xml#scene-graph-and-rendering">Scene Graph and Rendering</db:link> for more information.</db:para>
</db:note>
</db:section>
<db:section xml:id="context-and-surface-formats">
<db:title>Context and surface formats</db:title>
<db:para>While it is possible to specify a <db:link xlink:href="qsurfaceformat.xml">QSurfaceFormat</db:link> for every <db:link xlink:href="qquickwindow.xml">QQuickWindow</db:link> by calling the member function <db:link xlink:href="qwindow.xml#setFormat">setFormat</db:link>(), windows may also be created from QML by using the Window and <db:link xlink:href="qml-qtquick-controls-applicationwindow.xml">ApplicationWindow</db:link> elements. In this case there is no C++ code involved in the creation of the window instance, yet applications may still wish to set certain surface format values, for example to request a given OpenGL version or profile. Such applications can call the static function <db:link xlink:href="qsurfaceformat.xml#setDefaultFormat">QSurfaceFormat::setDefaultFormat</db:link>() at startup. The specified format will be used for all Quick windows created afterwards.</db:para>
</db:section>
</db:section>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtquick-scenegraph-openglunderqml-example.xml">Scene Graph - OpenGL Under QML</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="member-type-documentation">
<db:title>Member Type Documentation</db:title>
<db:section xml:id="CreateTextureOption-enum">
<db:title>enum QQuickWindow::CreateTextureOption</db:title>
<db:bridgehead renderas="sect2">flags QQuickWindow::CreateTextureOptions</db:bridgehead>
<db:para>The CreateTextureOption enums are used to customize a texture is wrapped.</db:para>
<db:informaltable>
<db:thead>
<db:tr>
<db:th>Constant</db:th>
<db:th>Value</db:th>
<db:th>Description</db:th>
</db:tr>
</db:thead>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qquickwindow.xml">QQuickWindow</db:link></db:emphasis>::TextureHasAlphaChannel</db:code></db:para>
</db:td>
<db:td><db:code>0x0001</db:code></db:td>
<db:td>
<db:para>The texture has an alpha channel and should be drawn using blending.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qquickwindow.xml">QQuickWindow</db:link></db:emphasis>::TextureHasMipmaps</db:code></db:para>
</db:td>
<db:td><db:code>0x0002</db:code></db:td>
<db:td>
<db:para>The texture has mipmaps and can be drawn with mipmapping enabled.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qquickwindow.xml">QQuickWindow</db:link></db:emphasis>::TextureOwnsGLTexture</db:code></db:para>
</db:td>
<db:td><db:code>0x0004</db:code></db:td>
<db:td>
<db:para>The texture object owns the texture id and will delete the OpenGL texture when the texture object is deleted.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qquickwindow.xml">QQuickWindow</db:link></db:emphasis>::TextureCanUseAtlas</db:code></db:para>
</db:td>
<db:td><db:code>0x0008</db:code></db:td>
<db:td>
<db:para>The image can be uploaded into a texture atlas.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qquickwindow.xml">QQuickWindow</db:link></db:emphasis>::TextureIsOpaque</db:code></db:para>
</db:td>
<db:td><db:code>0x0010</db:code></db:td>
<db:td>
<db:para>The texture will return false for <db:link xlink:href="qsgtexture.xml#hasAlphaChannel">QSGTexture::hasAlphaChannel</db:link>() and will not be blended. This flag was added in Qt 5.6.</db:para>
</db:td>
</db:tr>
</db:informaltable>
<db:para>The <db:code>CreateTextureOptions</db:code> type is a typedef for <db:code><db:link xlink:href="qflags.xml">QFlags</db:link>&lt;CreateTextureOption&gt;. </db:code>It stores an OR combination of <db:code>CreateTextureOption</db:code> values.</db:para>
</db:section>
<db:section xml:id="RenderStage-enum">
<db:title>[since 5.4] enum QQuickWindow::RenderStage</db:title>
<db:informaltable>
<db:thead>
<db:tr>
<db:th>Constant</db:th>
<db:th>Value</db:th>
<db:th>Description</db:th>
</db:tr>
</db:thead>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qquickwindow.xml">QQuickWindow</db:link></db:emphasis>::BeforeSynchronizingStage</db:code></db:para>
</db:td>
<db:td><db:code>0</db:code></db:td>
<db:td>
<db:para>Before synchronization.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qquickwindow.xml">QQuickWindow</db:link></db:emphasis>::AfterSynchronizingStage</db:code></db:para>
</db:td>
<db:td><db:code>1</db:code></db:td>
<db:td>
<db:para>After synchronization.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qquickwindow.xml">QQuickWindow</db:link></db:emphasis>::BeforeRenderingStage</db:code></db:para>
</db:td>
<db:td><db:code>2</db:code></db:td>
<db:td>
<db:para>Before rendering.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qquickwindow.xml">QQuickWindow</db:link></db:emphasis>::AfterRenderingStage</db:code></db:para>
</db:td>
<db:td><db:code>3</db:code></db:td>
<db:td>
<db:para>After rendering.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qquickwindow.xml">QQuickWindow</db:link></db:emphasis>::AfterSwapStage</db:code></db:para>
</db:td>
<db:td><db:code>4</db:code></db:td>
<db:td>
<db:para>After the frame is swapped.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qquickwindow.xml">QQuickWindow</db:link></db:emphasis>::NoStage</db:code></db:para>
</db:td>
<db:td><db:code>5</db:code></db:td>
<db:td>
<db:para>As soon as possible. This value was added in Qt 5.6.</db:para>
</db:td>
</db:tr>
</db:informaltable>
<db:para>This enum was introduced in Qt 5.4.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtquick-visualcanvas-scenegraph.xml#scene-graph-and-rendering">Scene Graph and Rendering</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="SceneGraphError-enum">
<db:title>[since 5.3] enum QQuickWindow::SceneGraphError</db:title>
<db:para>This enum describes the error in a <db:link xlink:href="qquickwindow.xml#sceneGraphError">sceneGraphError</db:link>() signal.</db:para>
<db:informaltable>
<db:thead>
<db:tr>
<db:th>Constant</db:th>
<db:th>Value</db:th>
<db:th>Description</db:th>
</db:tr>
</db:thead>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qquickwindow.xml">QQuickWindow</db:link></db:emphasis>::ContextNotAvailable</db:code></db:para>
</db:td>
<db:td><db:code>1</db:code></db:td>
<db:td>
<db:para>graphics context creation failed. This typically means that no suitable OpenGL implementation was found, for example because no graphics drivers are installed and so no OpenGL 2 support is present. On mobile and embedded boards that use OpenGL ES such an error is likely to indicate issues in the windowing system integration and possibly an incorrect configuration of Qt.</db:para>
</db:td>
</db:tr>
</db:informaltable>
<db:para>This enum was introduced in Qt 5.3.</db:para>
</db:section>
</db:section>
<db:section xml:id="property-documentation">
<db:title>Property Documentation</db:title>
<db:section xml:id="activeFocusItem-prop">
<db:title>[read-only] activeFocusItem : QQuickItem* const</db:title>
<db:para>This property holds the item which currently has active focus or <db:code>null</db:code> if there is no item with active focus.</db:para>
<db:para>
<db:emphasis role="bold">Access functions:
</db:emphasis>
</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:type><db:link xlink:href="qquickitem.xml">QQuickItem</db:link></db:type> *<db:emphasis role="bold">activeFocusItem</db:emphasis>() const</db:para>
</db:listitem>
</db:itemizedlist>
<db:para>
<db:emphasis role="bold">Notifier signal:
</db:emphasis>
</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:type>void</db:type> <db:emphasis role="bold">activeFocusItemChanged</db:emphasis>()</db:para>
</db:listitem>
</db:itemizedlist>
</db:section>
<db:section xml:id="color-prop">
<db:title>color : QColor</db:title>
<db:para>This property holds the color used to clear the OpenGL context.</db:para>
<db:para>Setting the clear color has no effect when clearing is disabled. By default, the clear color is white.</db:para>
<db:para>
<db:emphasis role="bold">Access functions:
</db:emphasis>
</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:type><db:link xlink:href="qcolor.xml">QColor</db:link></db:type> <db:emphasis role="bold">color</db:emphasis>() const</db:para>
</db:listitem>
<db:listitem>
<db:para><db:type>void</db:type> <db:emphasis role="bold">setColor</db:emphasis>(const <db:type><db:link xlink:href="qcolor.xml">QColor</db:link></db:type> &amp;<db:emphasis>color</db:emphasis>)</db:para>
</db:listitem>
</db:itemizedlist>
<db:para>
<db:emphasis role="bold">Notifier signal:
</db:emphasis>
</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:type>void</db:type> <db:emphasis role="bold">colorChanged</db:emphasis>(<db:emphasis>const QColor &amp;</db:emphasis>)</db:para>
</db:listitem>
</db:itemizedlist>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qquickwindow.xml#setClearBeforeRendering">setClearBeforeRendering</db:link>()</db:member>
<db:member><db:link xlink:href="qquickwindow.xml#setDefaultAlphaBuffer">setDefaultAlphaBuffer</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="contentItem-prop">
<db:title>[read-only] contentItem : QQuickItem* const</db:title>
<db:para>This property holds the invisible root item of the scene.</db:para>
<db:para>A <db:link xlink:href="qquickwindow.xml">QQuickWindow</db:link> always has a single invisible root item containing all of its content. To add items to this window, reparent the items to the contentItem or to an existing item in the scene.</db:para>
<db:para>
<db:emphasis role="bold">Access functions:
</db:emphasis>
</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:type><db:link xlink:href="qquickitem.xml">QQuickItem</db:link></db:type> *<db:emphasis role="bold">contentItem</db:emphasis>() const</db:para>
</db:listitem>
</db:itemizedlist>
</db:section>
</db:section>
<db:section xml:id="member-function-documentation">
<db:title>Member Function Documentation</db:title>
<db:section xml:id="QQuickWindow">
<db:title>[explicit] QQuickWindow::QQuickWindow(QWindow *<db:emphasis>parent</db:emphasis> = Q_NULLPTR)</db:title>
<db:para>Constructs a window for displaying a QML scene with parent window <db:code role="parameter">parent</db:code>.</db:para>
</db:section>
<db:section xml:id="dtor.QQuickWindow">
<db:title>[virtual noexcept] QQuickWindow::~QQuickWindow()</db:title>
<db:para>Destroys the window.</db:para>
</db:section>
<db:section xml:id="accessibleRoot">
<db:title>[override virtual] QAccessibleInterface *QQuickWindow::accessibleRoot() const</db:title>
<db:para>Returns an accessibility interface for this window, or 0 if such an interface cannot be created.</db:para>
</db:section>
<db:section xml:id="afterAnimating">
<db:title>[since 5.3] void QQuickWindow::afterAnimating()</db:title>
<db:para>This signal is emitted on the gui thread before requesting the render thread to perform the synchronization of the scene graph.</db:para>
<db:para>Unlike the other similar signals, this one is emitted on the gui thread instead of the render thread. It can be used to synchronize external animation systems with the QML content.</db:para>
<db:para>This function was introduced in Qt 5.3.</db:para>
</db:section>
<db:section xml:id="afterRendering">
<db:title>void QQuickWindow::afterRendering()</db:title>
<db:para>This signal is emitted after the scene has completed rendering, before swapbuffers is called.</db:para>
<db:para>This signal can be used to paint using raw OpenGL on top of QML content, or to do screen scraping of the current frame buffer.</db:para>
<db:para>The OpenGL context used for rendering the scene graph will be bound at this point.</db:para>
<db:warning>
<db:para>This signal is emitted from the scene graph rendering thread. If your slot function needs to finish before execution continues, you must make sure that the connection is direct (see <db:link xlink:href="qt.xml#ConnectionType-enum">Qt::ConnectionType</db:link>).</db:para>
</db:warning>
<db:warning>
<db:para>Make very sure that a signal handler for afterRendering() leaves the OpenGL context in the same state as it was when the signal handler was entered. Failing to do so can result in the scene not rendering properly.</db:para>
</db:warning>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qquickwindow.xml#resetOpenGLState">resetOpenGLState</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="afterSynchronizing">
<db:title>[since 5.3] void QQuickWindow::afterSynchronizing()</db:title>
<db:para>This signal is emitted after the scene graph is synchronized with the QML state.</db:para>
<db:para>This signal can be used to do preparation required after calls to <db:link xlink:href="qquickitem.xml#updatePaintNode">QQuickItem::updatePaintNode</db:link>(), while the GUI thread is still locked.</db:para>
<db:para>The graphics context used for rendering the scene graph will be bound at this point.</db:para>
<db:warning>
<db:para>This signal is emitted from the scene graph rendering thread. If your slot function needs to finish before execution continues, you must make sure that the connection is direct (see <db:link xlink:href="qt.xml#ConnectionType-enum">Qt::ConnectionType</db:link>).</db:para>
</db:warning>
<db:warning>
<db:para>When using the OpenGL adaptation, make sure that a signal handler for afterSynchronizing leaves the OpenGL context in the same state as it was when the signal handler was entered. Failing to do so can result in the scene not rendering properly.</db:para>
</db:warning>
<db:para>This function was introduced in Qt 5.3.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qquickwindow.xml#resetOpenGLState">resetOpenGLState</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="beforeRendering">
<db:title>void QQuickWindow::beforeRendering()</db:title>
<db:para>This signal is emitted before the scene starts rendering.</db:para>
<db:para>Combined with the modes for clearing the background, this option can be used to paint using raw OpenGL under QML content.</db:para>
<db:para>The OpenGL context used for rendering the scene graph will be bound at this point.</db:para>
<db:warning>
<db:para>This signal is emitted from the scene graph rendering thread. If your slot function needs to finish before execution continues, you must make sure that the connection is direct (see <db:link xlink:href="qt.xml#ConnectionType-enum">Qt::ConnectionType</db:link>).</db:para>
</db:warning>
<db:warning>
<db:para>Make very sure that a signal handler for beforeRendering leaves the OpenGL context in the same state as it was when the signal handler was entered. Failing to do so can result in the scene not rendering properly.</db:para>
</db:warning>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qquickwindow.xml#resetOpenGLState">resetOpenGLState</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="beforeSynchronizing">
<db:title>void QQuickWindow::beforeSynchronizing()</db:title>
<db:para>This signal is emitted before the scene graph is synchronized with the QML state.</db:para>
<db:para>This signal can be used to do any preparation required before calls to <db:link xlink:href="qquickitem.xml#updatePaintNode">QQuickItem::updatePaintNode</db:link>().</db:para>
<db:para>The OpenGL context used for rendering the scene graph will be bound at this point.</db:para>
<db:warning>
<db:para>This signal is emitted from the scene graph rendering thread. If your slot function needs to finish before execution continues, you must make sure that the connection is direct (see <db:link xlink:href="qt.xml#ConnectionType-enum">Qt::ConnectionType</db:link>).</db:para>
</db:warning>
<db:warning>
<db:para>Make very sure that a signal handler for beforeSynchronizing leaves the GL context in the same state as it was when the signal handler was entered. Failing to do so can result in the scene not rendering properly.</db:para>
</db:warning>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qquickwindow.xml#resetOpenGLState">resetOpenGLState</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="clearBeforeRendering">
<db:title>bool QQuickWindow::clearBeforeRendering() const</db:title>
<db:para>Returns whether clearing of the color buffer is done before rendering or not.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qquickwindow.xml#setClearBeforeRendering">setClearBeforeRendering</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="closing">
<db:title>[since 5.1] void QQuickWindow::closing(QQuickCloseEvent *<db:emphasis>close</db:emphasis>)</db:title>
<db:para>This signal is emitted when the window receives the event <db:code role="parameter">close</db:code> from the windowing system.</db:para>
<db:para>This function was introduced in Qt 5.1.</db:para>
</db:section>
<db:section xml:id="createImageNode">
<db:title>[since 5.8] QSGImageNode *QQuickWindow::createImageNode() const</db:title>
<db:para>Creates a simple image node. When the scenegraph is not initialized, the return value is null.</db:para>
<db:para>This is cross-backend alternative to constructing a QSGSimpleTextureNode directly.</db:para>
<db:para>This function was introduced in Qt 5.8.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qsgimagenode.xml">QSGImageNode</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="createNinePatchNode">
<db:title>[since 5.8] QSGNinePatchNode *QQuickWindow::createNinePatchNode() const</db:title>
<db:para>Creates a nine patch node. When the scenegraph is not initialized, the return value is null.</db:para>
<db:para>This function was introduced in Qt 5.8.</db:para>
</db:section>
<db:section xml:id="createRectangleNode">
<db:title>[since 5.8] QSGRectangleNode *QQuickWindow::createRectangleNode() const</db:title>
<db:para>Creates a simple rectangle node. When the scenegraph is not initialized, the return value is null.</db:para>
<db:para>This is cross-backend alternative to constructing a QSGSimpleRectNode directly.</db:para>
<db:para>This function was introduced in Qt 5.8.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qsgrectanglenode.xml">QSGRectangleNode</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="createTextureFromId">
<db:title>QSGTexture *QQuickWindow::createTextureFromId(uint <db:emphasis>id</db:emphasis>, const QSize &amp;<db:emphasis>size</db:emphasis>, QQuickWindow::CreateTextureOptions <db:emphasis>options</db:emphasis> = CreateTextureOption()) const</db:title>
<db:para>Creates a new <db:link xlink:href="qsgtexture.xml">QSGTexture</db:link> object from an existing OpenGL texture <db:code role="parameter">id</db:code> and <db:code role="parameter">size</db:code>.</db:para>
<db:para>The caller of the function is responsible for deleting the returned texture.</db:para>
<db:para>The returned texture will be using <db:code>GL_TEXTURE_2D</db:code> as texture target and assumes that internal format is <db:code>GL_RGBA</db:code>. Reimplement <db:link xlink:href="qsgtexture.xml">QSGTexture</db:link> to create textures with different parameters.</db:para>
<db:para>Use <db:code role="parameter">options</db:code> to customize the texture attributes. The TextureUsesAtlas option is ignored.</db:para>
<db:warning>
<db:para>This function will return null if the scenegraph has not yet been initialized or OpenGL is not in use.</db:para>
</db:warning>
<db:note>
<db:para>This function only has an effect when using the default OpenGL scene graph adpation.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qquickwindow.xml#sceneGraphInitialized">sceneGraphInitialized</db:link>()</db:member>
<db:member><db:link xlink:href="qsgtexture.xml">QSGTexture</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="createTextureFromImage">
<db:title>QSGTexture *QQuickWindow::createTextureFromImage(const QImage &amp;<db:emphasis>image</db:emphasis>, QQuickWindow::CreateTextureOptions <db:emphasis>options</db:emphasis>) const</db:title>
<db:para>Creates a new <db:link xlink:href="qsgtexture.xml">QSGTexture</db:link> from the supplied <db:code role="parameter">image</db:code>. If the image has an alpha channel, the corresponding texture will have an alpha channel.</db:para>
<db:para>The caller of the function is responsible for deleting the returned texture. For example whe using the OpenGL adaptation the actual OpenGL texture will be deleted when the texture object is deleted.</db:para>
<db:para>When <db:code role="parameter">options</db:code> contains <db:link xlink:href="qquickwindow.xml#CreateTextureOption-enum">TextureCanUseAtlas</db:link>, the engine may put the image into a texture atlas. Textures in an atlas need to rely on <db:link xlink:href="qsgtexture.xml#normalizedTextureSubRect">QSGTexture::normalizedTextureSubRect</db:link>() for their geometry and will not support <db:link xlink:href="qsgtexture.xml#WrapMode-enum">QSGTexture::Repeat</db:link>. Other values from <db:link xlink:href="qquickwindow.xml#CreateTextureOption-enum">CreateTextureOption</db:link> are ignored.</db:para>
<db:para>When <db:code role="parameter">options</db:code> contains <db:link xlink:href="qquickwindow.xml#CreateTextureOption-enum">TextureIsOpaque</db:link>, the engine will create an RGB texture which returns false for <db:link xlink:href="qsgtexture.xml#hasAlphaChannel">QSGTexture::hasAlphaChannel</db:link>(). Opaque textures will in most cases be faster to render. When this flag is not set, the texture will have an alpha channel based on the image's format.</db:para>
<db:para>When <db:code role="parameter">options</db:code> contains <db:link xlink:href="qquickwindow.xml#CreateTextureOption-enum">TextureHasMipmaps</db:link>, the engine will create a texture which can use mipmap filtering. Mipmapped textures can not be in an atlas.</db:para>
<db:para>When using the OpenGL adaptation, the returned texture will be using <db:code>GL_TEXTURE_2D</db:code> as texture target and <db:code>GL_RGBA</db:code> as internal format. Reimplement <db:link xlink:href="qsgtexture.xml">QSGTexture</db:link> to create textures with different parameters.</db:para>
<db:warning>
<db:para>This function will return 0 if the scene graph has not yet been initialized.</db:para>
</db:warning>
<db:warning>
<db:para>The returned texture is not memory managed by the scene graph and must be explicitly deleted by the caller on the rendering thread. This is achieved by deleting the texture from a <db:link xlink:href="qsgnode.xml">QSGNode</db:link> destructor or by using <db:link xlink:href="qobject.xml#deleteLater">deleteLater</db:link>() in the case where the texture already has affinity to the rendering thread.</db:para>
</db:warning>
<db:para>This function can be called from any thread.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qquickwindow.xml#sceneGraphInitialized">sceneGraphInitialized</db:link>()</db:member>
<db:member><db:link xlink:href="qsgtexture.xml">QSGTexture</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="createTextureFromImage-1">
<db:title>QSGTexture *QQuickWindow::createTextureFromImage(const QImage &amp;<db:emphasis>image</db:emphasis>) const</db:title>
<db:para>This is an overloaded function.</db:para>
</db:section>
<db:section xml:id="effectiveDevicePixelRatio">
<db:title>qreal QQuickWindow::effectiveDevicePixelRatio() const</db:title>
<db:para>Returns the device pixel ratio for this window.</db:para>
<db:para>This is different from <db:link xlink:href="qwindow.xml#devicePixelRatio">QWindow::devicePixelRatio</db:link>() in that it supports redirected rendering via <db:link xlink:href="qquickrendercontrol.xml">QQuickRenderControl</db:link>. When using a <db:link xlink:href="qquickrendercontrol.xml">QQuickRenderControl</db:link>, the <db:link xlink:href="qquickwindow.xml">QQuickWindow</db:link> is often not created, meaning it is never shown and there is no underlying native window created in the windowing system. As a result, querying properties like the device pixel ratio cannot give correct results. Use this function instead.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qwindow.xml#devicePixelRatio">QWindow::devicePixelRatio</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="event">
<db:title>[override virtual protected] bool QQuickWindow::event(QEvent *<db:emphasis>e</db:emphasis>)</db:title>
<db:para>Reimplements: <db:link xlink:href="qwindow.xml#event" role="function">QWindow::event(QEvent *ev)</db:link>.</db:para>
</db:section>
<db:section xml:id="exposeEvent">
<db:title>[override virtual protected] void QQuickWindow::exposeEvent(<db:emphasis>QExposeEvent *</db:emphasis>)</db:title>
<db:para>Reimplements: <db:link xlink:href="qwindow.xml#exposeEvent" role="function">QWindow::exposeEvent(QExposeEvent *ev)</db:link>.</db:para>
</db:section>
<db:section xml:id="focusInEvent">
<db:title>[override virtual protected] void QQuickWindow::focusInEvent(QFocusEvent *<db:emphasis>ev</db:emphasis>)</db:title>
<db:para>Reimplements: <db:link xlink:href="qwindow.xml#focusInEvent" role="function">QWindow::focusInEvent(QFocusEvent *ev)</db:link>.</db:para>
</db:section>
<db:section xml:id="focusOutEvent">
<db:title>[override virtual protected] void QQuickWindow::focusOutEvent(QFocusEvent *<db:emphasis>ev</db:emphasis>)</db:title>
<db:para>Reimplements: <db:link xlink:href="qwindow.xml#focusOutEvent" role="function">QWindow::focusOutEvent(QFocusEvent *ev)</db:link>.</db:para>
</db:section>
<db:section xml:id="frameSwapped">
<db:title>void QQuickWindow::frameSwapped()</db:title>
<db:para>This signal is emitted when a frame has been queued for presenting. With vertical synchronization enabled the signal is emitted at most once per vsync interval in a continuously animating scene.</db:para>
<db:para>This signal will be emitted from the scene graph rendering thread.</db:para>
</db:section>
<db:section xml:id="grabWindow">
<db:title>QImage QQuickWindow::grabWindow()</db:title>
<db:para>Grabs the contents of the window and returns it as an image.</db:para>
<db:para>It is possible to call the grabWindow() function when the window is not visible. This requires that the window is <db:link xlink:href="qwindow.xml#create">created</db:link> and has a valid size and that no other <db:link xlink:href="qquickwindow.xml">QQuickWindow</db:link> instances are rendering in the same process.</db:para>
<db:warning>
<db:para>Calling this function will cause performance problems.</db:para>
</db:warning>
<db:warning>
<db:para>This function can only be called from the GUI thread.</db:para>
</db:warning>
</db:section>
<db:section xml:id="hasDefaultAlphaBuffer">
<db:title>[static, since 5.1] bool QQuickWindow::hasDefaultAlphaBuffer()</db:title>
<db:para>Returns whether to use alpha transparency on newly created windows.</db:para>
<db:para>This function was introduced in Qt 5.1.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qquickwindow.xml#setDefaultAlphaBuffer">setDefaultAlphaBuffer</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="hideEvent">
<db:title>[override virtual protected] void QQuickWindow::hideEvent(<db:emphasis>QHideEvent *</db:emphasis>)</db:title>
<db:para>Reimplements: <db:link xlink:href="qwindow.xml#hideEvent" role="function">QWindow::hideEvent(QHideEvent *ev)</db:link>.</db:para>
</db:section>
<db:section xml:id="incubationController">
<db:title>QQmlIncubationController *QQuickWindow::incubationController() const</db:title>
<db:para>Returns an incubation controller that splices incubation between frames for this window. <db:link xlink:href="qquickview.xml">QQuickView</db:link> automatically installs this controller for you, otherwise you will need to install it yourself using <db:link xlink:href="qqmlengine.xml#setIncubationController">QQmlEngine::setIncubationController</db:link>().</db:para>
<db:para>The controller is owned by the window and will be destroyed when the window is deleted.</db:para>
</db:section>
<db:section xml:id="isPersistentOpenGLContext">
<db:title>bool QQuickWindow::isPersistentOpenGLContext() const</db:title>
<db:para>Returns whether the OpenGL context can be released during the lifetime of the <db:link xlink:href="qquickwindow.xml">QQuickWindow</db:link>.</db:para>
<db:note>
<db:para>This is a hint. When and how this happens is implementation specific. It also only has an effect when using the default OpenGL scene graph adaptation</db:para>
</db:note>
</db:section>
<db:section xml:id="isPersistentSceneGraph">
<db:title>bool QQuickWindow::isPersistentSceneGraph() const</db:title>
<db:para>Returns whether the scene graph nodes and resources can be released during the lifetime of this <db:link xlink:href="qquickwindow.xml">QQuickWindow</db:link>.</db:para>
<db:note>
<db:para>This is a hint. When and how this happens is implementation specific.</db:para>
</db:note>
</db:section>
<db:section xml:id="isSceneGraphInitialized">
<db:title>bool QQuickWindow::isSceneGraphInitialized() const</db:title>
<db:para>Returns true if the scene graph has been initialized; otherwise returns false.</db:para>
</db:section>
<db:section xml:id="keyPressEvent">
<db:title>[override virtual protected] void QQuickWindow::keyPressEvent(QKeyEvent *<db:emphasis>e</db:emphasis>)</db:title>
<db:para>Reimplements: <db:link xlink:href="qwindow.xml#keyPressEvent" role="function">QWindow::keyPressEvent(QKeyEvent *ev)</db:link>.</db:para>
</db:section>
<db:section xml:id="keyReleaseEvent">
<db:title>[override virtual protected] void QQuickWindow::keyReleaseEvent(QKeyEvent *<db:emphasis>e</db:emphasis>)</db:title>
<db:para>Reimplements: <db:link xlink:href="qwindow.xml#keyReleaseEvent" role="function">QWindow::keyReleaseEvent(QKeyEvent *ev)</db:link>.</db:para>
</db:section>
<db:section xml:id="mouseDoubleClickEvent">
<db:title>[override virtual protected] void QQuickWindow::mouseDoubleClickEvent(QMouseEvent *<db:emphasis>event</db:emphasis>)</db:title>
<db:para>Reimplements: <db:link xlink:href="qwindow.xml#mouseDoubleClickEvent" role="function">QWindow::mouseDoubleClickEvent(QMouseEvent *ev)</db:link>.</db:para>
</db:section>
<db:section xml:id="mouseGrabberItem">
<db:title>QQuickItem *QQuickWindow::mouseGrabberItem() const</db:title>
<db:para>Returns the item which currently has the mouse grab.</db:para>
</db:section>
<db:section xml:id="mouseMoveEvent">
<db:title>[override virtual protected] void QQuickWindow::mouseMoveEvent(QMouseEvent *<db:emphasis>event</db:emphasis>)</db:title>
<db:para>Reimplements: <db:link xlink:href="qwindow.xml#mouseMoveEvent" role="function">QWindow::mouseMoveEvent(QMouseEvent *ev)</db:link>.</db:para>
</db:section>
<db:section xml:id="mousePressEvent">
<db:title>[override virtual protected] void QQuickWindow::mousePressEvent(QMouseEvent *<db:emphasis>event</db:emphasis>)</db:title>
<db:para>Reimplements: <db:link xlink:href="qwindow.xml#mousePressEvent" role="function">QWindow::mousePressEvent(QMouseEvent *ev)</db:link>.</db:para>
</db:section>
<db:section xml:id="mouseReleaseEvent">
<db:title>[override virtual protected] void QQuickWindow::mouseReleaseEvent(QMouseEvent *<db:emphasis>event</db:emphasis>)</db:title>
<db:para>Reimplements: <db:link xlink:href="qwindow.xml#mouseReleaseEvent" role="function">QWindow::mouseReleaseEvent(QMouseEvent *ev)</db:link>.</db:para>
</db:section>
<db:section xml:id="openglContext">
<db:title>QOpenGLContext *QQuickWindow::openglContext() const</db:title>
<db:para>Returns the OpenGL context used for rendering.</db:para>
<db:para>If the scene graph is not ready, or the scene graph is not using OpenGL, this function will return null.</db:para>
<db:note>
<db:para>If using a scene graph adaptation other than OpenGL this function will return nullptr.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qquickwindow.xml#sceneGraphInitialized">sceneGraphInitialized</db:link>()</db:member>
<db:member><db:link xlink:href="qquickwindow.xml#sceneGraphInvalidated">sceneGraphInvalidated</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="openglContextCreated">
<db:title>[since 5.3] void QQuickWindow::openglContextCreated(QOpenGLContext *<db:emphasis>context</db:emphasis>)</db:title>
<db:para>This signal is emitted on the gui thread when the OpenGL <db:code role="parameter">context</db:code> for this window is created, before it is made current.</db:para>
<db:para>Some implementations will share the same OpenGL context between multiple <db:link xlink:href="qquickwindow.xml">QQuickWindow</db:link> instances. The openglContextCreated() signal will in this case only be emitted for the first window, when the OpenGL context is actually created.</db:para>
<db:para><db:link xlink:href="qquickwindow.xml#openglContext">QQuickWindow::openglContext</db:link>() will still return 0 for this window until after the QQuickWindow::sceneGraphInitialize() has been emitted.</db:para>
<db:note>
<db:para>This signal will only be emmited when using the default OpenGL scene graph adaptation.</db:para>
</db:note>
<db:para>This function was introduced in Qt 5.3.</db:para>
</db:section>
<db:section xml:id="releaseResources">
<db:title>void QQuickWindow::releaseResources()</db:title>
<db:para>This function tries to release redundant resources currently held by the QML scene.</db:para>
<db:para>Calling this function might result in the scene graph and the OpenGL context used for rendering being released to release graphics memory. If this happens, the <db:link xlink:href="qquickwindow.xml#sceneGraphInvalidated">sceneGraphInvalidated</db:link>() signal will be called, allowing users to clean up their own graphics resources. The <db:link xlink:href="qquickwindow.xml#setPersistentOpenGLContext">setPersistentOpenGLContext</db:link>() and <db:link xlink:href="qquickwindow.xml#setPersistentSceneGraph">setPersistentSceneGraph</db:link>() functions can be used to prevent this from happening, if handling the cleanup is not feasible in the application, at the cost of higher memory usage.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qquickwindow.xml#sceneGraphInvalidated">sceneGraphInvalidated</db:link>()</db:member>
<db:member><db:link xlink:href="qquickwindow.xml#setPersistentOpenGLContext">setPersistentOpenGLContext</db:link>()</db:member>
<db:member><db:link xlink:href="qquickwindow.xml#setPersistentSceneGraph">setPersistentSceneGraph</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="renderTarget">
<db:title>QOpenGLFramebufferObject *QQuickWindow::renderTarget() const</db:title>
<db:para>Returns the render target for this window.</db:para>
<db:para>The default is to render to the surface of the window, in which case the render target is 0.</db:para>
<db:note>
<db:para>This function will return nullptr when not using the OpenGL scene graph adaptation.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qquickwindow.xml#setRenderTarget">setRenderTarget</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="renderTargetId">
<db:title>uint QQuickWindow::renderTargetId() const</db:title>
<db:para>Returns the FBO id of the render target when set; otherwise returns 0.</db:para>
</db:section>
<db:section xml:id="renderTargetSize">
<db:title>QSize QQuickWindow::renderTargetSize() const</db:title>
<db:para>Returns the size of the currently set render target; otherwise returns an empty size.</db:para>
</db:section>
<db:section xml:id="rendererInterface">
<db:title>[since 5.8] QSGRendererInterface *QQuickWindow::rendererInterface() const</db:title>
<db:para>Returns the current renderer interface. The value is always valid and is never null.</db:para>
<db:note>
<db:para>This function can be called at any time after constructing the <db:link xlink:href="qquickwindow.xml">QQuickWindow</db:link>, even while <db:link xlink:href="qquickwindow.xml#isSceneGraphInitialized">isSceneGraphInitialized</db:link>() is still false. However, some renderer interface functions, in particular <db:link xlink:href="qsgrendererinterface.xml#getResource">QSGRendererInterface::getResource</db:link>() will not be functional until the scenegraph is up and running. Backend queries, like <db:link xlink:href="qsgrendererinterface.xml#graphicsApi">QSGRendererInterface::graphicsApi</db:link>() or <db:link xlink:href="qsgrendererinterface.xml#shaderType">QSGRendererInterface::shaderType</db:link>(), will always be functional on the other hand.</db:para>
</db:note>
<db:note>
<db:para>The ownership of the returned pointer stays with Qt. The returned instance may or may not be shared between different <db:link xlink:href="qquickwindow.xml">QQuickWindow</db:link> instances, depending on the scenegraph backend in use. Therefore applications are expected to query the interface object for each <db:link xlink:href="qquickwindow.xml">QQuickWindow</db:link> instead of reusing the already queried pointer.</db:para>
</db:note>
<db:para>This function was introduced in Qt 5.8.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qsgrendernode.xml">QSGRenderNode</db:link></db:member>
<db:member><db:link xlink:href="qsgrendererinterface.xml">QSGRendererInterface</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="resetOpenGLState">
<db:title>[since 5.2] void QQuickWindow::resetOpenGLState()</db:title>
<db:para>Call this function to reset the OpenGL context its default state.</db:para>
<db:para>The scene graph uses the OpenGL context and will both rely on and clobber its state. When mixing raw OpenGL commands with scene graph rendering, this function provides a convenient way of resetting the OpenGL context state back to its default values.</db:para>
<db:para>This function does not touch state in the fixed-function pipeline.</db:para>
<db:para>This function does not clear the color, depth and stencil buffers. Use <db:link xlink:href="qquickwindow.xml#setClearBeforeRendering">QQuickWindow::setClearBeforeRendering</db:link> to control clearing of the color buffer. The depth and stencil buffer might be clobbered by the scene graph renderer. Clear these manually on demand.</db:para>
<db:note>
<db:para>This function only has an effect when using the default OpenGL scene graph adpation.</db:para>
</db:note>
<db:para>This function was introduced in Qt 5.2.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qquickwindow.xml#beforeRendering">QQuickWindow::beforeRendering</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="resizeEvent">
<db:title>[override virtual protected] void QQuickWindow::resizeEvent(QResizeEvent *<db:emphasis>ev</db:emphasis>)</db:title>
<db:para>Reimplements: <db:link xlink:href="qwindow.xml#resizeEvent" role="function">QWindow::resizeEvent(QResizeEvent *ev)</db:link>.</db:para>
</db:section>
<db:section xml:id="sceneGraphAboutToStop">
<db:title>[since 5.3] void QQuickWindow::sceneGraphAboutToStop()</db:title>
<db:para>This signal is emitted on the render thread when the scene graph is about to stop rendering. This happens usually because the window has been hidden.</db:para>
<db:para>Applications may use this signal to release resources, but should be prepared to reinstantiated them again fast. The scene graph and the graphics context are not released at this time.</db:para>
<db:warning>
<db:para>This signal is emitted from the scene graph rendering thread. If your slot function needs to finish before execution continues, you must make sure that the connection is direct (see <db:link xlink:href="qt.xml#ConnectionType-enum">Qt::ConnectionType</db:link>).</db:para>
</db:warning>
<db:warning>
<db:para>Make very sure that a signal handler for sceneGraphAboutToStop() leaves the graphics context in the same state as it was when the signal handler was entered. Failing to do so can result in the scene not rendering properly.</db:para>
</db:warning>
<db:para>This function was introduced in Qt 5.3.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qquickwindow.xml#sceneGraphInvalidated">sceneGraphInvalidated</db:link>()</db:member>
<db:member><db:link xlink:href="qquickwindow.xml#resetOpenGLState">resetOpenGLState</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="sceneGraphError">
<db:title>[since 5.3] void QQuickWindow::sceneGraphError(QQuickWindow::SceneGraphError <db:emphasis>error</db:emphasis>, const QString &amp;<db:emphasis>message</db:emphasis>)</db:title>
<db:para>This signal is emitted when an <db:code role="parameter">error</db:code> occurred during scene graph initialization.</db:para>
<db:para>Applications should connect to this signal if they wish to handle errors, like graphics context creation failures, in a custom way. When no slot is connected to the signal, the behavior will be different: Quick will print the <db:code role="parameter">message</db:code>, or show a message box, and terminate the application.</db:para>
<db:para>This signal will be emitted from the gui thread.</db:para>
<db:para>This function was introduced in Qt 5.3.</db:para>
</db:section>
<db:section xml:id="sceneGraphInitialized">
<db:title>void QQuickWindow::sceneGraphInitialized()</db:title>
<db:para>This signal is emitted when the scene graph has been initialized.</db:para>
<db:para>This signal will be emitted from the scene graph rendering thread.</db:para>
</db:section>
<db:section xml:id="sceneGraphInvalidated">
<db:title>void QQuickWindow::sceneGraphInvalidated()</db:title>
<db:para>This signal is emitted when the scene graph has been invalidated.</db:para>
<db:para>This signal implies that the graphics rendering context used has been invalidated and all user resources tied to that context should be released.</db:para>
<db:para>In the case of the default OpenGL adaptation the context of this window will be bound when this function is called. The only exception is if the native OpenGL has been destroyed outside Qt's control, for instance through EGL_CONTEXT_LOST.</db:para>
<db:para>This signal will be emitted from the scene graph rendering thread.</db:para>
</db:section>
<db:section xml:id="scheduleRenderJob">
<db:title>[since 5.4] void QQuickWindow::scheduleRenderJob(QRunnable *<db:emphasis>job</db:emphasis>, QQuickWindow::RenderStage <db:emphasis>stage</db:emphasis>)</db:title>
<db:para>Schedules <db:code role="parameter">job</db:code> to run when the rendering of this window reaches the given <db:code role="parameter">stage</db:code>.</db:para>
<db:para>This is a convenience to the equivalent signals in <db:link xlink:href="qquickwindow.xml">QQuickWindow</db:link> for &quot;one shot&quot; tasks.</db:para>
<db:para>The window takes ownership over <db:code role="parameter">job</db:code> and will delete it when the job is completed.</db:para>
<db:para>If rendering is shut down before <db:code role="parameter">job</db:code> has a chance to run, the job will be run and then deleted as part of the scene graph cleanup. If the window is never shown and no rendering happens before the <db:link xlink:href="qquickwindow.xml">QQuickWindow</db:link> is destroyed, all pending jobs will be destroyed without their run() method being called.</db:para>
<db:para>If the rendering is happening on a different thread, then the job will happen on the rendering thread.</db:para>
<db:para>If <db:code role="parameter">stage</db:code> is <db:link xlink:href="qquickwindow.xml#RenderStage-enum">NoStage</db:link>, <db:code role="parameter">job</db:code> will be run at the earliest opportunity whenever the render thread is not busy rendering a frame. If there is no OpenGL context available or the window is not exposed at the time the job is either posted or handled, it is deleted without executing the run() method. If a non-threaded renderer is in use, the run() method of the job is executed synchronously. The OpenGL context is changed to the renderer context before executing a <db:link xlink:href="qquickwindow.xml#RenderStage-enum">NoStage</db:link> job.</db:para>
<db:note>
<db:para>This function does not trigger rendering; the jobs targeting any other stage than <db:link xlink:href="qquickwindow.xml#RenderStage-enum">NoStage</db:link> will be stored run until rendering is triggered elsewhere. To force the job to run earlier, call <db:link xlink:href="qquickwindow.xml#update">QQuickWindow::update</db:link>();</db:para>
</db:note>
<db:para>This function was introduced in Qt 5.4.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qquickwindow.xml#beforeRendering">beforeRendering</db:link>()</db:member>
<db:member><db:link xlink:href="qquickwindow.xml#afterRendering">afterRendering</db:link>()</db:member>
<db:member><db:link xlink:href="qquickwindow.xml#beforeSynchronizing">beforeSynchronizing</db:link>()</db:member>
<db:member><db:link xlink:href="qquickwindow.xml#afterSynchronizing">afterSynchronizing</db:link>()</db:member>
<db:member><db:link xlink:href="qquickwindow.xml#frameSwapped">frameSwapped</db:link>()</db:member>
<db:member><db:link xlink:href="qquickwindow.xml#sceneGraphInvalidated">sceneGraphInvalidated</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setClearBeforeRendering">
<db:title>void QQuickWindow::setClearBeforeRendering(bool <db:emphasis>enabled</db:emphasis>)</db:title>
<db:para>Sets whether the scene graph rendering of QML should clear the color buffer before it starts rendering to <db:code role="parameter">enabled</db:code>.</db:para>
<db:para>By disabling clearing of the color buffer, it is possible to render OpengGL content under the scene graph.</db:para>
<db:para>The color buffer is cleared by default.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qquickwindow.xml#clearBeforeRendering">clearBeforeRendering</db:link>()</db:member>
<db:member><db:link xlink:href="qquickwindow.xml#beforeRendering">beforeRendering</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setDefaultAlphaBuffer">
<db:title>[static, since 5.1] void QQuickWindow::setDefaultAlphaBuffer(bool <db:emphasis>useAlpha</db:emphasis>)</db:title>
<db:para><db:code role="parameter">useAlpha</db:code> specifies whether to use alpha transparency on newly created windows.</db:para>
<db:para>In any application which expects to create translucent windows, it's necessary to set this to true before creating the first <db:link xlink:href="qquickwindow.xml">QQuickWindow</db:link>. The default value is false.</db:para>
<db:para>This function was introduced in Qt 5.1.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qquickwindow.xml#hasDefaultAlphaBuffer">hasDefaultAlphaBuffer</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setPersistentOpenGLContext">
<db:title>void QQuickWindow::setPersistentOpenGLContext(bool <db:emphasis>persistent</db:emphasis>)</db:title>
<db:para>Sets whether the OpenGL context should be preserved, and cannot be released until the last window is deleted, to <db:code role="parameter">persistent</db:code>. The default value is true.</db:para>
<db:para>The OpenGL context can be released to free up graphics resources when the window is obscured, hidden or not rendering. When this happens is implementation specific.</db:para>
<db:para>The <db:link xlink:href="qopenglcontext.xml#aboutToBeDestroyed">QOpenGLContext::aboutToBeDestroyed</db:link>() signal is emitted from the <db:link xlink:href="qquickwindow.xml#openglContext">QQuickWindow::openglContext</db:link>() when the OpenGL context is about to be released. The <db:link xlink:href="qquickwindow.xml#sceneGraphInitialized">QQuickWindow::sceneGraphInitialized</db:link>() signal is emitted when a new OpenGL context is created for this window. Make a <db:link xlink:href="qt.xml#ConnectionType-enum">Qt::DirectConnection</db:link> to these signals to be notified.</db:para>
<db:para>The OpenGL context is still released when the last <db:link xlink:href="qquickwindow.xml">QQuickWindow</db:link> is deleted.</db:para>
<db:note>
<db:para>This only has an effect when using the default OpenGL scene graph adaptation.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qquickwindow.xml#isPersistentOpenGLContext">isPersistentOpenGLContext</db:link>()</db:member>
<db:member><db:link xlink:href="qquickwindow.xml#setPersistentSceneGraph">setPersistentSceneGraph</db:link>()</db:member>
<db:member><db:link xlink:href="qopenglcontext.xml#aboutToBeDestroyed">QOpenGLContext::aboutToBeDestroyed</db:link>()</db:member>
<db:member><db:link xlink:href="qquickwindow.xml#sceneGraphInitialized">sceneGraphInitialized</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setPersistentSceneGraph">
<db:title>void QQuickWindow::setPersistentSceneGraph(bool <db:emphasis>persistent</db:emphasis>)</db:title>
<db:para>Sets whether the scene graph nodes and resources can be released to <db:code role="parameter">persistent</db:code>. The default value is true.</db:para>
<db:para>The scene graph nodes and resources can be released to free up graphics resources when the window is obscured, hidden or not rendering. When this happens is implementation specific.</db:para>
<db:para>The <db:link xlink:href="qquickwindow.xml#sceneGraphInvalidated">QQuickWindow::sceneGraphInvalidated</db:link>() signal is emitted when cleanup occurs. The <db:link xlink:href="qquickwindow.xml#sceneGraphInitialized">QQuickWindow::sceneGraphInitialized</db:link>() signal is emitted when a new scene graph is recreated for this window. Make a <db:link xlink:href="qt.xml#ConnectionType-enum">Qt::DirectConnection</db:link> to these signals to be notified.</db:para>
<db:para>The scene graph nodes and resources are still released when the last <db:link xlink:href="qquickwindow.xml">QQuickWindow</db:link> is deleted.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qquickwindow.xml#isPersistentSceneGraph">isPersistentSceneGraph</db:link>()</db:member>
<db:member><db:link xlink:href="qquickwindow.xml#setPersistentOpenGLContext">setPersistentOpenGLContext</db:link>()</db:member>
<db:member><db:link xlink:href="qquickwindow.xml#sceneGraphInvalidated">sceneGraphInvalidated</db:link>()</db:member>
<db:member><db:link xlink:href="qquickwindow.xml#sceneGraphInitialized">sceneGraphInitialized</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setRenderTarget">
<db:title>void QQuickWindow::setRenderTarget(QOpenGLFramebufferObject *<db:emphasis>fbo</db:emphasis>)</db:title>
<db:para>Sets the render target for this window to be <db:code role="parameter">fbo</db:code>.</db:para>
<db:para>The specified fbo must be created in the context of the window or one that shares with it.</db:para>
<db:note>
<db:para>This function only has an effect when using the default OpenGL scene graph adaptation.</db:para>
</db:note>
<db:warning>
<db:para>This function can only be called from the thread doing the rendering.</db:para>
</db:warning>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qquickwindow.xml#renderTarget">renderTarget</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setRenderTarget-1">
<db:title>void QQuickWindow::setRenderTarget(uint <db:emphasis>fboId</db:emphasis>, const QSize &amp;<db:emphasis>size</db:emphasis>)</db:title>
<db:para>This is an overloaded function.</db:para>
<db:para>Sets the render target for this window to be an FBO with <db:code role="parameter">fboId</db:code> and <db:code role="parameter">size</db:code>.</db:para>
<db:para>The specified FBO must be created in the context of the window or one that shares with it.</db:para>
<db:note>
<db:para>This function only has an effect when using the default OpenGL scene graph adaptation.</db:para>
</db:note>
<db:warning>
<db:para>This function can only be called from the thread doing the rendering.</db:para>
</db:warning>
</db:section>
<db:section xml:id="setSceneGraphBackend">
<db:title>[static, since 5.8] void QQuickWindow::setSceneGraphBackend(QSGRendererInterface::GraphicsApi <db:emphasis>api</db:emphasis>)</db:title>
<db:para>Requests a Qt Quick scenegraph backend for the specified graphics <db:code role="parameter">api</db:code>. Backends can either be built-in or be installed in form of dynamically loaded plugins.</db:para>
<db:note>
<db:para>The call to the function must happen before constructing the first <db:link xlink:href="qquickwindow.xml">QQuickWindow</db:link> in the application. It cannot be changed afterwards.</db:para>
</db:note>
<db:para>If <db:code role="parameter">backend</db:code> is invalid or an error occurs, the default backend (OpenGL or software, depending on the Qt configuration) is used.</db:para>
<db:para>This function was introduced in Qt 5.8.</db:para>
</db:section>
<db:section xml:id="setSceneGraphBackend-1">
<db:title>[static, since 5.8] void QQuickWindow::setSceneGraphBackend(const QString &amp;<db:emphasis>backend</db:emphasis>)</db:title>
<db:para>Requests the specified Qt Quick scenegraph <db:code role="parameter">backend</db:code>. Backends can either be built-in or be installed in form of dynamically loaded plugins.</db:para>
<db:para>This is an overloaded function.</db:para>
<db:note>
<db:para>The call to the function must happen before constructing the first <db:link xlink:href="qquickwindow.xml">QQuickWindow</db:link> in the application. It cannot be changed afterwards.</db:para>
</db:note>
<db:para>If <db:code role="parameter">backend</db:code> is invalid or an error occurs, the default backend (OpenGL or software, depending on the Qt configuration) is used.</db:para>
<db:note>
<db:para>Calling this function is equivalent to setting the <db:code>QT_QUICK_BACKEND</db:code> or <db:code>QMLSCENE_DEVICE</db:code> environment variables. However, this API is safer to use in applications that spawn other processes as there is no need to worry about environment inheritance.</db:para>
</db:note>
<db:para>This function was introduced in Qt 5.8.</db:para>
</db:section>
<db:section xml:id="showEvent">
<db:title>[override virtual protected] void QQuickWindow::showEvent(<db:emphasis>QShowEvent *</db:emphasis>)</db:title>
<db:para>Reimplements: <db:link xlink:href="qwindow.xml#showEvent" role="function">QWindow::showEvent(QShowEvent *ev)</db:link>.</db:para>
</db:section>
<db:section xml:id="update">
<db:title>void QQuickWindow::update()</db:title>
<db:para>Schedules the window to render another frame.</db:para>
<db:para>Calling QQuickWindow::update() differs from <db:link xlink:href="qquickitem.xml#update">QQuickItem::update</db:link>() in that it always triggers a repaint, regardless of changes in the underlying scene graph or not.</db:para>
</db:section>
<db:section xml:id="wheelEvent">
<db:title>[override virtual protected] void QQuickWindow::wheelEvent(QWheelEvent *<db:emphasis>event</db:emphasis>)</db:title>
<db:para>Reimplements: <db:link xlink:href="qwindow.xml#wheelEvent" role="function">QWindow::wheelEvent(QWheelEvent *ev)</db:link>.</db:para>
</db:section>
</db:section>
</db:article>
