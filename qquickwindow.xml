<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en">
<db:info>
<db:title>QQuickWindow Class</db:title>
<db:productname>QtQuick</db:productname>
<db:edition>Qt 6.1.3 Reference Documentation</db:edition>
<db:titleabbrev>Qt Quick Reference Documentation</db:titleabbrev>
<db:abstract>
<db:para>The <db:link xlink:href="qquickwindow.xml">QQuickWindow</db:link> class provides the window for displaying a graphical QML scene.</db:para>
<db:para>This class was introduced in Qt 5.0.</db:para>
</db:abstract>
<db:pubdate>2024-12-27</db:pubdate>
<db:date>2024-12-27</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:variablelist>
<db:varlistentry>
<db:term>Header</db:term>
<db:listitem>
<db:para>QQuickWindow</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Since</db:term>
<db:listitem>
<db:para>Qt 5.0</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>CMake</db:term>
<db:listitem>
<db:para>find_package(Qt6 REQUIRED COMPONENTS Quick)</db:para>
<db:para>target_link_libraries(mytarget PRIVATE Qt6::Quick)</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>qmake</db:term>
<db:listitem>
<db:para>QT += quick</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Inherited By</db:term>
<db:listitem>
<db:para><db:link xlink:href="qquickview.xml" xlink:role="class">QQuickView</db:link></db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Instantiated By</db:term>
<db:listitem>
<db:para>qml-qtquick-window.xml</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Inherits</db:term>
<db:listitem>
<db:para><db:link xlink:href="qwindow.xml" xlink:role="class">QWindow</db:link></db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Inherited By</db:term>
<db:listitem>
<db:para><db:link xlink:href="qquickview.xml" xlink:role="class">QQuickView</db:link></db:para>
</db:listitem>
</db:varlistentry>
</db:variablelist>
<db:section xml:id="details">
<db:title>Detailed Description</db:title>
<db:para><db:link xlink:href="qquickwindow.xml">QQuickWindow</db:link> provides the graphical scene management needed to interact with and display a scene of QQuickItems.</db:para>
<db:para>A <db:link xlink:href="qquickwindow.xml">QQuickWindow</db:link> always has a single invisible root item. To add items to this window, reparent the items to the root item or to an existing item in the scene.</db:para>
<db:para>For easily displaying a scene from a QML file, see <db:link xlink:href="qquickview.xml">QQuickView</db:link>.</db:para>
<db:section xml:id="rendering">
<db:title>Rendering</db:title>
<db:para><db:link xlink:href="qquickwindow.xml">QQuickWindow</db:link> uses a scene graph to represent what needs to be rendered. This scene graph is disconnected from the QML scene and potentially lives in another thread, depending on the platform implementation. Since the rendering scene graph lives independently from the QML scene, it can also be completely released without affecting the state of the QML scene.</db:para>
<db:para>The <db:link xlink:href="qquickwindow.xml#sceneGraphInitialized">sceneGraphInitialized</db:link>() signal is emitted on the rendering thread before the QML scene is rendered to the screen for the first time. If the rendering scene graph has been released, the signal will be emitted again before the next frame is rendered. A visible, on-screen <db:link xlink:href="qquickwindow.xml">QQuickWindow</db:link> is driven internally by a <db:code>render loop</db:code>, of which there are multiple implementations provided in the scene graph. For details on the scene graph rendering process, see <db:link xlink:href="qtquick-visualcanvas-scenegraph.xml">Qt Quick Scene Graph</db:link>.</db:para>
<db:para>By default, a <db:link xlink:href="qquickwindow.xml">QQuickWindow</db:link> renders using an accelerated 3D graphics API, such as OpenGL or Vulkan. See <db:link xlink:href="qtquick-visualcanvas-adaptations.xml">Scene Graph Adaptations</db:link> for a detailed overview of scene graph backends and the supported graphics APIs.</db:para>
<db:warning>
<db:para>It is crucial that graphics operations and interaction with the scene graph happens exclusively on the rendering thread, primarily during the updatePaintNode() phase.</db:para>
</db:warning>
<db:warning>
<db:para>As many of the signals related to rendering are emitted from the rendering thread, connections should be made using <db:link xlink:href="qt.xml#ConnectionType-enum">Qt::DirectConnection</db:link>.</db:para>
</db:warning>
<db:section xml:id="integration-with-accelerated-3d-graphics-apis">
<db:title>Integration with Accelerated 3D Graphics APIs</db:title>
<db:para>It is possible to integrate OpenGL, Vulkan, Metal, or Direct3D 11 calls directly into the <db:link xlink:href="qquickwindow.xml">QQuickWindow</db:link>, as long as the <db:link xlink:href="qquickwindow.xml">QQuickWindow</db:link> and the underlying scene graph is rendering using the same API. To access native graphics objects, such as device or context object handles, use <db:link xlink:href="qsgrendererinterface.xml">QSGRendererInterface</db:link>. An instance of <db:link xlink:href="qsgrendererinterface.xml">QSGRendererInterface</db:link> is queriable from <db:link xlink:href="qquickwindow.xml">QQuickWindow</db:link> by calling <db:link xlink:href="qquickwindow.xml#rendererInterface">rendererInterface</db:link>(). The enablers for this integration are the <db:link xlink:href="qquickwindow.xml#beforeRendering">beforeRendering</db:link>(), <db:link xlink:href="qquickwindow.xml#beforeRenderPassRecording">beforeRenderPassRecording</db:link>(), <db:link xlink:href="qquickwindow.xml#afterRenderPassRecording">afterRenderPassRecording</db:link>(), and related signals. These allow rendering underlays or overlays. Alternatively, <db:link xlink:href="qnativeinterface-qsgopengltexture.xml">QNativeInterface::QSGOpenGLTexture</db:link>, <db:link xlink:href="qnativeinterface-qsgvulkantexture.xml">QNativeInterface::QSGVulkanTexture</db:link>, and other similar classes allow wrapping an existing native texture or image object in a <db:link xlink:href="qsgtexture.xml">QSGTexture</db:link> that can then be used with the scene graph.</db:para>
</db:section>
<db:section xml:id="rendering-without-acceleration">
<db:title>Rendering without Acceleration</db:title>
<db:para>A limited, pure software based rendering path is available as well. With the <db:code>software</db:code> backend, a number of Qt Quick features are not available, QML items relying on these will not be rendered at all. At the same time, this allows <db:link xlink:href="qquickwindow.xml">QQuickWindow</db:link> to be functional even on systems where there is no 3D graphics API available at all. See <db:link xlink:href="qtquick-visualcanvas-adaptations-software.xml">Qt Quick Software Adaptation</db:link> for more details.</db:para>
</db:section>
<db:section xml:id="redirected-rendering">
<db:title>Redirected Rendering</db:title>
<db:para>A <db:link xlink:href="qquickwindow.xml">QQuickWindow</db:link> is not necessarily backed by a native window on screen. The rendering can be redirected to target a custom render target, such as a given native texture. This is achieved in combination with the <db:link xlink:href="qquickrendercontrol.xml">QQuickRenderControl</db:link> class, and functions such as <db:link xlink:href="qquickwindow.xml#setRenderTarget">setRenderTarget</db:link>(), <db:link xlink:href="qquickwindow.xml#setGraphicsDevice">setGraphicsDevice</db:link>(), and <db:link xlink:href="qquickwindow.xml#setGraphicsConfiguration">setGraphicsConfiguration</db:link>().</db:para>
<db:para>In this case, the <db:link xlink:href="qquickwindow.xml">QQuickWindow</db:link> represents the scene, and provides the intrastructure for rendering a frame. It will not be backed by a render loop and a native window. Instead, in this case the application drives rendering, effectively substituting for the render loops. This allows generating image sequences, rendering into textures for use in external 3D engines, or rendering Qt Quick content within a VR environment.</db:para>
</db:section>
<db:section xml:id="resource-management">
<db:title>Resource Management</db:title>
<db:para>QML will try to cache images and scene graph nodes to improve performance, but in some low-memory scenarios it might be required to aggressively release these resources. The <db:link xlink:href="qquickwindow.xml#releaseResources">releaseResources</db:link>() function can be used to force the clean up of certain resources, especially resource that are cached and can be recreated later when needed again.</db:para>
<db:para>Additionally, calling <db:link xlink:href="qquickwindow.xml#releaseResources">releaseResources</db:link>() may result in releasing the entire scene graph and the associated graphics resources. The <db:link xlink:href="qquickwindow.xml#sceneGraphInvalidated">sceneGraphInvalidated</db:link>() signal will be emitted when this happens. This behavior is controlled by the <db:link xlink:href="qquickwindow.xml#setPersistentGraphics">setPersistentGraphics</db:link>() and <db:link xlink:href="qquickwindow.xml#setPersistentSceneGraph">setPersistentSceneGraph</db:link>() functions.</db:para>
<db:note>
<db:para>All classes with QSG prefix should be used solely on the scene graph's rendering thread. See <db:link xlink:href="qtquick-visualcanvas-scenegraph.xml#scene-graph-and-rendering">Scene Graph and Rendering</db:link> for more information.</db:para>
</db:note>
</db:section>
<db:section xml:id="exposure-and-visibility">
<db:title>Exposure and Visibility</db:title>
<db:para>When a <db:link xlink:href="qquickwindow.xml">QQuickWindow</db:link> instance is deliberately hidden with <db:link xlink:href="qwindow.xml#hide">hide</db:link>() or setVisible(false), it will stop rendering and its scene graph and graphics context might be released as well. This depends on the settings configured by <db:link xlink:href="qquickwindow.xml#setPersistentGraphics">setPersistentGraphics</db:link>() and <db:link xlink:href="qquickwindow.xml#setPersistentSceneGraph">setPersistentSceneGraph</db:link>(). The behavior in this respect is identical to explicitly calling the <db:link xlink:href="qquickwindow.xml#releaseResources">releaseResources</db:link>() function. A window can become not exposed, in other words non-renderable, by other means as well. This depends on the platform and windowing system. For example, on Windows minimizing a window makes it stop rendering. On macOS fully obscuring a window by other windows on top triggers the same. On Linux/X11, the behavior is dependent on the window manager.</db:para>
</db:section>
<db:section xml:id="opengl-context-and-surface-formats">
<db:title>OpenGL Context and Surface Formats</db:title>
<db:para>While it is possible to specify a <db:link xlink:href="qsurfaceformat.xml">QSurfaceFormat</db:link> for every <db:link xlink:href="qquickwindow.xml">QQuickWindow</db:link> by calling the member function <db:link xlink:href="qwindow.xml#setFormat">setFormat</db:link>(), windows may also be created from QML by using the Window and <db:link xlink:href="qml-qtquick-controls2-applicationwindow.xml">ApplicationWindow</db:link> elements. In this case there is no C++ code involved in the creation of the window instance, yet applications may still wish to set certain surface format values, for example to request a given OpenGL version or profile. Such applications can call the static function <db:link xlink:href="qsurfaceformat.xml#setDefaultFormat">QSurfaceFormat::setDefaultFormat</db:link>() at startup. The specified format will be used for all Quick windows created afterwards.</db:para>
</db:section>
<db:section xml:id="vulkan-instance">
<db:title>Vulkan Instance</db:title>
<db:para>When using Vulkan, a <db:link xlink:href="qquickwindow.xml">QQuickWindow</db:link> is automatically associated with a <db:link xlink:href="qvulkaninstance.xml">QVulkanInstance</db:link> that is created and managed internally by the scene graph. This way most applications do not need to worry about having a <db:code>VkInstance</db:code> available since it all happens automatically. In advanced cases an application may wish to create its own <db:link xlink:href="qvulkaninstance.xml">QVulkanInstance</db:link>, in order to configure it in a specific way. That is possible as well. Calling <db:link xlink:href="qwindow.xml#setVulkanInstance">setVulkanInstance</db:link>() on the <db:link xlink:href="qquickwindow.xml">QQuickWindow</db:link> right after construction, before making it visible, leads to using the application-supplied <db:link xlink:href="qvulkaninstance.xml">QVulkanInstance</db:link> (and the underlying <db:code>VkInstance</db:code>). When redirecting via <db:link xlink:href="qquickrendercontrol.xml">QQuickRenderControl</db:link>, there is no <db:link xlink:href="qvulkaninstance.xml">QVulkanInstance</db:link> provided automatically, but rather the application is expected to provide its own and associate it with the <db:link xlink:href="qquickwindow.xml">QQuickWindow</db:link>.</db:para>
</db:section>
<db:section xml:id="graphics-contexts-and-devices">
<db:title>Graphics Contexts and Devices</db:title>
<db:para>When the scene graph is initialized, which typically happens when the window becomes exposed or, in case of redirected rendering, initialization is performed <db:link xlink:href="qquickrendercontrol.xml#initialize">via QQuickRenderControl</db:link>, the context or device objects necessary for rendering are created automatically. This includes OpenGL contexts, Direct3D devices and device contexts, Vulkan and Metal devices. These are also queriable by application code afterwards via <db:link xlink:href="qsgrendererinterface.xml#getResource">QSGRendererInterface</db:link>. When using the <db:code>basic</db:code> render loop, which performs all rendering on the GUI thread, the same context or device is used with all visible QQuickWindows. The <db:code>threaded</db:code> render loop uses a dedicated context or device object for each rendering thread, and so for each <db:link xlink:href="qquickwindow.xml">QQuickWindow</db:link>. With some graphics APIs, there is a degree of customizability provided via <db:link xlink:href="qquickwindow.xml#setGraphicsConfiguration">setGraphicsConfiguration</db:link>(). This makes it possible, for example, to specify the list of Vulkan extensions to enable on the <db:code>VkDevice</db:code>. Alternatively, it is also possible to provide a set of existing context or device objects for use by the <db:link xlink:href="qquickwindow.xml">QQuickWindow</db:link>, instead of letting it construct its own. This is achieved through <db:link xlink:href="qquickwindow.xml#setGraphicsDevice">setGraphicsDevice</db:link>().</db:para>
</db:section>
</db:section>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qquickview.xml">QQuickView</db:link></db:member>
<db:member><db:link xlink:href="qquickrendercontrol.xml">QQuickRenderControl</db:link></db:member>
<db:member><db:link xlink:href="qquickrendertarget.xml">QQuickRenderTarget</db:link></db:member>
<db:member><db:link xlink:href="qquickgraphicsdevice.xml">QQuickGraphicsDevice</db:link></db:member>
<db:member><db:link xlink:href="qquickgraphicsconfiguration.xml">QQuickGraphicsConfiguration</db:link></db:member>
<db:member><db:link xlink:href="qsgrendererinterface.xml">QSGRendererInterface</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="member-type-documentation">
<db:title>Member Type Documentation</db:title>
<db:section xml:id="CreateTextureOption-enum">
<db:title>enum QQuickWindow::CreateTextureOption</db:title>
<db:bridgehead renderas="sect2">flags QQuickWindow::CreateTextureOptions</db:bridgehead>
<db:enumsynopsis>
<db:enumname>CreateTextureOption</db:enumname>
<db:enumitem>
<db:enumidentifier>TextureHasAlphaChannel</db:enumidentifier>
<db:enumvalue>0x0001</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>TextureHasMipmaps</db:enumidentifier>
<db:enumvalue>0x0002</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>TextureOwnsGLTexture</db:enumidentifier>
<db:enumvalue>0x0004</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>TextureCanUseAtlas</db:enumidentifier>
<db:enumvalue>0x0008</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>TextureIsOpaque</db:enumidentifier>
<db:enumvalue>0x0010</db:enumvalue>
</db:enumitem>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:enumsynopsis>
<db:typedefsynopsis>
<db:typedefname>QQuickWindow::CreateTextureOptions</db:typedefname>
</db:typedefsynopsis>
<db:para>The CreateTextureOption enums are used to customize a texture is wrapped.</db:para>
<db:informaltable>
<db:thead>
<db:tr>
<db:th>Constant</db:th>
<db:th>Value</db:th>
<db:th>Description</db:th>
</db:tr>
</db:thead>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qquickwindow.xml">QQuickWindow</db:link></db:emphasis>::TextureHasAlphaChannel</db:code></db:para>
</db:td>
<db:td><db:code>0x0001</db:code></db:td>
<db:td>
<db:para>The texture has an alpha channel and should be drawn using blending.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qquickwindow.xml">QQuickWindow</db:link></db:emphasis>::TextureHasMipmaps</db:code></db:para>
</db:td>
<db:td><db:code>0x0002</db:code></db:td>
<db:td>
<db:para>The texture has mipmaps and can be drawn with mipmapping enabled.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qquickwindow.xml">QQuickWindow</db:link></db:emphasis>::TextureOwnsGLTexture</db:code></db:para>
</db:td>
<db:td><db:code>0x0004</db:code></db:td>
<db:td>
<db:para>As of Qt 6.0, this flag is not used in practice and is ignored. Native graphics resource ownership is not transferable to the wrapping <db:link xlink:href="qsgtexture.xml">QSGTexture</db:link>, because Qt Quick may not have the necessary details on how such an object and the associated memory should be freed.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qquickwindow.xml">QQuickWindow</db:link></db:emphasis>::TextureCanUseAtlas</db:code></db:para>
</db:td>
<db:td><db:code>0x0008</db:code></db:td>
<db:td>
<db:para>The image can be uploaded into a texture atlas.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qquickwindow.xml">QQuickWindow</db:link></db:emphasis>::TextureIsOpaque</db:code></db:para>
</db:td>
<db:td><db:code>0x0010</db:code></db:td>
<db:td>
<db:para>The texture will return false for <db:link xlink:href="qsgtexture.xml#hasAlphaChannel">QSGTexture::hasAlphaChannel</db:link>() and will not be blended. This flag was added in Qt 5.6.</db:para>
</db:td>
</db:tr>
</db:informaltable>
<db:para>The <db:code>CreateTextureOptions</db:code> type is a typedef for <db:code><db:link xlink:href="qflags.xml">QFlags</db:link>&lt;CreateTextureOption&gt;. </db:code>It stores an OR combination of <db:code>CreateTextureOption</db:code> values.</db:para>
</db:section>
<db:section xml:id="RenderStage-enum">
<db:title>[since 5.4] enum QQuickWindow::RenderStage</db:title>
<db:enumsynopsis>
<db:enumname>RenderStage</db:enumname>
<db:enumitem>
<db:enumidentifier>BeforeSynchronizingStage</db:enumidentifier>
<db:enumvalue>0</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>AfterSynchronizingStage</db:enumidentifier>
<db:enumvalue>1</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>BeforeRenderingStage</db:enumidentifier>
<db:enumvalue>2</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>AfterRenderingStage</db:enumidentifier>
<db:enumvalue>3</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>AfterSwapStage</db:enumidentifier>
<db:enumvalue>4</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>NoStage</db:enumidentifier>
<db:enumvalue>5</db:enumvalue>
</db:enumitem>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:enumsynopsis>
<db:informaltable>
<db:thead>
<db:tr>
<db:th>Constant</db:th>
<db:th>Value</db:th>
<db:th>Description</db:th>
</db:tr>
</db:thead>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qquickwindow.xml">QQuickWindow</db:link></db:emphasis>::BeforeSynchronizingStage</db:code></db:para>
</db:td>
<db:td><db:code>0</db:code></db:td>
<db:td>
<db:para>Before synchronization.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qquickwindow.xml">QQuickWindow</db:link></db:emphasis>::AfterSynchronizingStage</db:code></db:para>
</db:td>
<db:td><db:code>1</db:code></db:td>
<db:td>
<db:para>After synchronization.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qquickwindow.xml">QQuickWindow</db:link></db:emphasis>::BeforeRenderingStage</db:code></db:para>
</db:td>
<db:td><db:code>2</db:code></db:td>
<db:td>
<db:para>Before rendering.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qquickwindow.xml">QQuickWindow</db:link></db:emphasis>::AfterRenderingStage</db:code></db:para>
</db:td>
<db:td><db:code>3</db:code></db:td>
<db:td>
<db:para>After rendering.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qquickwindow.xml">QQuickWindow</db:link></db:emphasis>::AfterSwapStage</db:code></db:para>
</db:td>
<db:td><db:code>4</db:code></db:td>
<db:td>
<db:para>After the frame is swapped.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qquickwindow.xml">QQuickWindow</db:link></db:emphasis>::NoStage</db:code></db:para>
</db:td>
<db:td><db:code>5</db:code></db:td>
<db:td>
<db:para>As soon as possible. This value was added in Qt 5.6.</db:para>
</db:td>
</db:tr>
</db:informaltable>
<db:para>This enum was introduced or modified in Qt 5.4.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtquick-visualcanvas-scenegraph.xml#scene-graph-and-rendering">Scene Graph and Rendering</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="SceneGraphError-enum">
<db:title>[since 5.3] enum QQuickWindow::SceneGraphError</db:title>
<db:enumsynopsis>
<db:enumname>SceneGraphError</db:enumname>
<db:enumitem>
<db:enumidentifier>ContextNotAvailable</db:enumidentifier>
<db:enumvalue>1</db:enumvalue>
</db:enumitem>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:enumsynopsis>
<db:para>This enum describes the error in a <db:link xlink:href="qquickwindow.xml#sceneGraphError">sceneGraphError</db:link>() signal.</db:para>
<db:informaltable>
<db:thead>
<db:tr>
<db:th>Constant</db:th>
<db:th>Value</db:th>
<db:th>Description</db:th>
</db:tr>
</db:thead>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qquickwindow.xml">QQuickWindow</db:link></db:emphasis>::ContextNotAvailable</db:code></db:para>
</db:td>
<db:td><db:code>1</db:code></db:td>
<db:td>
<db:para>graphics context creation failed. This typically means that no suitable OpenGL implementation was found, for example because no graphics drivers are installed and so no OpenGL 2 support is present. On mobile and embedded boards that use OpenGL ES such an error is likely to indicate issues in the windowing system integration and possibly an incorrect configuration of Qt.</db:para>
</db:td>
</db:tr>
</db:informaltable>
<db:para>This enum was introduced or modified in Qt 5.3.</db:para>
</db:section>
<db:section xml:id="TextRenderType-enum">
<db:title>[since 5.10] enum QQuickWindow::TextRenderType</db:title>
<db:enumsynopsis>
<db:enumname>TextRenderType</db:enumname>
<db:enumitem>
<db:enumidentifier>QtTextRendering</db:enumidentifier>
<db:enumvalue>0</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>NativeTextRendering</db:enumidentifier>
<db:enumvalue>1</db:enumvalue>
</db:enumitem>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:enumsynopsis>
<db:para>This enum describes the default render type of text-like elements in Qt Quick (<db:link xlink:href="qml-qtquick-text.xml">Text</db:link>, <db:link xlink:href="qml-qtquick-textinput.xml">TextInput</db:link>, etc.).</db:para>
<db:para>Select NativeTextRendering if you prefer text to look native on the target platform and do not require advanced features such as transformation of the text. Using such features in combination with the NativeTextRendering render type will lend poor and sometimes pixelated results.</db:para>
<db:informaltable>
<db:thead>
<db:tr>
<db:th>Constant</db:th>
<db:th>Value</db:th>
<db:th>Description</db:th>
</db:tr>
</db:thead>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qquickwindow.xml">QQuickWindow</db:link></db:emphasis>::QtTextRendering</db:code></db:para>
</db:td>
<db:td><db:code>0</db:code></db:td>
<db:td>
<db:para>Use Qt's own rasterization algorithm.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qquickwindow.xml">QQuickWindow</db:link></db:emphasis>::NativeTextRendering</db:code></db:para>
</db:td>
<db:td><db:code>1</db:code></db:td>
<db:td>
<db:para>Use the operating system's native rasterizer for text.</db:para>
</db:td>
</db:tr>
</db:informaltable>
<db:para>This enum was introduced or modified in Qt 5.10.</db:para>
</db:section>
</db:section>
<db:section xml:id="property-documentation">
<db:title>Property Documentation</db:title>
<db:section xml:id="activeFocusItem-prop">
<db:title>[read-only] activeFocusItem : QQuickItem* const</db:title>
<db:fieldsynopsis>
<db:modifier>(Qt property)</db:modifier>
<db:type>QQuickItem*</db:type>
<db:varname>activeFocusItem</db:varname>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
<db:synopsisinfo role="getter">activeFocusItem</db:synopsisinfo>
<db:synopsisinfo role="notifier">activeFocusItemChanged</db:synopsisinfo>
</db:fieldsynopsis>
<db:para>This property holds the item which currently has active focus or <db:code>null</db:code> if there is no item with active focus.</db:para>
<db:para>
<db:emphasis role="bold">Access functions:
</db:emphasis>
</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:type><db:link xlink:href="qquickitem.xml">QQuickItem</db:link></db:type> *<db:emphasis role="bold">activeFocusItem</db:emphasis>() const</db:para>
</db:listitem>
</db:itemizedlist>
<db:para>
<db:emphasis role="bold">Notifier signal:
</db:emphasis>
</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:type>void</db:type> <db:emphasis role="bold">activeFocusItemChanged</db:emphasis>()</db:para>
</db:listitem>
</db:itemizedlist>
</db:section>
<db:section xml:id="color-prop">
<db:title>color : QColor</db:title>
<db:fieldsynopsis>
<db:modifier>(Qt property)</db:modifier>
<db:type>QColor</db:type>
<db:varname>color</db:varname>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
<db:synopsisinfo role="getter">color</db:synopsisinfo>
<db:synopsisinfo role="setter">setColor</db:synopsisinfo>
<db:synopsisinfo role="notifier">colorChanged</db:synopsisinfo>
</db:fieldsynopsis>
<db:para>This property holds the color used to clear the color buffer at the beginning of each frame.</db:para>
<db:para>By default, the clear color is white.</db:para>
<db:para>
<db:emphasis role="bold">Access functions:
</db:emphasis>
</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:type><db:link xlink:href="qcolor.xml">QColor</db:link></db:type> <db:emphasis role="bold">color</db:emphasis>() const</db:para>
</db:listitem>
<db:listitem>
<db:para><db:type>void</db:type> <db:emphasis role="bold">setColor</db:emphasis>(const <db:type><db:link xlink:href="qcolor.xml">QColor</db:link></db:type> &amp;<db:emphasis>color</db:emphasis>)</db:para>
</db:listitem>
</db:itemizedlist>
<db:para>
<db:emphasis role="bold">Notifier signal:
</db:emphasis>
</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:type>void</db:type> <db:emphasis role="bold">colorChanged</db:emphasis>(<db:emphasis>const QColor &amp;</db:emphasis>)</db:para>
</db:listitem>
</db:itemizedlist>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qquickwindow.xml#setDefaultAlphaBuffer">setDefaultAlphaBuffer</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="contentItem-prop">
<db:title>[read-only] contentItem : QQuickItem* const</db:title>
<db:fieldsynopsis>
<db:modifier>(Qt property)</db:modifier>
<db:type>QQuickItem*</db:type>
<db:varname>contentItem</db:varname>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
<db:synopsisinfo role="getter">contentItem</db:synopsisinfo>
</db:fieldsynopsis>
<db:para>This property holds the invisible root item of the scene.</db:para>
<db:para>A <db:link xlink:href="qquickwindow.xml">QQuickWindow</db:link> always has a single invisible root item containing all of its content. To add items to this window, reparent the items to the contentItem or to an existing item in the scene.</db:para>
<db:para>
<db:emphasis role="bold">Access functions:
</db:emphasis>
</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:type><db:link xlink:href="qquickitem.xml">QQuickItem</db:link></db:type> *<db:emphasis role="bold">contentItem</db:emphasis>() const</db:para>
</db:listitem>
</db:itemizedlist>
</db:section>
<db:section xml:id="transientParent-prop">
<db:title>[since 5.13] transientParent : QWindow*</db:title>
<db:fieldsynopsis>
<db:modifier>(Qt property)</db:modifier>
<db:type>QWindow*</db:type>
<db:varname>transientParent</db:varname>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
<db:synopsisinfo role="getter">transientParent</db:synopsisinfo>
<db:synopsisinfo role="setter">setTransientParent</db:synopsisinfo>
<db:synopsisinfo role="notifier">transientParentChanged</db:synopsisinfo>
</db:fieldsynopsis>
<db:para>This property holds the window for which this window is a transient pop-up.</db:para>
<db:para>This is a hint to the window manager that this window is a dialog or pop-up on behalf of the transient parent, which may be any kind of <db:link xlink:href="qwindow.xml">QWindow</db:link>.</db:para>
<db:para>In order to cause the window to be centered above its transient parent by default, depending on the window manager, it may also be necessary to set the <db:link xlink:href="qwindow.xml#flags-prop">flags</db:link> property with a suitable <db:link xlink:href="qt.xml#WindowType-enum">Qt::WindowType</db:link> (such as <db:code>Qt::Dialog</db:code>).</db:para>
<db:para>This property was introduced in Qt 5.13.</db:para>
<db:para>
<db:emphasis role="bold">Access functions:
</db:emphasis>
</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:type><db:link xlink:href="qwindow.xml#QWindow">QWindow</db:link></db:type> *<db:emphasis role="bold"><db:link xlink:href="qwindow.xml#transientParent-prop">transientParent</db:link></db:emphasis>() const</db:para>
</db:listitem>
<db:listitem>
<db:para><db:type>void</db:type> <db:emphasis role="bold"><db:link xlink:href="qwindow.xml#transientParent-prop">setTransientParent</db:link></db:emphasis>(<db:type><db:link xlink:href="qwindow.xml#QWindow">QWindow</db:link></db:type> *<db:emphasis>parent</db:emphasis>)</db:para>
</db:listitem>
</db:itemizedlist>
<db:para>
<db:emphasis role="bold">Notifier signal:
</db:emphasis>
</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:type>void</db:type> <db:emphasis role="bold"><db:link xlink:href="qwindow.xml#transientParent-prop">transientParentChanged</db:link></db:emphasis>(<db:type><db:link xlink:href="qwindow.xml#QWindow">QWindow</db:link></db:type> *<db:emphasis>transientParent</db:emphasis>)</db:para>
</db:listitem>
</db:itemizedlist>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qwindow.xml#parent">parent</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
</db:section>
<db:section xml:id="member-function-documentation">
<db:title>Member Function Documentation</db:title>
<db:section xml:id="QQuickWindow">
<db:title>[explicit] QQuickWindow::QQuickWindow(QWindow *<db:emphasis>parent</db:emphasis> = nullptr)</db:title>
<db:constructorsynopsis>
<db:methodname>QQuickWindow</db:methodname>
<db:methodparam>
<db:type>QWindow *</db:type>
<db:parameter>parent</db:parameter>
<db:initializer>nullptr</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">constructor</db:synopsisinfo>
<db:synopsisinfo role="signature">QQuickWindow(QWindow *parent)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:constructorsynopsis>
<db:para>Constructs a window for displaying a QML scene with parent window <db:code role="parameter">parent</db:code>.</db:para>
</db:section>
<db:section xml:id="dtor.QQuickWindow">
<db:title>[override virtual] QQuickWindow::~QQuickWindow()</db:title>
<db:destructorsynopsis>
<db:modifier>virtual</db:modifier>
<db:methodname>~QQuickWindow</db:methodname>
<db:void/>
<db:modifier>override</db:modifier>
<db:synopsisinfo role="meta">destructor</db:synopsisinfo>
<db:synopsisinfo role="signature">~QQuickWindow() override</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:destructorsynopsis>
<db:para>Destroys the window.</db:para>
</db:section>
<db:section xml:id="accessibleRoot">
<db:title>[override virtual] QAccessibleInterface *QQuickWindow::accessibleRoot() const</db:title>
<db:methodsynopsis>
<db:modifier>virtual</db:modifier>
<db:modifier>const</db:modifier>
<db:type>QAccessibleInterface *</db:type>
<db:methodname>accessibleRoot</db:methodname>
<db:void/>
<db:modifier>override</db:modifier>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QAccessibleInterface * accessibleRoot() const override</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns an accessibility interface for this window, or 0 if such an interface cannot be created.</db:para>
</db:section>
<db:section xml:id="afterAnimating">
<db:title>[since 5.3] void QQuickWindow::afterAnimating()</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>afterAnimating</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void afterAnimating()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This signal is emitted on the GUI thread before requesting the render thread to perform the synchronization of the scene graph.</db:para>
<db:para>Unlike the other similar signals, this one is emitted on the GUI thread instead of the render thread. It can be used to synchronize external animation systems with the QML content. At the same time this means that this signal is not suitable for triggering graphics operations.</db:para>
<db:para>This function was introduced in Qt 5.3.</db:para>
</db:section>
<db:section xml:id="afterFrameEnd">
<db:title>[since 6.0] void QQuickWindow::afterFrameEnd()</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>afterFrameEnd</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void afterFrameEnd()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This signal is emitted when the scene graph has submitted a frame. This is emitted after all other related signals, such as <db:link xlink:href="qquickwindow.xml#afterRendering">afterRendering</db:link>(). It is the last signal that is emitted by the scene graph rendering thread when rendering a frame.</db:para>
<db:note>
<db:para>Unlike <db:link xlink:href="qquickwindow.xml#frameSwapped">frameSwapped</db:link>(), this signal is guaranteed to be emitted also when the Qt Quick output is redirected via <db:link xlink:href="qquickrendercontrol.xml">QQuickRenderControl</db:link>.</db:para>
</db:note>
<db:warning>
<db:para>This signal is emitted from the scene graph rendering thread. If your slot function needs to finish before execution continues, you must make sure that the connection is direct (see <db:link xlink:href="qt.xml#ConnectionType-enum">Qt::ConnectionType</db:link>).</db:para>
</db:warning>
<db:para>This function was introduced in Qt 6.0.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qquickwindow.xml#beforeFrameBegin">beforeFrameBegin</db:link>()</db:member>
<db:member><db:link xlink:href="qquickwindow.xml#rendererInterface">rendererInterface</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="afterRenderPassRecording">
<db:title>[since 5.14] void QQuickWindow::afterRenderPassRecording()</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>afterRenderPassRecording</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void afterRenderPassRecording()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This signal is emitted after the scenegraph has recorded the commands for its main render pass, but the pass is not yet finalized on the command buffer.</db:para>
<db:para>This signal is emitted earlier than <db:link xlink:href="qquickwindow.xml#afterRendering">afterRendering</db:link>(), and it guarantees that not just the frame but also the recording of the scenegraph's main render pass is still active. This allows inserting commands without having to generate an entire, separate render pass (which would typically clear the attached images). The native graphics objects can be queried via <db:link xlink:href="qsgrendererinterface.xml">QSGRendererInterface</db:link>.</db:para>
<db:note>
<db:para>Resource updates (uploads, copies) typically cannot be enqueued from within a render pass. Therefore, more complex user rendering will need to connect to both <db:link xlink:href="qquickwindow.xml#beforeRendering">beforeRendering</db:link>() and this signal.</db:para>
</db:note>
<db:warning>
<db:para>This signal is emitted from the scene graph rendering thread. If your slot function needs to finish before execution continues, you must make sure that the connection is direct (see <db:link xlink:href="qt.xml#ConnectionType-enum">Qt::ConnectionType</db:link>).</db:para>
</db:warning>
<db:para>This function was introduced in Qt 5.14.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qquickwindow.xml#rendererInterface">rendererInterface</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="afterRendering">
<db:title>void QQuickWindow::afterRendering()</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>afterRendering</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void afterRendering()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>The signal is emitted after scene graph has added its commands to the command buffer, which is not yet submitted to the graphics queue. If desired, the slot function connected to this signal can query native resources, like the command buffer, before via <db:link xlink:href="qsgrendererinterface.xml">QSGRendererInterface</db:link>. Note however that the render pass (or passes) are already recorded at this point and it is not possible to add more commands within the scenegraph's pass. Instead, use <db:link xlink:href="qquickwindow.xml#afterRenderPassRecording">afterRenderPassRecording</db:link>() for that. This signal has therefore limited use in Qt 6, unlike in Qt 5. Rather, it is the combination of <db:link xlink:href="qquickwindow.xml#beforeRendering">beforeRendering</db:link>() and <db:link xlink:href="qquickwindow.xml#beforeRenderPassRecording">beforeRenderPassRecording</db:link>(), or <db:link xlink:href="qquickwindow.xml#beforeRendering">beforeRendering</db:link>() and <db:link xlink:href="qquickwindow.xml#afterRenderPassRecording">afterRenderPassRecording</db:link>(), that is typically used to achieve under- or overlaying of the custom rendering.</db:para>
<db:para>When using OpenGL, the <db:link xlink:href="qopenglcontext.xml">QOpenGLContext</db:link> used for rendering by the scene graph will be bound at this point.</db:para>
<db:warning>
<db:para>This signal is emitted from the scene graph rendering thread. If your slot function needs to finish before execution continues, you must make sure that the connection is direct (see <db:link xlink:href="qt.xml#ConnectionType-enum">Qt::ConnectionType</db:link>).</db:para>
</db:warning>
<db:warning>
<db:para>When using OpenGL, be aware that setting OpenGL 3.x or 4.x specific states and leaving these enabled or set to non-default values when returning from the connected slot can interfere with the scene graph's rendering.</db:para>
</db:warning>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qquickwindow.xml#rendererInterface">rendererInterface</db:link>()</db:member>
<db:member><db:link xlink:href="qtquick-scenegraph-openglunderqml-example.xml">Scene Graph - OpenGL Under QML</db:link></db:member>
<db:member><db:link xlink:href="qtquick-scenegraph-metalunderqml-example.xml">Scene Graph - Metal Under QML</db:link></db:member>
<db:member><db:link xlink:href="qtquick-scenegraph-vulkanunderqml-example.xml">Scene Graph - Vulkan Under QML</db:link></db:member>
<db:member><db:link xlink:href="qtquick-scenegraph-d3d11underqml-example.xml">Scene Graph - Direct3D 11 Under QML</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="afterSynchronizing">
<db:title>[since 5.3] void QQuickWindow::afterSynchronizing()</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>afterSynchronizing</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void afterSynchronizing()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This signal is emitted after the scene graph is synchronized with the QML state.</db:para>
<db:para>This signal can be used to do preparation required after calls to <db:link xlink:href="qquickitem.xml#updatePaintNode">QQuickItem::updatePaintNode</db:link>(), while the GUI thread is still locked.</db:para>
<db:para>When using OpenGL, the <db:link xlink:href="qopenglcontext.xml">QOpenGLContext</db:link> used for rendering by the scene graph will be bound at this point.</db:para>
<db:warning>
<db:para>This signal is emitted from the scene graph rendering thread. If your slot function needs to finish before execution continues, you must make sure that the connection is direct (see <db:link xlink:href="qt.xml#ConnectionType-enum">Qt::ConnectionType</db:link>).</db:para>
</db:warning>
<db:warning>
<db:para>When using OpenGL, be aware that setting OpenGL 3.x or 4.x specific states and leaving these enabled or set to non-default values when returning from the connected slot can interfere with the scene graph's rendering.</db:para>
</db:warning>
<db:para>This function was introduced in Qt 5.3.</db:para>
</db:section>
<db:section xml:id="beforeFrameBegin">
<db:title>[since 6.0] void QQuickWindow::beforeFrameBegin()</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>beforeFrameBegin</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void beforeFrameBegin()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This signal is emitted before the scene graph starts preparing the frame. This precedes signals like <db:link xlink:href="qquickwindow.xml#beforeSynchronizing">beforeSynchronizing</db:link>() or <db:link xlink:href="qquickwindow.xml#beforeRendering">beforeRendering</db:link>(). It is the earliest signal that is emitted by the scene graph rendering thread when starting to prepare a new frame.</db:para>
<db:para>This signal is relevant for lower level graphics frameworks that need to execute certain operations, such as resource cleanup, at a stage where Qt Quick has not initiated the recording of a new frame via the underlying rendering hardware interface APIs.</db:para>
<db:warning>
<db:para>This signal is emitted from the scene graph rendering thread. If your slot function needs to finish before execution continues, you must make sure that the connection is direct (see <db:link xlink:href="qt.xml#ConnectionType-enum">Qt::ConnectionType</db:link>).</db:para>
</db:warning>
<db:para>This function was introduced in Qt 6.0.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qquickwindow.xml#afterFrameEnd">afterFrameEnd</db:link>()</db:member>
<db:member><db:link xlink:href="qquickwindow.xml#rendererInterface">rendererInterface</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="beforeRenderPassRecording">
<db:title>[since 5.14] void QQuickWindow::beforeRenderPassRecording()</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>beforeRenderPassRecording</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void beforeRenderPassRecording()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This signal is emitted before the scenegraph starts recording commands for the main render pass. (Layers have their own passes and are fully recorded by the time this signal is emitted.) The render pass is already active on the command buffer when the signal is emitted.</db:para>
<db:para>This signal is emitted later than <db:link xlink:href="qquickwindow.xml#beforeRendering">beforeRendering</db:link>() and it guarantees that not just the frame, but also the recording of the scenegraph's main render pass is active. This allows inserting commands without having to generate an entire, separate render pass (which would typically clear the attached images). The native graphics objects can be queried via <db:link xlink:href="qsgrendererinterface.xml">QSGRendererInterface</db:link>.</db:para>
<db:note>
<db:para>Resource updates (uploads, copies) typically cannot be enqueued from within a render pass. Therefore, more complex user rendering will need to connect to both <db:link xlink:href="qquickwindow.xml#beforeRendering">beforeRendering</db:link>() and this signal.</db:para>
</db:note>
<db:warning>
<db:para>This signal is emitted from the scene graph rendering thread. If your slot function needs to finish before execution continues, you must make sure that the connection is direct (see <db:link xlink:href="qt.xml#ConnectionType-enum">Qt::ConnectionType</db:link>).</db:para>
</db:warning>
<db:para>This function was introduced in Qt 5.14.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qquickwindow.xml#rendererInterface">rendererInterface</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="beforeRendering">
<db:title>void QQuickWindow::beforeRendering()</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>beforeRendering</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void beforeRendering()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This signal is emitted after the preparations for the frame have been done, meaning there is a command buffer in recording mode, where applicable. If desired, the slot function connected to this signal can query native resources like the command before via <db:link xlink:href="qsgrendererinterface.xml">QSGRendererInterface</db:link>. Note however that the recording of the main render pass is not yet started at this point and it is not possible to add commands within that pass. Starting a pass means clearing the color, depth, and stencil buffers so it is not possible to achieve an underlay type of rendering by just connecting to this signal. Rather, connect to <db:link xlink:href="qquickwindow.xml#beforeRenderPassRecording">beforeRenderPassRecording</db:link>(). However, connecting to this signal is still important if the recording of copy type of commands is desired since those cannot be enqueued within a render pass.</db:para>
<db:para>When using OpenGL, the <db:link xlink:href="qopenglcontext.xml">QOpenGLContext</db:link> used for rendering by the scene graph will be bound at this point.</db:para>
<db:warning>
<db:para>This signal is emitted from the scene graph rendering thread. If your slot function needs to finish before execution continues, you must make sure that the connection is direct (see <db:link xlink:href="qt.xml#ConnectionType-enum">Qt::ConnectionType</db:link>).</db:para>
</db:warning>
<db:warning>
<db:para>When using OpenGL, be aware that setting OpenGL 3.x or 4.x specific states and leaving these enabled or set to non-default values when returning from the connected slot can interfere with the scene graph's rendering.</db:para>
</db:warning>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qquickwindow.xml#rendererInterface">rendererInterface</db:link>()</db:member>
<db:member><db:link xlink:href="qtquick-scenegraph-openglunderqml-example.xml">Scene Graph - OpenGL Under QML</db:link></db:member>
<db:member><db:link xlink:href="qtquick-scenegraph-metalunderqml-example.xml">Scene Graph - Metal Under QML</db:link></db:member>
<db:member><db:link xlink:href="qtquick-scenegraph-vulkanunderqml-example.xml">Scene Graph - Vulkan Under QML</db:link></db:member>
<db:member><db:link xlink:href="qtquick-scenegraph-d3d11underqml-example.xml">Scene Graph - Direct3D 11 Under QML</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="beforeSynchronizing">
<db:title>void QQuickWindow::beforeSynchronizing()</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>beforeSynchronizing</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void beforeSynchronizing()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This signal is emitted before the scene graph is synchronized with the QML state.</db:para>
<db:para>Even though the signal is emitted from the scene graph rendering thread, the GUI thread is guaranteed to be blocked, like it is in <db:link xlink:href="qquickitem.xml#updatePaintNode">QQuickItem::updatePaintNode</db:link>(). Therefore, it is safe to access GUI thread thread data in a slot or lambda that is connected with <db:link xlink:href="qt.xml#ConnectionType-enum">Qt::DirectConnection</db:link>.</db:para>
<db:para>This signal can be used to do any preparation required before calls to <db:link xlink:href="qquickitem.xml#updatePaintNode">QQuickItem::updatePaintNode</db:link>().</db:para>
<db:para>When using OpenGL, the <db:link xlink:href="qopenglcontext.xml">QOpenGLContext</db:link> used for rendering by the scene graph will be bound at this point.</db:para>
<db:warning>
<db:para>This signal is emitted from the scene graph rendering thread. If your slot function needs to finish before execution continues, you must make sure that the connection is direct (see <db:link xlink:href="qt.xml#ConnectionType-enum">Qt::ConnectionType</db:link>).</db:para>
</db:warning>
<db:warning>
<db:para>When using OpenGL, be aware that setting OpenGL 3.x or 4.x specific states and leaving these enabled or set to non-default values when returning from the connected slot can interfere with the scene graph's rendering.</db:para>
</db:warning>
</db:section>
<db:section xml:id="beginExternalCommands">
<db:title>[since 5.14] void QQuickWindow::beginExternalCommands()</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>beginExternalCommands</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void beginExternalCommands()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>When mixing raw graphics (OpenGL, Vulkan, Metal, etc.) commands with scene graph rendering, it is necessary to call this function before recording commands to the command buffer used by the scene graph to render its main render pass. This is to avoid clobbering state.</db:para>
<db:para>In practice this function is often called from a slot connected to the <db:link xlink:href="qquickwindow.xml#beforeRenderPassRecording">beforeRenderPassRecording</db:link>() or <db:link xlink:href="qquickwindow.xml#afterRenderPassRecording">afterRenderPassRecording</db:link>() signals.</db:para>
<db:para>The function does not need to be called when recording commands to the application's own command buffer (such as, a VkCommandBuffer or MTLCommandBuffer + MTLRenderCommandEncoder created and managed by the application, not retrieved from the scene graph). With graphics APIs where no native command buffer concept is exposed (OpenGL, Direct 3D 11), beginExternalCommands() and <db:link xlink:href="qquickwindow.xml#endExternalCommands">endExternalCommands</db:link>() together provide a replacement for the Qt 5 resetOpenGLState() function.</db:para>
<db:para>Calling this function and <db:link xlink:href="qquickwindow.xml#endExternalCommands">endExternalCommands</db:link>() is not necessary within the <db:link xlink:href="qsgrendernode.xml#render">render</db:link>() implementation of a <db:link xlink:href="qsgrendernode.xml">QSGRenderNode</db:link> because the scene graph performs the necessary steps implicitly for render nodes.</db:para>
<db:para>Native graphics objects (such as, graphics device, command buffer or encoder) are accessible via <db:link xlink:href="qsgrendererinterface.xml#getResource">QSGRendererInterface::getResource</db:link>().</db:para>
<db:warning>
<db:para>Watch out for the fact that <db:link xlink:href="qsgrendererinterface.xml#Resource-enum">QSGRendererInterface::CommandListResource</db:link> may return a different object between beginExternalCommands() - <db:link xlink:href="qquickwindow.xml#endExternalCommands">endExternalCommands</db:link>(). This can happen when the underlying implementation provides a dedicated secondary command buffer for recording external graphics commands within a render pass. Therefore, always query CommandListResource after calling this function. Do not attempt to reuse an object from an earlier query.</db:para>
</db:warning>
<db:note>
<db:para>When the scenegraph is using OpenGL, pay attention to the fact that the OpenGL state in the context can have arbitrary settings, and this function does not perform any resetting of the state back to defaults.</db:para>
</db:note>
<db:para>This function was introduced in Qt 5.14.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qquickwindow.xml#endExternalCommands">endExternalCommands</db:link>()</db:member>
<db:member><db:link xlink:href="qquickopenglutils.xml#resetOpenGLState">QQuickOpenGLUtils::resetOpenGLState</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="closeEvent">
<db:title>[override virtual protected] void QQuickWindow::closeEvent(QCloseEvent *<db:emphasis>e</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:modifier>virtual</db:modifier>
<db:void/>
<db:methodname>closeEvent</db:methodname>
<db:methodparam>
<db:type>QCloseEvent *</db:type>
<db:parameter>e</db:parameter>
</db:methodparam>
<db:modifier>override</db:modifier>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void closeEvent(QCloseEvent *e) override</db:synopsisinfo>
<db:synopsisinfo role="access">protected</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Reimplements: <db:link xlink:href="qwindow.xml#closeEvent" role="function">QWindow::closeEvent(QCloseEvent *ev)</db:link>.</db:para>
</db:section>
<db:section xml:id="closing">
<db:title>[since 5.1] void QQuickWindow::closing(QQuickCloseEvent *<db:emphasis>close</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>closing</db:methodname>
<db:methodparam>
<db:type>QQuickCloseEvent *</db:type>
<db:parameter>close</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void closing(QQuickCloseEvent *close)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This signal is emitted when the window receives the event <db:code role="parameter">close</db:code> from the windowing system.</db:para>
<db:para>On macOs, Qt will create a menu item <db:code>Quit</db:code> if there is no menu item whose text is &quot;quit&quot; or &quot;exit&quot;. This menu item calls the <db:code>QCoreApplication::quit</db:code> signal, not the <db:code>QQuickWindow::closing()</db:code> signal.</db:para>
<db:para>This function was introduced in Qt 5.1.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qmenubar.xml#qmenubar-as-a-global-menu-bar">QMenuBar as a Global Menu Bar</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="createImageNode">
<db:title>[since 5.8] QSGImageNode *QQuickWindow::createImageNode() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QSGImageNode *</db:type>
<db:methodname>createImageNode</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QSGImageNode * createImageNode() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Creates a simple image node. When the scenegraph is not initialized, the return value is null.</db:para>
<db:para>This is cross-backend alternative to constructing a <db:link xlink:href="qsgsimpletexturenode.xml">QSGSimpleTextureNode</db:link> directly.</db:para>
<db:para>This function was introduced in Qt 5.8.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qsgimagenode.xml">QSGImageNode</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="createNinePatchNode">
<db:title>[since 5.8] QSGNinePatchNode *QQuickWindow::createNinePatchNode() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QSGNinePatchNode *</db:type>
<db:methodname>createNinePatchNode</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QSGNinePatchNode * createNinePatchNode() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Creates a nine patch node. When the scenegraph is not initialized, the return value is null.</db:para>
<db:para>This function was introduced in Qt 5.8.</db:para>
</db:section>
<db:section xml:id="createRectangleNode">
<db:title>[since 5.8] QSGRectangleNode *QQuickWindow::createRectangleNode() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QSGRectangleNode *</db:type>
<db:methodname>createRectangleNode</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QSGRectangleNode * createRectangleNode() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Creates a simple rectangle node. When the scenegraph is not initialized, the return value is null.</db:para>
<db:para>This is cross-backend alternative to constructing a <db:link xlink:href="qsgsimplerectnode.xml">QSGSimpleRectNode</db:link> directly.</db:para>
<db:para>This function was introduced in Qt 5.8.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qsgrectanglenode.xml">QSGRectangleNode</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="createTextureFromImage">
<db:title>QSGTexture *QQuickWindow::createTextureFromImage(const QImage &amp;<db:emphasis>image</db:emphasis>, QQuickWindow::CreateTextureOptions <db:emphasis>options</db:emphasis>) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QSGTexture *</db:type>
<db:methodname>createTextureFromImage</db:methodname>
<db:methodparam>
<db:type>const QImage &amp;</db:type>
<db:parameter>image</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>QQuickWindow::CreateTextureOptions</db:type>
<db:parameter>options</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QSGTexture * createTextureFromImage(const QImage &amp;image, QQuickWindow::CreateTextureOptions options) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Creates a new <db:link xlink:href="qsgtexture.xml">QSGTexture</db:link> from the supplied <db:code role="parameter">image</db:code>. If the image has an alpha channel, the corresponding texture will have an alpha channel.</db:para>
<db:para>The caller of the function is responsible for deleting the returned texture. The underlying native texture object is then destroyed together with the <db:link xlink:href="qsgtexture.xml">QSGTexture</db:link>.</db:para>
<db:para>When <db:code role="parameter">options</db:code> contains <db:link xlink:href="qquickwindow.xml#CreateTextureOption-enum">TextureCanUseAtlas</db:link>, the engine may put the image into a texture atlas. Textures in an atlas need to rely on <db:link xlink:href="qsgtexture.xml#normalizedTextureSubRect">QSGTexture::normalizedTextureSubRect</db:link>() for their geometry and will not support <db:link xlink:href="qsgtexture.xml#WrapMode-enum">QSGTexture::Repeat</db:link>. Other values from <db:link xlink:href="qquickwindow.xml#CreateTextureOption-enum">CreateTextureOption</db:link> are ignored.</db:para>
<db:para>When <db:code role="parameter">options</db:code> contains <db:link xlink:href="qquickwindow.xml#CreateTextureOption-enum">TextureIsOpaque</db:link>, the engine will create an RGB texture which returns false for <db:link xlink:href="qsgtexture.xml#hasAlphaChannel">QSGTexture::hasAlphaChannel</db:link>(). Opaque textures will in most cases be faster to render. When this flag is not set, the texture will have an alpha channel based on the image's format.</db:para>
<db:para>When <db:code role="parameter">options</db:code> contains <db:link xlink:href="qquickwindow.xml#CreateTextureOption-enum">TextureHasMipmaps</db:link>, the engine will create a texture which can use mipmap filtering. Mipmapped textures can not be in an atlas.</db:para>
<db:para>When the scene graph uses OpenGL, the returned texture will be using <db:code>GL_TEXTURE_2D</db:code> as texture target and <db:code>GL_RGBA</db:code> as internal format. With other graphics APIs, the texture format is typically <db:code>RGBA8</db:code>. Reimplement <db:link xlink:href="qsgtexture.xml">QSGTexture</db:link> to create textures with different parameters.</db:para>
<db:warning>
<db:para>This function will return 0 if the scene graph has not yet been initialized.</db:para>
</db:warning>
<db:warning>
<db:para>The returned texture is not memory managed by the scene graph and must be explicitly deleted by the caller on the rendering thread. This is achieved by deleting the texture from a <db:link xlink:href="qsgnode.xml">QSGNode</db:link> destructor or by using <db:link xlink:href="qobject.xml#deleteLater">deleteLater</db:link>() in the case where the texture already has affinity to the rendering thread.</db:para>
</db:warning>
<db:para>This function can be called from any thread.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qquickwindow.xml#sceneGraphInitialized">sceneGraphInitialized</db:link>()</db:member>
<db:member><db:link xlink:href="qsgtexture.xml">QSGTexture</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="createTextureFromImage-1">
<db:title>QSGTexture *QQuickWindow::createTextureFromImage(const QImage &amp;<db:emphasis>image</db:emphasis>) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QSGTexture *</db:type>
<db:methodname>createTextureFromImage</db:methodname>
<db:methodparam>
<db:type>const QImage &amp;</db:type>
<db:parameter>image</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">QSGTexture * createTextureFromImage(const QImage &amp;image) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
</db:section>
<db:section xml:id="effectiveDevicePixelRatio">
<db:title>qreal QQuickWindow::effectiveDevicePixelRatio() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>qreal</db:type>
<db:methodname>effectiveDevicePixelRatio</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">qreal effectiveDevicePixelRatio() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the device pixel ratio for this window.</db:para>
<db:para>This is different from <db:link xlink:href="qwindow.xml#devicePixelRatio">QWindow::devicePixelRatio</db:link>() in that it supports redirected rendering via <db:link xlink:href="qquickrendercontrol.xml">QQuickRenderControl</db:link>. When using a <db:link xlink:href="qquickrendercontrol.xml">QQuickRenderControl</db:link>, the <db:link xlink:href="qquickwindow.xml">QQuickWindow</db:link> is often not created, meaning it is never shown and there is no underlying native window created in the windowing system. As a result, querying properties like the device pixel ratio cannot give correct results. Use this function instead.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qwindow.xml#devicePixelRatio">QWindow::devicePixelRatio</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="endExternalCommands">
<db:title>[since 5.14] void QQuickWindow::endExternalCommands()</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>endExternalCommands</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void endExternalCommands()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>When mixing raw graphics (OpenGL, Vulkan, Metal, etc.) commands with scene graph rendering, it is necessary to call this function after recording commands to the command buffer used by the scene graph to render its main render pass. This is to avoid clobbering state.</db:para>
<db:para>In practice this function is often called from a slot connected to the <db:link xlink:href="qquickwindow.xml#beforeRenderPassRecording">beforeRenderPassRecording</db:link>() or <db:link xlink:href="qquickwindow.xml#afterRenderPassRecording">afterRenderPassRecording</db:link>() signals.</db:para>
<db:para>The function does not need to be called when recording commands to the application's own command buffer (such as, a VkCommandBuffer or MTLCommandBuffer + MTLRenderCommandEncoder created and managed by the application, not retrieved from the scene graph). With graphics APIs where no native command buffer concept is exposed (OpenGL, Direct 3D 11), <db:link xlink:href="qquickwindow.xml#beginExternalCommands">beginExternalCommands</db:link>() and endExternalCommands() together provide a replacement for the Qt 5 resetOpenGLState() function.</db:para>
<db:para>Calling this function and <db:link xlink:href="qquickwindow.xml#beginExternalCommands">beginExternalCommands</db:link>() is not necessary within the <db:link xlink:href="qsgrendernode.xml#render">render</db:link>() implementation of a <db:link xlink:href="qsgrendernode.xml">QSGRenderNode</db:link> because the scene graph performs the necessary steps implicitly for render nodes.</db:para>
<db:para>This function was introduced in Qt 5.14.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qquickwindow.xml#beginExternalCommands">beginExternalCommands</db:link>()</db:member>
<db:member><db:link xlink:href="qquickopenglutils.xml#resetOpenGLState">QQuickOpenGLUtils::resetOpenGLState</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="event">
<db:title>[override virtual protected] bool QQuickWindow::event(QEvent *<db:emphasis>e</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:modifier>virtual</db:modifier>
<db:type>bool</db:type>
<db:methodname>event</db:methodname>
<db:methodparam>
<db:type>QEvent *</db:type>
<db:parameter>e</db:parameter>
</db:methodparam>
<db:modifier>override</db:modifier>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool event(QEvent *e) override</db:synopsisinfo>
<db:synopsisinfo role="access">protected</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Reimplements: <db:link xlink:href="qwindow.xml#event" role="function">QWindow::event(QEvent *ev)</db:link>.</db:para>
</db:section>
<db:section xml:id="exposeEvent">
<db:title>[override virtual protected] void QQuickWindow::exposeEvent(<db:emphasis>QExposeEvent *</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:modifier>virtual</db:modifier>
<db:void/>
<db:methodname>exposeEvent</db:methodname>
<db:methodparam>
<db:type>QExposeEvent *</db:type>
<db:parameter></db:parameter>
</db:methodparam>
<db:modifier>override</db:modifier>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void exposeEvent(QExposeEvent *) override</db:synopsisinfo>
<db:synopsisinfo role="access">protected</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Reimplements: <db:link xlink:href="qwindow.xml#exposeEvent" role="function">QWindow::exposeEvent(QExposeEvent *ev)</db:link>.</db:para>
</db:section>
<db:section xml:id="focusInEvent">
<db:title>[override virtual protected] void QQuickWindow::focusInEvent(QFocusEvent *<db:emphasis>ev</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:modifier>virtual</db:modifier>
<db:void/>
<db:methodname>focusInEvent</db:methodname>
<db:methodparam>
<db:type>QFocusEvent *</db:type>
<db:parameter>ev</db:parameter>
</db:methodparam>
<db:modifier>override</db:modifier>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void focusInEvent(QFocusEvent *ev) override</db:synopsisinfo>
<db:synopsisinfo role="access">protected</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Reimplements: <db:link xlink:href="qwindow.xml#focusInEvent" role="function">QWindow::focusInEvent(QFocusEvent *ev)</db:link>.</db:para>
</db:section>
<db:section xml:id="focusOutEvent">
<db:title>[override virtual protected] void QQuickWindow::focusOutEvent(QFocusEvent *<db:emphasis>ev</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:modifier>virtual</db:modifier>
<db:void/>
<db:methodname>focusOutEvent</db:methodname>
<db:methodparam>
<db:type>QFocusEvent *</db:type>
<db:parameter>ev</db:parameter>
</db:methodparam>
<db:modifier>override</db:modifier>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void focusOutEvent(QFocusEvent *ev) override</db:synopsisinfo>
<db:synopsisinfo role="access">protected</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Reimplements: <db:link xlink:href="qwindow.xml#focusOutEvent" role="function">QWindow::focusOutEvent(QFocusEvent *ev)</db:link>.</db:para>
</db:section>
<db:section xml:id="frameSwapped">
<db:title>void QQuickWindow::frameSwapped()</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>frameSwapped</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void frameSwapped()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This signal is emitted when a frame has been queued for presenting. With vertical synchronization enabled the signal is emitted at most once per vsync interval in a continuously animating scene.</db:para>
<db:para>This signal will be emitted from the scene graph rendering thread.</db:para>
</db:section>
<db:section xml:id="grabWindow">
<db:title>QImage QQuickWindow::grabWindow()</db:title>
<db:methodsynopsis>
<db:type>QImage</db:type>
<db:methodname>grabWindow</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QImage grabWindow()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Grabs the contents of the window and returns it as an image.</db:para>
<db:para>It is possible to call the grabWindow() function when the window is not visible. This requires that the window is <db:link xlink:href="qwindow.xml#create">created</db:link> and has a valid size and that no other <db:link xlink:href="qquickwindow.xml">QQuickWindow</db:link> instances are rendering in the same process.</db:para>
<db:note>
<db:para>When using this window in combination with <db:link xlink:href="qquickrendercontrol.xml">QQuickRenderControl</db:link>, the result of this function is an empty image, unless the <db:code>software</db:code> backend is in use. This is because when redirecting the output to an application-managed graphics resource (such as, a texture) by using <db:link xlink:href="qquickrendercontrol.xml">QQuickRenderControl</db:link> and <db:link xlink:href="qquickwindow.xml#setRenderTarget">setRenderTarget</db:link>(), the application is better suited for managing and executing an eventual read back operation, since it is in full control of the resource to begin with.</db:para>
</db:note>
<db:warning>
<db:para>Calling this function will cause performance problems.</db:para>
</db:warning>
<db:warning>
<db:para>This function can only be called from the GUI thread.</db:para>
</db:warning>
</db:section>
<db:section xml:id="graphicsApi">
<db:title>[static, since 6.0] QSGRendererInterface::GraphicsApi QQuickWindow::graphicsApi()</db:title>
<db:methodsynopsis>
<db:modifier>static</db:modifier>
<db:type>QSGRendererInterface::GraphicsApi</db:type>
<db:methodname>graphicsApi</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QSGRendererInterface::GraphicsApi graphicsApi()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the graphics API that would be used by the scene graph if it was initialized at this point in time.</db:para>
<db:para>The standard way to query the API used by the scene graph is to use <db:link xlink:href="qsgrendererinterface.xml#graphicsApi">QSGRendererInterface::graphicsApi</db:link>() once the scene graph has initialized, for example when or after the <db:link xlink:href="qquickwindow.xml#sceneGraphInitialized">sceneGraphInitialized</db:link>() signal is emitted. In that case one gets the true, real result, because then it is known that everything was initialized correctly using that graphics API.</db:para>
<db:para>This is not always convenient. If the application needs to set up external frameworks, or needs to work with <db:link xlink:href="qquickwindow.xml#setGraphicsDevice">setGraphicsDevice</db:link>() in a manner that depends on the scene graph's built in API selection logic, it is not always feasiable to defer such operations until after the <db:link xlink:href="qquickwindow.xml">QQuickWindow</db:link> has been made visible or <db:link xlink:href="qquickrendercontrol.xml#initialize">QQuickRenderControl::initialize</db:link>() has been called.</db:para>
<db:para>Therefore, this static function is provided as a counterpart to <db:link xlink:href="qquickwindow.xml#setGraphicsApi">setGraphicsApi</db:link>(): it can be called at any time, and the result reflects what API the scene graph would choose if it was initialized at the point of the call.</db:para>
<db:note>
<db:para>This static function is intended to be called on the main (GUI) thread only. For querying the API when rendering, use <db:link xlink:href="qsgrendererinterface.xml">QSGRendererInterface</db:link> since that object lives on the render thread.</db:para>
</db:note>
<db:note>
<db:para>This function does not take scene graph backends into account.</db:para>
</db:note>
<db:para>This function was introduced in Qt 6.0.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qquickwindow.xml#setGraphicsApi">setGraphicsApi</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="graphicsConfiguration">
<db:title>[since 6.0] QQuickGraphicsConfiguration QQuickWindow::graphicsConfiguration() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QQuickGraphicsConfiguration</db:type>
<db:methodname>graphicsConfiguration</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QQuickGraphicsConfiguration graphicsConfiguration() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the <db:link xlink:href="qquickgraphicsdevice.xml">QQuickGraphicsDevice</db:link> passed to <db:link xlink:href="qquickwindow.xml#setGraphicsDevice">setGraphicsDevice</db:link>(), or a default constructed one otherwise</db:para>
<db:para>This function was introduced in Qt 6.0.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qquickwindow.xml#setGraphicsConfiguration">setGraphicsConfiguration</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="graphicsDevice">
<db:title>[since 6.0] QQuickGraphicsDevice QQuickWindow::graphicsDevice() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QQuickGraphicsDevice</db:type>
<db:methodname>graphicsDevice</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QQuickGraphicsDevice graphicsDevice() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the <db:link xlink:href="qquickgraphicsdevice.xml">QQuickGraphicsDevice</db:link> passed to <db:link xlink:href="qquickwindow.xml#setGraphicsDevice">setGraphicsDevice</db:link>(), or a default constructed one otherwise</db:para>
<db:para>This function was introduced in Qt 6.0.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qquickwindow.xml#setGraphicsDevice">setGraphicsDevice</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="graphicsStateInfo">
<db:title>const QQuickWindow::GraphicsStateInfo &amp;QQuickWindow::graphicsStateInfo()</db:title>
<db:methodsynopsis>
<db:type>const QQuickWindow::GraphicsStateInfo &amp;</db:type>
<db:methodname>graphicsStateInfo</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">const QQuickWindow::GraphicsStateInfo &amp; graphicsStateInfo()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns a reference to a <db:link xlink:href="qquickwindow-graphicsstateinfo.xml">GraphicsStateInfo</db:link> struct describing some of the RHI's internal state, in particular, the double or tripple buffering status of the backend (such as, the Vulkan or Metal integrations). This is relevant when the underlying graphics APIs is Vulkan or Metal, and the external rendering code wishes to perform double or tripple buffering of its own often-changing resources, such as, uniform buffers, in order to avoid stalling the pipeline.</db:para>
</db:section>
<db:section xml:id="hasDefaultAlphaBuffer">
<db:title>[static, since 5.1] bool QQuickWindow::hasDefaultAlphaBuffer()</db:title>
<db:methodsynopsis>
<db:modifier>static</db:modifier>
<db:type>bool</db:type>
<db:methodname>hasDefaultAlphaBuffer</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool hasDefaultAlphaBuffer()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns whether to use alpha transparency on newly created windows.</db:para>
<db:para>This function was introduced in Qt 5.1.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qquickwindow.xml#setDefaultAlphaBuffer">setDefaultAlphaBuffer</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="hideEvent">
<db:title>[override virtual protected] void QQuickWindow::hideEvent(<db:emphasis>QHideEvent *</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:modifier>virtual</db:modifier>
<db:void/>
<db:methodname>hideEvent</db:methodname>
<db:methodparam>
<db:type>QHideEvent *</db:type>
<db:parameter></db:parameter>
</db:methodparam>
<db:modifier>override</db:modifier>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void hideEvent(QHideEvent *) override</db:synopsisinfo>
<db:synopsisinfo role="access">protected</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Reimplements: <db:link xlink:href="qwindow.xml#hideEvent" role="function">QWindow::hideEvent(QHideEvent *ev)</db:link>.</db:para>
</db:section>
<db:section xml:id="incubationController">
<db:title>QQmlIncubationController *QQuickWindow::incubationController() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QQmlIncubationController *</db:type>
<db:methodname>incubationController</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QQmlIncubationController * incubationController() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns an incubation controller that splices incubation between frames for this window. <db:link xlink:href="qquickview.xml">QQuickView</db:link> automatically installs this controller for you, otherwise you will need to install it yourself using <db:link xlink:href="qqmlengine.xml#setIncubationController">QQmlEngine::setIncubationController</db:link>().</db:para>
<db:para>The controller is owned by the window and will be destroyed when the window is deleted.</db:para>
</db:section>
<db:section xml:id="isPersistentGraphics">
<db:title>bool QQuickWindow::isPersistentGraphics() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>bool</db:type>
<db:methodname>isPersistentGraphics</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool isPersistentGraphics() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns whether essential graphics resources can be released during the lifetime of the <db:link xlink:href="qquickwindow.xml">QQuickWindow</db:link>.</db:para>
<db:note>
<db:para>This is a hint, and is not guaranteed that it is taken into account.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qquickwindow.xml#setPersistentGraphics">setPersistentGraphics</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="isPersistentSceneGraph">
<db:title>bool QQuickWindow::isPersistentSceneGraph() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>bool</db:type>
<db:methodname>isPersistentSceneGraph</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool isPersistentSceneGraph() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns whether the scene graph nodes and resources can be released during the lifetime of this <db:link xlink:href="qquickwindow.xml">QQuickWindow</db:link>.</db:para>
<db:note>
<db:para>This is a hint. When and how this happens is implementation specific.</db:para>
</db:note>
</db:section>
<db:section xml:id="isSceneGraphInitialized">
<db:title>bool QQuickWindow::isSceneGraphInitialized() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>bool</db:type>
<db:methodname>isSceneGraphInitialized</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool isSceneGraphInitialized() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns true if the scene graph has been initialized; otherwise returns false.</db:para>
</db:section>
<db:section xml:id="keyPressEvent">
<db:title>[override virtual protected] void QQuickWindow::keyPressEvent(QKeyEvent *<db:emphasis>e</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:modifier>virtual</db:modifier>
<db:void/>
<db:methodname>keyPressEvent</db:methodname>
<db:methodparam>
<db:type>QKeyEvent *</db:type>
<db:parameter>e</db:parameter>
</db:methodparam>
<db:modifier>override</db:modifier>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void keyPressEvent(QKeyEvent *e) override</db:synopsisinfo>
<db:synopsisinfo role="access">protected</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Reimplements: <db:link xlink:href="qwindow.xml#keyPressEvent" role="function">QWindow::keyPressEvent(QKeyEvent *ev)</db:link>.</db:para>
</db:section>
<db:section xml:id="keyReleaseEvent">
<db:title>[override virtual protected] void QQuickWindow::keyReleaseEvent(QKeyEvent *<db:emphasis>e</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:modifier>virtual</db:modifier>
<db:void/>
<db:methodname>keyReleaseEvent</db:methodname>
<db:methodparam>
<db:type>QKeyEvent *</db:type>
<db:parameter>e</db:parameter>
</db:methodparam>
<db:modifier>override</db:modifier>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void keyReleaseEvent(QKeyEvent *e) override</db:synopsisinfo>
<db:synopsisinfo role="access">protected</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Reimplements: <db:link xlink:href="qwindow.xml#keyReleaseEvent" role="function">QWindow::keyReleaseEvent(QKeyEvent *ev)</db:link>.</db:para>
</db:section>
<db:section xml:id="mouseDoubleClickEvent">
<db:title>[override virtual protected] void QQuickWindow::mouseDoubleClickEvent(QMouseEvent *<db:emphasis>event</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:modifier>virtual</db:modifier>
<db:void/>
<db:methodname>mouseDoubleClickEvent</db:methodname>
<db:methodparam>
<db:type>QMouseEvent *</db:type>
<db:parameter>event</db:parameter>
</db:methodparam>
<db:modifier>override</db:modifier>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void mouseDoubleClickEvent(QMouseEvent *event) override</db:synopsisinfo>
<db:synopsisinfo role="access">protected</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Reimplements: <db:link xlink:href="qwindow.xml#mouseDoubleClickEvent" role="function">QWindow::mouseDoubleClickEvent(QMouseEvent *ev)</db:link>.</db:para>
</db:section>
<db:section xml:id="mouseMoveEvent">
<db:title>[override virtual protected] void QQuickWindow::mouseMoveEvent(QMouseEvent *<db:emphasis>event</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:modifier>virtual</db:modifier>
<db:void/>
<db:methodname>mouseMoveEvent</db:methodname>
<db:methodparam>
<db:type>QMouseEvent *</db:type>
<db:parameter>event</db:parameter>
</db:methodparam>
<db:modifier>override</db:modifier>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void mouseMoveEvent(QMouseEvent *event) override</db:synopsisinfo>
<db:synopsisinfo role="access">protected</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Reimplements: <db:link xlink:href="qwindow.xml#mouseMoveEvent" role="function">QWindow::mouseMoveEvent(QMouseEvent *ev)</db:link>.</db:para>
</db:section>
<db:section xml:id="mousePressEvent">
<db:title>[override virtual protected] void QQuickWindow::mousePressEvent(QMouseEvent *<db:emphasis>event</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:modifier>virtual</db:modifier>
<db:void/>
<db:methodname>mousePressEvent</db:methodname>
<db:methodparam>
<db:type>QMouseEvent *</db:type>
<db:parameter>event</db:parameter>
</db:methodparam>
<db:modifier>override</db:modifier>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void mousePressEvent(QMouseEvent *event) override</db:synopsisinfo>
<db:synopsisinfo role="access">protected</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Reimplements: <db:link xlink:href="qwindow.xml#mousePressEvent" role="function">QWindow::mousePressEvent(QMouseEvent *ev)</db:link>.</db:para>
</db:section>
<db:section xml:id="mouseReleaseEvent">
<db:title>[override virtual protected] void QQuickWindow::mouseReleaseEvent(QMouseEvent *<db:emphasis>event</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:modifier>virtual</db:modifier>
<db:void/>
<db:methodname>mouseReleaseEvent</db:methodname>
<db:methodparam>
<db:type>QMouseEvent *</db:type>
<db:parameter>event</db:parameter>
</db:methodparam>
<db:modifier>override</db:modifier>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void mouseReleaseEvent(QMouseEvent *event) override</db:synopsisinfo>
<db:synopsisinfo role="access">protected</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Reimplements: <db:link xlink:href="qwindow.xml#mouseReleaseEvent" role="function">QWindow::mouseReleaseEvent(QMouseEvent *ev)</db:link>.</db:para>
</db:section>
<db:section xml:id="releaseResources">
<db:title>void QQuickWindow::releaseResources()</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>releaseResources</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void releaseResources()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This function tries to release redundant resources currently held by the QML scene.</db:para>
<db:para>Calling this function requests the scene graph to release cached graphics resources, such as graphics pipeline objects or shader programs.</db:para>
<db:note>
<db:para>The releasing of cached graphics resources is not dependent on the hint from <db:link xlink:href="qquickwindow.xml#setPersistentGraphics">setPersistentGraphics</db:link>().</db:para>
</db:note>
<db:para>Additionally, depending on the render loop in use, this function may also result in the scene graph and all rendering resources to be released. If this happens, the <db:link xlink:href="qquickwindow.xml#sceneGraphInvalidated">sceneGraphInvalidated</db:link>() signal will be emitted, allowing users to clean up their own graphics resources. The <db:link xlink:href="qquickwindow.xml#setPersistentGraphics">setPersistentGraphics</db:link>() and <db:link xlink:href="qquickwindow.xml#setPersistentSceneGraph">setPersistentSceneGraph</db:link>() functions can be used to prevent this from happening, if handling the cleanup is not feasible in the application, at the cost of higher memory usage.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qquickwindow.xml#sceneGraphInvalidated">sceneGraphInvalidated</db:link>()</db:member>
<db:member><db:link xlink:href="qquickwindow.xml#setPersistentGraphics">setPersistentGraphics</db:link>()</db:member>
<db:member><db:link xlink:href="qquickwindow.xml#setPersistentSceneGraph">setPersistentSceneGraph</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="renderTarget">
<db:title>[since 6.0] QQuickRenderTarget QQuickWindow::renderTarget() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QQuickRenderTarget</db:type>
<db:methodname>renderTarget</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QQuickRenderTarget renderTarget() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the <db:link xlink:href="qquickrendertarget.xml">QQuickRenderTarget</db:link> passed to <db:link xlink:href="qquickwindow.xml#setRenderTarget">setRenderTarget</db:link>(), or a default constructed one otherwise</db:para>
<db:para>This function was introduced in Qt 6.0.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qquickwindow.xml#setRenderTarget">setRenderTarget</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="rendererInterface">
<db:title>[since 5.8] QSGRendererInterface *QQuickWindow::rendererInterface() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QSGRendererInterface *</db:type>
<db:methodname>rendererInterface</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QSGRendererInterface * rendererInterface() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the current renderer interface. The value is always valid and is never null.</db:para>
<db:note>
<db:para>This function can be called at any time after constructing the <db:link xlink:href="qquickwindow.xml">QQuickWindow</db:link>, even while <db:link xlink:href="qquickwindow.xml#isSceneGraphInitialized">isSceneGraphInitialized</db:link>() is still false. However, some renderer interface functions, in particular <db:link xlink:href="qsgrendererinterface.xml#getResource">QSGRendererInterface::getResource</db:link>() will not be functional until the scenegraph is up and running. Backend queries, like <db:link xlink:href="qsgrendererinterface.xml#graphicsApi">QSGRendererInterface::graphicsApi</db:link>() or <db:link xlink:href="qsgrendererinterface.xml#shaderType">QSGRendererInterface::shaderType</db:link>(), will always be functional on the other hand.</db:para>
</db:note>
<db:note>
<db:para>The ownership of the returned pointer stays with Qt. The returned instance may or may not be shared between different <db:link xlink:href="qquickwindow.xml">QQuickWindow</db:link> instances, depending on the scenegraph backend in use. Therefore applications are expected to query the interface object for each <db:link xlink:href="qquickwindow.xml">QQuickWindow</db:link> instead of reusing the already queried pointer.</db:para>
</db:note>
<db:para>This function was introduced in Qt 5.8.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qsgrendernode.xml">QSGRenderNode</db:link></db:member>
<db:member><db:link xlink:href="qsgrendererinterface.xml">QSGRendererInterface</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="resizeEvent">
<db:title>[override virtual protected] void QQuickWindow::resizeEvent(QResizeEvent *<db:emphasis>ev</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:modifier>virtual</db:modifier>
<db:void/>
<db:methodname>resizeEvent</db:methodname>
<db:methodparam>
<db:type>QResizeEvent *</db:type>
<db:parameter>ev</db:parameter>
</db:methodparam>
<db:modifier>override</db:modifier>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void resizeEvent(QResizeEvent *ev) override</db:synopsisinfo>
<db:synopsisinfo role="access">protected</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Reimplements: <db:link xlink:href="qwindow.xml#resizeEvent" role="function">QWindow::resizeEvent(QResizeEvent *ev)</db:link>.</db:para>
</db:section>
<db:section xml:id="sceneGraphAboutToStop">
<db:title>[since 5.3] void QQuickWindow::sceneGraphAboutToStop()</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>sceneGraphAboutToStop</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void sceneGraphAboutToStop()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This signal is emitted on the render thread when the scene graph is about to stop rendering. This happens usually because the window has been hidden.</db:para>
<db:para>Applications may use this signal to release resources, but should be prepared to reinstantiated them again fast. The scene graph and the graphics context are not released at this time.</db:para>
<db:warning>
<db:para>This signal is emitted from the scene graph rendering thread. If your slot function needs to finish before execution continues, you must make sure that the connection is direct (see <db:link xlink:href="qt.xml#ConnectionType-enum">Qt::ConnectionType</db:link>).</db:para>
</db:warning>
<db:warning>
<db:para>Make very sure that a signal handler for sceneGraphAboutToStop() leaves the graphics context in the same state as it was when the signal handler was entered. Failing to do so can result in the scene not rendering properly.</db:para>
</db:warning>
<db:para>This function was introduced in Qt 5.3.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qquickwindow.xml#sceneGraphInvalidated">sceneGraphInvalidated</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="sceneGraphBackend">
<db:title>[static, since 5.9] QString QQuickWindow::sceneGraphBackend()</db:title>
<db:methodsynopsis>
<db:modifier>static</db:modifier>
<db:type>QString</db:type>
<db:methodname>sceneGraphBackend</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QString sceneGraphBackend()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the requested Qt Quick scenegraph backend.</db:para>
<db:note>
<db:para>The return value of this function may still be outdated by subsequent calls to <db:link xlink:href="qquickwindow.xml#setSceneGraphBackend">setSceneGraphBackend</db:link>() until the first <db:link xlink:href="qquickwindow.xml">QQuickWindow</db:link> in the application has been constructed.</db:para>
</db:note>
<db:note>
<db:para>The value only reflects the request in the <db:code>QT_QUICK_BACKEND</db:code> environment variable after a <db:link xlink:href="qquickwindow.xml">QQuickWindow</db:link> has been constructed.</db:para>
</db:note>
<db:para>This function was introduced in Qt 5.9.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qquickwindow.xml#setSceneGraphBackend">setSceneGraphBackend</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="sceneGraphError">
<db:title>[since 5.3] void QQuickWindow::sceneGraphError(QQuickWindow::SceneGraphError <db:emphasis>error</db:emphasis>, const QString &amp;<db:emphasis>message</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>sceneGraphError</db:methodname>
<db:methodparam>
<db:type>QQuickWindow::SceneGraphError</db:type>
<db:parameter>error</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const QString &amp;</db:type>
<db:parameter>message</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void sceneGraphError(QQuickWindow::SceneGraphError error, const QString &amp;message)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This signal is emitted when an <db:code role="parameter">error</db:code> occurred during scene graph initialization.</db:para>
<db:para>Applications should connect to this signal if they wish to handle errors, like graphics context creation failures, in a custom way. When no slot is connected to the signal, the behavior will be different: Quick will print the <db:code role="parameter">message</db:code>, or show a message box, and terminate the application.</db:para>
<db:para>This signal will be emitted from the GUI thread.</db:para>
<db:para>This function was introduced in Qt 5.3.</db:para>
</db:section>
<db:section xml:id="sceneGraphInitialized">
<db:title>void QQuickWindow::sceneGraphInitialized()</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>sceneGraphInitialized</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void sceneGraphInitialized()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This signal is emitted when the scene graph has been initialized.</db:para>
<db:para>This signal will be emitted from the scene graph rendering thread.</db:para>
</db:section>
<db:section xml:id="sceneGraphInvalidated">
<db:title>void QQuickWindow::sceneGraphInvalidated()</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>sceneGraphInvalidated</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void sceneGraphInvalidated()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This signal is emitted when the scene graph has been invalidated.</db:para>
<db:para>This signal implies that the graphics rendering context used has been invalidated and all user resources tied to that context should be released.</db:para>
<db:para>When rendering with OpenGL, the <db:link xlink:href="qopenglcontext.xml">QOpenGLContext</db:link> of this window will be bound when this function is called. The only exception is if the native OpenGL has been destroyed outside Qt's control, for instance through EGL_CONTEXT_LOST.</db:para>
<db:para>This signal will be emitted from the scene graph rendering thread.</db:para>
</db:section>
<db:section xml:id="scheduleRenderJob">
<db:title>[since 5.4] void QQuickWindow::scheduleRenderJob(QRunnable *<db:emphasis>job</db:emphasis>, QQuickWindow::RenderStage <db:emphasis>stage</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>scheduleRenderJob</db:methodname>
<db:methodparam>
<db:type>QRunnable *</db:type>
<db:parameter>job</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>QQuickWindow::RenderStage</db:type>
<db:parameter>stage</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void scheduleRenderJob(QRunnable *job, QQuickWindow::RenderStage stage)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Schedules <db:code role="parameter">job</db:code> to run when the rendering of this window reaches the given <db:code role="parameter">stage</db:code>.</db:para>
<db:para>This is a convenience to the equivalent signals in <db:link xlink:href="qquickwindow.xml">QQuickWindow</db:link> for &quot;one shot&quot; tasks.</db:para>
<db:para>The window takes ownership over <db:code role="parameter">job</db:code> and will delete it when the job is completed.</db:para>
<db:para>If rendering is shut down before <db:code role="parameter">job</db:code> has a chance to run, the job will be run and then deleted as part of the scene graph cleanup. If the window is never shown and no rendering happens before the <db:link xlink:href="qquickwindow.xml">QQuickWindow</db:link> is destroyed, all pending jobs will be destroyed without their run() method being called.</db:para>
<db:para>If the rendering is happening on a different thread, then the job will happen on the rendering thread.</db:para>
<db:para>If <db:code role="parameter">stage</db:code> is <db:link xlink:href="qquickwindow.xml#RenderStage-enum">NoStage</db:link>, <db:code role="parameter">job</db:code> will be run at the earliest opportunity whenever the render thread is not busy rendering a frame. If the window is not exposed, and is not renderable, at the time the job is either posted or handled, the job is deleted without executing the run() method. If a non-threaded renderer is in use, the run() method of the job is executed synchronously. When rendering with OpenGL, the OpenGL context is changed to the renderer's context before executing any job, including <db:link xlink:href="qquickwindow.xml#RenderStage-enum">NoStage</db:link> jobs.</db:para>
<db:note>
<db:para>This function does not trigger rendering; the jobs targeting any other stage than <db:link xlink:href="qquickwindow.xml#RenderStage-enum">NoStage</db:link> will be stored run until rendering is triggered elsewhere. To force the job to run earlier, call <db:link xlink:href="qquickwindow.xml#update">QQuickWindow::update</db:link>();</db:para>
</db:note>
<db:para>This function was introduced in Qt 5.4.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qquickwindow.xml#beforeRendering">beforeRendering</db:link>()</db:member>
<db:member><db:link xlink:href="qquickwindow.xml#afterRendering">afterRendering</db:link>()</db:member>
<db:member><db:link xlink:href="qquickwindow.xml#beforeSynchronizing">beforeSynchronizing</db:link>()</db:member>
<db:member><db:link xlink:href="qquickwindow.xml#afterSynchronizing">afterSynchronizing</db:link>()</db:member>
<db:member><db:link xlink:href="qquickwindow.xml#frameSwapped">frameSwapped</db:link>()</db:member>
<db:member><db:link xlink:href="qquickwindow.xml#sceneGraphInvalidated">sceneGraphInvalidated</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setDefaultAlphaBuffer">
<db:title>[static, since 5.1] void QQuickWindow::setDefaultAlphaBuffer(bool <db:emphasis>useAlpha</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:modifier>static</db:modifier>
<db:void/>
<db:methodname>setDefaultAlphaBuffer</db:methodname>
<db:methodparam>
<db:type>bool</db:type>
<db:parameter>useAlpha</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void setDefaultAlphaBuffer(bool useAlpha)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para><db:code role="parameter">useAlpha</db:code> specifies whether to use alpha transparency on newly created windows.</db:para>
<db:para>In any application which expects to create translucent windows, it's necessary to set this to true before creating the first <db:link xlink:href="qquickwindow.xml">QQuickWindow</db:link>. The default value is false.</db:para>
<db:para>This function was introduced in Qt 5.1.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qquickwindow.xml#hasDefaultAlphaBuffer">hasDefaultAlphaBuffer</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setGraphicsApi">
<db:title>[static, since 5.8] void QQuickWindow::setGraphicsApi(QSGRendererInterface::GraphicsApi <db:emphasis>api</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:modifier>static</db:modifier>
<db:void/>
<db:methodname>setGraphicsApi</db:methodname>
<db:methodparam>
<db:type>QSGRendererInterface::GraphicsApi</db:type>
<db:parameter>api</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void setGraphicsApi(QSGRendererInterface::GraphicsApi api)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Requests the specified graphics <db:code role="parameter">api</db:code>.</db:para>
<db:para>When the built-in, default graphics adaptation is used, <db:code role="parameter">api</db:code> specifies which graphics API (OpenGL, Vulkan, Metal, or Direct3D) the scene graph should use to render. In addition, the <db:code>software</db:code> backend is built-in as well, and can be requested by setting <db:code role="parameter">api</db:code> to <db:link xlink:href="qsgrendererinterface.xml#GraphicsApi-enum">QSGRendererInterface::Software</db:link>.</db:para>
<db:para>Unlike <db:link xlink:href="qquickwindow.xml#setSceneGraphBackend">setSceneGraphBackend</db:link>(), which can only be used to request a given backend (shipped either built-in or installed as dynamically loaded plugins), this function works with the higher level concept of graphics APIs. It covers the backends that ship with Qt Quick, and thus have corresponding values in the <db:link xlink:href="qsgrendererinterface.xml#GraphicsApi-enum">QSGRendererInterface::GraphicsApi</db:link> enum.</db:para>
<db:para>When this function is not called at all, and the equivalent environment variable <db:code>QSG_RHI_BACKEND</db:code> is not set either, the scene graph will choose the graphics API to use based on the platform.</db:para>
<db:para>This function becomes important in applications that are only prepared for rendering with a given API. For example, if there is native OpenGL or Vulkan rendering done by the application, it will want to ensure Qt Quick is rendering using OpenGL or Vulkan too. Such applications are expected to call this function early in their main() function.</db:para>
<db:note>
<db:para>The call to the function must happen before constructing the first <db:link xlink:href="qquickwindow.xml">QQuickWindow</db:link> in the application. The graphics API cannot be changed afterwards.</db:para>
</db:note>
<db:note>
<db:para>When used in combination with <db:link xlink:href="qquickrendercontrol.xml">QQuickRenderControl</db:link>, this rule is relaxed: it is possible to change the graphics API, but only when all existing <db:link xlink:href="qquickrendercontrol.xml">QQuickRenderControl</db:link> and <db:link xlink:href="qquickwindow.xml">QQuickWindow</db:link> instances have been destroyed.</db:para>
</db:note>
<db:para>To query what graphics API the scene graph is using to render, <db:link xlink:href="qsgrendererinterface.xml#graphicsApi">QSGRendererInterface::graphicsApi</db:link>() after the scene graph <db:link xlink:href="qquickwindow.xml#isSceneGraphInitialized">has initialized</db:link>, which typically happens either when the window becomes visible for the first time, or when <db:link xlink:href="qquickrendercontrol.xml#initialize">QQuickRenderControl::initialize</db:link>() is called.</db:para>
<db:para>To switch back to the default behavior, where the scene graph chooses a graphics API based on the platform and other conditions, set <db:code role="parameter">api</db:code> to <db:link xlink:href="qsgrendererinterface.xml#GraphicsApi-enum">QSGRendererInterface::Unknown</db:link>.</db:para>
<db:para>This function was introduced in Qt 5.8.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qquickwindow.xml#graphicsApi">graphicsApi</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setGraphicsConfiguration">
<db:title>[since 6.0] void QQuickWindow::setGraphicsConfiguration(const QQuickGraphicsConfiguration &amp;<db:emphasis>config</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>setGraphicsConfiguration</db:methodname>
<db:methodparam>
<db:type>const QQuickGraphicsConfiguration &amp;</db:type>
<db:parameter>config</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void setGraphicsConfiguration(const QQuickGraphicsConfiguration &amp;config)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Sets the graphics configuration for this window. <db:code role="parameter">config</db:code> contains various settings that may be taken into account by the scene graph when initializing the underlying graphics devices and contexts.</db:para>
<db:para>Such additional configuration, specifying for example what device extensions to enable for Vulkan, becomes relevant and essential when integrating native graphics rendering code that relies on certain extensions. The same is true when integrating with an external 3D or VR engines, such as OpenXR.</db:para>
<db:note>
<db:para>The configuration is ignored when adopting existing graphics devices via <db:link xlink:href="qquickwindow.xml#setGraphicsDevice">setGraphicsDevice</db:link>() since the scene graph is then not in control of the actual construction of those objects.</db:para>
</db:note>
<db:para><db:link xlink:href="qquickgraphicsconfiguration.xml">QQuickGraphicsConfiguration</db:link> instances are implicitly shared, copyable, and can be passed by value.</db:para>
<db:warning>
<db:para>Setting a <db:link xlink:href="qquickgraphicsconfiguration.xml">QQuickGraphicsConfiguration</db:link> on a <db:link xlink:href="qquickwindow.xml">QQuickWindow</db:link> must happen early enough, before the scene graph is initialized for the first time for that window. With on-screen windows this means the call must be done before invoking <db:link xlink:href="qwindow.xml#show">show</db:link>() on the <db:link xlink:href="qquickwindow.xml">QQuickWindow</db:link> or <db:link xlink:href="qquickview.xml">QQuickView</db:link>. With <db:link xlink:href="qquickrendercontrol.xml">QQuickRenderControl</db:link> the configuration must be finalized before calling <db:link xlink:href="qquickrendercontrol.xml#initialize">initialize</db:link>().</db:para>
</db:warning>
<db:para>This function was introduced in Qt 6.0.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qquickwindow.xml#graphicsConfiguration">graphicsConfiguration</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setGraphicsDevice">
<db:title>[since 6.0] void QQuickWindow::setGraphicsDevice(const QQuickGraphicsDevice &amp;<db:emphasis>device</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>setGraphicsDevice</db:methodname>
<db:methodparam>
<db:type>const QQuickGraphicsDevice &amp;</db:type>
<db:parameter>device</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void setGraphicsDevice(const QQuickGraphicsDevice &amp;device)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Sets the graphics device objects for this window. The scenegraph will use existing device, physical device, and other objects specified by <db:code role="parameter">device</db:code> instead of creating new ones.</db:para>
<db:para>This function is very often used in combination with <db:link xlink:href="qquickrendercontrol.xml">QQuickRenderControl</db:link> and <db:link xlink:href="qquickwindow.xml#setRenderTarget">setRenderTarget</db:link>(), in order to redirect Qt Quick rendering into a texture.</db:para>
<db:para>A default constructed <db:link xlink:href="qquickgraphicsdevice.xml">QQuickGraphicsDevice</db:link> does not change the default behavior in any way. Once a <db:code role="parameter">device</db:code> created via one of the <db:link xlink:href="qquickgraphicsdevice.xml">QQuickGraphicsDevice</db:link> factory functions, such as, <db:link xlink:href="qquickgraphicsdevice.xml#fromDeviceObjects">QQuickGraphicsDevice::fromDeviceObjects</db:link>(), is passed in, and the scenegraph uses a matching graphics API (with the example of fromDeviceObjects(), that would be Vulkan), the scenegraph will use the existing device objects (such as, the <db:code>VkPhysicalDevice</db:code>, <db:code>VkDevice</db:code>, and graphics queue family index, in case of Vulkan) encapsulated by the <db:link xlink:href="qquickgraphicsdevice.xml">QQuickGraphicsDevice</db:link>. This allows using the same device, and so sharing resources, such as buffers and textures, between Qt Quick and native rendering engines.</db:para>
<db:warning>
<db:para>This function can only be called before initializing the scenegraph and will have no effect if called afterwards. In practice this typically means calling it right before <db:link xlink:href="qquickrendercontrol.xml#initialize">QQuickRenderControl::initialize</db:link>().</db:para>
</db:warning>
<db:para>As an example, this time with Direct3D, the typical usage is expected to be the following:</db:para>
<db:programlisting language="cpp" role="bad">// native graphics resources set up by a custom D3D rendering engine
ID3D11Device *device;
ID3D11DeviceContext *context;
ID3D11Texture2D *texture;
...
// now to redirect Qt Quick content into 'texture' we could do the following:
QQuickRenderControl *renderControl = new QQuickRenderControl;
QQuickWindow *window = new QQuickWindow(renderControl); // this window will never be shown on-screen
...
window-&amp;gt;setGraphicsDevice(QQuickGraphicsDevice::fromDeviceAndContext(device, context));
renderControl-&amp;gt;initialize();
window-&amp;gt;setRenderTarget(QQuickRenderTarget::fromD3D11Texture(texture, textureSize);
...
</db:programlisting>
<db:para>The key aspect of using this function is to ensure that resources or handles to resources, such as <db:code>texture</db:code> in the above example, are visible to and usable by both the external rendering engine and the scenegraph renderer. This requires using the same graphics device (or with OpenGL, OpenGL context).</db:para>
<db:para><db:link xlink:href="qquickgraphicsdevice.xml">QQuickGraphicsDevice</db:link> instances are implicitly shared, copyable, and can be passed by value. They do not own the associated native objects (such as, the ID3D11Device in the example).</db:para>
<db:note>
<db:para>Using <db:link xlink:href="qquickrendercontrol.xml">QQuickRenderControl</db:link> does not always imply having to call this function. When adopting an existing device or context is not needed, this function should not be called, and the scene graph will then initialize its own devices and contexts normally, just as it would with an on-screen <db:link xlink:href="qquickwindow.xml">QQuickWindow</db:link>.</db:para>
</db:note>
<db:para>This function was introduced in Qt 6.0.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qquickwindow.xml#graphicsDevice">graphicsDevice</db:link>()</db:member>
<db:member><db:link xlink:href="qquickrendercontrol.xml">QQuickRenderControl</db:link></db:member>
<db:member><db:link xlink:href="qquickwindow.xml#setRenderTarget">setRenderTarget</db:link>()</db:member>
<db:member><db:link xlink:href="qquickwindow.xml#setGraphicsApi">setGraphicsApi</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setPersistentGraphics">
<db:title>void QQuickWindow::setPersistentGraphics(bool <db:emphasis>persistent</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>setPersistentGraphics</db:methodname>
<db:methodparam>
<db:type>bool</db:type>
<db:parameter>persistent</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void setPersistentGraphics(bool persistent)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Sets whether the graphics resources (graphics device or context, swapchain, buffers, textures) should be preserved, and cannot be released until the last window is deleted, to <db:code role="parameter">persistent</db:code>. The default value is true.</db:para>
<db:para>When calling <db:link xlink:href="qquickwindow.xml#releaseResources">releaseResources</db:link>(), or when the window gets hidden (more specifically, not renderable), some render loops have the possibility to release all, not just the cached, graphics resources. This can free up memory temporarily, but it also means the rendering engine will have to do a full, potentially costly reinitialization of the resources when the window needs to render again.</db:para>
<db:note>
<db:para>The rules for when a window is not renderable are platform and window manager specific.</db:para>
</db:note>
<db:note>
<db:para>All graphics resources are released when the last <db:link xlink:href="qquickwindow.xml">QQuickWindow</db:link> is deleted, regardless of this setting.</db:para>
</db:note>
<db:note>
<db:para>This is a hint, and is not guaranteed that it is taken into account.</db:para>
</db:note>
<db:note>
<db:para>This hint does not apply to cached resources, that are relatively cheap to drop and then recreate later. Therefore, calling <db:link xlink:href="qquickwindow.xml#releaseResources">releaseResources</db:link>() will typically lead to releasing those regardless of the value of this hint.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qquickwindow.xml#isPersistentGraphics">isPersistentGraphics</db:link>()</db:member>
<db:member><db:link xlink:href="qquickwindow.xml#setPersistentSceneGraph">setPersistentSceneGraph</db:link>()</db:member>
<db:member><db:link xlink:href="qquickwindow.xml#sceneGraphInitialized">sceneGraphInitialized</db:link>()</db:member>
<db:member><db:link xlink:href="qquickwindow.xml#sceneGraphInvalidated">sceneGraphInvalidated</db:link>()</db:member>
<db:member><db:link xlink:href="qquickwindow.xml#releaseResources">releaseResources</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setPersistentSceneGraph">
<db:title>void QQuickWindow::setPersistentSceneGraph(bool <db:emphasis>persistent</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>setPersistentSceneGraph</db:methodname>
<db:methodparam>
<db:type>bool</db:type>
<db:parameter>persistent</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void setPersistentSceneGraph(bool persistent)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Sets whether the scene graph nodes and resources are <db:code role="parameter">persistent</db:code>. Persistent means the nodes and resources cannot be released. The default value is <db:code>true</db:code>.</db:para>
<db:para>When calling <db:link xlink:href="qquickwindow.xml#releaseResources">releaseResources</db:link>(), when the window gets hidden (more specifically, not renderable), some render loops have the possibility to release the scene graph nodes and related graphics resources. This frees up memory temporarily, but will also mean the scene graph has to be rebuilt when the window renders next time.</db:para>
<db:note>
<db:para>The rules for when a window is not renderable are platform and window manager specific.</db:para>
</db:note>
<db:note>
<db:para>The scene graph nodes and resources are always released when the last <db:link xlink:href="qquickwindow.xml">QQuickWindow</db:link> is deleted, regardless of this setting.</db:para>
</db:note>
<db:note>
<db:para>This is a hint, and is not guaranteed that it is taken into account.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qquickwindow.xml#isPersistentSceneGraph">isPersistentSceneGraph</db:link>()</db:member>
<db:member><db:link xlink:href="qquickwindow.xml#setPersistentGraphics">setPersistentGraphics</db:link>()</db:member>
<db:member><db:link xlink:href="qquickwindow.xml#sceneGraphInvalidated">sceneGraphInvalidated</db:link>()</db:member>
<db:member><db:link xlink:href="qquickwindow.xml#sceneGraphInitialized">sceneGraphInitialized</db:link>()</db:member>
<db:member><db:link xlink:href="qquickwindow.xml#releaseResources">releaseResources</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setRenderTarget">
<db:title>[since 6.0] void QQuickWindow::setRenderTarget(const QQuickRenderTarget &amp;<db:emphasis>target</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>setRenderTarget</db:methodname>
<db:methodparam>
<db:type>const QQuickRenderTarget &amp;</db:type>
<db:parameter>target</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void setRenderTarget(const QQuickRenderTarget &amp;target)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Sets the render target for this window to be <db:code role="parameter">target</db:code>.</db:para>
<db:para>A <db:link xlink:href="qquickrendertarget.xml">QQuickRenderTarget</db:link> serves as an opaque handle for a renderable native object, most commonly a 2D texture, and associated metadata, such as the size in pixels.</db:para>
<db:para>A default constructed <db:link xlink:href="qquickrendertarget.xml">QQuickRenderTarget</db:link> means no redirection. A valid <db:code role="parameter">target</db:code>, created via one of the static <db:link xlink:href="qquickrendertarget.xml">QQuickRenderTarget</db:link> factory functions, on the other hand, enables redirection of the rendering of the Qt Quick scene: it will no longer target the color buffers for the surface associated with the window, but rather the textures or other graphics objects specified in <db:code role="parameter">target</db:code>.</db:para>
<db:para>For example, assuming the scenegraph is using Vulkan to render, one can redirect its output into a <db:code>VkImage</db:code>. For graphics APIs like Vulkan, the image layout must be provided as well. <db:link xlink:href="qquickrendertarget.xml">QQuickRenderTarget</db:link> instances are implicitly shared and are copyable and can be passed by value. They do not own the associated native objects (such as, the VkImage in the example), however.</db:para>
<db:programlisting language="cpp" role="bad">QQuickRenderTarget rt = QQuickRenderTarget::fromVulkanImage(vulkanImage, VK_IMAGE_LAYOUT_PREINITIALIZED, pixelSize);
quickWindow-&amp;gt;setRenderTarget(rt);
</db:programlisting>
<db:para>This function is very often used in combination with <db:link xlink:href="qquickrendercontrol.xml">QQuickRenderControl</db:link> and an invisible <db:link xlink:href="qquickwindow.xml">QQuickWindow</db:link>, in order to render Qt Quick content into a texture, without creating an on-screen native window for this <db:link xlink:href="qquickwindow.xml">QQuickWindow</db:link>.</db:para>
<db:para>When the desired target, or associated data, such as the size, changes, call this function with a new <db:link xlink:href="qquickrendertarget.xml">QQuickRenderTarget</db:link>. Constructing <db:link xlink:href="qquickrendertarget.xml">QQuickRenderTarget</db:link> instances and calling this function is cheap, but be aware that setting a new <db:code role="parameter">target</db:code> with a different native object or other data may lead to potentially expensive initialization steps when the scenegraph is about to render the next frame. Therefore change the target only when necessary.</db:para>
<db:note>
<db:para>This function should not be used when using the <db:code>software</db:code> backend. Instead, use <db:link xlink:href="qquickwindow.xml#grabWindow">grabWindow</db:link>() to render the content into a <db:link xlink:href="qimage.xml">QImage</db:link>.</db:para>
</db:note>
<db:note>
<db:para>The window does not take ownership of any native objects referenced in <db:code role="parameter">target</db:code>.</db:para>
</db:note>
<db:note>
<db:para>It is the caller's responsibility to ensure the native objects referred to in <db:code role="parameter">target</db:code> are valid for the scenegraph renderer too. For instance, with Vulkan, Metal, and Direct3D this implies that the texture or image is created on the same graphics device that is used by the scenegraph internally. Therefore, when texture objects created on an already existing device or context are involved, this function is often used in combination with <db:link xlink:href="qquickwindow.xml#setGraphicsDevice">setGraphicsDevice</db:link>().</db:para>
</db:note>
<db:note>
<db:para>With graphics APIs where relevant, the application must pay attention to image layout transitions performed by the scenegraph. For example, once a VkImage is associated with the scenegraph by calling this function, its layout will transition to <db:code>VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL</db:code> when rendering a frame.</db:para>
</db:note>
<db:warning>
<db:para>This function can only be called from the thread doing the rendering.</db:para>
</db:warning>
<db:para>This function was introduced in Qt 6.0.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qquickwindow.xml#renderTarget">renderTarget</db:link>()</db:member>
<db:member><db:link xlink:href="qquickrendercontrol.xml">QQuickRenderControl</db:link></db:member>
<db:member><db:link xlink:href="qquickwindow.xml#setGraphicsDevice">setGraphicsDevice</db:link>()</db:member>
<db:member><db:link xlink:href="qquickwindow.xml#setGraphicsApi">setGraphicsApi</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setSceneGraphBackend">
<db:title>[static, since 5.8] void QQuickWindow::setSceneGraphBackend(const QString &amp;<db:emphasis>backend</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:modifier>static</db:modifier>
<db:void/>
<db:methodname>setSceneGraphBackend</db:methodname>
<db:methodparam>
<db:type>const QString &amp;</db:type>
<db:parameter>backend</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void setSceneGraphBackend(const QString &amp;backend)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Requests a Qt Quick scenegraph <db:code role="parameter">backend</db:code>. Backends can either be built-in or be installed in form of dynamically loaded plugins.</db:para>
<db:para>This is an overloaded function.</db:para>
<db:note>
<db:para>The call to the function must happen before constructing the first <db:link xlink:href="qquickwindow.xml">QQuickWindow</db:link> in the application. It cannot be changed afterwards.</db:para>
</db:note>
<db:para>See <db:link xlink:href="qtquick-visualcanvas-adaptations.xml#switch-between-adaptations-in-your-application">Switch Between Adaptations in Your Application</db:link> for more information about the list of backends. If <db:code role="parameter">backend</db:code> is invalid or an error occurs, the request is ignored.</db:para>
<db:note>
<db:para>Calling this function is equivalent to setting the <db:code>QT_QUICK_BACKEND</db:code> or <db:code>QMLSCENE_DEVICE</db:code> environment variables. However, this API is safer to use in applications that spawn other processes as there is no need to worry about environment inheritance.</db:para>
</db:note>
<db:para>This function was introduced in Qt 5.8.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qquickwindow.xml#sceneGraphBackend">sceneGraphBackend</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setTextRenderType">
<db:title>[static, since 5.10] void QQuickWindow::setTextRenderType(QQuickWindow::TextRenderType <db:emphasis>renderType</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:modifier>static</db:modifier>
<db:void/>
<db:methodname>setTextRenderType</db:methodname>
<db:methodparam>
<db:type>QQuickWindow::TextRenderType</db:type>
<db:parameter>renderType</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void setTextRenderType(QQuickWindow::TextRenderType renderType)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Sets the default render type of text-like elements in Qt Quick to <db:code role="parameter">renderType</db:code>.</db:para>
<db:note>
<db:para>setting the render type will only affect elements created afterwards; the render type of existing elements will not be modified.</db:para>
</db:note>
<db:para>This function was introduced in Qt 5.10.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qquickwindow.xml#textRenderType">textRenderType</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="showEvent">
<db:title>[override virtual protected] void QQuickWindow::showEvent(<db:emphasis>QShowEvent *</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:modifier>virtual</db:modifier>
<db:void/>
<db:methodname>showEvent</db:methodname>
<db:methodparam>
<db:type>QShowEvent *</db:type>
<db:parameter></db:parameter>
</db:methodparam>
<db:modifier>override</db:modifier>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void showEvent(QShowEvent *) override</db:synopsisinfo>
<db:synopsisinfo role="access">protected</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Reimplements: <db:link xlink:href="qwindow.xml#showEvent" role="function">QWindow::showEvent(QShowEvent *ev)</db:link>.</db:para>
</db:section>
<db:section xml:id="tabletEvent">
<db:title>[override virtual protected] void QQuickWindow::tabletEvent(QTabletEvent *<db:emphasis>event</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:modifier>virtual</db:modifier>
<db:void/>
<db:methodname>tabletEvent</db:methodname>
<db:methodparam>
<db:type>QTabletEvent *</db:type>
<db:parameter>event</db:parameter>
</db:methodparam>
<db:modifier>override</db:modifier>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void tabletEvent(QTabletEvent *event) override</db:synopsisinfo>
<db:synopsisinfo role="access">protected</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Reimplements: <db:link xlink:href="qwindow.xml#tabletEvent" role="function">QWindow::tabletEvent(QTabletEvent *ev)</db:link>.</db:para>
</db:section>
<db:section xml:id="textRenderType">
<db:title>[static, since 5.10] QQuickWindow::TextRenderType QQuickWindow::textRenderType()</db:title>
<db:methodsynopsis>
<db:modifier>static</db:modifier>
<db:type>QQuickWindow::TextRenderType</db:type>
<db:methodname>textRenderType</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QQuickWindow::TextRenderType textRenderType()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the render type of text-like elements in Qt Quick. The default is <db:link xlink:href="qquickwindow.xml#TextRenderType-enum">QQuickWindow::QtTextRendering</db:link>.</db:para>
<db:para>This function was introduced in Qt 5.10.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qquickwindow.xml#setTextRenderType">setTextRenderType</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="update">
<db:title>void QQuickWindow::update()</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>update</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void update()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Schedules the window to render another frame.</db:para>
<db:para>Calling QQuickWindow::update() differs from <db:link xlink:href="qquickitem.xml#update">QQuickItem::update</db:link>() in that it always triggers a repaint, regardless of changes in the underlying scene graph or not.</db:para>
</db:section>
<db:section xml:id="wheelEvent">
<db:title>[override virtual protected] void QQuickWindow::wheelEvent(QWheelEvent *<db:emphasis>event</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:modifier>virtual</db:modifier>
<db:void/>
<db:methodname>wheelEvent</db:methodname>
<db:methodparam>
<db:type>QWheelEvent *</db:type>
<db:parameter>event</db:parameter>
</db:methodparam>
<db:modifier>override</db:modifier>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void wheelEvent(QWheelEvent *event) override</db:synopsisinfo>
<db:synopsisinfo role="access">protected</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Reimplements: <db:link xlink:href="qwindow.xml#wheelEvent" role="function">QWindow::wheelEvent(QWheelEvent *ev)</db:link>.</db:para>
</db:section>
</db:section>
<db:section xml:id="obsolete">
<db:title>Obsolete Members for QQuickWindow</db:title>
<db:para><db:emphasis role="bold">The following members of class <db:link xlink:href="qquickwindow.xml">QQuickWindow</db:link> are deprecated.</db:emphasis> We strongly advise against using them in new code.</db:para>
<db:section xml:id="obsolete-member-function-documentation">
<db:title>Obsolete Member Function Documentation</db:title>
<db:section xml:id="mouseGrabberItem">
<db:title>QQuickItem *QQuickWindow::mouseGrabberItem() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QQuickItem *</db:type>
<db:methodname>mouseGrabberItem</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QQuickItem * mouseGrabberItem() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">deprecated</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This function is deprecated. We strongly advise against using it in new code.</db:para>
<db:para>Use <db:link xlink:href="qpointerevent.xml#exclusiveGrabber">QPointerEvent::exclusiveGrabber</db:link>() Returns the item which currently has the mouse grab.</db:para>
</db:section>
</db:section>
</db:section>
</db:article>
