<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en_US">
<db:info>
<db:title>QQmlEngine</db:title>
<db:productname>QtQml</db:productname>
<db:edition>Qt 5.2.1 Reference Documentation</db:edition>
<db:titleabbrev>Qt QML Reference Documentation</db:titleabbrev>
<db:abstract>
<db:para>Qt QML Reference Documentation.</db:para></db:abstract>
<db:pubdate>2025-06-29</db:pubdate>
<db:date>2025-06-29</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:section xml:id="function-documentation">
<db:title>Function Documentation</db:title>
<db:section xml:id="qmlProtectModule">
<db:title>class Q_DECL_IMPORT qmlProtectModule(const char *<db:emphasis>uri</db:emphasis>, int <db:emphasis>majVersion</db:emphasis>)</db:title>
<db:para>This function protects a module from having types registered into it. This can be used to prevent other plugins from injecting types into your module. It can also be a performance improvement, as it allows the engine to skip checking for the possibility of new types or plugins when this import is reached.</db:para>
<db:para>The performance benefit is primarily seen when registering application specific types from within the application instead of through a plugin. Using qmlProtectModule allows the engine to skip checking for a plugin when that uri is imported, which can be noticeable with slow file systems.</db:para>
<db:para>After this function is called, any attempt to register C++ types into this uri, major version combination will lead to a runtime error. Call this after you have registered all of your types with the engine.</db:para>
<db:para>#include &lt;<db:link xlink:href="qtqml-module.xml">QtQml</db:link>&gt; to use this function.</db:para>
<db:para>Returns true if the module with <db:code role="parameter">uri</db:code> as a <db:link xlink:href="qtqml-modules-identifiedmodules.xml">module identifier</db:link> and <db:code role="parameter">majVersion</db:code> as a major version number was found and locked, otherwise returns false. The module must contain exported types in order to be found.</db:para>
</db:section>
<db:section xml:id="qmlRegisterSingletonType">
<db:title>int qmlRegisterSingletonType(const char *<db:emphasis>uri</db:emphasis>, int <db:emphasis>versionMajor</db:emphasis>, int <db:emphasis>versionMinor</db:emphasis>, const char *<db:emphasis>typeName</db:emphasis>, QJSValue (*)(QQmlEngine *, QJSEngine *) <db:emphasis>callback</db:emphasis>)</db:title>
<db:para>This function may be used to register a singleton type provider <db:code role="parameter">callback</db:code> in a particular <db:code role="parameter">uri</db:code> and <db:code role="parameter">typeName</db:code> with a version specified in <db:code role="parameter">versionMajor</db:code> and <db:code role="parameter">versionMinor</db:code>.</db:para>
<db:para>Installing a singleton type allows developers to provide arbitrary functionality (methods and properties) to a client without requiring individual instances of the type to be instantiated by the client.</db:para>
<db:para>A singleton type may be either a <db:link xlink:href="qobject.xml">QObject</db:link> or a QJSValue. This function should be used to register a singleton type provider function which returns a QJSValue as a singleton type.</db:para>
<db:para><db:emphasis role="bold">NOTE:</db:emphasis> QJSValue singleton type properties will <db:emphasis role="bold">not</db:emphasis> trigger binding re-evaluation if changed.</db:para>
<db:para>Usage:</db:para>
<db:programlisting language="cpp">// First, define the singleton type provider function (callback).
static QJSValue *example_qjsvalue_singletontype_provider(QQmlEngine *engine, QJSEngine *scriptEngine)
{
    Q_UNUSED(engine)

    static int seedValue = 5;
    QJSValue example = scriptEngine-&gt;newObject();
    example.setProperty(&quot;someProperty&quot;, seedValue++);
    return example;
}

// Second, register the singleton type provider with QML by calling this function in an initialization function.
#include &lt;QtQml&gt;
...
qmlRegisterSingletonType(&quot;Qt.example.qjsvalueApi&quot;, 1, 0, &quot;MyApi&quot;, example_qjsvalue_singletontype_provider);
...
</db:programlisting>
<db:para>In order to use the registered singleton type in QML, you must import the singleton type.</db:para>
<db:programlisting language="qml">import QtQuick 2.0
import Qt.example.qjsvalueApi 1.0 as ExampleApi
Item {
    id: root
    property int someValue: ExampleApi.MyApi.someProperty
}
</db:programlisting>
</db:section>
</db:section>
<db:section xml:id="macro-documentation">
<db:title>Macro Documentation</db:title>
<db:section xml:id="QML_DECLARE_TYPE">
<db:title>QML_DECLARE_TYPE</db:title>
<db:para>Equivalent to Q_DECLARE_METATYPE(TYPE *) and Q_DECLARE_METATYPE(QQmlListProperty&lt;TYPE&gt;)</db:para>
<db:para>#include &lt;<db:link xlink:href="qtqml-module.xml">QtQml</db:link>&gt; to use this macro.</db:para>
</db:section>
<db:section xml:id="QML_DECLARE_TYPEINFO">
<db:title>QML_DECLARE_TYPEINFO(<db:emphasis>Type</db:emphasis>, <db:emphasis>Flags</db:emphasis>)</db:title>
<db:para>Declares additional properties of the given <db:code role="parameter">Type</db:code> as described by the specified <db:code role="parameter">Flags</db:code>.</db:para>
<db:para>Current the only supported type info is QML_HAS_ATTACHED_PROPERTIES which declares that the <db:code role="parameter">Type</db:code> supports <db:link xlink:href="qtqml-syntax-objectattributes.xml#attached-properties-and-attached-signal-handlers">attached properties</db:link>.</db:para>
<db:para>#include &lt;<db:link xlink:href="qtqml-module.xml">QtQml</db:link>&gt; to use this macro.</db:para>
</db:section>
</db:section>
</db:article>
