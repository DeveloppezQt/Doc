<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en">
<db:info>
<db:title>QRegExp Class</db:title>
<db:productname>QtCore5Compat</db:productname>
<db:edition>Qt 6.1.3 Reference Documentation</db:edition>
<db:titleabbrev>Qt 5 Core Compatibility APIs Documentation</db:titleabbrev>
<db:abstract>
<db:para>The <db:link xlink:href="qregexp.xml">QRegExp</db:link> class provides pattern matching using regular expressions.</db:para>
<db:note>
<db:para>All functions in this class are <db:link xlink:href="threads-reentrancy.xml">reentrant</db:link>.</db:para>
</db:note>
</db:abstract>
<db:pubdate>2024-12-27</db:pubdate>
<db:date>2024-12-27</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:variablelist>
<db:varlistentry>
<db:term>Header</db:term>
<db:listitem>
<db:para>QRegExp</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>CMake</db:term>
<db:listitem>
<db:para>find_package(Qt6 REQUIRED COMPONENTS Core5Compat)</db:para>
<db:para>target_link_libraries(mytarget PRIVATE Qt6::Core5Compat)</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>qmake</db:term>
<db:listitem>
<db:para>QT += core5compat</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Group</db:term>
<db:listitem>
<db:para>QRegExp is part of <db:simplelist><db:member>tools</db:member><db:member>shared</db:member></db:simplelist></db:para>
</db:listitem>
</db:varlistentry>
</db:variablelist>
<db:section xml:id="details">
<db:title>Detailed Description</db:title>
<db:para>This class is deprecated in Qt 6. Please use <db:link xlink:href="qregularexpression.xml">QRegularExpression</db:link> instead for all new code. For guidelines on porting old code from <db:link xlink:href="qregexp.xml">QRegExp</db:link> to <db:link xlink:href="qregularexpression.xml">QRegularExpression</db:link>, see {Porting to <db:link xlink:href="qregularexpression.xml">QRegularExpression</db:link>}</db:para>
<db:para>A regular expression, or &quot;regexp&quot;, is a pattern for matching substrings in a text. This is useful in many contexts, e.g.,</db:para>
<db:informaltable style="generic">
<db:tr valign="top">
<db:td>
<db:para>Validation</db:para>
</db:td>
<db:td>
<db:para>A regexp can test whether a substring meets some criteria, e.g. is an integer or contains no whitespace.</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>Searching</db:para>
</db:td>
<db:td>
<db:para>A regexp provides more powerful pattern matching than simple substring matching, e.g., match one of the words <db:emphasis>mail</db:emphasis>, <db:emphasis>letter</db:emphasis> or <db:emphasis>correspondence</db:emphasis>, but none of the words <db:emphasis>email</db:emphasis>, <db:emphasis>mailman</db:emphasis>, <db:emphasis>mailer</db:emphasis>, <db:emphasis>letterbox</db:emphasis>, etc.</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>Search and Replace</db:para>
</db:td>
<db:td>
<db:para>A regexp can replace all occurrences of a substring with a different substring, e.g., replace all occurrences of <db:emphasis>&amp;</db:emphasis> with <db:emphasis>&amp;amp;</db:emphasis> except where the <db:emphasis>&amp;</db:emphasis> is already followed by an <db:emphasis>amp;</db:emphasis>.</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>String Splitting</db:para>
</db:td>
<db:td>
<db:para>A regexp can be used to identify where a string should be split apart, e.g. splitting tab-delimited strings.</db:para>
</db:td>
</db:tr>
</db:informaltable>
<db:para>A brief introduction to regexps is presented, a description of Qt's regexp language, some examples, and the function documentation itself. <db:link xlink:href="qregexp.xml">QRegExp</db:link> is modeled on Perl's regexp language. It fully supports Unicode. <db:link xlink:href="qregexp.xml">QRegExp</db:link> can also be used in a simpler, <db:emphasis>wildcard mode</db:emphasis> that is similar to the functionality found in command shells. The syntax rules used by <db:link xlink:href="qregexp.xml">QRegExp</db:link> can be changed with <db:link xlink:href="qregexp.xml#setPatternSyntax">setPatternSyntax</db:link>(). In particular, the pattern syntax can be set to <db:link xlink:href="qregexp.xml#PatternSyntax-enum">QRegExp::FixedString</db:link>, which means the pattern to be matched is interpreted as a plain string, i.e., special characters (e.g., backslash) are not escaped.</db:para>
<db:para>A good text on regexps is <db:emphasis>Mastering Regular Expressions</db:emphasis> (Third Edition) by Jeffrey E. F. Friedl, ISBN 0-596-52812-4.</db:para>
<db:note>
<db:para>In Qt 5, the new <db:link xlink:href="qregularexpression.xml">QRegularExpression</db:link> class provides a Perl compatible implementation of regular expressions and is recommended in place of <db:link xlink:href="qregexp.xml">QRegExp</db:link>.</db:para>
</db:note>
<db:section xml:id="introduction">
<db:title>Introduction</db:title>
<db:para>Regexps are built up from expressions, quantifiers, and assertions. The simplest expression is a character, e.g. <db:emphasis role="bold">x</db:emphasis> or <db:emphasis role="bold">5</db:emphasis>. An expression can also be a set of characters enclosed in square brackets. <db:emphasis role="bold">[ABCD]</db:emphasis> will match an <db:emphasis role="bold">A</db:emphasis> or a <db:emphasis role="bold">B</db:emphasis> or a <db:emphasis role="bold">C</db:emphasis> or a <db:emphasis role="bold">D</db:emphasis>. We can write this same expression as <db:emphasis role="bold">[A-D]</db:emphasis>, and an expression to match any capital letter in the English alphabet is written as <db:emphasis role="bold">[A-Z]</db:emphasis>.</db:para>
<db:para>A quantifier specifies the number of occurrences of an expression that must be matched. <db:emphasis role="bold">x{1,1}</db:emphasis> means match one and only one <db:emphasis role="bold">x</db:emphasis>. <db:emphasis role="bold">x{1,5}</db:emphasis> means match a sequence of <db:emphasis role="bold">x</db:emphasis> characters that contains at least one <db:emphasis role="bold">x</db:emphasis> but no more than five.</db:para>
<db:para>Note that in general regexps cannot be used to check for balanced brackets or tags. For example, a regexp can be written to match an opening html <db:code>&lt;b&gt;</db:code> and its closing <db:code>&lt;/b&gt;</db:code>, if the <db:code>&lt;b&gt;</db:code> tags are not nested, but if the <db:code>&lt;b&gt;</db:code> tags are nested, that same regexp will match an opening <db:code>&lt;b&gt;</db:code> tag with the wrong closing <db:code>&lt;/b&gt;</db:code>. For the fragment <db:code>&lt;b&gt;bold &lt;b&gt;bolder&lt;/b&gt;&lt;/b&gt;</db:code>, the first <db:code>&lt;b&gt;</db:code> would be matched with the first <db:code>&lt;/b&gt;</db:code>, which is not correct. However, it is possible to write a regexp that will match nested brackets or tags correctly, but only if the number of nesting levels is fixed and known. If the number of nesting levels is not fixed and known, it is impossible to write a regexp that will not fail.</db:para>
<db:para>Suppose we want a regexp to match integers in the range 0 to 99. At least one digit is required, so we start with the expression <db:emphasis role="bold">[0-9]{1,1}</db:emphasis>, which matches a single digit exactly once. This regexp matches integers in the range 0 to 9. To match integers up to 99, increase the maximum number of occurrences to 2, so the regexp becomes <db:emphasis role="bold">[0-9]{1,2}</db:emphasis>. This regexp satisfies the original requirement to match integers from 0 to 99, but it will also match integers that occur in the middle of strings. If we want the matched integer to be the whole string, we must use the anchor assertions, <db:emphasis role="bold">^</db:emphasis> (caret) and <db:emphasis role="bold">$</db:emphasis> (dollar). When <db:emphasis role="bold">^</db:emphasis> is the first character in a regexp, it means the regexp must match from the beginning of the string. When <db:emphasis role="bold">$</db:emphasis> is the last character of the regexp, it means the regexp must match to the end of the string. The regexp becomes <db:emphasis role="bold">^[0-9]{1,2}$</db:emphasis>. Note that assertions, e.g. <db:emphasis role="bold">^</db:emphasis> and <db:emphasis role="bold">$</db:emphasis>, do not match characters but locations in the string.</db:para>
<db:para>If you have seen regexps described elsewhere, they may have looked different from the ones shown here. This is because some sets of characters and some quantifiers are so common that they have been given special symbols to represent them. <db:emphasis role="bold">[0-9]</db:emphasis> can be replaced with the symbol <db:emphasis role="bold">\d</db:emphasis>. The quantifier to match exactly one occurrence, <db:emphasis role="bold">{1,1}</db:emphasis>, can be replaced with the expression itself, i.e. <db:emphasis role="bold">x{1,1}</db:emphasis> is the same as <db:emphasis role="bold">x</db:emphasis>. So our 0 to 99 matcher could be written as <db:emphasis role="bold">^\d{1,2}$</db:emphasis>. It can also be written <db:emphasis role="bold">^\d\d{0,1}$</db:emphasis>, i.e. <db:emphasis>From the start of the string, match a digit, followed immediately by 0 or 1 digits</db:emphasis>. In practice, it would be written as <db:emphasis role="bold">^\d\d?$</db:emphasis>. The <db:emphasis role="bold">?</db:emphasis> is shorthand for the quantifier <db:emphasis role="bold">{0,1}</db:emphasis>, i.e. 0 or 1 occurrences. <db:emphasis role="bold">?</db:emphasis> makes an expression optional. The regexp <db:emphasis role="bold">^\d\d?$</db:emphasis> means <db:emphasis>From the beginning of the string, match one digit, followed immediately by 0 or 1 more digit, followed immediately by end of string</db:emphasis>.</db:para>
<db:para>To write a regexp that matches one of the words 'mail' <db:emphasis>or</db:emphasis> 'letter' <db:emphasis>or</db:emphasis> 'correspondence' but does not match words that contain these words, e.g., 'email', 'mailman', 'mailer', and 'letterbox', start with a regexp that matches 'mail'. Expressed fully, the regexp is <db:emphasis role="bold">m{1,1}a{1,1}i{1,1}l{1,1}</db:emphasis>, but because a character expression is automatically quantified by <db:emphasis role="bold">{1,1}</db:emphasis>, we can simplify the regexp to <db:emphasis role="bold">mail</db:emphasis>, i.e., an 'm' followed by an 'a' followed by an 'i' followed by an 'l'. Now we can use the vertical bar <db:emphasis role="bold">|</db:emphasis>, which means <db:emphasis role="bold">or</db:emphasis>, to include the other two words, so our regexp for matching any of the three words becomes <db:emphasis role="bold">mail|letter|correspondence</db:emphasis>. Match 'mail' <db:emphasis role="bold">or</db:emphasis> 'letter' <db:emphasis role="bold">or</db:emphasis> 'correspondence'. While this regexp will match one of the three words we want to match, it will also match words we don't want to match, e.g., 'email'. To prevent the regexp from matching unwanted words, we must tell it to begin and end the match at word boundaries. First we enclose our regexp in parentheses, <db:emphasis role="bold">(mail|letter|correspondence)</db:emphasis>. Parentheses group expressions together, and they identify a part of the regexp that we wish to <db:link xlink:href="qregexp.xml#capturing-text">capture</db:link>. Enclosing the expression in parentheses allows us to use it as a component in more complex regexps. It also allows us to examine which of the three words was actually matched. To force the match to begin and end on word boundaries, we enclose the regexp in <db:emphasis role="bold">\b</db:emphasis> <db:emphasis>word boundary</db:emphasis> assertions: <db:emphasis role="bold">\b(mail|letter|correspondence)\b</db:emphasis>. Now the regexp means: <db:emphasis>Match a word boundary, followed by the regexp in parentheses, followed by a word boundary</db:emphasis>. The <db:emphasis role="bold">\b</db:emphasis> assertion matches a <db:emphasis>position</db:emphasis> in the regexp, not a <db:emphasis>character</db:emphasis>. A word boundary is any non-word character, e.g., a space, newline, or the beginning or ending of a string.</db:para>
<db:para>If we want to replace ampersand characters with the HTML entity <db:emphasis role="bold">&amp;amp;</db:emphasis>, the regexp to match is simply <db:emphasis role="bold">&amp;</db:emphasis>. But this regexp will also match ampersands that have already been converted to HTML entities. We want to replace only ampersands that are not already followed by <db:emphasis role="bold">amp;</db:emphasis>. For this, we need the negative lookahead assertion, <db:emphasis role="bold">(?!</db:emphasis>__<db:emphasis role="bold">)</db:emphasis>. The regexp can then be written as <db:emphasis role="bold">&amp;(?!amp;)</db:emphasis>, i.e. <db:emphasis>Match an ampersand that is</db:emphasis> <db:emphasis role="bold">not</db:emphasis> <db:emphasis>followed by</db:emphasis> <db:emphasis role="bold">amp;</db:emphasis>.</db:para>
<db:para>If we want to count all the occurrences of 'Eric' and 'Eirik' in a string, two valid solutions are <db:emphasis role="bold">\b(Eric|Eirik)\b</db:emphasis> and <db:emphasis role="bold">\bEi?ri[ck]\b</db:emphasis>. The word boundary assertion '\b' is required to avoid matching words that contain either name, e.g. 'Ericsson'. Note that the second regexp matches more spellings than we want: 'Eric', 'Erik', 'Eiric' and 'Eirik'.</db:para>
<db:para>Some of the examples discussed above are implemented in the <db:link xlink:href="qregexp.xml#code-examples">code examples</db:link> section.</db:para>
</db:section>
<db:section xml:id="characters-and-abbreviations-for-sets-of-characters">
<db:title>Characters and Abbreviations for Sets of Characters</db:title>
<db:informaltable style="generic">
<db:thead>
<db:tr>
<db:th>
<db:para>Element</db:para>
</db:th>
<db:th>
<db:para>Meaning</db:para>
</db:th>
</db:tr>
</db:thead>
<db:tr valign="top">
<db:td>
<db:para><db:emphasis role="bold">c</db:emphasis></db:para>
</db:td>
<db:td>
<db:para>A character represents itself unless it has a special regexp meaning. e.g. <db:emphasis role="bold">c</db:emphasis> matches the character <db:emphasis>c</db:emphasis>.</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para><db:emphasis role="bold">\c</db:emphasis></db:para>
</db:td>
<db:td>
<db:para>A character that follows a backslash matches the character itself, except as specified below. e.g., To match a literal caret at the beginning of a string, write <db:emphasis role="bold">\^</db:emphasis>.</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para><db:emphasis role="bold">\a</db:emphasis></db:para>
</db:td>
<db:td>
<db:para>Matches the ASCII bell (BEL, 0x07).</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para><db:emphasis role="bold">\f</db:emphasis></db:para>
</db:td>
<db:td>
<db:para>Matches the ASCII form feed (FF, 0x0C).</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para><db:emphasis role="bold">\n</db:emphasis></db:para>
</db:td>
<db:td>
<db:para>Matches the ASCII line feed (LF, 0x0A, Unix newline).</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para><db:emphasis role="bold">\r</db:emphasis></db:para>
</db:td>
<db:td>
<db:para>Matches the ASCII carriage return (CR, 0x0D).</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para><db:emphasis role="bold">\t</db:emphasis></db:para>
</db:td>
<db:td>
<db:para>Matches the ASCII horizontal tab (HT, 0x09).</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para><db:emphasis role="bold">\v</db:emphasis></db:para>
</db:td>
<db:td>
<db:para>Matches the ASCII vertical tab (VT, 0x0B).</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para><db:emphasis role="bold">\x<db:emphasis>hhhh</db:emphasis></db:emphasis></db:para>
</db:td>
<db:td>
<db:para>Matches the Unicode character corresponding to the hexadecimal number <db:emphasis>hhhh</db:emphasis> (between 0x0000 and 0xFFFF).</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para><db:emphasis role="bold">\0<db:emphasis>ooo</db:emphasis></db:emphasis> (i.e., \zero <db:emphasis>ooo</db:emphasis>)</db:para>
</db:td>
<db:td>
<db:para>matches the ASCII/Latin1 character for the octal number <db:emphasis>ooo</db:emphasis> (between 0 and 0377).</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para><db:emphasis role="bold">. (dot)</db:emphasis></db:para>
</db:td>
<db:td>
<db:para>Matches any character (including newline).</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para><db:emphasis role="bold">\d</db:emphasis></db:para>
</db:td>
<db:td>
<db:para>Matches a digit (<db:link xlink:href="qchar.xml#isDigit">QChar::isDigit</db:link>()).</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para><db:emphasis role="bold">\D</db:emphasis></db:para>
</db:td>
<db:td>
<db:para>Matches a non-digit.</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para><db:emphasis role="bold">\s</db:emphasis></db:para>
</db:td>
<db:td>
<db:para>Matches a whitespace character (<db:link xlink:href="qchar.xml#isSpace">QChar::isSpace</db:link>()).</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para><db:emphasis role="bold">\S</db:emphasis></db:para>
</db:td>
<db:td>
<db:para>Matches a non-whitespace character.</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para><db:emphasis role="bold">\w</db:emphasis></db:para>
</db:td>
<db:td>
<db:para>Matches a word character (<db:link xlink:href="qchar.xml#isLetterOrNumber">QChar::isLetterOrNumber</db:link>(), <db:link xlink:href="qchar.xml#isMark">QChar::isMark</db:link>(), or '_').</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para><db:emphasis role="bold">\W</db:emphasis></db:para>
</db:td>
<db:td>
<db:para>Matches a non-word character.</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para><db:emphasis role="bold">\<db:emphasis>n</db:emphasis></db:emphasis></db:para>
</db:td>
<db:td>
<db:para>The <db:emphasis>n</db:emphasis>-th backreference, e.g. \1, \2, etc.</db:para>
</db:td>
</db:tr>
</db:informaltable>
<db:para><db:emphasis role="bold">Note:</db:emphasis> The C++ compiler transforms backslashes in strings. To include a <db:emphasis role="bold">\</db:emphasis> in a regexp, enter it twice, i.e. <db:code>\\</db:code>. To match the backslash character itself, enter it four times, i.e. <db:code>\\\\</db:code>.</db:para>
</db:section>
<db:section xml:id="sets-of-characters">
<db:title>Sets of Characters</db:title>
<db:para>Square brackets mean match any character contained in the square brackets. The character set abbreviations described above can appear in a character set in square brackets. Except for the character set abbreviations and the following two exceptions, characters do not have special meanings in square brackets.</db:para>
<db:informaltable style="generic">
<db:tr valign="top">
<db:td>
<db:para><db:emphasis role="bold">^</db:emphasis></db:para>
</db:td>
<db:td>
<db:para>The caret negates the character set if it occurs as the first character (i.e. immediately after the opening square bracket). <db:emphasis role="bold">[abc]</db:emphasis> matches 'a' or 'b' or 'c', but <db:emphasis role="bold">[^abc]</db:emphasis> matches anything <db:emphasis>but</db:emphasis> 'a' or 'b' or 'c'.</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para><db:emphasis role="bold">-</db:emphasis></db:para>
</db:td>
<db:td>
<db:para>The dash indicates a range of characters. <db:emphasis role="bold">[W-Z]</db:emphasis> matches 'W' or 'X' or 'Y' or 'Z'.</db:para>
</db:td>
</db:tr>
</db:informaltable>
<db:para>Using the predefined character set abbreviations is more portable than using character ranges across platforms and languages. For example, <db:emphasis role="bold">[0-9]</db:emphasis> matches a digit in Western alphabets but <db:emphasis role="bold">\d</db:emphasis> matches a digit in <db:emphasis>any</db:emphasis> alphabet.</db:para>
<db:para>Note: In other regexp documentation, sets of characters are often called &quot;character classes&quot;.</db:para>
</db:section>
<db:section xml:id="quantifiers">
<db:title>Quantifiers</db:title>
<db:para>By default, an expression is automatically quantified by <db:emphasis role="bold">{1,1}</db:emphasis>, i.e. it should occur exactly once. In the following list, <db:emphasis role="bold"><db:emphasis>E</db:emphasis></db:emphasis> stands for expression. An expression is a character, or an abbreviation for a set of characters, or a set of characters in square brackets, or an expression in parentheses.</db:para>
<db:informaltable style="generic">
<db:tr valign="top">
<db:td>
<db:para><db:emphasis role="bold"><db:emphasis>E</db:emphasis>?</db:emphasis></db:para>
</db:td>
<db:td>
<db:para>Matches zero or one occurrences of <db:emphasis>E</db:emphasis>. This quantifier means <db:emphasis>The previous expression is optional</db:emphasis>, because it will match whether or not the expression is found. <db:emphasis role="bold"><db:emphasis>E</db:emphasis>?</db:emphasis> is the same as <db:emphasis role="bold"><db:emphasis>E</db:emphasis>{0,1}</db:emphasis>. e.g., <db:emphasis role="bold">dents?</db:emphasis> matches 'dent' or 'dents'.</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para><db:emphasis role="bold"><db:emphasis>E</db:emphasis>+</db:emphasis></db:para>
</db:td>
<db:td>
<db:para>Matches one or more occurrences of <db:emphasis>E</db:emphasis>. <db:emphasis role="bold"><db:emphasis>E</db:emphasis>+</db:emphasis> is the same as <db:emphasis role="bold"><db:emphasis>E</db:emphasis>{1,}</db:emphasis>. e.g., <db:emphasis role="bold">0+</db:emphasis> matches '0', '00', '000', etc.</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para><db:emphasis role="bold"><db:emphasis>E</db:emphasis>*</db:emphasis></db:para>
</db:td>
<db:td>
<db:para>Matches zero or more occurrences of <db:emphasis>E</db:emphasis>. It is the same as <db:emphasis role="bold"><db:emphasis>E</db:emphasis>{0,}</db:emphasis>. The <db:emphasis role="bold">*</db:emphasis> quantifier is often used in error where <db:emphasis role="bold">+</db:emphasis> should be used. For example, if <db:emphasis role="bold">\s*$</db:emphasis> is used in an expression to match strings that end in whitespace, it will match every string because <db:emphasis role="bold">\s*$</db:emphasis> means <db:emphasis>Match zero or more whitespaces followed by end of string</db:emphasis>. The correct regexp to match strings that have at least one trailing whitespace character is <db:emphasis role="bold">\s+$</db:emphasis>.</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para><db:emphasis role="bold"><db:emphasis>E</db:emphasis>{n}</db:emphasis></db:para>
</db:td>
<db:td>
<db:para>Matches exactly <db:emphasis>n</db:emphasis> occurrences of <db:emphasis>E</db:emphasis>. <db:emphasis role="bold"><db:emphasis>E</db:emphasis>{n}</db:emphasis> is the same as repeating <db:emphasis>E</db:emphasis> <db:emphasis>n</db:emphasis> times. For example, <db:emphasis role="bold">x{5}</db:emphasis> is the same as <db:emphasis role="bold">xxxxx</db:emphasis>. It is also the same as <db:emphasis role="bold"><db:emphasis>E</db:emphasis>{n,n}</db:emphasis>, e.g. <db:emphasis role="bold">x{5,5}</db:emphasis>.</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para><db:emphasis role="bold"><db:emphasis>E</db:emphasis>{n,}</db:emphasis></db:para>
</db:td>
<db:td>
<db:para>Matches at least <db:emphasis>n</db:emphasis> occurrences of <db:emphasis>E</db:emphasis>.</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para><db:emphasis role="bold"><db:emphasis>E</db:emphasis>{,m}</db:emphasis></db:para>
</db:td>
<db:td>
<db:para>Matches at most <db:emphasis>m</db:emphasis> occurrences of <db:emphasis>E</db:emphasis>. <db:emphasis role="bold"><db:emphasis>E</db:emphasis>{,m}</db:emphasis> is the same as <db:emphasis role="bold"><db:emphasis>E</db:emphasis>{0,m}</db:emphasis>.</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para><db:emphasis role="bold"><db:emphasis>E</db:emphasis>{n,m}</db:emphasis></db:para>
</db:td>
<db:td>
<db:para>Matches at least <db:emphasis>n</db:emphasis> and at most <db:emphasis>m</db:emphasis> occurrences of <db:emphasis>E</db:emphasis>.</db:para>
</db:td>
</db:tr>
</db:informaltable>
<db:para>To apply a quantifier to more than just the preceding character, use parentheses to group characters together in an expression. For example, <db:emphasis role="bold">tag+</db:emphasis> matches a 't' followed by an 'a' followed by at least one 'g', whereas <db:emphasis role="bold">(tag)+</db:emphasis> matches at least one occurrence of 'tag'.</db:para>
<db:para>Note: Quantifiers are normally &quot;greedy&quot;. They always match as much text as they can. For example, <db:emphasis role="bold">0+</db:emphasis> matches the first zero it finds and all the consecutive zeros after the first zero. Applied to '20005', it matches '2<db:emphasis role="underline">000</db:emphasis>5'. Quantifiers can be made non-greedy, see <db:link xlink:href="qregexp.xml#setMinimal">setMinimal</db:link>().</db:para>
<db:anchor xml:id="capturing-parentheses"/>
<db:anchor xml:id="backreferences"/>
</db:section>
<db:section xml:id="capturing-text">
<db:title>Capturing Text</db:title>
<db:para>Parentheses allow us to group elements together so that we can quantify and capture them. For example if we have the expression <db:emphasis role="bold">mail|letter|correspondence</db:emphasis> that matches a string we know that <db:emphasis>one</db:emphasis> of the words matched but not which one. Using parentheses allows us to &quot;capture&quot; whatever is matched within their bounds, so if we used <db:emphasis role="bold">(mail|letter|correspondence)</db:emphasis> and matched this regexp against the string &quot;I sent you some email&quot; we can use the <db:link xlink:href="qregexp.xml#cap">cap</db:link>() or <db:link xlink:href="qregexp.xml#capturedTexts">capturedTexts</db:link>() functions to extract the matched characters, in this case 'mail'.</db:para>
<db:para>We can use captured text within the regexp itself. To refer to the captured text we use <db:emphasis>backreferences</db:emphasis> which are indexed from 1, the same as for <db:link xlink:href="qregexp.xml#cap">cap</db:link>(). For example we could search for duplicate words in a string using <db:emphasis role="bold">\b(\w+)\W+\1\b</db:emphasis> which means match a word boundary followed by one or more word characters followed by one or more non-word characters followed by the same text as the first parenthesized expression followed by a word boundary.</db:para>
<db:para>If we want to use parentheses purely for grouping and not for capturing we can use the non-capturing syntax, e.g. <db:emphasis role="bold">(?:green|blue)</db:emphasis>. Non-capturing parentheses begin '(?:' and end ')'. In this example we match either 'green' or 'blue' but we do not capture the match so we only know whether or not we matched but not which color we actually found. Using non-capturing parentheses is more efficient than using capturing parentheses since the regexp engine has to do less book-keeping.</db:para>
<db:para>Both capturing and non-capturing parentheses may be nested.</db:para>
<db:anchor xml:id="greedy-quantifiers"/>
<db:para>For historical reasons, quantifiers (e.g. <db:emphasis role="bold">*</db:emphasis>) that apply to capturing parentheses are more &quot;greedy&quot; than other quantifiers. For example, <db:emphasis role="bold">a*(a*)</db:emphasis> will match &quot;aaa&quot; with cap(1) == &quot;aaa&quot;. This behavior is different from what other regexp engines do (notably, Perl). To obtain a more intuitive capturing behavior, specify <db:link xlink:href="qregexp.xml#PatternSyntax-enum">QRegExp::RegExp2</db:link> to the <db:link xlink:href="qregexp.xml">QRegExp</db:link> constructor or call <db:link xlink:href="qregexp.xml#setPatternSyntax">setPatternSyntax</db:link>(<db:link xlink:href="qregexp.xml#PatternSyntax-enum">QRegExp::RegExp2</db:link>).</db:para>
<db:anchor xml:id="cap-in-a-loop"/>
<db:para>When the number of matches cannot be determined in advance, a common idiom is to use <db:link xlink:href="qregexp.xml#cap">cap</db:link>() in a loop. For example:</db:para>
<db:programlisting language="cpp">QRegExp rx(&quot;(\\d+)&quot;);
QString str = &quot;Offsets: 12 14 99 231 7&quot;;
QStringList list;
int pos = 0;

while ((pos = rx.indexIn(str, pos)) != -1) {
    list &amp;lt;&amp;lt; rx.cap(1);
    pos += rx.matchedLength();
}
// list: [&quot;12&quot;, &quot;14&quot;, &quot;99&quot;, &quot;231&quot;, &quot;7&quot;]
</db:programlisting>
</db:section>
<db:section xml:id="assertions">
<db:title>Assertions</db:title>
<db:para>Assertions make some statement about the text at the point where they occur in the regexp but they do not match any characters. In the following list <db:emphasis role="bold"><db:emphasis>E</db:emphasis></db:emphasis> stands for any expression.</db:para>
<db:informaltable style="generic">
<db:tr valign="top">
<db:td>
<db:para><db:emphasis role="bold">^</db:emphasis></db:para>
</db:td>
<db:td>
<db:para>The caret signifies the beginning of the string. If you wish to match a literal <db:code>^</db:code> you must escape it by writing <db:code>\\^</db:code>. For example, <db:emphasis role="bold">^#include</db:emphasis> will only match strings which <db:emphasis>begin</db:emphasis> with the characters '#include'. (When the caret is the first character of a character set it has a special meaning, see <db:link xlink:href="qregexp.xml#sets-of-characters">Sets of Characters</db:link>.)</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para><db:emphasis role="bold">$</db:emphasis></db:para>
</db:td>
<db:td>
<db:para>The dollar signifies the end of the string. For example <db:emphasis role="bold">\d\s*$</db:emphasis> will match strings which end with a digit optionally followed by whitespace. If you wish to match a literal <db:code>$</db:code> you must escape it by writing <db:code>\\$</db:code>.</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para><db:emphasis role="bold">\b</db:emphasis></db:para>
</db:td>
<db:td>
<db:para>A word boundary. For example the regexp <db:emphasis role="bold">\bOK\b</db:emphasis> means match immediately after a word boundary (e.g. start of string or whitespace) the letter 'O' then the letter 'K' immediately before another word boundary (e.g. end of string or whitespace). But note that the assertion does not actually match any whitespace so if we write <db:emphasis role="bold">(\bOK\b)</db:emphasis> and we have a match it will only contain 'OK' even if the string is &quot;It's <db:emphasis role="underline">OK</db:emphasis> now&quot;.</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para><db:emphasis role="bold">\B</db:emphasis></db:para>
</db:td>
<db:td>
<db:para>A non-word boundary. This assertion is true wherever <db:emphasis role="bold">\b</db:emphasis> is false. For example if we searched for <db:emphasis role="bold">\Bon\B</db:emphasis> in &quot;Left on&quot; the match would fail (space and end of string aren't non-word boundaries), but it would match in &quot;t<db:emphasis role="underline">on</db:emphasis>ne&quot;.</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para><db:emphasis role="bold">(?=<db:emphasis>E</db:emphasis>)</db:emphasis></db:para>
</db:td>
<db:td>
<db:para>Positive lookahead. This assertion is true if the expression matches at this point in the regexp. For example, <db:emphasis role="bold">const(?=\s+char)</db:emphasis> matches 'const' whenever it is followed by 'char', as in 'static <db:emphasis role="underline">const</db:emphasis> char *'. (Compare with <db:emphasis role="bold">const\s+char</db:emphasis>, which matches 'static <db:emphasis role="underline">const char</db:emphasis> *'.)</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para><db:emphasis role="bold">(?!<db:emphasis>E</db:emphasis>)</db:emphasis></db:para>
</db:td>
<db:td>
<db:para>Negative lookahead. This assertion is true if the expression does not match at this point in the regexp. For example, <db:emphasis role="bold">const(?!\s+char)</db:emphasis> matches 'const' <db:emphasis>except</db:emphasis> when it is followed by 'char'.</db:para>
</db:td>
</db:tr>
</db:informaltable>
<db:anchor xml:id="qregexp-wildcard-matching"/>
</db:section>
<db:section xml:id="wildcard-matching">
<db:title>Wildcard Matching</db:title>
<db:para>Most command shells such as <db:emphasis>bash</db:emphasis> or <db:emphasis>cmd.exe</db:emphasis> support &quot;file globbing&quot;, the ability to identify a group of files by using wildcards. The <db:link xlink:href="qregexp.xml#setPatternSyntax">setPatternSyntax</db:link>() function is used to switch between regexp and wildcard mode. Wildcard matching is much simpler than full regexps and has only four features:</db:para>
<db:informaltable style="generic">
<db:tr valign="top">
<db:td>
<db:para><db:emphasis role="bold">c</db:emphasis></db:para>
</db:td>
<db:td>
<db:para>Any character represents itself apart from those mentioned below. Thus <db:emphasis role="bold">c</db:emphasis> matches the character <db:emphasis>c</db:emphasis>.</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para><db:emphasis role="bold">?</db:emphasis></db:para>
</db:td>
<db:td>
<db:para>Matches any single character. It is the same as <db:emphasis role="bold">.</db:emphasis> in full regexps.</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para><db:emphasis role="bold">*</db:emphasis></db:para>
</db:td>
<db:td>
<db:para>Matches zero or more of any characters. It is the same as <db:emphasis role="bold">.*</db:emphasis> in full regexps.</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para><db:emphasis role="bold">[...]</db:emphasis></db:para>
</db:td>
<db:td>
<db:para>Sets of characters can be represented in square brackets, similar to full regexps. Within the character class, like outside, backslash has no special meaning.</db:para>
</db:td>
</db:tr>
</db:informaltable>
<db:para>In the mode Wildcard, the wildcard characters cannot be escaped. In the mode <db:link xlink:href="qregexp.xml#PatternSyntax-enum">WildcardUnix</db:link>, the character '\' escapes the wildcard.</db:para>
<db:para>For example if we are in wildcard mode and have strings which contain filenames we could identify HTML files with <db:emphasis role="bold">*.html</db:emphasis>. This will match zero or more characters followed by a dot followed by 'h', 't', 'm' and 'l'.</db:para>
<db:para>To test a string against a wildcard expression, use <db:link xlink:href="qregexp.xml#exactMatch">exactMatch</db:link>(). For example:</db:para>
<db:programlisting language="cpp">QRegExp rx(&quot;*.txt&quot;);
rx.setPatternSyntax(QRegExp::Wildcard);
rx.exactMatch(&quot;README.txt&quot;);        // returns true
rx.exactMatch(&quot;welcome.txt.bak&quot;);   // returns false
</db:programlisting>
<db:anchor xml:id="perl-users"/>
</db:section>
<db:section xml:id="notes-for-perl-users">
<db:title>Notes for Perl Users</db:title>
<db:para>Most of the character class abbreviations supported by Perl are supported by <db:link xlink:href="qregexp.xml">QRegExp</db:link>, see <db:link xlink:href="qregexp.xml#characters-and-abbreviations-for-sets-of-characters">characters and abbreviations for sets of characters</db:link>.</db:para>
<db:para>In <db:link xlink:href="qregexp.xml">QRegExp</db:link>, apart from within character classes, <db:code>^</db:code> always signifies the start of the string, so carets must always be escaped unless used for that purpose. In Perl the meaning of caret varies automagically depending on where it occurs so escaping it is rarely necessary. The same applies to <db:code>$</db:code> which in <db:link xlink:href="qregexp.xml">QRegExp</db:link> always signifies the end of the string.</db:para>
<db:para><db:link xlink:href="qregexp.xml">QRegExp</db:link>'s quantifiers are the same as Perl's greedy quantifiers (but see the <db:link xlink:href="qregexp.xml#greedy-quantifiers">note above</db:link>). Non-greedy matching cannot be applied to individual quantifiers, but can be applied to all the quantifiers in the pattern. For example, to match the Perl regexp <db:emphasis role="bold">ro+?m</db:emphasis> requires:</db:para>
<db:programlisting language="cpp">QRegExp rx(&quot;ro+m&quot;);
rx.setMinimal(true);
</db:programlisting>
<db:para>The equivalent of Perl's <db:code>/i</db:code> option is <db:link xlink:href="qregexp.xml#setCaseSensitivity">setCaseSensitivity</db:link>(<db:link xlink:href="qt.xml#CaseSensitivity-enum">Qt::CaseInsensitive</db:link>).</db:para>
<db:para>Perl's <db:code>/g</db:code> option can be emulated using a <db:link xlink:href="qregexp.xml#cap-in-a-loop">loop</db:link>.</db:para>
<db:para>In <db:link xlink:href="qregexp.xml">QRegExp</db:link> <db:emphasis role="bold">.</db:emphasis> matches any character, therefore all <db:link xlink:href="qregexp.xml">QRegExp</db:link> regexps have the equivalent of Perl's <db:code>/s</db:code> option. <db:link xlink:href="qregexp.xml">QRegExp</db:link> does not have an equivalent to Perl's <db:code>/m</db:code> option, but this can be emulated in various ways for example by splitting the input into lines or by looping with a regexp that searches for newlines.</db:para>
<db:para>Because <db:link xlink:href="qregexp.xml">QRegExp</db:link> is string oriented, there are no \A, \Z, or \z assertions. The \G assertion is not supported but can be emulated in a loop.</db:para>
<db:para>Perl's $&amp; is cap(0) or <db:link xlink:href="qregexp.xml#capturedTexts">capturedTexts</db:link>()[0]. There are no <db:link xlink:href="qregexp.xml">QRegExp</db:link> equivalents for $`, $' or $+. Perl's capturing variables, $1, $2, ... correspond to cap(1) or <db:link xlink:href="qregexp.xml#capturedTexts">capturedTexts</db:link>()[1], cap(2) or <db:link xlink:href="qregexp.xml#capturedTexts">capturedTexts</db:link>()[2], etc.</db:para>
<db:para>To substitute a pattern use <db:link xlink:href="qstring.xml#replace">QString::replace</db:link>().</db:para>
<db:para>Perl's extended <db:code>/x</db:code> syntax is not supported, nor are directives, e.g. (?i), or regexp comments, e.g. (?#comment). On the other hand, C++'s rules for literal strings can be used to achieve the same:</db:para>
<db:programlisting language="cpp">QRegExp mark(&quot;\\b&quot;      // word boundary
              &quot;[Mm]ark&quot; // the word we want to match
            );
</db:programlisting>
<db:para>Both zero-width positive and zero-width negative lookahead assertions (?=pattern) and (?!pattern) are supported with the same syntax as Perl. Perl's lookbehind assertions, &quot;independent&quot; subexpressions and conditional expressions are not supported.</db:para>
<db:para>Non-capturing parentheses are also supported, with the same (?:pattern) syntax.</db:para>
<db:para>See <db:link xlink:href="qstring.xml#split">QString::split</db:link>() and <db:link xlink:href="qstringlist.xml#join">QStringList::join</db:link>() for equivalents to Perl's split and join functions.</db:para>
<db:para>Note: because C++ transforms \'s they must be written <db:emphasis>twice</db:emphasis> in code, e.g. <db:emphasis role="bold">\b</db:emphasis> must be written <db:emphasis role="bold">\\b</db:emphasis>.</db:para>
</db:section>
<db:section xml:id="code-examples">
<db:title>Code Examples</db:title>
<db:programlisting language="cpp">QRegExp rx(&quot;^\\d\\d?$&quot;);    // match integers 0 to 99
rx.indexIn(&quot;123&quot;);          // returns -1 (no match)
rx.indexIn(&quot;-6&quot;);           // returns -1 (no match)
rx.indexIn(&quot;6&quot;);            // returns 0 (matched at position 0)
</db:programlisting>
<db:para>The third string matches '<db:emphasis role="underline">6</db:emphasis>'. This is a simple validation regexp for integers in the range 0 to 99.</db:para>
<db:programlisting language="cpp">QRegExp rx(&quot;^\\S+$&quot;);       // match strings without whitespace
rx.indexIn(&quot;Hello world&quot;);  // returns -1 (no match)
rx.indexIn(&quot;This_is-OK&quot;);   // returns 0 (matched at position 0)
</db:programlisting>
<db:para>The second string matches '<db:emphasis role="underline">This_is-OK</db:emphasis>'. We've used the character set abbreviation '\S' (non-whitespace) and the anchors to match strings which contain no whitespace.</db:para>
<db:para>In the following example we match strings containing 'mail' or 'letter' or 'correspondence' but only match whole words i.e. not 'email'</db:para>
<db:programlisting language="cpp">QRegExp rx(&quot;\\b(mail|letter|correspondence)\\b&quot;);
rx.indexIn(&quot;I sent you an email&quot;);     // returns -1 (no match)
rx.indexIn(&quot;Please write the letter&quot;); // returns 17
</db:programlisting>
<db:para>The second string matches &quot;Please write the <db:emphasis role="underline">letter</db:emphasis>&quot;. The word 'letter' is also captured (because of the parentheses). We can see what text we've captured like this:</db:para>
<db:programlisting language="cpp">QString captured = rx.cap(1); // captured == &quot;letter&quot;
</db:programlisting>
<db:para>This will capture the text from the first set of capturing parentheses (counting capturing left parentheses from left to right). The parentheses are counted from 1 since cap(0) is the whole matched regexp (equivalent to '&amp;' in most regexp engines).</db:para>
<db:programlisting language="cpp">QRegExp rx(&quot;&amp;amp;(?!amp;)&quot;);      // match ampersands but not &amp;amp;amp;
QString line1 = &quot;This &amp;amp; that&quot;;
line1.replace(rx, &quot;&amp;amp;amp;&quot;);
// line1 == &quot;This &amp;amp;amp; that&quot;
QString line2 = &quot;His &amp;amp;amp; hers &amp;amp; theirs&quot;;
line2.replace(rx, &quot;&amp;amp;amp;&quot;);
// line2 == &quot;His &amp;amp;amp; hers &amp;amp;amp; theirs&quot;
</db:programlisting>
<db:para>Here we've passed the <db:link xlink:href="qregexp.xml">QRegExp</db:link> to <db:link xlink:href="qstring.xml">QString</db:link>'s replace() function to replace the matched text with new text.</db:para>
<db:programlisting language="cpp">QString str = &quot;One Eric another Eirik, and an Ericsson. &quot;
              &quot;How many Eiriks, Eric?&quot;;
QRegExp rx(&quot;\\b(Eric|Eirik)\\b&quot;); // match Eric or Eirik
int pos = 0;    // where we are in the string
int count = 0;  // how many Eric and Eirik's we've counted
while (pos &amp;gt;= 0) {
    pos = rx.indexIn(str, pos);
    if (pos &amp;gt;= 0) {
        ++pos;      // move along in str
        ++count;    // count our Eric or Eirik
    }
}
</db:programlisting>
<db:para>We've used the <db:link xlink:href="qregexp.xml#indexIn">indexIn</db:link>() function to repeatedly match the regexp in the string. Note that instead of moving forward by one character at a time <db:code>pos++</db:code> we could have written <db:code>pos += rx.matchedLength()</db:code> to skip over the already matched string. The count will equal 3, matching 'One <db:emphasis role="underline">Eric</db:emphasis> another <db:emphasis role="underline">Eirik</db:emphasis>, and an Ericsson. How many Eiriks, <db:emphasis role="underline">Eric</db:emphasis>?'; it doesn't match 'Ericsson' or 'Eiriks' because they are not bounded by non-word boundaries.</db:para>
<db:para>One common use of regexps is to split lines of delimited data into their component fields.</db:para>
<db:programlisting language="cpp">str = &quot;The Qt Company Ltd\tqt.io\tFinland&quot;;
QString company, web, country;
rx.setPattern(&quot;^([^\t]+)\t([^\t]+)\t([^\t]+)$&quot;);
if (rx.indexIn(str) != -1) {
    company = rx.cap(1);
    web = rx.cap(2);
    country = rx.cap(3);
}
</db:programlisting>
<db:para>In this example our input lines have the format company name, web address and country. Unfortunately the regexp is rather long and not very versatile â€“ the code will break if we add any more fields. A simpler and better solution is to look for the separator, '\t' in this case, and take the surrounding text. The <db:link xlink:href="qstring.xml#split">QString::split</db:link>() function can take a separator string or regexp as an argument and split a string accordingly.</db:para>
<db:programlisting language="cpp">QStringList field = str.split(&quot;\t&quot;);
</db:programlisting>
<db:para>Here field[0] is the company, field[1] the web address and so on.</db:para>
<db:para>To imitate the matching of a shell we can use wildcard mode.</db:para>
<db:programlisting language="cpp">QRegExp rx(&quot;*.html&quot;);
rx.setPatternSyntax(QRegExp::Wildcard);
rx.exactMatch(&quot;index.html&quot;);                // returns true
rx.exactMatch(&quot;default.htm&quot;);               // returns false
rx.exactMatch(&quot;readme.txt&quot;);                // returns false
</db:programlisting>
<db:para>Wildcard matching can be convenient because of its simplicity, but any wildcard regexp can be defined using full regexps, e.g. <db:emphasis role="bold">.*\.html$</db:emphasis>. Notice that we can't match both <db:code>.html</db:code> and <db:code>.htm</db:code> files with a wildcard unless we use <db:emphasis role="bold">*.htm*</db:emphasis> which will also match 'test.html.bak'. A full regexp gives us the precision we need, <db:emphasis role="bold">.*\.html?$</db:emphasis>.</db:para>
<db:para><db:link xlink:href="qregexp.xml">QRegExp</db:link> can match case insensitively using <db:link xlink:href="qregexp.xml#setCaseSensitivity">setCaseSensitivity</db:link>(), and can use non-greedy matching, see <db:link xlink:href="qregexp.xml#setMinimal">setMinimal</db:link>(). By default <db:link xlink:href="qregexp.xml">QRegExp</db:link> uses full regexps but this can be changed with <db:link xlink:href="qregexp.xml#setPatternSyntax">setPatternSyntax</db:link>(). Searching can be done forward with <db:link xlink:href="qregexp.xml#indexIn">indexIn</db:link>() or backward with <db:link xlink:href="qregexp.xml#lastIndexIn">lastIndexIn</db:link>(). Captured text can be accessed using <db:link xlink:href="qregexp.xml#capturedTexts">capturedTexts</db:link>() which returns a string list of all captured strings, or using <db:link xlink:href="qregexp.xml#cap">cap</db:link>() which returns the captured string for the given index. The <db:link xlink:href="qregexp.xml#pos">pos</db:link>() function takes a match index and returns the position in the string where the match was made (or -1 if there was no match).</db:para>
</db:section>
<db:section xml:id="porting-to-qregularexpression">
<db:title>Porting to QRegularExpression</db:title>
<db:para>The <db:link xlink:href="qregularexpression.xml">QRegularExpression</db:link> class introduced in Qt 5 is a big improvement upon <db:link xlink:href="qregexp.xml">QRegExp</db:link>, in terms of APIs offered, supported pattern syntax and speed of execution. The biggest difference is that <db:link xlink:href="qregularexpression.xml">QRegularExpression</db:link> simply holds a regular expression, and it's <db:emphasis>not</db:emphasis> modified when a match is requested. Instead, a <db:link xlink:href="qregularexpressionmatch.xml">QRegularExpressionMatch</db:link> object is returned, in order to check the result of a match and extract the captured substring. The same applies with global matching and <db:link xlink:href="qregularexpressionmatchiterator.xml">QRegularExpressionMatchIterator</db:link>.</db:para>
<db:para>Other differences are outlined below.</db:para>
<db:section xml:id="different-pattern-syntax">
<db:title>Different pattern syntax</db:title>
<db:para>Porting a regular expression from <db:link xlink:href="qregexp.xml">QRegExp</db:link> to <db:link xlink:href="qregularexpression.xml">QRegularExpression</db:link> may require changes to the pattern itself.</db:para>
<db:para>In certain scenarios, <db:link xlink:href="qregexp.xml">QRegExp</db:link> was too lenient and accepted patterns that are simply invalid when using <db:link xlink:href="qregularexpression.xml">QRegularExpression</db:link>. These are somehow easy to detect, because the <db:link xlink:href="qregularexpression.xml">QRegularExpression</db:link> objects built with these patterns are not valid (cf. <db:link xlink:href="qregularexpression.xml#isValid">QRegularExpression::isValid</db:link>()).</db:para>
<db:para>In other cases, a pattern ported from <db:link xlink:href="qregexp.xml">QRegExp</db:link> to <db:link xlink:href="qregularexpression.xml">QRegularExpression</db:link> may silently change semantics. Therefore, it is necessary to review the patterns used. The most notable cases of silent incompatibility are:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para>Curly braces are needed in order to use a hexadecimal escape like <db:code>\xHHHH</db:code> with more than 2 digits. A pattern like <db:code>\x2022</db:code> neeeds to be ported to <db:code>\x{2022}</db:code>, or it will match a space (<db:code>0x20</db:code>) followed by the string <db:code>&quot;22&quot;</db:code>. In general, it is highly recommended to always use curly braces with the <db:code>\x</db:code> escape, no matter the amount of digits specified.</db:para>
</db:listitem>
<db:listitem>
<db:para>A 0-to-n quantification like <db:code>{,n}</db:code> needs to be ported to <db:code>{0,n}</db:code> to preserve semantics. Otherwise, a pattern such as <db:code>\d{,3}</db:code> would actually match a digit followed by the exact string <db:code>&quot;{,3}&quot;</db:code>.</db:para>
</db:listitem>
<db:listitem>
<db:para><db:link xlink:href="qregexp.xml">QRegExp</db:link> by default does Unicode-aware matching, while <db:link xlink:href="qregularexpression.xml">QRegularExpression</db:link> requires a separate option; see below for more details.</db:para>
</db:listitem>
<db:listitem>
<db:para>c{.} in <db:link xlink:href="qregexp.xml">QRegExp</db:link> does by default match all characters, including the newline character. <db:link xlink:href="qregularexpression.xml">QRegularExpression</db:link> excludes the newline character by default. To include the newline character, set the <db:link xlink:href="qregularexpression.xml#PatternOption-enum">QRegularExpression::DotMatchesEverythingOption</db:link> pattern option.</db:para>
</db:listitem>
</db:itemizedlist>
</db:section>
<db:section xml:id="porting-from-qregexp-exactmatch">
<db:title>Porting from QRegExp::exactMatch()</db:title>
<db:para><db:link xlink:href="qregexp.xml#exactMatch">QRegExp::exactMatch</db:link>() in Qt 4 served two purposes: it exactly matched a regular expression against a subject string, and it implemented partial matching.</db:para>
<db:section xml:id="porting-from-qregexp-s-exact-matching">
<db:title>Porting from QRegExp's Exact Matching</db:title>
<db:para>Exact matching indicates whether the regular expression matches the entire subject string. For example, the classes yield on the subject string <db:code>&quot;abc123&quot;</db:code>:</db:para>
<db:informaltable style="generic">
<db:thead>
<db:tr>
<db:th>
</db:th>
<db:th>
<db:para><db:link xlink:href="qregexp.xml#exactMatch">QRegExp::exactMatch</db:link>()</db:para>
</db:th>
<db:th>
<db:para><db:link xlink:href="qregularexpressionmatch.xml#hasMatch">QRegularExpressionMatch::hasMatch</db:link>()</db:para>
</db:th>
</db:tr>
</db:thead>
<db:tr valign="top">
<db:td>
<db:para><db:code>&quot;\\d+&quot;</db:code></db:para>
</db:td>
<db:td>
<db:para><db:emphasis role="bold">false</db:emphasis></db:para>
</db:td>
<db:td>
<db:para><db:emphasis role="bold">true</db:emphasis></db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para><db:code>&quot;[a-z]+\\d+&quot;</db:code></db:para>
</db:td>
<db:td>
<db:para><db:emphasis role="bold">true</db:emphasis></db:para>
</db:td>
<db:td>
<db:para><db:emphasis role="bold">true</db:emphasis></db:para>
</db:td>
</db:tr>
</db:informaltable>
<db:para>Exact matching is not reflected in <db:link xlink:href="qregularexpression.xml">QRegularExpression</db:link>. If you want to be sure that the subject string matches the regular expression exactly, you can wrap the pattern using the <db:link xlink:href="qregularexpression.xml#anchoredPattern">QRegularExpression::anchoredPattern</db:link>() function:</db:para>
<db:programlisting language="cpp">QString p(&quot;a .*|pattern&quot;);

// re matches exactly the pattern string p
QRegularExpression re(QRegularExpression::anchoredPattern(p));
</db:programlisting>
</db:section>
<db:section xml:id="porting-from-qregexp-s-partial-matching">
<db:title>Porting from QRegExp's Partial Matching</db:title>
<db:para>When using <db:link xlink:href="qregexp.xml#exactMatch">QRegExp::exactMatch</db:link>(), if an exact match was not found, one could still find out how much of the subject string was matched by the regular expression by calling <db:link xlink:href="qregexp.xml#matchedLength">QRegExp::matchedLength</db:link>(). If the returned length was equal to the subject string's length, then one could conclude that a partial match was found.</db:para>
<db:para><db:link xlink:href="qregularexpression.xml">QRegularExpression</db:link> supports partial matching explicitly by means of the appropriate MatchType.</db:para>
</db:section>
</db:section>
<db:section xml:id="global-matching">
<db:title>Global matching</db:title>
<db:para>Due to limitations of the <db:link xlink:href="qregexp.xml">QRegExp</db:link> API it was impossible to implement global matching correctly (that is, like Perl does). In particular, patterns that can match 0 characters (like <db:code>&quot;a*&quot;</db:code>) are problematic.</db:para>
<db:para><db:link xlink:href="qregularexpression.xml#globalMatch">QRegularExpression::globalMatch</db:link>() implements Perl global match correctly, and the returned iterator can be used to examine each result.</db:para>
</db:section>
<db:section xml:id="unicode-properties-support">
<db:title>Unicode properties support</db:title>
<db:para>When using <db:link xlink:href="qregexp.xml">QRegExp</db:link>, character classes such as <db:code>\w</db:code>, <db:code>\d</db:code>, etc. match characters with the corresponding Unicode property: for instance, <db:code>\d</db:code> matches any character with the Unicode Nd (decimal digit) property.</db:para>
<db:para>Those character classes only match ASCII characters by default when using <db:link xlink:href="qregularexpression.xml">QRegularExpression</db:link>: for instance, <db:code>\d</db:code> matches exactly a character in the <db:code>0-9</db:code> ASCII range. It is possible to change this behavior by using the UseUnicodePropertiesOption pattern option.</db:para>
</db:section>
<db:section xml:id="wildcard-matching">
<db:title>Wildcard matching</db:title>
<db:para>There is no direct way to do wildcard matching in <db:link xlink:href="qregularexpression.xml">QRegularExpression</db:link>. However, the wildcardToRegularExpression method is provided to translate glob patterns into a Perl-compatible regular expression that can be used for that purpose.</db:para>
</db:section>
<db:section xml:id="other-pattern-syntaxes">
<db:title>Other pattern syntaxes</db:title>
<db:para><db:link xlink:href="qregularexpression.xml">QRegularExpression</db:link> supports only Perl-compatible regular expressions.</db:para>
</db:section>
<db:section xml:id="minimal-matching">
<db:title>Minimal matching</db:title>
<db:para><db:link xlink:href="qregexp.xml#setMinimal">QRegExp::setMinimal</db:link>() implemented minimal matching by simply reversing the greediness of the quantifiers (<db:link xlink:href="qregexp.xml">QRegExp</db:link> did not support lazy quantifiers, like <db:code>*?</db:code>, <db:code>+?</db:code>, etc.). <db:link xlink:href="qregularexpression.xml">QRegularExpression</db:link> instead does support greedy, lazy and possessive quantifiers. The InvertedGreedinessOption pattern option can be useful to emulate the effects of <db:link xlink:href="qregexp.xml#setMinimal">QRegExp::setMinimal</db:link>(): if enabled, it inverts the greediness of quantifiers (greedy ones become lazy and vice versa).</db:para>
</db:section>
<db:section xml:id="caret-modes">
<db:title>Caret modes</db:title>
<db:para>The AnchorAtOffsetMatchOption match option can be used to emulate the <db:link xlink:href="qregexp.xml#CaretMode-enum">QRegExp::CaretAtOffset</db:link> behavior. There is no equivalent for the other <db:link xlink:href="qregexp.xml#CaretMode-enum">QRegExp::CaretMode</db:link> modes.</db:para>
</db:section>
</db:section>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qstring.xml">QString</db:link></db:member>
<db:member><db:link xlink:href="qstringlist.xml">QStringList</db:link></db:member>
<db:member><db:link xlink:href="qsortfilterproxymodel.xml">QSortFilterProxyModel</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="member-type-documentation">
<db:title>Member Type Documentation</db:title>
<db:section xml:id="CaretMode-enum">
<db:title>enum QRegExp::CaretMode</db:title>
<db:enumsynopsis>
<db:enumname>CaretMode</db:enumname>
<db:enumitem>
<db:enumidentifier>CaretAtZero</db:enumidentifier>
<db:enumvalue>0</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>CaretAtOffset</db:enumidentifier>
<db:enumvalue>1</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>CaretWontMatch</db:enumidentifier>
<db:enumvalue>2</db:enumvalue>
</db:enumitem>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:enumsynopsis>
<db:para>The CaretMode enum defines the different meanings of the caret (<db:emphasis role="bold">^</db:emphasis>) in a regular expression. The possible values are:</db:para>
<db:informaltable>
<db:thead>
<db:tr>
<db:th>Constant</db:th>
<db:th>Value</db:th>
<db:th>Description</db:th>
</db:tr>
</db:thead>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qregexp.xml">QRegExp</db:link></db:emphasis>::CaretAtZero</db:code></db:para>
</db:td>
<db:td><db:code>0</db:code></db:td>
<db:td>
<db:para>The caret corresponds to index 0 in the searched string.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qregexp.xml">QRegExp</db:link></db:emphasis>::CaretAtOffset</db:code></db:para>
</db:td>
<db:td><db:code>1</db:code></db:td>
<db:td>
<db:para>The caret corresponds to the start offset of the search.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qregexp.xml">QRegExp</db:link></db:emphasis>::CaretWontMatch</db:code></db:para>
</db:td>
<db:td><db:code>2</db:code></db:td>
<db:td>
<db:para>The caret never matches.</db:para>
</db:td>
</db:tr>
</db:informaltable>
</db:section>
<db:section xml:id="PatternSyntax-enum">
<db:title>enum QRegExp::PatternSyntax</db:title>
<db:enumsynopsis>
<db:enumname>PatternSyntax</db:enumname>
<db:enumitem>
<db:enumidentifier>RegExp</db:enumidentifier>
<db:enumvalue>0</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>Wildcard</db:enumidentifier>
<db:enumvalue>1</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>FixedString</db:enumidentifier>
<db:enumvalue>2</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>RegExp2</db:enumidentifier>
<db:enumvalue>3</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>WildcardUnix</db:enumidentifier>
<db:enumvalue>4</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>W3CXmlSchema11</db:enumidentifier>
<db:enumvalue>5</db:enumvalue>
</db:enumitem>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:enumsynopsis>
<db:para>The syntax used to interpret the meaning of the pattern.</db:para>
<db:informaltable>
<db:thead>
<db:tr>
<db:th>Constant</db:th>
<db:th>Value</db:th>
<db:th>Description</db:th>
</db:tr>
</db:thead>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qregexp.xml">QRegExp</db:link></db:emphasis>::RegExp</db:code></db:para>
</db:td>
<db:td><db:code>0</db:code></db:td>
<db:td>
<db:para>A rich Perl-like pattern matching syntax. This is the default.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qregexp.xml">QRegExp</db:link></db:emphasis>::RegExp2</db:code></db:para>
</db:td>
<db:td><db:code>3</db:code></db:td>
<db:td>
<db:para>Like RegExp, but with <db:link xlink:href="qregexp.xml#greedy-quantifiers">greedy quantifiers</db:link>. (Introduced in Qt 4.2.)</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qregexp.xml">QRegExp</db:link></db:emphasis>::Wildcard</db:code></db:para>
</db:td>
<db:td><db:code>1</db:code></db:td>
<db:td>
<db:para>This provides a simple pattern matching syntax similar to that used by shells (command interpreters) for &quot;file globbing&quot;. See <db:link xlink:href="qregexp.xml#qregexp-wildcard-matching">QRegExp wildcard matching</db:link>.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qregexp.xml">QRegExp</db:link></db:emphasis>::WildcardUnix</db:code></db:para>
</db:td>
<db:td><db:code>4</db:code></db:td>
<db:td>
<db:para>This is similar to Wildcard but with the behavior of a Unix shell. The wildcard characters can be escaped with the character &quot;\&quot;.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qregexp.xml">QRegExp</db:link></db:emphasis>::FixedString</db:code></db:para>
</db:td>
<db:td><db:code>2</db:code></db:td>
<db:td>
<db:para>The pattern is a fixed string. This is equivalent to using the RegExp pattern on a string in which all metacharacters are escaped using <db:link xlink:href="qregexp.xml#escape">escape</db:link>().</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qregexp.xml">QRegExp</db:link></db:emphasis>::W3CXmlSchema11</db:code></db:para>
</db:td>
<db:td><db:code>5</db:code></db:td>
<db:td>
<db:para>The pattern is a regular expression as defined by the W3C XML Schema 1.1 specification.</db:para>
</db:td>
</db:tr>
</db:informaltable>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qregexp.xml#setPatternSyntax">setPatternSyntax</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
</db:section>
<db:section xml:id="member-function-documentation">
<db:title>Member Function Documentation</db:title>
<db:section xml:id="QRegExp">
<db:title>QRegExp::QRegExp()</db:title>
<db:constructorsynopsis>
<db:methodname>QRegExp</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">constructor</db:synopsisinfo>
<db:synopsisinfo role="signature">QRegExp()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:constructorsynopsis>
<db:para>Constructs an empty regexp.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qregexp.xml#isValid">isValid</db:link>()</db:member>
<db:member><db:link xlink:href="qregexp.xml#errorString">errorString</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="QRegExp-1">
<db:title>[explicit] QRegExp::QRegExp(const QString &amp;<db:emphasis>pattern</db:emphasis>, Qt::CaseSensitivity <db:emphasis>cs</db:emphasis> = Qt::CaseSensitive, QRegExp::PatternSyntax <db:emphasis>syntax</db:emphasis> = RegExp)</db:title>
<db:constructorsynopsis>
<db:methodname>QRegExp</db:methodname>
<db:methodparam>
<db:type>const QString &amp;</db:type>
<db:parameter>pattern</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>Qt::CaseSensitivity</db:type>
<db:parameter>cs</db:parameter>
<db:initializer>Qt::CaseSensitive</db:initializer>
</db:methodparam>
<db:methodparam>
<db:type>QRegExp::PatternSyntax</db:type>
<db:parameter>syntax</db:parameter>
<db:initializer>RegExp</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">constructor</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">QRegExp(const QString &amp;pattern, Qt::CaseSensitivity cs, QRegExp::PatternSyntax syntax)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:constructorsynopsis>
<db:para>Constructs a regular expression object for the given <db:code role="parameter">pattern</db:code> string. The pattern must be given using wildcard notation if <db:code role="parameter">syntax</db:code> is <db:link xlink:href="qregexp.xml#PatternSyntax-enum">Wildcard</db:link>; the default is <db:link xlink:href="qregexp.xml#PatternSyntax-enum">RegExp</db:link>. The pattern is case sensitive, unless <db:code role="parameter">cs</db:code> is <db:link xlink:href="qt.xml#CaseSensitivity-enum">Qt::CaseInsensitive</db:link>. Matching is greedy (maximal), but can be changed by calling <db:link xlink:href="qregexp.xml#setMinimal">setMinimal</db:link>().</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qregexp.xml#setPattern">setPattern</db:link>()</db:member>
<db:member><db:link xlink:href="qregexp.xml#setCaseSensitivity">setCaseSensitivity</db:link>()</db:member>
<db:member><db:link xlink:href="qregexp.xml#setPatternSyntax">setPatternSyntax</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="QRegExp-2">
<db:title>QRegExp::QRegExp(const QRegExp &amp;<db:emphasis>rx</db:emphasis>)</db:title>
<db:constructorsynopsis>
<db:methodname>QRegExp</db:methodname>
<db:methodparam>
<db:type>const QRegExp &amp;</db:type>
<db:parameter>rx</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">copy-constructor</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">2</db:synopsisinfo>
<db:synopsisinfo role="signature">QRegExp(const QRegExp &amp;rx)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:constructorsynopsis>
<db:para>Constructs a regular expression as a copy of <db:code role="parameter">rx</db:code>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qregexp.xml#operator-eq">operator=</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="dtor.QRegExp">
<db:title>QRegExp::~QRegExp()</db:title>
<db:destructorsynopsis>
<db:methodname>~QRegExp</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">destructor</db:synopsisinfo>
<db:synopsisinfo role="signature">~QRegExp()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:destructorsynopsis>
<db:para>Destroys the regular expression and cleans up its internal data.</db:para>
</db:section>
<db:section xml:id="cap">
<db:title>QString QRegExp::cap(int <db:emphasis>nth</db:emphasis> = 0) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QString</db:type>
<db:methodname>cap</db:methodname>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>nth</db:parameter>
<db:initializer>0</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QString cap(int nth) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the text captured by the <db:code role="parameter">nth</db:code> subexpression. The entire match has index 0 and the parenthesized subexpressions have indexes starting from 1 (excluding non-capturing parentheses).</db:para>
<db:programlisting language="cpp">QRegExp rxlen(&quot;(\\d+)(?:\\s*)(cm|inch)&quot;);
int pos = rxlen.indexIn(&quot;Length: 189cm&quot;);
if (pos &amp;gt; -1) {
    QString value = rxlen.cap(1); // &quot;189&quot;
    QString unit = rxlen.cap(2);  // &quot;cm&quot;
    // ...
}
</db:programlisting>
<db:para>The order of elements matched by cap() is as follows. The first element, cap(0), is the entire matching string. Each subsequent element corresponds to the next capturing open left parentheses. Thus cap(1) is the text of the first capturing parentheses, cap(2) is the text of the second, and so on.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qregexp.xml#capturedTexts">capturedTexts</db:link>()</db:member>
<db:member><db:link xlink:href="qregexp.xml#pos">pos</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="captureCount">
<db:title>int QRegExp::captureCount() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>int</db:type>
<db:methodname>captureCount</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">int captureCount() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the number of captures contained in the regular expression.</db:para>
</db:section>
<db:section xml:id="capturedTexts">
<db:title>QStringList QRegExp::capturedTexts() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QStringList</db:type>
<db:methodname>capturedTexts</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QStringList capturedTexts() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns a list of the captured text strings.</db:para>
<db:para>The first string in the list is the entire matched string. Each subsequent list element contains a string that matched a (capturing) subexpression of the regexp.</db:para>
<db:para>For example:</db:para>
<db:programlisting language="cpp">QRegExp rx(&quot;(\\d+)(\\s*)(cm|inch(es)?)&quot;);
int pos = rx.indexIn(&quot;Length: 36 inches&quot;);
QStringList list = rx.capturedTexts();
// list is now (&quot;36 inches&quot;, &quot;36&quot;, &quot; &quot;, &quot;inches&quot;, &quot;es&quot;)
</db:programlisting>
<db:para>The above example also captures elements that may be present but which we have no interest in. This problem can be solved by using non-capturing parentheses:</db:para>
<db:programlisting language="cpp">QRegExp rx(&quot;(\\d+)(?:\\s*)(cm|inch(?:es)?)&quot;);
int pos = rx.indexIn(&quot;Length: 36 inches&quot;);
QStringList list = rx.capturedTexts();
// list is now (&quot;36 inches&quot;, &quot;36&quot;, &quot;inches&quot;)
</db:programlisting>
<db:para>Note that if you want to iterate over the list, you should iterate over a copy, e.g.</db:para>
<db:programlisting language="cpp">QStringList list = rx.capturedTexts();
QStringList::iterator it = list.begin();
while (it != list.end()) {
    myProcessing(*it);
    ++it;
}
</db:programlisting>
<db:para>Some regexps can match an indeterminate number of times. For example if the input string is &quot;Offsets: 12 14 99 231 7&quot; and the regexp, <db:code>rx</db:code>, is <db:emphasis role="bold">(\d+)+</db:emphasis>, we would hope to get a list of all the numbers matched. However, after calling <db:code>rx.indexIn(str)</db:code>, capturedTexts() will return the list (&quot;12&quot;, &quot;12&quot;), i.e. the entire match was &quot;12&quot; and the first subexpression matched was &quot;12&quot;. The correct approach is to use <db:link xlink:href="qregexp.xml#cap">cap</db:link>() in a <db:link xlink:href="qregexp.xml#cap-in-a-loop">loop</db:link>.</db:para>
<db:para>The order of elements in the string list is as follows. The first element is the entire matching string. Each subsequent element corresponds to the next capturing open left parentheses. Thus capturedTexts()[1] is the text of the first capturing parentheses, capturedTexts()[2] is the text of the second and so on (corresponding to $1, $2, etc., in some other regexp languages).</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qregexp.xml#cap">cap</db:link>()</db:member>
<db:member><db:link xlink:href="qregexp.xml#pos">pos</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="caseSensitivity">
<db:title>Qt::CaseSensitivity QRegExp::caseSensitivity() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>Qt::CaseSensitivity</db:type>
<db:methodname>caseSensitivity</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">Qt::CaseSensitivity caseSensitivity() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns <db:link xlink:href="qt.xml#CaseSensitivity-enum">Qt::CaseSensitive</db:link> if the regexp is matched case sensitively; otherwise returns <db:link xlink:href="qt.xml#CaseSensitivity-enum">Qt::CaseInsensitive</db:link>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qregexp.xml#setCaseSensitivity">setCaseSensitivity</db:link>()</db:member>
<db:member><db:link xlink:href="qregexp.xml#patternSyntax">patternSyntax</db:link>()</db:member>
<db:member><db:link xlink:href="qregexp.xml#pattern">pattern</db:link>()</db:member>
<db:member><db:link xlink:href="qregexp.xml#isMinimal">isMinimal</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="countIn">
<db:title>int QRegExp::countIn(const QString &amp;<db:emphasis>str</db:emphasis>) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>int</db:type>
<db:methodname>countIn</db:methodname>
<db:methodparam>
<db:type>const QString &amp;</db:type>
<db:parameter>str</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">int countIn(const QString &amp;str) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the number of times this regular expression matches in <db:code role="parameter">str</db:code>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qregexp.xml#indexIn">indexIn</db:link>()</db:member>
<db:member><db:link xlink:href="qregexp.xml#lastIndexIn">lastIndexIn</db:link>()</db:member>
<db:member><db:link xlink:href="qregexp.xml#replaceIn">replaceIn</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="errorString">
<db:title>QString QRegExp::errorString() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QString</db:type>
<db:methodname>errorString</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QString errorString() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns a text string that explains why a regexp pattern is invalid the case being; otherwise returns &quot;no error occurred&quot;.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qregexp.xml#isValid">isValid</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="escape">
<db:title>[static] QString QRegExp::escape(const QString &amp;<db:emphasis>str</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:modifier>static</db:modifier>
<db:type>QString</db:type>
<db:methodname>escape</db:methodname>
<db:methodparam>
<db:type>const QString &amp;</db:type>
<db:parameter>str</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QString escape(const QString &amp;str)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the string <db:code role="parameter">str</db:code> with every regexp special character escaped with a backslash. The special characters are $, (,), *, +, ., ?, [, ,], ^, {, | and }.</db:para>
<db:para>Example:</db:para>
<db:programlisting language="cpp">s1 = QRegExp::escape(&quot;bingo&quot;);   // s1 == &quot;bingo&quot;
s2 = QRegExp::escape(&quot;f(x)&quot;);    // s2 == &quot;f\\(x\\)&quot;
</db:programlisting>
<db:para>This function is useful to construct regexp patterns dynamically:</db:para>
<db:programlisting language="cpp">QRegExp rx(&quot;(&quot; + QRegExp::escape(name) +
           &quot;|&quot; + QRegExp::escape(alias) + &quot;)&quot;);
</db:programlisting>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qregexp.xml#setPatternSyntax">setPatternSyntax</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="exactMatch">
<db:title>bool QRegExp::exactMatch(const QString &amp;<db:emphasis>str</db:emphasis>) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>bool</db:type>
<db:methodname>exactMatch</db:methodname>
<db:methodparam>
<db:type>const QString &amp;</db:type>
<db:parameter>str</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool exactMatch(const QString &amp;str) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns <db:code>true</db:code> if <db:code role="parameter">str</db:code> is matched exactly by this regular expression; otherwise returns <db:code>false</db:code>. You can determine how much of the string was matched by calling <db:link xlink:href="qregexp.xml#matchedLength">matchedLength</db:link>().</db:para>
<db:para>For a given regexp string R, exactMatch(&quot;R&quot;) is the equivalent of <db:link xlink:href="qregexp.xml#indexIn">indexIn</db:link>(&quot;^R$&quot;) since exactMatch() effectively encloses the regexp in the start of string and end of string anchors, except that it sets <db:link xlink:href="qregexp.xml#matchedLength">matchedLength</db:link>() differently.</db:para>
<db:para>For example, if the regular expression is <db:emphasis role="bold">blue</db:emphasis>, then exactMatch() returns <db:code>true</db:code> only for input <db:code>blue</db:code>. For inputs <db:code>bluebell</db:code>, <db:code>blutak</db:code> and <db:code>lightblue</db:code>, exactMatch() returns <db:code>false</db:code> and <db:link xlink:href="qregexp.xml#matchedLength">matchedLength</db:link>() will return 4, 3 and 0 respectively.</db:para>
<db:para>Although const, this function sets <db:link xlink:href="qregexp.xml#matchedLength">matchedLength</db:link>(), <db:link xlink:href="qregexp.xml#capturedTexts">capturedTexts</db:link>(), and <db:link xlink:href="qregexp.xml#pos">pos</db:link>().</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qregexp.xml#indexIn">indexIn</db:link>()</db:member>
<db:member><db:link xlink:href="qregexp.xml#lastIndexIn">lastIndexIn</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="filterList">
<db:title>QStringList QRegExp::filterList(const QStringList &amp;<db:emphasis>stringList</db:emphasis>) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QStringList</db:type>
<db:methodname>filterList</db:methodname>
<db:methodparam>
<db:type>const QStringList &amp;</db:type>
<db:parameter>stringList</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QStringList filterList(const QStringList &amp;stringList) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns a list of all the strings that match this regular expression in <db:code role="parameter">stringList</db:code>.</db:para>
</db:section>
<db:section xml:id="indexIn">
<db:title>int QRegExp::indexIn(const QString &amp;<db:emphasis>str</db:emphasis>, int <db:emphasis>offset</db:emphasis> = 0, QRegExp::CaretMode <db:emphasis>caretMode</db:emphasis> = CaretAtZero) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>int</db:type>
<db:methodname>indexIn</db:methodname>
<db:methodparam>
<db:type>const QString &amp;</db:type>
<db:parameter>str</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>offset</db:parameter>
<db:initializer>0</db:initializer>
</db:methodparam>
<db:methodparam>
<db:type>QRegExp::CaretMode</db:type>
<db:parameter>caretMode</db:parameter>
<db:initializer>CaretAtZero</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">int indexIn(const QString &amp;str, int offset, QRegExp::CaretMode caretMode) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Attempts to find a match in <db:code role="parameter">str</db:code> from position <db:code role="parameter">offset</db:code> (0 by default). If <db:code role="parameter">offset</db:code> is -1, the search starts at the last character; if -2, at the next to last character; etc.</db:para>
<db:para>Returns the position of the first match, or -1 if there was no match.</db:para>
<db:para>The <db:code role="parameter">caretMode</db:code> parameter can be used to instruct whether <db:emphasis role="bold">^</db:emphasis> should match at index 0 or at <db:code role="parameter">offset</db:code>.</db:para>
<db:para>You might prefer to use <db:link xlink:href="qstring.xml#indexOf">QString::indexOf</db:link>(), <db:link xlink:href="qstring.xml#contains">QString::contains</db:link>(), or even <db:link xlink:href="qstringlist.xml#filter">QStringList::filter</db:link>(). To replace matches use <db:link xlink:href="qstring.xml#replace">QString::replace</db:link>().</db:para>
<db:para>Example:</db:para>
<db:programlisting language="cpp">QString str = &quot;offsets: 1.23 .50 71.00 6.00&quot;;
QRegExp rx(&quot;\\d*\\.\\d+&quot;);    // primitive floating point matching
int count = 0;
int pos = 0;
while ((pos = rx.indexIn(str, pos)) != -1) {
    ++count;
    pos += rx.matchedLength();
}
// pos will be 9, 14, 18 and finally 24; count will end up as 4
</db:programlisting>
<db:para>Although const, this function sets <db:link xlink:href="qregexp.xml#matchedLength">matchedLength</db:link>(), <db:link xlink:href="qregexp.xml#capturedTexts">capturedTexts</db:link>() and <db:link xlink:href="qregexp.xml#pos">pos</db:link>().</db:para>
<db:para>If the <db:link xlink:href="qregexp.xml">QRegExp</db:link> is a wildcard expression (see <db:link xlink:href="qregexp.xml#setPatternSyntax">setPatternSyntax</db:link>()) and want to test a string against the whole wildcard expression, use <db:link xlink:href="qregexp.xml#exactMatch">exactMatch</db:link>() instead of this function.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qregexp.xml#lastIndexIn">lastIndexIn</db:link>()</db:member>
<db:member><db:link xlink:href="qregexp.xml#exactMatch">exactMatch</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="indexIn-1">
<db:title>int QRegExp::indexIn(const QStringList &amp;<db:emphasis>list</db:emphasis>, int <db:emphasis>from</db:emphasis>) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>int</db:type>
<db:methodname>indexIn</db:methodname>
<db:methodparam>
<db:type>const QStringList &amp;</db:type>
<db:parameter>list</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>from</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">int indexIn(const QStringList &amp;list, int from) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the index position of the first exact match of this regexp in <db:code role="parameter">list</db:code>, searching forward from index position <db:code role="parameter">from</db:code>. Returns -1 if no item matched.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qregexp.xml#lastIndexIn">lastIndexIn</db:link>()</db:member>
<db:member><db:link xlink:href="qregexp.xml#exactMatch">exactMatch</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="isEmpty">
<db:title>bool QRegExp::isEmpty() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>bool</db:type>
<db:methodname>isEmpty</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool isEmpty() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns <db:code>true</db:code> if the pattern string is empty; otherwise returns false.</db:para>
<db:para>If you call <db:link xlink:href="qregexp.xml#exactMatch">exactMatch</db:link>() with an empty pattern on an empty string it will return true; otherwise it returns <db:code>false</db:code> since it operates over the whole string. If you call <db:link xlink:href="qregexp.xml#indexIn">indexIn</db:link>() with an empty pattern on <db:emphasis>any</db:emphasis> string it will return the start offset (0 by default) because the empty pattern matches the 'emptiness' at the start of the string. In this case the length of the match returned by <db:link xlink:href="qregexp.xml#matchedLength">matchedLength</db:link>() will be 0.</db:para>
<db:para>See <db:link xlink:href="qstring.xml#isEmpty">QString::isEmpty</db:link>().</db:para>
</db:section>
<db:section xml:id="isMinimal">
<db:title>bool QRegExp::isMinimal() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>bool</db:type>
<db:methodname>isMinimal</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool isMinimal() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns <db:code>true</db:code> if minimal (non-greedy) matching is enabled; otherwise returns <db:code>false</db:code>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qregexp.xml#caseSensitivity">caseSensitivity</db:link>()</db:member>
<db:member><db:link xlink:href="qregexp.xml#setMinimal">setMinimal</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="isValid">
<db:title>bool QRegExp::isValid() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>bool</db:type>
<db:methodname>isValid</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool isValid() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns <db:code>true</db:code> if the regular expression is valid; otherwise returns false. An invalid regular expression never matches.</db:para>
<db:para>The pattern <db:emphasis role="bold">[a-z</db:emphasis> is an example of an invalid pattern, since it lacks a closing square bracket.</db:para>
<db:para>Note that the validity of a regexp may also depend on the setting of the wildcard flag, for example <db:emphasis role="bold">*.html</db:emphasis> is a valid wildcard regexp but an invalid full regexp.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qregexp.xml#errorString">errorString</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="lastIndexIn">
<db:title>int QRegExp::lastIndexIn(const QString &amp;<db:emphasis>str</db:emphasis>, int <db:emphasis>offset</db:emphasis> = -1, QRegExp::CaretMode <db:emphasis>caretMode</db:emphasis> = CaretAtZero) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>int</db:type>
<db:methodname>lastIndexIn</db:methodname>
<db:methodparam>
<db:type>const QString &amp;</db:type>
<db:parameter>str</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>offset</db:parameter>
<db:initializer>-1</db:initializer>
</db:methodparam>
<db:methodparam>
<db:type>QRegExp::CaretMode</db:type>
<db:parameter>caretMode</db:parameter>
<db:initializer>CaretAtZero</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">int lastIndexIn(const QString &amp;str, int offset, QRegExp::CaretMode caretMode) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Attempts to find a match backwards in <db:code role="parameter">str</db:code> from position <db:code role="parameter">offset</db:code>. If <db:code role="parameter">offset</db:code> is -1 (the default), the search starts at the last character; if -2, at the next to last character; etc.</db:para>
<db:para>Returns the position of the first match, or -1 if there was no match.</db:para>
<db:para>The <db:code role="parameter">caretMode</db:code> parameter can be used to instruct whether <db:emphasis role="bold">^</db:emphasis> should match at index 0 or at <db:code role="parameter">offset</db:code>.</db:para>
<db:para>Although const, this function sets <db:link xlink:href="qregexp.xml#matchedLength">matchedLength</db:link>(), <db:link xlink:href="qregexp.xml#capturedTexts">capturedTexts</db:link>() and <db:link xlink:href="qregexp.xml#pos">pos</db:link>().</db:para>
<db:warning>
<db:para>Searching backwards is much slower than searching forwards.</db:para>
</db:warning>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qregexp.xml#indexIn">indexIn</db:link>()</db:member>
<db:member><db:link xlink:href="qregexp.xml#exactMatch">exactMatch</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="lastIndexIn-1">
<db:title>int QRegExp::lastIndexIn(const QStringList &amp;<db:emphasis>list</db:emphasis>, int <db:emphasis>from</db:emphasis>) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>int</db:type>
<db:methodname>lastIndexIn</db:methodname>
<db:methodparam>
<db:type>const QStringList &amp;</db:type>
<db:parameter>list</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>from</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">int lastIndexIn(const QStringList &amp;list, int from) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the index position of the last exact match of this regexp in <db:code role="parameter">list</db:code>, searching backward from index position <db:code role="parameter">from</db:code>. If <db:code role="parameter">from</db:code> is -1 (the default), the search starts at the last item. Returns -1 if no item matched.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qregexp.xml#exactMatch">QRegExp::exactMatch</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="matchedLength">
<db:title>int QRegExp::matchedLength() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>int</db:type>
<db:methodname>matchedLength</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">int matchedLength() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the length of the last matched string, or -1 if there was no match.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qregexp.xml#exactMatch">exactMatch</db:link>()</db:member>
<db:member><db:link xlink:href="qregexp.xml#indexIn">indexIn</db:link>()</db:member>
<db:member><db:link xlink:href="qregexp.xml#lastIndexIn">lastIndexIn</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="pattern">
<db:title>QString QRegExp::pattern() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QString</db:type>
<db:methodname>pattern</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QString pattern() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the pattern string of the regular expression. The pattern has either regular expression syntax or wildcard syntax, depending on <db:link xlink:href="qregexp.xml#patternSyntax">patternSyntax</db:link>().</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qregexp.xml#setPattern">setPattern</db:link>()</db:member>
<db:member><db:link xlink:href="qregexp.xml#patternSyntax">patternSyntax</db:link>()</db:member>
<db:member><db:link xlink:href="qregexp.xml#caseSensitivity">caseSensitivity</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="patternSyntax">
<db:title>QRegExp::PatternSyntax QRegExp::patternSyntax() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QRegExp::PatternSyntax</db:type>
<db:methodname>patternSyntax</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QRegExp::PatternSyntax patternSyntax() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the syntax used by the regular expression. The default is <db:link xlink:href="qregexp.xml#PatternSyntax-enum">QRegExp::RegExp</db:link>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qregexp.xml#setPatternSyntax">setPatternSyntax</db:link>()</db:member>
<db:member><db:link xlink:href="qregexp.xml#pattern">pattern</db:link>()</db:member>
<db:member><db:link xlink:href="qregexp.xml#caseSensitivity">caseSensitivity</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="pos">
<db:title>int QRegExp::pos(int <db:emphasis>nth</db:emphasis> = 0) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>int</db:type>
<db:methodname>pos</db:methodname>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>nth</db:parameter>
<db:initializer>0</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">int pos(int nth) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the position of the <db:code role="parameter">nth</db:code> captured text in the searched string. If <db:code role="parameter">nth</db:code> is 0 (the default), pos() returns the position of the whole match.</db:para>
<db:para>Example:</db:para>
<db:programlisting language="cpp">QRegExp rx(&quot;/([a-z]+)/([a-z]+)&quot;);
rx.indexIn(&quot;Output /dev/null&quot;);   // returns 7 (position of /dev/null)
rx.pos(0);                        // returns 7 (position of /dev/null)
rx.pos(1);                        // returns 8 (position of dev)
rx.pos(2);                        // returns 12 (position of null)
</db:programlisting>
<db:para>For zero-length matches, pos() always returns -1. (For example, if cap(4) would return an empty string, pos(4) returns -1.) This is a feature of the implementation.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qregexp.xml#cap">cap</db:link>()</db:member>
<db:member><db:link xlink:href="qregexp.xml#capturedTexts">capturedTexts</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="removeIn">
<db:title>QString QRegExp::removeIn(const QString &amp;<db:emphasis>str</db:emphasis>) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QString</db:type>
<db:methodname>removeIn</db:methodname>
<db:methodparam>
<db:type>const QString &amp;</db:type>
<db:parameter>str</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QString removeIn(const QString &amp;str) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Removes every occurrence of this regular expression <db:code role="parameter">str</db:code>, and returns the result</db:para>
<db:para>Does the same as <db:link xlink:href="qregexp.xml#replaceIn">replaceIn</db:link>(str, QString()).</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qregexp.xml#indexIn">indexIn</db:link>()</db:member>
<db:member><db:link xlink:href="qregexp.xml#lastIndexIn">lastIndexIn</db:link>()</db:member>
<db:member><db:link xlink:href="qregexp.xml#replaceIn">replaceIn</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="replaceIn">
<db:title>QString QRegExp::replaceIn(const QString &amp;<db:emphasis>str</db:emphasis>, const QString &amp;<db:emphasis>after</db:emphasis>) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QString</db:type>
<db:methodname>replaceIn</db:methodname>
<db:methodparam>
<db:type>const QString &amp;</db:type>
<db:parameter>str</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const QString &amp;</db:type>
<db:parameter>after</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QString replaceIn(const QString &amp;str, const QString &amp;after) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Replaces every occurrence of this regular expression in <db:code role="parameter">str</db:code> with <db:code role="parameter">after</db:code> and returns the result.</db:para>
<db:para>For regular expressions containing <db:link xlink:href="qregexp.xml#capturing-parentheses">capturing parentheses</db:link>, occurrences of <db:emphasis role="bold">\1</db:emphasis>, <db:emphasis role="bold">\2</db:emphasis>, ..., in <db:code role="parameter">after</db:code> are replaced with <db:code>rx</db:code>.cap(1), cap(2), ...</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qregexp.xml#indexIn">indexIn</db:link>()</db:member>
<db:member><db:link xlink:href="qregexp.xml#lastIndexIn">lastIndexIn</db:link>()</db:member>
<db:member><db:link xlink:href="qregexp.xml#cap">QRegExp::cap</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="replaceIn-1">
<db:title>QStringList QRegExp::replaceIn(const QStringList &amp;<db:emphasis>stringList</db:emphasis>, const QString &amp;<db:emphasis>after</db:emphasis>) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QStringList</db:type>
<db:methodname>replaceIn</db:methodname>
<db:methodparam>
<db:type>const QStringList &amp;</db:type>
<db:parameter>stringList</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const QString &amp;</db:type>
<db:parameter>after</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">QStringList replaceIn(const QStringList &amp;stringList, const QString &amp;after) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Replaces every occurrence of this regexp, in each of <db:code role="parameter">stringList</db:code>'s with <db:code role="parameter">after</db:code>. Returns a reference to the string list.</db:para>
</db:section>
<db:section xml:id="setCaseSensitivity">
<db:title>void QRegExp::setCaseSensitivity(Qt::CaseSensitivity <db:emphasis>cs</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>setCaseSensitivity</db:methodname>
<db:methodparam>
<db:type>Qt::CaseSensitivity</db:type>
<db:parameter>cs</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void setCaseSensitivity(Qt::CaseSensitivity cs)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Sets case sensitive matching to <db:code role="parameter">cs</db:code>.</db:para>
<db:para>If <db:code role="parameter">cs</db:code> is <db:link xlink:href="qt.xml#CaseSensitivity-enum">Qt::CaseSensitive</db:link>, <db:emphasis role="bold">\.txt$</db:emphasis> matches <db:code>readme.txt</db:code> but not <db:code>README.TXT</db:code>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qregexp.xml#caseSensitivity">caseSensitivity</db:link>()</db:member>
<db:member><db:link xlink:href="qregexp.xml#setPatternSyntax">setPatternSyntax</db:link>()</db:member>
<db:member><db:link xlink:href="qregexp.xml#setPattern">setPattern</db:link>()</db:member>
<db:member><db:link xlink:href="qregexp.xml#setMinimal">setMinimal</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setMinimal">
<db:title>void QRegExp::setMinimal(bool <db:emphasis>minimal</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>setMinimal</db:methodname>
<db:methodparam>
<db:type>bool</db:type>
<db:parameter>minimal</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void setMinimal(bool minimal)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Enables or disables minimal matching. If <db:code role="parameter">minimal</db:code> is false, matching is greedy (maximal) which is the default.</db:para>
<db:para>For example, suppose we have the input string &quot;We must be &lt;b&gt;bold&lt;/b&gt;, very &lt;b&gt;bold&lt;/b&gt;!&quot; and the pattern <db:emphasis role="bold">&lt;b&gt;.*&lt;/b&gt;</db:emphasis>. With the default greedy (maximal) matching, the match is &quot;We must be <db:emphasis role="underline">&lt;b&gt;bold&lt;/b&gt;, very &lt;b&gt;bold&lt;/b&gt;</db:emphasis>!&quot;. But with minimal (non-greedy) matching, the first match is: &quot;We must be <db:emphasis role="underline">&lt;b&gt;bold&lt;/b&gt;</db:emphasis>, very &lt;b&gt;bold&lt;/b&gt;!&quot; and the second match is &quot;We must be &lt;b&gt;bold&lt;/b&gt;, very <db:emphasis role="underline">&lt;b&gt;bold&lt;/b&gt;</db:emphasis>!&quot;. In practice we might use the pattern <db:emphasis role="bold">&lt;b&gt;[^&lt;]*&lt;/b&gt;</db:emphasis> instead, although this will still fail for nested tags.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qregexp.xml#isMinimal">isMinimal</db:link>()</db:member>
<db:member><db:link xlink:href="qregexp.xml#setCaseSensitivity">setCaseSensitivity</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setPattern">
<db:title>void QRegExp::setPattern(const QString &amp;<db:emphasis>pattern</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>setPattern</db:methodname>
<db:methodparam>
<db:type>const QString &amp;</db:type>
<db:parameter>pattern</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void setPattern(const QString &amp;pattern)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Sets the pattern string to <db:code role="parameter">pattern</db:code>. The case sensitivity, wildcard, and minimal matching options are not changed.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qregexp.xml#pattern">pattern</db:link>()</db:member>
<db:member><db:link xlink:href="qregexp.xml#setPatternSyntax">setPatternSyntax</db:link>()</db:member>
<db:member><db:link xlink:href="qregexp.xml#setCaseSensitivity">setCaseSensitivity</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setPatternSyntax">
<db:title>void QRegExp::setPatternSyntax(QRegExp::PatternSyntax <db:emphasis>syntax</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>setPatternSyntax</db:methodname>
<db:methodparam>
<db:type>QRegExp::PatternSyntax</db:type>
<db:parameter>syntax</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void setPatternSyntax(QRegExp::PatternSyntax syntax)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Sets the syntax mode for the regular expression. The default is <db:link xlink:href="qregexp.xml#PatternSyntax-enum">QRegExp::RegExp</db:link>.</db:para>
<db:para>Setting <db:code role="parameter">syntax</db:code> to <db:link xlink:href="qregexp.xml#PatternSyntax-enum">QRegExp::Wildcard</db:link> enables simple shell-like <db:link xlink:href="qregexp.xml#qregexp-wildcard-matching">QRegExp wildcard matching</db:link>. For example, <db:emphasis role="bold">r*.txt</db:emphasis> matches the string <db:code>readme.txt</db:code> in wildcard mode, but does not match <db:code>readme</db:code>.</db:para>
<db:para>Setting <db:code role="parameter">syntax</db:code> to <db:link xlink:href="qregexp.xml#PatternSyntax-enum">QRegExp::FixedString</db:link> means that the pattern is interpreted as a plain string. Special characters (e.g., backslash) don't need to be escaped then.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qregexp.xml#patternSyntax">patternSyntax</db:link>()</db:member>
<db:member><db:link xlink:href="qregexp.xml#setPattern">setPattern</db:link>()</db:member>
<db:member><db:link xlink:href="qregexp.xml#setCaseSensitivity">setCaseSensitivity</db:link>()</db:member>
<db:member><db:link xlink:href="qregexp.xml#escape">escape</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="splitString">
<db:title>QStringList QRegExp::splitString(const QString &amp;<db:emphasis>str</db:emphasis>, Qt::SplitBehavior <db:emphasis>behavior</db:emphasis> = Qt::KeepEmptyParts) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QStringList</db:type>
<db:methodname>splitString</db:methodname>
<db:methodparam>
<db:type>const QString &amp;</db:type>
<db:parameter>str</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>Qt::SplitBehavior</db:type>
<db:parameter>behavior</db:parameter>
<db:initializer>Qt::KeepEmptyParts</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QStringList splitString(const QString &amp;str, Qt::SplitBehavior behavior) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Splits <db:code role="parameter">str</db:code> into substrings wherever this regular expression matches, and returns the list of those strings. If this regular expression does not match anywhere in the string, split() returns a single-element list containing <db:code role="parameter">str</db:code>.</db:para>
<db:para>If <db:code role="parameter">behavior</db:code> is set to <db:link xlink:href="qt.xml#SplitBehaviorFlags-enum">Qt::KeepEmptyParts</db:link>, empty fields are included in the resulting list.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qstringlist.xml#join">QStringList::join</db:link>()</db:member>
<db:member><db:link xlink:href="qstring.xml#split">QString::split</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="swap">
<db:title>void QRegExp::swap(QRegExp &amp;<db:emphasis>other</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>swap</db:methodname>
<db:methodparam>
<db:type>QRegExp &amp;</db:type>
<db:parameter>other</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void swap(QRegExp &amp;other)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Swaps regular expression <db:code role="parameter">other</db:code> with this regular expression. This operation is very fast and never fails.</db:para>
</db:section>
<db:section xml:id="operator-QVariant">
<db:title>QVariant QRegExp::operator QVariant() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QVariant</db:type>
<db:methodname>operator QVariant</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QVariant operator QVariant() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the regexp as a <db:link xlink:href="qvariant.xml">QVariant</db:link></db:para>
</db:section>
<db:section xml:id="operator-not-eq">
<db:title>bool QRegExp::operator!=(const QRegExp &amp;<db:emphasis>rx</db:emphasis>) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>bool</db:type>
<db:methodname>operator!=</db:methodname>
<db:methodparam>
<db:type>const QRegExp &amp;</db:type>
<db:parameter>rx</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool operator!=(const QRegExp &amp;rx) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns <db:code>true</db:code> if this regular expression is not equal to <db:code role="parameter">rx</db:code>; otherwise returns <db:code>false</db:code>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qregexp.xml#operator-eq-eq">operator==</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="operator-eq">
<db:title>QRegExp &amp;QRegExp::operator=(const QRegExp &amp;<db:emphasis>rx</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>QRegExp &amp;</db:type>
<db:methodname>operator=</db:methodname>
<db:methodparam>
<db:type>const QRegExp &amp;</db:type>
<db:parameter>rx</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">copy-assign</db:synopsisinfo>
<db:synopsisinfo role="signature">QRegExp &amp; operator=(const QRegExp &amp;rx)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Copies the regular expression <db:code role="parameter">rx</db:code> and returns a reference to the copy. The case sensitivity, wildcard, and minimal matching options are also copied.</db:para>
</db:section>
<db:section xml:id="operator-eq-1">
<db:title>[since 5.2] QRegExp &amp;QRegExp::operator=(QRegExp &amp;&amp;<db:emphasis>other</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>QRegExp &amp;</db:type>
<db:methodname>operator=</db:methodname>
<db:methodparam>
<db:type>QRegExp &amp;&amp;</db:type>
<db:parameter>other</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">move-assign</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">QRegExp &amp; operator=(QRegExp &amp;&amp;other)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Move-assigns <db:code role="parameter">other</db:code> to this <db:link xlink:href="qregexp.xml">QRegExp</db:link> instance.</db:para>
<db:para>This function was introduced in Qt 5.2.</db:para>
</db:section>
<db:section xml:id="operator-eq-eq">
<db:title>bool QRegExp::operator==(const QRegExp &amp;<db:emphasis>rx</db:emphasis>) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>bool</db:type>
<db:methodname>operator==</db:methodname>
<db:methodparam>
<db:type>const QRegExp &amp;</db:type>
<db:parameter>rx</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool operator==(const QRegExp &amp;rx) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns <db:code>true</db:code> if this regular expression is equal to <db:code role="parameter">rx</db:code>; otherwise returns <db:code>false</db:code>.</db:para>
<db:para>Two <db:link xlink:href="qregexp.xml">QRegExp</db:link> objects are equal if they have the same pattern strings and the same settings for case sensitivity, wildcard and minimal matching.</db:para>
</db:section>
</db:section>
<db:section xml:id="related-non-members">
<db:title>Related Non-Members</db:title>
<db:section xml:id="qHash">
<db:title>[since 5.6] size_t qHash(const QRegExp &amp;<db:emphasis>key</db:emphasis>, size_t <db:emphasis>seed</db:emphasis> = 0)</db:title>
<db:methodsynopsis>
<db:type>size_t</db:type>
<db:methodname>qHash</db:methodname>
<db:methodparam>
<db:type>const QRegExp &amp;</db:type>
<db:parameter>key</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>size_t</db:type>
<db:parameter>seed</db:parameter>
<db:initializer>0</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">size_t qHash(const QRegExp &amp;key, size_t seed)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the hash value for <db:code role="parameter">key</db:code>, using <db:code role="parameter">seed</db:code> to seed the calculation.</db:para>
<db:para>This function was introduced in Qt 5.6.</db:para>
</db:section>
<db:section xml:id="operator-lt-lt">
<db:title>QDataStream &amp;operator&lt;&lt;(QDataStream &amp;<db:emphasis>out</db:emphasis>, const QRegExp &amp;<db:emphasis>regExp</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>QDataStream &amp;</db:type>
<db:methodname>operator&lt;&lt;</db:methodname>
<db:methodparam>
<db:type>QDataStream &amp;</db:type>
<db:parameter>out</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const QRegExp &amp;</db:type>
<db:parameter>regExp</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QDataStream &amp; operator&lt;&lt;(QDataStream &amp;out, const QRegExp &amp;regExp)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Writes the regular expression <db:code role="parameter">regExp</db:code> to stream <db:code role="parameter">out</db:code>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="datastreamformat.xml">Serializing Qt Data Types</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="operator-gt-gt">
<db:title>QDataStream &amp;operator&gt;&gt;(QDataStream &amp;<db:emphasis>in</db:emphasis>, QRegExp &amp;<db:emphasis>regExp</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>QDataStream &amp;</db:type>
<db:methodname>operator&gt;&gt;</db:methodname>
<db:methodparam>
<db:type>QDataStream &amp;</db:type>
<db:parameter>in</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>QRegExp &amp;</db:type>
<db:parameter>regExp</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QDataStream &amp; operator&gt;&gt;(QDataStream &amp;in, QRegExp &amp;regExp)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Reads a regular expression from stream <db:code role="parameter">in</db:code> into <db:code role="parameter">regExp</db:code>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="datastreamformat.xml">Serializing Qt Data Types</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
</db:section>
</db:article>
