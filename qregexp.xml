<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en">
<db:info>
<db:title>QRegExp Class</db:title>
<db:productname>QtCore</db:productname>
<db:edition>Qt 5.7.1 Reference Documentation</db:edition>
<db:titleabbrev>Qt Core Reference Documentation</db:titleabbrev>
<db:abstract>
<db:para>The <db:link xlink:href="qregexp.xml">QRegExp</db:link> class provides pattern matching using regular expressions.</db:para>
<db:note>
<db:para>All functions in this class are <db:link xlink:href="threads-reentrancy.xml">reentrant</db:link>.</db:para>
</db:note>
</db:abstract>
<db:pubdate>2025-06-29</db:pubdate>
<db:date>2025-06-29</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:variablelist>
<db:varlistentry>
<db:term>Header</db:term>
<db:listitem>
<db:para>QRegExp</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>qmake</db:term>
<db:listitem>
<db:para>QT += core</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Group</db:term>
<db:listitem>
<db:para>QRegExp is part of <db:simplelist><db:member>tools</db:member><db:member><db:link xlink:href="shared.xml">Implicitly Shared Classes</db:link></db:member></db:simplelist>
</db:para>
</db:listitem>
</db:varlistentry>
</db:variablelist>
<db:section xml:id="details">
<db:title>Detailed Description</db:title>
<db:para>A regular expression, or &quot;regexp&quot;, is a pattern for matching substrings in a text. This is useful in many contexts, e.g.,</db:para>
<db:informaltable style="generic">
<db:tr valign="top">
<db:td>
<db:para>Validation</db:para>
</db:td>
<db:td>
<db:para>A regexp can test whether a substring meets some criteria, e.g. is an integer or contains no whitespace.</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>Searching</db:para>
</db:td>
<db:td>
<db:para>A regexp provides more powerful pattern matching than simple substring matching, e.g., match one of the words <db:emphasis>mail</db:emphasis>, <db:emphasis>letter</db:emphasis> or <db:emphasis>correspondence</db:emphasis>, but none of the words <db:emphasis>email</db:emphasis>, <db:emphasis>mailman</db:emphasis>, <db:emphasis>mailer</db:emphasis>, <db:emphasis>letterbox</db:emphasis>, etc.</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>Search and Replace</db:para>
</db:td>
<db:td>
<db:para>A regexp can replace all occurrences of a substring with a different substring, e.g., replace all occurrences of <db:emphasis>&amp;</db:emphasis> with <db:emphasis>&amp;amp;</db:emphasis> except where the <db:emphasis>&amp;</db:emphasis> is already followed by an <db:emphasis>amp;</db:emphasis>.</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>String Splitting</db:para>
</db:td>
<db:td>
<db:para>A regexp can be used to identify where a string should be split apart, e.g. splitting tab-delimited strings.</db:para>
</db:td>
</db:tr>
</db:informaltable>
<db:para>A brief introduction to regexps is presented, a description of Qt's regexp language, some examples, and the function documentation itself. <db:link xlink:href="qregexp.xml">QRegExp</db:link> is modeled on Perl's regexp language. It fully supports Unicode. <db:link xlink:href="qregexp.xml">QRegExp</db:link> can also be used in a simpler, <db:emphasis>wildcard mode</db:emphasis> that is similar to the functionality found in command shells. The syntax rules used by <db:link xlink:href="qregexp.xml">QRegExp</db:link> can be changed with <db:link xlink:href="qregexp.xml#setPatternSyntax">setPatternSyntax</db:link>(). In particular, the pattern syntax can be set to <db:link xlink:href="qregexp.xml#PatternSyntax-enum">QRegExp::FixedString</db:link>, which means the pattern to be matched is interpreted as a plain string, i.e., special characters (e.g., backslash) are not escaped.</db:para>
<db:para>A good text on regexps is <db:emphasis>Mastering Regular Expressions</db:emphasis> (Third Edition) by Jeffrey E. F. Friedl, ISBN 0-596-52812-4.</db:para>
<db:note>
<db:para>In Qt 5, the new <db:link xlink:href="qregularexpression.xml">QRegularExpression</db:link> class provides a Perl compatible implementation of regular expressions and is recommended in place of <db:link xlink:href="qregexp.xml">QRegExp</db:link>.</db:para>
</db:note>
<db:section xml:id="introduction">
<db:title>Introduction</db:title>
<db:para>Regexps are built up from expressions, quantifiers, and assertions. The simplest expression is a character, e.g. <db:emphasis role="bold">x</db:emphasis> or <db:emphasis role="bold">5</db:emphasis>. An expression can also be a set of characters enclosed in square brackets. <db:emphasis role="bold">[ABCD]</db:emphasis> will match an <db:emphasis role="bold">A</db:emphasis> or a <db:emphasis role="bold">B</db:emphasis> or a <db:emphasis role="bold">C</db:emphasis> or a <db:emphasis role="bold">D</db:emphasis>. We can write this same expression as <db:emphasis role="bold">[A-D]</db:emphasis>, and an expression to match any capital letter in the English alphabet is written as <db:emphasis role="bold">[A-Z]</db:emphasis>.</db:para>
<db:para>A quantifier specifies the number of occurrences of an expression that must be matched. <db:emphasis role="bold">x{1,1}</db:emphasis> means match one and only one <db:emphasis role="bold">x</db:emphasis>. <db:emphasis role="bold">x{1,5}</db:emphasis> means match a sequence of <db:emphasis role="bold">x</db:emphasis> characters that contains at least one <db:emphasis role="bold">x</db:emphasis> but no more than five.</db:para>
<db:para>Note that in general regexps cannot be used to check for balanced brackets or tags. For example, a regexp can be written to match an opening html <db:code>&lt;b&gt;</db:code> and its closing <db:code>&lt;/b&gt;</db:code>, if the <db:code>&lt;b&gt;</db:code> tags are not nested, but if the <db:code>&lt;b&gt;</db:code> tags are nested, that same regexp will match an opening <db:code>&lt;b&gt;</db:code> tag with the wrong closing <db:code>&lt;/b&gt;</db:code>. For the fragment <db:code>&lt;b&gt;bold &lt;b&gt;bolder&lt;/b&gt;&lt;/b&gt;</db:code>, the first <db:code>&lt;b&gt;</db:code> would be matched with the first <db:code>&lt;/b&gt;</db:code>, which is not correct. However, it is possible to write a regexp that will match nested brackets or tags correctly, but only if the number of nesting levels is fixed and known. If the number of nesting levels is not fixed and known, it is impossible to write a regexp that will not fail.</db:para>
<db:para>Suppose we want a regexp to match integers in the range 0 to 99. At least one digit is required, so we start with the expression <db:emphasis role="bold">[0-9]{1,1}</db:emphasis>, which matches a single digit exactly once. This regexp matches integers in the range 0 to 9. To match integers up to 99, increase the maximum number of occurrences to 2, so the regexp becomes <db:emphasis role="bold">[0-9]{1,2}</db:emphasis>. This regexp satisfies the original requirement to match integers from 0 to 99, but it will also match integers that occur in the middle of strings. If we want the matched integer to be the whole string, we must use the anchor assertions, <db:emphasis role="bold">^</db:emphasis> (caret) and <db:emphasis role="bold">$</db:emphasis> (dollar). When <db:emphasis role="bold">^</db:emphasis> is the first character in a regexp, it means the regexp must match from the beginning of the string. When <db:emphasis role="bold">$</db:emphasis> is the last character of the regexp, it means the regexp must match to the end of the string. The regexp becomes <db:emphasis role="bold">^[0-9]{1,2}$</db:emphasis>. Note that assertions, e.g. <db:emphasis role="bold">^</db:emphasis> and <db:emphasis role="bold">$</db:emphasis>, do not match characters but locations in the string.</db:para>
<db:para>If you have seen regexps described elsewhere, they may have looked different from the ones shown here. This is because some sets of characters and some quantifiers are so common that they have been given special symbols to represent them. <db:emphasis role="bold">[0-9]</db:emphasis> can be replaced with the symbol <db:emphasis role="bold">\d</db:emphasis>. The quantifier to match exactly one occurrence, <db:emphasis role="bold">{1,1}</db:emphasis>, can be replaced with the expression itself, i.e. <db:emphasis role="bold">x{1,1}</db:emphasis> is the same as <db:emphasis role="bold">x</db:emphasis>. So our 0 to 99 matcher could be written as <db:emphasis role="bold">^\d{1,2}$</db:emphasis>. It can also be written <db:emphasis role="bold">^\d\d{0,1}$</db:emphasis>, i.e. <db:emphasis>From the start of the string, match a digit, followed immediately by 0 or 1 digits</db:emphasis>. In practice, it would be written as <db:emphasis role="bold">^\d\d?$</db:emphasis>. The <db:emphasis role="bold">?</db:emphasis> is shorthand for the quantifier <db:emphasis role="bold">{0,1}</db:emphasis>, i.e. 0 or 1 occurrences. <db:emphasis role="bold">?</db:emphasis> makes an expression optional. The regexp <db:emphasis role="bold">^\d\d?$</db:emphasis> means <db:emphasis>From the beginning of the string, match one digit, followed immediately by 0 or 1 more digit, followed immediately by end of string</db:emphasis>.</db:para>
<db:para>To write a regexp that matches one of the words 'mail' <db:emphasis>or</db:emphasis> 'letter' <db:emphasis>or</db:emphasis> 'correspondence' but does not match words that contain these words, e.g., 'email', 'mailman', 'mailer', and 'letterbox', start with a regexp that matches 'mail'. Expressed fully, the regexp is <db:emphasis role="bold">m{1,1}a{1,1}i{1,1}l{1,1}</db:emphasis>, but because a character expression is automatically quantified by <db:emphasis role="bold">{1,1}</db:emphasis>, we can simplify the regexp to <db:emphasis role="bold">mail</db:emphasis>, i.e., an 'm' followed by an 'a' followed by an 'i' followed by an 'l'. Now we can use the vertical bar <db:emphasis role="bold">|</db:emphasis>, which means <db:emphasis role="bold">or</db:emphasis>, to include the other two words, so our regexp for matching any of the three words becomes <db:emphasis role="bold">mail|letter|correspondence</db:emphasis>. Match 'mail' <db:emphasis role="bold">or</db:emphasis> 'letter' <db:emphasis role="bold">or</db:emphasis> 'correspondence'. While this regexp will match one of the three words we want to match, it will also match words we don't want to match, e.g., 'email'. To prevent the regexp from matching unwanted words, we must tell it to begin and end the match at word boundaries. First we enclose our regexp in parentheses, <db:emphasis role="bold">(mail|letter|correspondence)</db:emphasis>. Parentheses group expressions together, and they identify a part of the regexp that we wish to <db:link xlink:href="qregexp.xml#capturing-text">capture</db:link>. Enclosing the expression in parentheses allows us to use it as a component in more complex regexps. It also allows us to examine which of the three words was actually matched. To force the match to begin and end on word boundaries, we enclose the regexp in <db:emphasis role="bold">\b</db:emphasis> <db:emphasis>word boundary</db:emphasis> assertions: <db:emphasis role="bold">\b(mail|letter|correspondence)\b</db:emphasis>. Now the regexp means: <db:emphasis>Match a word boundary, followed by the regexp in parentheses, followed by a word boundary</db:emphasis>. The <db:emphasis role="bold">\b</db:emphasis> assertion matches a <db:emphasis>position</db:emphasis> in the regexp, not a <db:emphasis>character</db:emphasis>. A word boundary is any non-word character, e.g., a space, newline, or the beginning or ending of a string.</db:para>
<db:para>If we want to replace ampersand characters with the HTML entity <db:emphasis role="bold">&amp;amp;</db:emphasis>, the regexp to match is simply <db:emphasis role="bold">&amp;</db:emphasis>. But this regexp will also match ampersands that have already been converted to HTML entities. We want to replace only ampersands that are not already followed by <db:emphasis role="bold">amp;</db:emphasis>. For this, we need the negative lookahead assertion, <db:emphasis role="bold">(?!</db:emphasis>__<db:emphasis role="bold">)</db:emphasis>. The regexp can then be written as <db:emphasis role="bold">&amp;(?!amp;)</db:emphasis>, i.e. <db:emphasis>Match an ampersand that is</db:emphasis> <db:emphasis role="bold">not</db:emphasis> <db:emphasis>followed by</db:emphasis> <db:emphasis role="bold">amp;</db:emphasis>.</db:para>
<db:para>If we want to count all the occurrences of 'Eric' and 'Eirik' in a string, two valid solutions are <db:emphasis role="bold">\b(Eric|Eirik)\b</db:emphasis> and <db:emphasis role="bold">\bEi?ri[ck]\b</db:emphasis>. The word boundary assertion '\b' is required to avoid matching words that contain either name, e.g. 'Ericsson'. Note that the second regexp matches more spellings than we want: 'Eric', 'Erik', 'Eiric' and 'Eirik'.</db:para>
<db:para>Some of the examples discussed above are implemented in the <db:link xlink:href="qregexp.xml#code-examples">code examples</db:link> section.</db:para>
</db:section>
<db:section xml:id="characters-and-abbreviations-for-sets-of-characters">
<db:title>Characters and Abbreviations for Sets of Characters</db:title>
<db:informaltable style="generic">
<db:thead>
<db:tr>
<db:th>
<db:para>Element</db:para>
</db:th>
<db:th>
<db:para>Meaning</db:para>
</db:th>
</db:tr>
</db:thead>
<db:tr valign="top">
<db:td>
<db:para><db:emphasis role="bold">c</db:emphasis></db:para>
</db:td>
<db:td>
<db:para>A character represents itself unless it has a special regexp meaning. e.g. <db:emphasis role="bold">c</db:emphasis> matches the character <db:emphasis>c</db:emphasis>.</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para><db:emphasis role="bold">\c</db:emphasis></db:para>
</db:td>
<db:td>
<db:para>A character that follows a backslash matches the character itself, except as specified below. e.g., To match a literal caret at the beginning of a string, write <db:emphasis role="bold">\^</db:emphasis>.</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para><db:emphasis role="bold">\a</db:emphasis></db:para>
</db:td>
<db:td>
<db:para>Matches the ASCII bell (BEL, 0x07).</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para><db:emphasis role="bold">\f</db:emphasis></db:para>
</db:td>
<db:td>
<db:para>Matches the ASCII form feed (FF, 0x0C).</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para><db:emphasis role="bold">\n</db:emphasis></db:para>
</db:td>
<db:td>
<db:para>Matches the ASCII line feed (LF, 0x0A, Unix newline).</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para><db:emphasis role="bold">\r</db:emphasis></db:para>
</db:td>
<db:td>
<db:para>Matches the ASCII carriage return (CR, 0x0D).</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para><db:emphasis role="bold">\t</db:emphasis></db:para>
</db:td>
<db:td>
<db:para>Matches the ASCII horizontal tab (HT, 0x09).</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para><db:emphasis role="bold">\v</db:emphasis></db:para>
</db:td>
<db:td>
<db:para>Matches the ASCII vertical tab (VT, 0x0B).</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para><db:emphasis role="bold">\x<db:emphasis>hhhh</db:emphasis></db:emphasis></db:para>
</db:td>
<db:td>
<db:para>Matches the Unicode character corresponding to the hexadecimal number <db:emphasis>hhhh</db:emphasis> (between 0x0000 and 0xFFFF).</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para><db:emphasis role="bold">\0<db:emphasis>ooo</db:emphasis></db:emphasis> (i.e., \zero <db:emphasis>ooo</db:emphasis>)</db:para>
</db:td>
<db:td>
<db:para>matches the ASCII/Latin1 character for the octal number <db:emphasis>ooo</db:emphasis> (between 0 and 0377).</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para><db:emphasis role="bold">. (dot)</db:emphasis></db:para>
</db:td>
<db:td>
<db:para>Matches any character (including newline).</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para><db:emphasis role="bold">\d</db:emphasis></db:para>
</db:td>
<db:td>
<db:para>Matches a digit (<db:link xlink:href="qchar.xml#isDigit">QChar::isDigit</db:link>()).</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para><db:emphasis role="bold">\D</db:emphasis></db:para>
</db:td>
<db:td>
<db:para>Matches a non-digit.</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para><db:emphasis role="bold">\s</db:emphasis></db:para>
</db:td>
<db:td>
<db:para>Matches a whitespace character (<db:link xlink:href="qchar.xml#isSpace">QChar::isSpace</db:link>()).</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para><db:emphasis role="bold">\S</db:emphasis></db:para>
</db:td>
<db:td>
<db:para>Matches a non-whitespace character.</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para><db:emphasis role="bold">\w</db:emphasis></db:para>
</db:td>
<db:td>
<db:para>Matches a word character (<db:link xlink:href="qchar.xml#isLetterOrNumber">QChar::isLetterOrNumber</db:link>(), <db:link xlink:href="qchar.xml#isMark">QChar::isMark</db:link>(), or '_').</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para><db:emphasis role="bold">\W</db:emphasis></db:para>
</db:td>
<db:td>
<db:para>Matches a non-word character.</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para><db:emphasis role="bold">\<db:emphasis>n</db:emphasis></db:emphasis></db:para>
</db:td>
<db:td>
<db:para>The <db:emphasis>n</db:emphasis>-th backreference, e.g. \1, \2, etc.</db:para>
</db:td>
</db:tr>
</db:informaltable>
<db:para><db:emphasis role="bold">Note:</db:emphasis> The C++ compiler transforms backslashes in strings. To include a <db:emphasis role="bold">\</db:emphasis> in a regexp, enter it twice, i.e. <db:code>\\</db:code>. To match the backslash character itself, enter it four times, i.e. <db:code>\\\\</db:code>.</db:para>
</db:section>
<db:section xml:id="sets-of-characters">
<db:title>Sets of Characters</db:title>
<db:para>Square brackets mean match any character contained in the square brackets. The character set abbreviations described above can appear in a character set in square brackets. Except for the character set abbreviations and the following two exceptions, characters do not have special meanings in square brackets.</db:para>
<db:informaltable style="generic">
<db:tr valign="top">
<db:td>
<db:para><db:emphasis role="bold">^</db:emphasis></db:para>
</db:td>
<db:td>
<db:para>The caret negates the character set if it occurs as the first character (i.e. immediately after the opening square bracket). <db:emphasis role="bold">[abc]</db:emphasis> matches 'a' or 'b' or 'c', but <db:emphasis role="bold">[^abc]</db:emphasis> matches anything <db:emphasis>but</db:emphasis> 'a' or 'b' or 'c'.</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para><db:emphasis role="bold">-</db:emphasis></db:para>
</db:td>
<db:td>
<db:para>The dash indicates a range of characters. <db:emphasis role="bold">[W-Z]</db:emphasis> matches 'W' or 'X' or 'Y' or 'Z'.</db:para>
</db:td>
</db:tr>
</db:informaltable>
<db:para>Using the predefined character set abbreviations is more portable than using character ranges across platforms and languages. For example, <db:emphasis role="bold">[0-9]</db:emphasis> matches a digit in Western alphabets but <db:emphasis role="bold">\d</db:emphasis> matches a digit in <db:emphasis>any</db:emphasis> alphabet.</db:para>
<db:para>Note: In other regexp documentation, sets of characters are often called &quot;character classes&quot;.</db:para>
</db:section>
<db:section xml:id="quantifiers">
<db:title>Quantifiers</db:title>
<db:para>By default, an expression is automatically quantified by <db:emphasis role="bold">{1,1}</db:emphasis>, i.e. it should occur exactly once. In the following list, <db:emphasis role="bold"><db:emphasis>E</db:emphasis></db:emphasis> stands for expression. An expression is a character, or an abbreviation for a set of characters, or a set of characters in square brackets, or an expression in parentheses.</db:para>
<db:informaltable style="generic">
<db:tr valign="top">
<db:td>
<db:para><db:emphasis role="bold"><db:emphasis>E</db:emphasis>?</db:emphasis></db:para>
</db:td>
<db:td>
<db:para>Matches zero or one occurrences of <db:emphasis>E</db:emphasis>. This quantifier means <db:emphasis>The previous expression is optional</db:emphasis>, because it will match whether or not the expression is found. <db:emphasis role="bold"><db:emphasis>E</db:emphasis>?</db:emphasis> is the same as <db:emphasis role="bold"><db:emphasis>E</db:emphasis>{0,1}</db:emphasis>. e.g., <db:emphasis role="bold">dents?</db:emphasis> matches 'dent' or 'dents'.</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para><db:emphasis role="bold"><db:emphasis>E</db:emphasis>+</db:emphasis></db:para>
</db:td>
<db:td>
<db:para>Matches one or more occurrences of <db:emphasis>E</db:emphasis>. <db:emphasis role="bold"><db:emphasis>E</db:emphasis>+</db:emphasis> is the same as <db:emphasis role="bold"><db:emphasis>E</db:emphasis>{1,}</db:emphasis>. e.g., <db:emphasis role="bold">0+</db:emphasis> matches '0', '00', '000', etc.</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para><db:emphasis role="bold"><db:emphasis>E</db:emphasis>*</db:emphasis></db:para>
</db:td>
<db:td>
<db:para>Matches zero or more occurrences of <db:emphasis>E</db:emphasis>. It is the same as <db:emphasis role="bold"><db:emphasis>E</db:emphasis>{0,}</db:emphasis>. The <db:emphasis role="bold">*</db:emphasis> quantifier is often used in error where <db:emphasis role="bold">+</db:emphasis> should be used. For example, if <db:emphasis role="bold">\s*$</db:emphasis> is used in an expression to match strings that end in whitespace, it will match every string because <db:emphasis role="bold">\s*$</db:emphasis> means <db:emphasis>Match zero or more whitespaces followed by end of string</db:emphasis>. The correct regexp to match strings that have at least one trailing whitespace character is <db:emphasis role="bold">\s+$</db:emphasis>.</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para><db:emphasis role="bold"><db:emphasis>E</db:emphasis>{n}</db:emphasis></db:para>
</db:td>
<db:td>
<db:para>Matches exactly <db:emphasis>n</db:emphasis> occurrences of <db:emphasis>E</db:emphasis>. <db:emphasis role="bold"><db:emphasis>E</db:emphasis>{n}</db:emphasis> is the same as repeating <db:emphasis>E</db:emphasis> <db:emphasis>n</db:emphasis> times. For example, <db:emphasis role="bold">x{5}</db:emphasis> is the same as <db:emphasis role="bold">xxxxx</db:emphasis>. It is also the same as <db:emphasis role="bold"><db:emphasis>E</db:emphasis>{n,n}</db:emphasis>, e.g. <db:emphasis role="bold">x{5,5}</db:emphasis>.</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para><db:emphasis role="bold"><db:emphasis>E</db:emphasis>{n,}</db:emphasis></db:para>
</db:td>
<db:td>
<db:para>Matches at least <db:emphasis>n</db:emphasis> occurrences of <db:emphasis>E</db:emphasis>.</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para><db:emphasis role="bold"><db:emphasis>E</db:emphasis>{,m}</db:emphasis></db:para>
</db:td>
<db:td>
<db:para>Matches at most <db:emphasis>m</db:emphasis> occurrences of <db:emphasis>E</db:emphasis>. <db:emphasis role="bold"><db:emphasis>E</db:emphasis>{,m}</db:emphasis> is the same as <db:emphasis role="bold"><db:emphasis>E</db:emphasis>{0,m}</db:emphasis>.</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para><db:emphasis role="bold"><db:emphasis>E</db:emphasis>{n,m}</db:emphasis></db:para>
</db:td>
<db:td>
<db:para>Matches at least <db:emphasis>n</db:emphasis> and at most <db:emphasis>m</db:emphasis> occurrences of <db:emphasis>E</db:emphasis>.</db:para>
</db:td>
</db:tr>
</db:informaltable>
<db:para>To apply a quantifier to more than just the preceding character, use parentheses to group characters together in an expression. For example, <db:emphasis role="bold">tag+</db:emphasis> matches a 't' followed by an 'a' followed by at least one 'g', whereas <db:emphasis role="bold">(tag)+</db:emphasis> matches at least one occurrence of 'tag'.</db:para>
<db:para>Note: Quantifiers are normally &quot;greedy&quot;. They always match as much text as they can. For example, <db:emphasis role="bold">0+</db:emphasis> matches the first zero it finds and all the consecutive zeros after the first zero. Applied to '20005', it matches '2<db:emphasis role="underline">000</db:emphasis>5'. Quantifiers can be made non-greedy, see <db:link xlink:href="qregexp.xml#setMinimal">setMinimal</db:link>().</db:para>
<db:anchor xml:id="capturing-parentheses"/>
<db:anchor xml:id="backreferences"/>
</db:section>
<db:section xml:id="capturing-text">
<db:title>Capturing Text</db:title>
<db:para>Parentheses allow us to group elements together so that we can quantify and capture them. For example if we have the expression <db:emphasis role="bold">mail|letter|correspondence</db:emphasis> that matches a string we know that <db:emphasis>one</db:emphasis> of the words matched but not which one. Using parentheses allows us to &quot;capture&quot; whatever is matched within their bounds, so if we used <db:emphasis role="bold">(mail|letter|correspondence)</db:emphasis> and matched this regexp against the string &quot;I sent you some email&quot; we can use the <db:link xlink:href="qregexp.xml#cap">cap</db:link>() or <db:link xlink:href="qregexp.xml#capturedTexts">capturedTexts</db:link>() functions to extract the matched characters, in this case 'mail'.</db:para>
<db:para>We can use captured text within the regexp itself. To refer to the captured text we use <db:emphasis>backreferences</db:emphasis> which are indexed from 1, the same as for <db:link xlink:href="qregexp.xml#cap">cap</db:link>(). For example we could search for duplicate words in a string using <db:emphasis role="bold">\b(\w+)\W+\1\b</db:emphasis> which means match a word boundary followed by one or more word characters followed by one or more non-word characters followed by the same text as the first parenthesized expression followed by a word boundary.</db:para>
<db:para>If we want to use parentheses purely for grouping and not for capturing we can use the non-capturing syntax, e.g. <db:emphasis role="bold">(?:green|blue)</db:emphasis>. Non-capturing parentheses begin '(?:' and end ')'. In this example we match either 'green' or 'blue' but we do not capture the match so we only know whether or not we matched but not which color we actually found. Using non-capturing parentheses is more efficient than using capturing parentheses since the regexp engine has to do less book-keeping.</db:para>
<db:para>Both capturing and non-capturing parentheses may be nested.</db:para>
<db:anchor xml:id="greedy-quantifiers"/>
<db:para>For historical reasons, quantifiers (e.g. <db:emphasis role="bold">*</db:emphasis>) that apply to capturing parentheses are more &quot;greedy&quot; than other quantifiers. For example, <db:emphasis role="bold">a*(a*)</db:emphasis> will match &quot;aaa&quot; with cap(1) == &quot;aaa&quot;. This behavior is different from what other regexp engines do (notably, Perl). To obtain a more intuitive capturing behavior, specify <db:link xlink:href="qregexp.xml#PatternSyntax-enum">QRegExp::RegExp2</db:link> to the <db:link xlink:href="qregexp.xml">QRegExp</db:link> constructor or call <db:link xlink:href="qregexp.xml#setPatternSyntax">setPatternSyntax</db:link>(<db:link xlink:href="qregexp.xml#PatternSyntax-enum">QRegExp::RegExp2</db:link>).</db:para>
<db:anchor xml:id="cap-in-a-loop"/>
<db:para>When the number of matches cannot be determined in advance, a common idiom is to use <db:link xlink:href="qregexp.xml#cap">cap</db:link>() in a loop. For example:</db:para>
<db:programlisting language="cpp">QRegExp rx(&quot;(\\d+)&quot;);
QString str = &quot;Offsets: 12 14 99 231 7&quot;;
QStringList list;
int pos = 0;

while ((pos = rx.indexIn(str, pos)) != -1) {
    list &lt;&lt; rx.cap(1);
    pos += rx.matchedLength();
}
// list: [&quot;12&quot;, &quot;14&quot;, &quot;99&quot;, &quot;231&quot;, &quot;7&quot;]
</db:programlisting>
</db:section>
<db:section xml:id="assertions">
<db:title>Assertions</db:title>
<db:para>Assertions make some statement about the text at the point where they occur in the regexp but they do not match any characters. In the following list <db:emphasis role="bold"><db:emphasis>E</db:emphasis></db:emphasis> stands for any expression.</db:para>
<db:informaltable style="generic">
<db:tr valign="top">
<db:td>
<db:para><db:emphasis role="bold">^</db:emphasis></db:para>
</db:td>
<db:td>
<db:para>The caret signifies the beginning of the string. If you wish to match a literal <db:code>^</db:code> you must escape it by writing <db:code>\\^</db:code>. For example, <db:emphasis role="bold">^#include</db:emphasis> will only match strings which <db:emphasis>begin</db:emphasis> with the characters '#include'. (When the caret is the first character of a character set it has a special meaning, see <db:link xlink:href="qregexp.xml#sets-of-characters">Sets of Characters</db:link>.)</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para><db:emphasis role="bold">$</db:emphasis></db:para>
</db:td>
<db:td>
<db:para>The dollar signifies the end of the string. For example <db:emphasis role="bold">\d\s*$</db:emphasis> will match strings which end with a digit optionally followed by whitespace. If you wish to match a literal <db:code>$</db:code> you must escape it by writing <db:code>\\$</db:code>.</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para><db:emphasis role="bold">\b</db:emphasis></db:para>
</db:td>
<db:td>
<db:para>A word boundary. For example the regexp <db:emphasis role="bold">\bOK\b</db:emphasis> means match immediately after a word boundary (e.g. start of string or whitespace) the letter 'O' then the letter 'K' immediately before another word boundary (e.g. end of string or whitespace). But note that the assertion does not actually match any whitespace so if we write <db:emphasis role="bold">(\bOK\b)</db:emphasis> and we have a match it will only contain 'OK' even if the string is &quot;It's <db:emphasis role="underline">OK</db:emphasis> now&quot;.</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para><db:emphasis role="bold">\B</db:emphasis></db:para>
</db:td>
<db:td>
<db:para>A non-word boundary. This assertion is true wherever <db:emphasis role="bold">\b</db:emphasis> is false. For example if we searched for <db:emphasis role="bold">\Bon\B</db:emphasis> in &quot;Left on&quot; the match would fail (space and end of string aren't non-word boundaries), but it would match in &quot;t<db:emphasis role="underline">on</db:emphasis>ne&quot;.</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para><db:emphasis role="bold">(?=<db:emphasis>E</db:emphasis>)</db:emphasis></db:para>
</db:td>
<db:td>
<db:para>Positive lookahead. This assertion is true if the expression matches at this point in the regexp. For example, <db:emphasis role="bold">const(?=\s+char)</db:emphasis> matches 'const' whenever it is followed by 'char', as in 'static <db:emphasis role="underline">const</db:emphasis> char *'. (Compare with <db:emphasis role="bold">const\s+char</db:emphasis>, which matches 'static <db:emphasis role="underline">const char</db:emphasis> *'.)</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para><db:emphasis role="bold">(?!<db:emphasis>E</db:emphasis>)</db:emphasis></db:para>
</db:td>
<db:td>
<db:para>Negative lookahead. This assertion is true if the expression does not match at this point in the regexp. For example, <db:emphasis role="bold">const(?!\s+char)</db:emphasis> matches 'const' <db:emphasis>except</db:emphasis> when it is followed by 'char'.</db:para>
</db:td>
</db:tr>
</db:informaltable>
<db:anchor xml:id="qregexp-wildcard-matching"/>
</db:section>
<db:section xml:id="wildcard-matching">
<db:title>Wildcard Matching</db:title>
<db:para>Most command shells such as <db:emphasis>bash</db:emphasis> or <db:emphasis>cmd.exe</db:emphasis> support &quot;file globbing&quot;, the ability to identify a group of files by using wildcards. The <db:link xlink:href="qregexp.xml#setPatternSyntax">setPatternSyntax</db:link>() function is used to switch between regexp and wildcard mode. Wildcard matching is much simpler than full regexps and has only four features:</db:para>
<db:informaltable style="generic">
<db:tr valign="top">
<db:td>
<db:para><db:emphasis role="bold">c</db:emphasis></db:para>
</db:td>
<db:td>
<db:para>Any character represents itself apart from those mentioned below. Thus <db:emphasis role="bold">c</db:emphasis> matches the character <db:emphasis>c</db:emphasis>.</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para><db:emphasis role="bold">?</db:emphasis></db:para>
</db:td>
<db:td>
<db:para>Matches any single character. It is the same as <db:emphasis role="bold">.</db:emphasis> in full regexps.</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para><db:emphasis role="bold">*</db:emphasis></db:para>
</db:td>
<db:td>
<db:para>Matches zero or more of any characters. It is the same as <db:emphasis role="bold">.*</db:emphasis> in full regexps.</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para><db:emphasis role="bold">[...]</db:emphasis></db:para>
</db:td>
<db:td>
<db:para>Sets of characters can be represented in square brackets, similar to full regexps. Within the character class, like outside, backslash has no special meaning.</db:para>
</db:td>
</db:tr>
</db:informaltable>
<db:para>In the mode Wildcard, the wildcard characters cannot be escaped. In the mode <db:link xlink:href="qregexp.xml#PatternSyntax-enum">WildcardUnix</db:link>, the character '\' escapes the wildcard.</db:para>
<db:para>For example if we are in wildcard mode and have strings which contain filenames we could identify HTML files with <db:emphasis role="bold">*.html</db:emphasis>. This will match zero or more characters followed by a dot followed by 'h', 't', 'm' and 'l'.</db:para>
<db:para>To test a string against a wildcard expression, use <db:link xlink:href="qregexp.xml#exactMatch">exactMatch</db:link>(). For example:</db:para>
<db:programlisting language="cpp">QRegExp rx(&quot;*.txt&quot;);
rx.setPatternSyntax(QRegExp::Wildcard);
rx.exactMatch(&quot;README.txt&quot;);        // returns true
rx.exactMatch(&quot;welcome.txt.bak&quot;);   // returns false
</db:programlisting>
<db:anchor xml:id="perl-users"/>
</db:section>
<db:section xml:id="notes-for-perl-users">
<db:title>Notes for Perl Users</db:title>
<db:para>Most of the character class abbreviations supported by Perl are supported by <db:link xlink:href="qregexp.xml">QRegExp</db:link>, see <db:link xlink:href="qregexp.xml#characters-and-abbreviations-for-sets-of-characters">characters and abbreviations for sets of characters</db:link>.</db:para>
<db:para>In <db:link xlink:href="qregexp.xml">QRegExp</db:link>, apart from within character classes, <db:code>^</db:code> always signifies the start of the string, so carets must always be escaped unless used for that purpose. In Perl the meaning of caret varies automagically depending on where it occurs so escaping it is rarely necessary. The same applies to <db:code>$</db:code> which in <db:link xlink:href="qregexp.xml">QRegExp</db:link> always signifies the end of the string.</db:para>
<db:para><db:link xlink:href="qregexp.xml">QRegExp</db:link>'s quantifiers are the same as Perl's greedy quantifiers (but see the <db:link xlink:href="qregexp.xml#greedy-quantifiers">note above</db:link>). Non-greedy matching cannot be applied to individual quantifiers, but can be applied to all the quantifiers in the pattern. For example, to match the Perl regexp <db:emphasis role="bold">ro+?m</db:emphasis> requires:</db:para>
<db:programlisting language="cpp">QRegExp rx(&quot;ro+m&quot;);
rx.setMinimal(true);
</db:programlisting>
<db:para>The equivalent of Perl's <db:code>/i</db:code> option is <db:link xlink:href="qregexp.xml#setCaseSensitivity">setCaseSensitivity</db:link>(<db:link xlink:href="qt.xml#CaseSensitivity-enum">Qt::CaseInsensitive</db:link>).</db:para>
<db:para>Perl's <db:code>/g</db:code> option can be emulated using a <db:link xlink:href="qregexp.xml#cap-in-a-loop">loop</db:link>.</db:para>
<db:para>In <db:link xlink:href="qregexp.xml">QRegExp</db:link> <db:emphasis role="bold">.</db:emphasis> matches any character, therefore all <db:link xlink:href="qregexp.xml">QRegExp</db:link> regexps have the equivalent of Perl's <db:code>/s</db:code> option. <db:link xlink:href="qregexp.xml">QRegExp</db:link> does not have an equivalent to Perl's <db:code>/m</db:code> option, but this can be emulated in various ways for example by splitting the input into lines or by looping with a regexp that searches for newlines.</db:para>
<db:para>Because <db:link xlink:href="qregexp.xml">QRegExp</db:link> is string oriented, there are no \A, \Z, or \z assertions. The \G assertion is not supported but can be emulated in a loop.</db:para>
<db:para>Perl's $&amp; is cap(0) or <db:link xlink:href="qregexp.xml#capturedTexts">capturedTexts</db:link>()[0]. There are no <db:link xlink:href="qregexp.xml">QRegExp</db:link> equivalents for $`, $' or $+. Perl's capturing variables, $1, $2, ... correspond to cap(1) or <db:link xlink:href="qregexp.xml#capturedTexts">capturedTexts</db:link>()[1], cap(2) or <db:link xlink:href="qregexp.xml#capturedTexts">capturedTexts</db:link>()[2], etc.</db:para>
<db:para>To substitute a pattern use <db:link xlink:href="qstring.xml#replace">QString::replace</db:link>().</db:para>
<db:para>Perl's extended <db:code>/x</db:code> syntax is not supported, nor are directives, e.g. (?i), or regexp comments, e.g. (?#comment). On the other hand, C++'s rules for literal strings can be used to achieve the same:</db:para>
<db:programlisting language="cpp">QRegExp mark(&quot;\\b&quot;      // word boundary
              &quot;[Mm]ark&quot; // the word we want to match
            );
</db:programlisting>
<db:para>Both zero-width positive and zero-width negative lookahead assertions (?=pattern) and (?!pattern) are supported with the same syntax as Perl. Perl's lookbehind assertions, &quot;independent&quot; subexpressions and conditional expressions are not supported.</db:para>
<db:para>Non-capturing parentheses are also supported, with the same (?:pattern) syntax.</db:para>
<db:para>See <db:link xlink:href="qstring.xml#split">QString::split</db:link>() and <db:link xlink:href="qstringlist.xml#join">QStringList::join</db:link>() for equivalents to Perl's split and join functions.</db:para>
<db:para>Note: because C++ transforms \'s they must be written <db:emphasis>twice</db:emphasis> in code, e.g. <db:emphasis role="bold">\b</db:emphasis> must be written <db:emphasis role="bold">\\b</db:emphasis>.</db:para>
</db:section>
<db:section xml:id="code-examples">
<db:title>Code Examples</db:title>
<db:programlisting language="cpp">QRegExp rx(&quot;^\\d\\d?$&quot;);    // match integers 0 to 99
rx.indexIn(&quot;123&quot;);          // returns -1 (no match)
rx.indexIn(&quot;-6&quot;);           // returns -1 (no match)
rx.indexIn(&quot;6&quot;);            // returns 0 (matched at position 0)
</db:programlisting>
<db:para>The third string matches '<db:emphasis role="underline">6</db:emphasis>'. This is a simple validation regexp for integers in the range 0 to 99.</db:para>
<db:programlisting language="cpp">QRegExp rx(&quot;^\\S+$&quot;);       // match strings without whitespace
rx.indexIn(&quot;Hello world&quot;);  // returns -1 (no match)
rx.indexIn(&quot;This_is-OK&quot;);   // returns 0 (matched at position 0)
</db:programlisting>
<db:para>The second string matches '<db:emphasis role="underline">This_is-OK</db:emphasis>'. We've used the character set abbreviation '\S' (non-whitespace) and the anchors to match strings which contain no whitespace.</db:para>
<db:para>In the following example we match strings containing 'mail' or 'letter' or 'correspondence' but only match whole words i.e. not 'email'</db:para>
<db:programlisting language="cpp">QRegExp rx(&quot;\\b(mail|letter|correspondence)\\b&quot;);
rx.indexIn(&quot;I sent you an email&quot;);     // returns -1 (no match)
rx.indexIn(&quot;Please write the letter&quot;); // returns 17
</db:programlisting>
<db:para>The second string matches &quot;Please write the <db:emphasis role="underline">letter</db:emphasis>&quot;. The word 'letter' is also captured (because of the parentheses). We can see what text we've captured like this:</db:para>
<db:programlisting language="cpp">QString captured = rx.cap(1); // captured == &quot;letter&quot;
</db:programlisting>
<db:para>This will capture the text from the first set of capturing parentheses (counting capturing left parentheses from left to right). The parentheses are counted from 1 since cap(0) is the whole matched regexp (equivalent to '&amp;' in most regexp engines).</db:para>
<db:programlisting language="cpp">QRegExp rx(&quot;&amp;(?!amp;)&quot;);      // match ampersands but not &amp;amp;
QString line1 = &quot;This &amp; that&quot;;
line1.replace(rx, &quot;&amp;amp;&quot;);
// line1 == &quot;This &amp;amp; that&quot;
QString line2 = &quot;His &amp;amp; hers &amp; theirs&quot;;
line2.replace(rx, &quot;&amp;amp;&quot;);
// line2 == &quot;His &amp;amp; hers &amp;amp; theirs&quot;
</db:programlisting>
<db:para>Here we've passed the <db:link xlink:href="qregexp.xml">QRegExp</db:link> to <db:link xlink:href="qstring.xml">QString</db:link>'s replace() function to replace the matched text with new text.</db:para>
<db:programlisting language="cpp">QString str = &quot;One Eric another Eirik, and an Ericsson. &quot;
              &quot;How many Eiriks, Eric?&quot;;
QRegExp rx(&quot;\\b(Eric|Eirik)\\b&quot;); // match Eric or Eirik
int pos = 0;    // where we are in the string
int count = 0;  // how many Eric and Eirik's we've counted
while (pos &gt;= 0) {
    pos = rx.indexIn(str, pos);
    if (pos &gt;= 0) {
        ++pos;      // move along in str
        ++count;    // count our Eric or Eirik
    }
}
</db:programlisting>
<db:para>We've used the <db:link xlink:href="qregexp.xml#indexIn">indexIn</db:link>() function to repeatedly match the regexp in the string. Note that instead of moving forward by one character at a time <db:code>pos++</db:code> we could have written <db:code>pos += rx.matchedLength()</db:code> to skip over the already matched string. The count will equal 3, matching 'One <db:emphasis role="underline">Eric</db:emphasis> another <db:emphasis role="underline">Eirik</db:emphasis>, and an Ericsson. How many Eiriks, <db:emphasis role="underline">Eric</db:emphasis>?'; it doesn't match 'Ericsson' or 'Eiriks' because they are not bounded by non-word boundaries.</db:para>
<db:para>One common use of regexps is to split lines of delimited data into their component fields.</db:para>
<db:programlisting language="cpp">str = &quot;The Qt Company Ltd\tqt.io\tFinland&quot;;
QString company, web, country;
rx.setPattern(&quot;^([^\t]+)\t([^\t]+)\t([^\t]+)$&quot;);
if (rx.indexIn(str) != -1) {
    company = rx.cap(1);
    web = rx.cap(2);
    country = rx.cap(3);
}
</db:programlisting>
<db:para>In this example our input lines have the format company name, web address and country. Unfortunately the regexp is rather long and not very versatile – the code will break if we add any more fields. A simpler and better solution is to look for the separator, '\t' in this case, and take the surrounding text. The <db:link xlink:href="qstring.xml#split">QString::split</db:link>() function can take a separator string or regexp as an argument and split a string accordingly.</db:para>
<db:programlisting language="cpp">QStringList field = str.split(&quot;\t&quot;);
</db:programlisting>
<db:para>Here field[0] is the company, field[1] the web address and so on.</db:para>
<db:para>To imitate the matching of a shell we can use wildcard mode.</db:para>
<db:programlisting language="cpp">QRegExp rx(&quot;*.html&quot;);
rx.setPatternSyntax(QRegExp::Wildcard);
rx.exactMatch(&quot;index.html&quot;);                // returns true
rx.exactMatch(&quot;default.htm&quot;);               // returns false
rx.exactMatch(&quot;readme.txt&quot;);                // returns false
</db:programlisting>
<db:para>Wildcard matching can be convenient because of its simplicity, but any wildcard regexp can be defined using full regexps, e.g. <db:emphasis role="bold">.*\.html$</db:emphasis>. Notice that we can't match both <db:code>.html</db:code> and <db:code>.htm</db:code> files with a wildcard unless we use <db:emphasis role="bold">*.htm*</db:emphasis> which will also match 'test.html.bak'. A full regexp gives us the precision we need, <db:emphasis role="bold">.*\.html?$</db:emphasis>.</db:para>
<db:para><db:link xlink:href="qregexp.xml">QRegExp</db:link> can match case insensitively using <db:link xlink:href="qregexp.xml#setCaseSensitivity">setCaseSensitivity</db:link>(), and can use non-greedy matching, see <db:link xlink:href="qregexp.xml#setMinimal">setMinimal</db:link>(). By default <db:link xlink:href="qregexp.xml">QRegExp</db:link> uses full regexps but this can be changed with <db:link xlink:href="qregexp.xml#setPatternSyntax">setPatternSyntax</db:link>(). Searching can be done forward with <db:link xlink:href="qregexp.xml#indexIn">indexIn</db:link>() or backward with <db:link xlink:href="qregexp.xml#lastIndexIn">lastIndexIn</db:link>(). Captured text can be accessed using <db:link xlink:href="qregexp.xml#capturedTexts">capturedTexts</db:link>() which returns a string list of all captured strings, or using <db:link xlink:href="qregexp.xml#cap">cap</db:link>() which returns the captured string for the given index. The <db:link xlink:href="qregexp.xml#pos">pos</db:link>() function takes a match index and returns the position in the string where the match was made (or -1 if there was no match).</db:para>
</db:section>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qstring.xml">QString</db:link></db:member>
<db:member><db:link xlink:href="qstringlist.xml">QStringList</db:link></db:member>
<db:member><db:link xlink:href="qregexpvalidator.xml">QRegExpValidator</db:link></db:member>
<db:member><db:link xlink:href="qsortfilterproxymodel.xml">QSortFilterProxyModel</db:link></db:member>
<db:member><db:link xlink:href="qtwidgets-tools-regexp-example.xml">Regular Expression Example</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="member-type-documentation">
<db:title>Member Type Documentation</db:title>
<db:section xml:id="CaretMode-enum">
<db:title>enum QRegExp::CaretMode</db:title>
<db:para>The CaretMode enum defines the different meanings of the caret (<db:emphasis role="bold">^</db:emphasis>) in a regular expression. The possible values are:</db:para>
<db:informaltable>
<db:thead>
<db:tr>
<db:th>Constant</db:th>
<db:th>Value</db:th>
<db:th>Description</db:th>
</db:tr>
</db:thead>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qregexp.xml">QRegExp</db:link></db:emphasis>::CaretAtZero</db:code></db:para>
</db:td>
<db:td><db:code>0</db:code></db:td>
<db:td>
<db:para>The caret corresponds to index 0 in the searched string.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qregexp.xml">QRegExp</db:link></db:emphasis>::CaretAtOffset</db:code></db:para>
</db:td>
<db:td><db:code>1</db:code></db:td>
<db:td>
<db:para>The caret corresponds to the start offset of the search.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qregexp.xml">QRegExp</db:link></db:emphasis>::CaretWontMatch</db:code></db:para>
</db:td>
<db:td><db:code>2</db:code></db:td>
<db:td>
<db:para>The caret never matches.</db:para>
</db:td>
</db:tr>
</db:informaltable>
</db:section>
<db:section xml:id="PatternSyntax-enum">
<db:title>enum QRegExp::PatternSyntax</db:title>
<db:para>The syntax used to interpret the meaning of the pattern.</db:para>
<db:informaltable>
<db:thead>
<db:tr>
<db:th>Constant</db:th>
<db:th>Value</db:th>
<db:th>Description</db:th>
</db:tr>
</db:thead>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qregexp.xml">QRegExp</db:link></db:emphasis>::RegExp</db:code></db:para>
</db:td>
<db:td><db:code>0</db:code></db:td>
<db:td>
<db:para>A rich Perl-like pattern matching syntax. This is the default.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qregexp.xml">QRegExp</db:link></db:emphasis>::RegExp2</db:code></db:para>
</db:td>
<db:td><db:code>3</db:code></db:td>
<db:td>
<db:para>Like RegExp, but with <db:link xlink:href="qregexp.xml#greedy-quantifiers">greedy quantifiers</db:link>. (Introduced in Qt 4.2.)</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qregexp.xml">QRegExp</db:link></db:emphasis>::Wildcard</db:code></db:para>
</db:td>
<db:td><db:code>1</db:code></db:td>
<db:td>
<db:para>This provides a simple pattern matching syntax similar to that used by shells (command interpreters) for &quot;file globbing&quot;. See <db:link xlink:href="qregexp.xml#wildcard-matching">QRegExp wildcard matching</db:link>.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qregexp.xml">QRegExp</db:link></db:emphasis>::WildcardUnix</db:code></db:para>
</db:td>
<db:td><db:code>4</db:code></db:td>
<db:td>
<db:para>This is similar to Wildcard but with the behavior of a Unix shell. The wildcard characters can be escaped with the character &quot;\&quot;.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qregexp.xml">QRegExp</db:link></db:emphasis>::FixedString</db:code></db:para>
</db:td>
<db:td><db:code>2</db:code></db:td>
<db:td>
<db:para>The pattern is a fixed string. This is equivalent to using the RegExp pattern on a string in which all metacharacters are escaped using <db:link xlink:href="qregexp.xml#escape">escape</db:link>().</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qregexp.xml">QRegExp</db:link></db:emphasis>::W3CXmlSchema11</db:code></db:para>
</db:td>
<db:td><db:code>5</db:code></db:td>
<db:td>
<db:para>The pattern is a regular expression as defined by the W3C XML Schema 1.1 specification.</db:para>
</db:td>
</db:tr>
</db:informaltable>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qregexp.xml#setPatternSyntax">setPatternSyntax</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
</db:section>
<db:section xml:id="member-function-documentation">
<db:title>Member Function Documentation</db:title>
<db:section xml:id="QRegExp">
<db:title>QRegExp::QRegExp()</db:title>
<db:para>Constructs an empty regexp.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qregexp.xml#isValid">isValid</db:link>()</db:member>
<db:member><db:link xlink:href="qregexp.xml#errorString">errorString</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="QRegExp-2">
<db:title>[explicit] QRegExp::QRegExp(const QString &amp;<db:emphasis>pattern</db:emphasis>, Qt::CaseSensitivity <db:emphasis>cs</db:emphasis> = Qt::CaseSensitive, QRegExp::PatternSyntax <db:emphasis>syntax</db:emphasis> = RegExp)</db:title>
<db:para>Constructs a regular expression object for the given <db:code role="parameter">pattern</db:code> string. The pattern must be given using wildcard notation if <db:code role="parameter">syntax</db:code> is <db:link xlink:href="qregexp.xml#PatternSyntax-enum">Wildcard</db:link>; the default is <db:link xlink:href="qregexp.xml#PatternSyntax-enum">RegExp</db:link>. The pattern is case sensitive, unless <db:code role="parameter">cs</db:code> is <db:link xlink:href="qt.xml#CaseSensitivity-enum">Qt::CaseInsensitive</db:link>. Matching is greedy (maximal), but can be changed by calling <db:link xlink:href="qregexp.xml#setMinimal">setMinimal</db:link>().</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qregexp.xml#setPattern">setPattern</db:link>()</db:member>
<db:member><db:link xlink:href="qregexp.xml#setCaseSensitivity">setCaseSensitivity</db:link>()</db:member>
<db:member><db:link xlink:href="qregexp.xml#setPatternSyntax">setPatternSyntax</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="QRegExp-1">
<db:title>QRegExp::QRegExp(const QRegExp &amp;<db:emphasis>rx</db:emphasis>)</db:title>
<db:para>Constructs a regular expression as a copy of <db:code role="parameter">rx</db:code>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qregexp.xml#operator-eq">operator=</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="dtor.QRegExp">
<db:title>[noexcept] QRegExp::~QRegExp()</db:title>
<db:para>Destroys the regular expression and cleans up its internal data.</db:para>
</db:section>
<db:section xml:id="cap">
<db:title>QString QRegExp::cap(int <db:emphasis>nth</db:emphasis> = 0) const</db:title>
<db:para>Returns the text captured by the <db:code role="parameter">nth</db:code> subexpression. The entire match has index 0 and the parenthesized subexpressions have indexes starting from 1 (excluding non-capturing parentheses).</db:para>
<db:programlisting language="cpp">QRegExp rxlen(&quot;(\\d+)(?:\\s*)(cm|inch)&quot;);
int pos = rxlen.indexIn(&quot;Length: 189cm&quot;);
if (pos &gt; -1) {
    QString value = rxlen.cap(1); // &quot;189&quot;
    QString unit = rxlen.cap(2);  // &quot;cm&quot;
    // ...
}
</db:programlisting>
<db:para>The order of elements matched by cap() is as follows. The first element, cap(0), is the entire matching string. Each subsequent element corresponds to the next capturing open left parentheses. Thus cap(1) is the text of the first capturing parentheses, cap(2) is the text of the second, and so on.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qregexp.xml#capturedTexts">capturedTexts</db:link>()</db:member>
<db:member><db:link xlink:href="qregexp.xml#pos">pos</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="captureCount">
<db:title>[since 4.6] int QRegExp::captureCount() const</db:title>
<db:para>Returns the number of captures contained in the regular expression.</db:para>
<db:para>This function was introduced in Qt 4.6.</db:para>
</db:section>
<db:section xml:id="capturedTexts">
<db:title>QStringList QRegExp::capturedTexts() const</db:title>
<db:para>Returns a list of the captured text strings.</db:para>
<db:para>The first string in the list is the entire matched string. Each subsequent list element contains a string that matched a (capturing) subexpression of the regexp.</db:para>
<db:para>For example:</db:para>
<db:programlisting language="cpp">QRegExp rx(&quot;(\\d+)(\\s*)(cm|inch(es)?)&quot;);
int pos = rx.indexIn(&quot;Length: 36 inches&quot;);
QStringList list = rx.capturedTexts();
// list is now (&quot;36 inches&quot;, &quot;36&quot;, &quot; &quot;, &quot;inches&quot;, &quot;es&quot;)
</db:programlisting>
<db:para>The above example also captures elements that may be present but which we have no interest in. This problem can be solved by using non-capturing parentheses:</db:para>
<db:programlisting language="cpp">QRegExp rx(&quot;(\\d+)(?:\\s*)(cm|inch(?:es)?)&quot;);
int pos = rx.indexIn(&quot;Length: 36 inches&quot;);
QStringList list = rx.capturedTexts();
// list is now (&quot;36 inches&quot;, &quot;36&quot;, &quot;inches&quot;)
</db:programlisting>
<db:para>Note that if you want to iterate over the list, you should iterate over a copy, e.g.</db:para>
<db:programlisting language="cpp">QStringList list = rx.capturedTexts();
QStringList::iterator it = list.begin();
while (it != list.end()) {
    myProcessing(*it);
    ++it;
}
</db:programlisting>
<db:para>Some regexps can match an indeterminate number of times. For example if the input string is &quot;Offsets: 12 14 99 231 7&quot; and the regexp, <db:code>rx</db:code>, is <db:emphasis role="bold">(\d+)+</db:emphasis>, we would hope to get a list of all the numbers matched. However, after calling <db:code>rx.indexIn(str)</db:code>, capturedTexts() will return the list (&quot;12&quot;, &quot;12&quot;), i.e. the entire match was &quot;12&quot; and the first subexpression matched was &quot;12&quot;. The correct approach is to use <db:link xlink:href="qregexp.xml#cap">cap</db:link>() in a <db:link xlink:href="qregexp.xml#cap-in-a-loop">loop</db:link>.</db:para>
<db:para>The order of elements in the string list is as follows. The first element is the entire matching string. Each subsequent element corresponds to the next capturing open left parentheses. Thus capturedTexts()[1] is the text of the first capturing parentheses, capturedTexts()[2] is the text of the second and so on (corresponding to $1, $2, etc., in some other regexp languages).</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qregexp.xml#cap">cap</db:link>()</db:member>
<db:member><db:link xlink:href="qregexp.xml#pos">pos</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="caseSensitivity">
<db:title>Qt::CaseSensitivity QRegExp::caseSensitivity() const</db:title>
<db:para>Returns <db:link xlink:href="qt.xml#CaseSensitivity-enum">Qt::CaseSensitive</db:link> if the regexp is matched case sensitively; otherwise returns <db:link xlink:href="qt.xml#CaseSensitivity-enum">Qt::CaseInsensitive</db:link>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qregexp.xml#setCaseSensitivity">setCaseSensitivity</db:link>()</db:member>
<db:member><db:link xlink:href="qregexp.xml#patternSyntax">patternSyntax</db:link>()</db:member>
<db:member><db:link xlink:href="qregexp.xml#pattern">pattern</db:link>()</db:member>
<db:member><db:link xlink:href="qregexp.xml#isMinimal">isMinimal</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="errorString">
<db:title>QString QRegExp::errorString() const</db:title>
<db:para>Returns a text string that explains why a regexp pattern is invalid the case being; otherwise returns &quot;no error occurred&quot;.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qregexp.xml#isValid">isValid</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="escape">
<db:title>[static] QString QRegExp::escape(const QString &amp;<db:emphasis>str</db:emphasis>)</db:title>
<db:para>Returns the string <db:code role="parameter">str</db:code> with every regexp special character escaped with a backslash. The special characters are $, (,), *, +, ., ?, [, ,], ^, {, | and }.</db:para>
<db:para>Example:</db:para>
<db:programlisting language="cpp">s1 = QRegExp::escape(&quot;bingo&quot;);   // s1 == &quot;bingo&quot;
s2 = QRegExp::escape(&quot;f(x)&quot;);    // s2 == &quot;f\\(x\\)&quot;
</db:programlisting>
<db:para>This function is useful to construct regexp patterns dynamically:</db:para>
<db:programlisting language="cpp">QRegExp rx(&quot;(&quot; + QRegExp::escape(name) +
           &quot;|&quot; + QRegExp::escape(alias) + &quot;)&quot;);
</db:programlisting>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qregexp.xml#setPatternSyntax">setPatternSyntax</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="exactMatch">
<db:title>bool QRegExp::exactMatch(const QString &amp;<db:emphasis>str</db:emphasis>) const</db:title>
<db:para>Returns <db:code>true</db:code> if <db:code role="parameter">str</db:code> is matched exactly by this regular expression; otherwise returns <db:code>false</db:code>. You can determine how much of the string was matched by calling <db:link xlink:href="qregexp.xml#matchedLength">matchedLength</db:link>().</db:para>
<db:para>For a given regexp string R, exactMatch(&quot;R&quot;) is the equivalent of <db:link xlink:href="qregexp.xml#indexIn">indexIn</db:link>(&quot;^R$&quot;) since exactMatch() effectively encloses the regexp in the start of string and end of string anchors, except that it sets <db:link xlink:href="qregexp.xml#matchedLength">matchedLength</db:link>() differently.</db:para>
<db:para>For example, if the regular expression is <db:emphasis role="bold">blue</db:emphasis>, then exactMatch() returns <db:code>true</db:code> only for input <db:code>blue</db:code>. For inputs <db:code>bluebell</db:code>, <db:code>blutak</db:code> and <db:code>lightblue</db:code>, exactMatch() returns <db:code>false</db:code> and <db:link xlink:href="qregexp.xml#matchedLength">matchedLength</db:link>() will return 4, 3 and 0 respectively.</db:para>
<db:para>Although const, this function sets <db:link xlink:href="qregexp.xml#matchedLength">matchedLength</db:link>(), <db:link xlink:href="qregexp.xml#capturedTexts">capturedTexts</db:link>(), and <db:link xlink:href="qregexp.xml#pos">pos</db:link>().</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qregexp.xml#indexIn">indexIn</db:link>()</db:member>
<db:member><db:link xlink:href="qregexp.xml#lastIndexIn">lastIndexIn</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="indexIn">
<db:title>int QRegExp::indexIn(const QString &amp;<db:emphasis>str</db:emphasis>, int <db:emphasis>offset</db:emphasis> = 0, QRegExp::CaretMode <db:emphasis>caretMode</db:emphasis> = CaretAtZero) const</db:title>
<db:para>Attempts to find a match in <db:code role="parameter">str</db:code> from position <db:code role="parameter">offset</db:code> (0 by default). If <db:code role="parameter">offset</db:code> is -1, the search starts at the last character; if -2, at the next to last character; etc.</db:para>
<db:para>Returns the position of the first match, or -1 if there was no match.</db:para>
<db:para>The <db:code role="parameter">caretMode</db:code> parameter can be used to instruct whether <db:emphasis role="bold">^</db:emphasis> should match at index 0 or at <db:code role="parameter">offset</db:code>.</db:para>
<db:para>You might prefer to use <db:link xlink:href="qstring.xml#indexOf">QString::indexOf</db:link>(), <db:link xlink:href="qstring.xml#contains">QString::contains</db:link>(), or even <db:link xlink:href="qstringlist.xml#filter">QStringList::filter</db:link>(). To replace matches use <db:link xlink:href="qstring.xml#replace">QString::replace</db:link>().</db:para>
<db:para>Example:</db:para>
<db:programlisting language="cpp">QString str = &quot;offsets: 1.23 .50 71.00 6.00&quot;;
QRegExp rx(&quot;\\d*\\.\\d+&quot;);    // primitive floating point matching
int count = 0;
int pos = 0;
while ((pos = rx.indexIn(str, pos)) != -1) {
    ++count;
    pos += rx.matchedLength();
}
// pos will be 9, 14, 18 and finally 24; count will end up as 4
</db:programlisting>
<db:para>Although const, this function sets <db:link xlink:href="qregexp.xml#matchedLength">matchedLength</db:link>(), <db:link xlink:href="qregexp.xml#capturedTexts">capturedTexts</db:link>() and <db:link xlink:href="qregexp.xml#pos">pos</db:link>().</db:para>
<db:para>If the <db:link xlink:href="qregexp.xml">QRegExp</db:link> is a wildcard expression (see <db:link xlink:href="qregexp.xml#setPatternSyntax">setPatternSyntax</db:link>()) and want to test a string against the whole wildcard expression, use <db:link xlink:href="qregexp.xml#exactMatch">exactMatch</db:link>() instead of this function.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qregexp.xml#lastIndexIn">lastIndexIn</db:link>()</db:member>
<db:member><db:link xlink:href="qregexp.xml#exactMatch">exactMatch</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="isEmpty">
<db:title>bool QRegExp::isEmpty() const</db:title>
<db:para>Returns <db:code>true</db:code> if the pattern string is empty; otherwise returns false.</db:para>
<db:para>If you call <db:link xlink:href="qregexp.xml#exactMatch">exactMatch</db:link>() with an empty pattern on an empty string it will return true; otherwise it returns <db:code>false</db:code> since it operates over the whole string. If you call <db:link xlink:href="qregexp.xml#indexIn">indexIn</db:link>() with an empty pattern on <db:emphasis>any</db:emphasis> string it will return the start offset (0 by default) because the empty pattern matches the 'emptiness' at the start of the string. In this case the length of the match returned by <db:link xlink:href="qregexp.xml#matchedLength">matchedLength</db:link>() will be 0.</db:para>
<db:para>See <db:link xlink:href="qstring.xml#isEmpty">QString::isEmpty</db:link>().</db:para>
</db:section>
<db:section xml:id="isMinimal">
<db:title>bool QRegExp::isMinimal() const</db:title>
<db:para>Returns <db:code>true</db:code> if minimal (non-greedy) matching is enabled; otherwise returns <db:code>false</db:code>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qregexp.xml#caseSensitivity">caseSensitivity</db:link>()</db:member>
<db:member><db:link xlink:href="qregexp.xml#setMinimal">setMinimal</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="isValid">
<db:title>bool QRegExp::isValid() const</db:title>
<db:para>Returns <db:code>true</db:code> if the regular expression is valid; otherwise returns false. An invalid regular expression never matches.</db:para>
<db:para>The pattern <db:emphasis role="bold">[a-z</db:emphasis> is an example of an invalid pattern, since it lacks a closing square bracket.</db:para>
<db:para>Note that the validity of a regexp may also depend on the setting of the wildcard flag, for example <db:emphasis role="bold">*.html</db:emphasis> is a valid wildcard regexp but an invalid full regexp.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qregexp.xml#errorString">errorString</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="lastIndexIn">
<db:title>int QRegExp::lastIndexIn(const QString &amp;<db:emphasis>str</db:emphasis>, int <db:emphasis>offset</db:emphasis> = -1, QRegExp::CaretMode <db:emphasis>caretMode</db:emphasis> = CaretAtZero) const</db:title>
<db:para>Attempts to find a match backwards in <db:code role="parameter">str</db:code> from position <db:code role="parameter">offset</db:code>. If <db:code role="parameter">offset</db:code> is -1 (the default), the search starts at the last character; if -2, at the next to last character; etc.</db:para>
<db:para>Returns the position of the first match, or -1 if there was no match.</db:para>
<db:para>The <db:code role="parameter">caretMode</db:code> parameter can be used to instruct whether <db:emphasis role="bold">^</db:emphasis> should match at index 0 or at <db:code role="parameter">offset</db:code>.</db:para>
<db:para>Although const, this function sets <db:link xlink:href="qregexp.xml#matchedLength">matchedLength</db:link>(), <db:link xlink:href="qregexp.xml#capturedTexts">capturedTexts</db:link>() and <db:link xlink:href="qregexp.xml#pos">pos</db:link>().</db:para>
<db:warning>
<db:para>Searching backwards is much slower than searching forwards.</db:para>
</db:warning>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qregexp.xml#indexIn">indexIn</db:link>()</db:member>
<db:member><db:link xlink:href="qregexp.xml#exactMatch">exactMatch</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="matchedLength">
<db:title>int QRegExp::matchedLength() const</db:title>
<db:para>Returns the length of the last matched string, or -1 if there was no match.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qregexp.xml#exactMatch">exactMatch</db:link>()</db:member>
<db:member><db:link xlink:href="qregexp.xml#indexIn">indexIn</db:link>()</db:member>
<db:member><db:link xlink:href="qregexp.xml#lastIndexIn">lastIndexIn</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="pattern">
<db:title>QString QRegExp::pattern() const</db:title>
<db:para>Returns the pattern string of the regular expression. The pattern has either regular expression syntax or wildcard syntax, depending on <db:link xlink:href="qregexp.xml#patternSyntax">patternSyntax</db:link>().</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qregexp.xml#setPattern">setPattern</db:link>()</db:member>
<db:member><db:link xlink:href="qregexp.xml#patternSyntax">patternSyntax</db:link>()</db:member>
<db:member><db:link xlink:href="qregexp.xml#caseSensitivity">caseSensitivity</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="patternSyntax">
<db:title>QRegExp::PatternSyntax QRegExp::patternSyntax() const</db:title>
<db:para>Returns the syntax used by the regular expression. The default is <db:link xlink:href="qregexp.xml#PatternSyntax-enum">QRegExp::RegExp</db:link>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qregexp.xml#setPatternSyntax">setPatternSyntax</db:link>()</db:member>
<db:member><db:link xlink:href="qregexp.xml#pattern">pattern</db:link>()</db:member>
<db:member><db:link xlink:href="qregexp.xml#caseSensitivity">caseSensitivity</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="pos">
<db:title>int QRegExp::pos(int <db:emphasis>nth</db:emphasis> = 0) const</db:title>
<db:para>Returns the position of the <db:code role="parameter">nth</db:code> captured text in the searched string. If <db:code role="parameter">nth</db:code> is 0 (the default), pos() returns the position of the whole match.</db:para>
<db:para>Example:</db:para>
<db:programlisting language="cpp">QRegExp rx(&quot;/([a-z]+)/([a-z]+)&quot;);
rx.indexIn(&quot;Output /dev/null&quot;);   // returns 7 (position of /dev/null)
rx.pos(0);                        // returns 7 (position of /dev/null)
rx.pos(1);                        // returns 8 (position of dev)
rx.pos(2);                        // returns 12 (position of null)
</db:programlisting>
<db:para>For zero-length matches, pos() always returns -1. (For example, if cap(4) would return an empty string, pos(4) returns -1.) This is a feature of the implementation.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qregexp.xml#cap">cap</db:link>()</db:member>
<db:member><db:link xlink:href="qregexp.xml#capturedTexts">capturedTexts</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setCaseSensitivity">
<db:title>void QRegExp::setCaseSensitivity(Qt::CaseSensitivity <db:emphasis>cs</db:emphasis>)</db:title>
<db:para>Sets case sensitive matching to <db:code role="parameter">cs</db:code>.</db:para>
<db:para>If <db:code role="parameter">cs</db:code> is <db:link xlink:href="qt.xml#CaseSensitivity-enum">Qt::CaseSensitive</db:link>, <db:emphasis role="bold">\.txt$</db:emphasis> matches <db:code>readme.txt</db:code> but not <db:code>README.TXT</db:code>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qregexp.xml#caseSensitivity">caseSensitivity</db:link>()</db:member>
<db:member><db:link xlink:href="qregexp.xml#setPatternSyntax">setPatternSyntax</db:link>()</db:member>
<db:member><db:link xlink:href="qregexp.xml#setPattern">setPattern</db:link>()</db:member>
<db:member><db:link xlink:href="qregexp.xml#setMinimal">setMinimal</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setMinimal">
<db:title>void QRegExp::setMinimal(bool <db:emphasis>minimal</db:emphasis>)</db:title>
<db:para>Enables or disables minimal matching. If <db:code role="parameter">minimal</db:code> is false, matching is greedy (maximal) which is the default.</db:para>
<db:para>For example, suppose we have the input string &quot;We must be &lt;b&gt;bold&lt;/b&gt;, very &lt;b&gt;bold&lt;/b&gt;!&quot; and the pattern <db:emphasis role="bold">&lt;b&gt;.*&lt;/b&gt;</db:emphasis>. With the default greedy (maximal) matching, the match is &quot;We must be <db:emphasis role="underline">&lt;b&gt;bold&lt;/b&gt;, very &lt;b&gt;bold&lt;/b&gt;</db:emphasis>!&quot;. But with minimal (non-greedy) matching, the first match is: &quot;We must be <db:emphasis role="underline">&lt;b&gt;bold&lt;/b&gt;</db:emphasis>, very &lt;b&gt;bold&lt;/b&gt;!&quot; and the second match is &quot;We must be &lt;b&gt;bold&lt;/b&gt;, very <db:emphasis role="underline">&lt;b&gt;bold&lt;/b&gt;</db:emphasis>!&quot;. In practice we might use the pattern <db:emphasis role="bold">&lt;b&gt;[^&lt;]*&lt;/b&gt;</db:emphasis> instead, although this will still fail for nested tags.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qregexp.xml#isMinimal">isMinimal</db:link>()</db:member>
<db:member><db:link xlink:href="qregexp.xml#setCaseSensitivity">setCaseSensitivity</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setPattern">
<db:title>void QRegExp::setPattern(const QString &amp;<db:emphasis>pattern</db:emphasis>)</db:title>
<db:para>Sets the pattern string to <db:code role="parameter">pattern</db:code>. The case sensitivity, wildcard, and minimal matching options are not changed.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qregexp.xml#pattern">pattern</db:link>()</db:member>
<db:member><db:link xlink:href="qregexp.xml#setPatternSyntax">setPatternSyntax</db:link>()</db:member>
<db:member><db:link xlink:href="qregexp.xml#setCaseSensitivity">setCaseSensitivity</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setPatternSyntax">
<db:title>void QRegExp::setPatternSyntax(QRegExp::PatternSyntax <db:emphasis>syntax</db:emphasis>)</db:title>
<db:para>Sets the syntax mode for the regular expression. The default is <db:link xlink:href="qregexp.xml#PatternSyntax-enum">QRegExp::RegExp</db:link>.</db:para>
<db:para>Setting <db:code role="parameter">syntax</db:code> to <db:link xlink:href="qregexp.xml#PatternSyntax-enum">QRegExp::Wildcard</db:link> enables simple shell-like <db:link xlink:href="qregexp.xml#wildcard-matching">QRegExp wildcard matching</db:link>. For example, <db:emphasis role="bold">r*.txt</db:emphasis> matches the string <db:code>readme.txt</db:code> in wildcard mode, but does not match <db:code>readme</db:code>.</db:para>
<db:para>Setting <db:code role="parameter">syntax</db:code> to <db:link xlink:href="qregexp.xml#PatternSyntax-enum">QRegExp::FixedString</db:link> means that the pattern is interpreted as a plain string. Special characters (e.g., backslash) don't need to be escaped then.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qregexp.xml#patternSyntax">patternSyntax</db:link>()</db:member>
<db:member><db:link xlink:href="qregexp.xml#setPattern">setPattern</db:link>()</db:member>
<db:member><db:link xlink:href="qregexp.xml#setCaseSensitivity">setCaseSensitivity</db:link>()</db:member>
<db:member><db:link xlink:href="qregexp.xml#escape">escape</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="swap">
<db:title>[noexcept, since 4.8] void QRegExp::swap(QRegExp &amp;<db:emphasis>other</db:emphasis>)</db:title>
<db:para>Swaps regular expression <db:code role="parameter">other</db:code> with this regular expression. This operation is very fast and never fails.</db:para>
<db:para>This function was introduced in Qt 4.8.</db:para>
</db:section>
<db:section xml:id="operator-not-eq">
<db:title>bool QRegExp::operator!=(const QRegExp &amp;<db:emphasis>rx</db:emphasis>) const</db:title>
<db:para>Returns <db:code>true</db:code> if this regular expression is not equal to <db:code role="parameter">rx</db:code>; otherwise returns <db:code>false</db:code>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qregexp.xml#operator-eq-eq">operator==</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="operator-eq">
<db:title>[default, since 5.2] QRegExp &amp;QRegExp::operator=(QRegExp &amp;&amp;<db:emphasis>other</db:emphasis>)</db:title>
<db:para>Move-assigns <db:code role="parameter">other</db:code> to this <db:link xlink:href="qregexp.xml">QRegExp</db:link> instance.</db:para>
<db:para>This function was introduced in Qt 5.2.</db:para>
</db:section>
<db:section xml:id="operator-eq-1">
<db:title>QRegExp &amp;QRegExp::operator=(const QRegExp &amp;<db:emphasis>rx</db:emphasis>)</db:title>
<db:para>Copies the regular expression <db:code role="parameter">rx</db:code> and returns a reference to the copy. The case sensitivity, wildcard, and minimal matching options are also copied.</db:para>
</db:section>
<db:section xml:id="operator-eq-eq">
<db:title>bool QRegExp::operator==(const QRegExp &amp;<db:emphasis>rx</db:emphasis>) const</db:title>
<db:para>Returns <db:code>true</db:code> if this regular expression is equal to <db:code role="parameter">rx</db:code>; otherwise returns <db:code>false</db:code>.</db:para>
<db:para>Two <db:link xlink:href="qregexp.xml">QRegExp</db:link> objects are equal if they have the same pattern strings and the same settings for case sensitivity, wildcard and minimal matching.</db:para>
</db:section>
</db:section>
<db:section xml:id="related-non-members">
<db:title>Related Non-Members</db:title>
<db:section xml:id="qHash-10">
<db:title>[noexcept, since 5.6] uint qHash(const QRegExp &amp;<db:emphasis>key</db:emphasis>, uint <db:emphasis>seed</db:emphasis> = 0)</db:title>
<db:para>Returns the hash value for <db:code role="parameter">key</db:code>, using <db:code role="parameter">seed</db:code> to seed the calculation.</db:para>
<db:para>This function was introduced in Qt 5.6.</db:para>
</db:section>
<db:section xml:id="operator-lt-lt-14">
<db:title>QDataStream &amp;operator&lt;&lt;(QDataStream &amp;<db:emphasis>out</db:emphasis>, const QRegExp &amp;<db:emphasis>regExp</db:emphasis>)</db:title>
<db:para>Writes the regular expression <db:code role="parameter">regExp</db:code> to stream <db:code role="parameter">out</db:code>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="datastreamformat.xml">Serializing Qt Data Types</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="operator-gt-gt-14">
<db:title>QDataStream &amp;operator&gt;&gt;(QDataStream &amp;<db:emphasis>in</db:emphasis>, QRegExp &amp;<db:emphasis>regExp</db:emphasis>)</db:title>
<db:para>Reads a regular expression from stream <db:code role="parameter">in</db:code> into <db:code role="parameter">regExp</db:code>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="datastreamformat.xml">Serializing Qt Data Types</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
</db:section>
</db:article>
