<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en">
<db:info>
<db:title>QQuickRenderControl Class</db:title>
<db:productname>QtQuick</db:productname>
<db:edition>Qt 5.6.3 Reference Documentation</db:edition>
<db:titleabbrev>Qt Quick Reference Documentation</db:titleabbrev>
<db:abstract>
<db:para>The <db:link xlink:href="qquickrendercontrol.xml">QQuickRenderControl</db:link> class provides a mechanism for rendering the Qt Quick scenegraph onto an offscreen render target in a fully application-controlled manner.</db:para>
<db:para>This class was introduced in Qt 5.4.</db:para>
</db:abstract>
<db:pubdate>2025-06-29</db:pubdate>
<db:date>2025-06-29</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:variablelist>
<db:varlistentry>
<db:term>Header</db:term>
<db:listitem>
<db:para>QQuickRenderControl</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Since</db:term>
<db:listitem>
<db:para>Qt 5.4</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>qmake</db:term>
<db:listitem>
<db:para>QT += quick</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Inherits</db:term>
<db:listitem>
<db:para><db:link xlink:href="qobject.xml" xlink:role="class">QObject</db:link></db:para>
</db:listitem>
</db:varlistentry>
</db:variablelist>
<db:section xml:id="details">
<db:title>Detailed Description</db:title>
<db:para><db:link xlink:href="qquickwindow.xml">QQuickWindow</db:link> and <db:link xlink:href="qquickview.xml">QQuickView</db:link> and their associated internal render loops render the Qt Quick scene onto a native window. In some cases, for example when integrating with 3rd party OpenGL renderers, it might be beneficial to get the scene into a texture that can then be used in arbitrary ways by the external rendering engine. <db:link xlink:href="qquickrendercontrol.xml">QQuickRenderControl</db:link> makes this possible in a hardware accelerated manner, unlike the performance-wise limited alternative of using <db:link xlink:href="qquickwindow.xml#grabWindow">QQuickWindow::grabWindow</db:link>()</db:para>
<db:para>When using a <db:link xlink:href="qquickrendercontrol.xml">QQuickRenderControl</db:link>, the <db:link xlink:href="qquickwindow.xml">QQuickWindow</db:link> does not have to be shown or even created at all. This means there will not be an underlying native window for it. Instead, the <db:link xlink:href="qquickwindow.xml">QQuickWindow</db:link> instance is associated with the render control, using the overload of the <db:link xlink:href="qquickwindow.xml">QQuickWindow</db:link> constructor, and an OpenGL framebuffer object by calling <db:link xlink:href="qquickwindow.xml#setRenderTarget">QQuickWindow::setRenderTarget</db:link>().</db:para>
<db:para>Management of the context and framebuffer object is up to the application. The context that will be used by Qt Quick must be created before calling <db:link xlink:href="qquickrendercontrol.xml#initialize">initialize</db:link>(). The creation of the framebuffer object can be deferred, see below. Qt 5.4 introduces the ability for <db:link xlink:href="qopenglcontext.xml">QOpenGLContext</db:link> to adopt existing native contexts. Together with <db:link xlink:href="qquickrendercontrol.xml">QQuickRenderControl</db:link> this makes it possible to create a <db:link xlink:href="qopenglcontext.xml">QOpenGLContext</db:link> that shares with an external rendering engine's existing context. This new <db:link xlink:href="qopenglcontext.xml">QOpenGLContext</db:link> can then be used to render the Qt Quick scene into a texture that is accessible by the other engine's context too.</db:para>
<db:para>Loading and instantiation of the QML components happen by using a <db:link xlink:href="qqmlengine.xml">QQmlEngine</db:link>. Once the root object is created, it will need to be parented to the <db:link xlink:href="qquickwindow.xml">QQuickWindow</db:link>'s contentItem().</db:para>
<db:para>Applications will usually have to connect to 4 important signals:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:link xlink:href="qquickwindow.xml#sceneGraphInitialized">QQuickWindow::sceneGraphInitialized</db:link>() Emitted at some point after calling <db:link xlink:href="qquickrendercontrol.xml#initialize">QQuickRenderControl::initialize</db:link>(). Upon this signal, the application is expected to create its framebuffer object and associate it with the <db:link xlink:href="qquickwindow.xml">QQuickWindow</db:link>.</db:para>
</db:listitem>
<db:listitem>
<db:para><db:link xlink:href="qquickwindow.xml#sceneGraphInvalidated">QQuickWindow::sceneGraphInvalidated</db:link>() When the scenegraph resources are released, the framebuffer object can be destroyed too.</db:para>
</db:listitem>
<db:listitem>
<db:para><db:link xlink:href="qquickrendercontrol.xml#renderRequested">QQuickRenderControl::renderRequested</db:link>() Indicates that the scene has to be rendered by calling <db:link xlink:href="qquickrendercontrol.xml#render">render</db:link>(). After making the context current, applications are expected to call <db:link xlink:href="qquickrendercontrol.xml#render">render</db:link>().</db:para>
</db:listitem>
<db:listitem>
<db:para><db:link xlink:href="qquickrendercontrol.xml#sceneChanged">QQuickRenderControl::sceneChanged</db:link>() Indicates that the scene has changed meaning that, before rendering, polishing and synchronizing is also necessary.</db:para>
</db:listitem>
</db:itemizedlist>
<db:para>To send events, for example mouse or keyboard events, to the scene, use <db:link xlink:href="qcoreapplication.xml#sendEvent">QCoreApplication::sendEvent</db:link>() with the <db:link xlink:href="qquickwindow.xml">QQuickWindow</db:link> instance as the receiver.</db:para>
</db:section>
<db:section xml:id="member-function-documentation">
<db:title>Member Function Documentation</db:title>
<db:section xml:id="QQuickRenderControl">
<db:title>[explicit] QQuickRenderControl::QQuickRenderControl(QObject *<db:emphasis>parent</db:emphasis> = Q_NULLPTR)</db:title>
<db:para>Constructs a <db:link xlink:href="qquickrendercontrol.xml">QQuickRenderControl</db:link> object, with parent object <db:code role="parameter">parent</db:code>.</db:para>
</db:section>
<db:section xml:id="dtor.QQuickRenderControl">
<db:title>[virtual noexcept] QQuickRenderControl::~QQuickRenderControl()</db:title>
<db:para>Destroys the instance. Releases all scenegraph resources.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qquickrendercontrol.xml#invalidate">invalidate</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="grab">
<db:title>QImage QQuickRenderControl::grab()</db:title>
<db:para>Grabs the contents of the scene and returns it as an image.</db:para>
<db:note>
<db:para>Requires the context to be current.</db:para>
</db:note>
</db:section>
<db:section xml:id="initialize">
<db:title>void QQuickRenderControl::initialize(QOpenGLContext *<db:emphasis>gl</db:emphasis>)</db:title>
<db:para>Initializes the scene graph resources. The context <db:code role="parameter">gl</db:code> has to be the current context.</db:para>
<db:note>
<db:para>Qt Quick does not take ownership of the context. It is up to the application to destroy it after a call to <db:link xlink:href="qquickrendercontrol.xml#invalidate">invalidate</db:link>() or after the <db:link xlink:href="qquickrendercontrol.xml">QQuickRenderControl</db:link> instance is destroyed.</db:para>
</db:note>
</db:section>
<db:section xml:id="invalidate">
<db:title>void QQuickRenderControl::invalidate()</db:title>
<db:para>Stop rendering and release resources. Requires a current context.</db:para>
<db:para>This is the equivalent of the cleanup operations that happen with a real <db:link xlink:href="qquickwindow.xml">QQuickWindow</db:link> when the window becomes hidden.</db:para>
<db:para>This function is called from the destructor. Therefore there will typically be no need to call it directly. Pay attention however to the fact that this requires the context, that was passed to <db:link xlink:href="qquickrendercontrol.xml#initialize">initialize</db:link>(), to be the current one at the time of destroying the <db:link xlink:href="qquickrendercontrol.xml">QQuickRenderControl</db:link> instance.</db:para>
<db:para>Once invalidate() has been called, it is possible to reuse the <db:link xlink:href="qquickrendercontrol.xml">QQuickRenderControl</db:link> instance by calling <db:link xlink:href="qquickrendercontrol.xml#initialize">initialize</db:link>() again.</db:para>
<db:note>
<db:para>This function does not take QQuickWindow::persistentSceneGraph() or QQuickWindow::persistentOpenGLContext() into account. This means that context-specific resources are always released.</db:para>
</db:note>
</db:section>
<db:section xml:id="polishItems">
<db:title>void QQuickRenderControl::polishItems()</db:title>
<db:para>This function should be called as late as possible before <db:link xlink:href="qquickrendercontrol.xml#sync">sync</db:link>(). In a threaded scenario, rendering can happen in parallel with this function.</db:para>
</db:section>
<db:section xml:id="prepareThread">
<db:title>void QQuickRenderControl::prepareThread(QThread *<db:emphasis>targetThread</db:emphasis>)</db:title>
<db:para>Prepares rendering the Qt Quick scene outside the gui thread.</db:para>
<db:para><db:code role="parameter">targetThread</db:code> specifies the thread on which synchronization and rendering will happen. There is no need to call this function in a single threaded scenario.</db:para>
</db:section>
<db:section xml:id="render">
<db:title>void QQuickRenderControl::render()</db:title>
<db:para>Renders the scenegraph using the current context.</db:para>
</db:section>
<db:section xml:id="renderRequested">
<db:title>void QQuickRenderControl::renderRequested()</db:title>
<db:para>This signal is emitted when the scene graph needs to be rendered. It is not necessary to call <db:link xlink:href="qquickrendercontrol.xml#sync">sync</db:link>().</db:para>
<db:note>
<db:para>Avoid triggering rendering directly when this signal is emitted. Instead, prefer deferring it by using a timer for example. This will lead to better performance.</db:para>
</db:note>
</db:section>
<db:section xml:id="renderWindow">
<db:title>[virtual] QWindow *QQuickRenderControl::renderWindow(QPoint *<db:emphasis>offset</db:emphasis>)</db:title>
<db:para>Reimplemented in subclasses to return the real window this render control is rendering into.</db:para>
<db:para>If <db:code role="parameter">offset</db:code> in non-null, it is set to the offset of the control inside the window.</db:para>
<db:note>
<db:para>While not mandatory, reimplementing this function becomes essential for supporting multiple screens with different device pixel ratios and properly positioning popup windows opened from QML. Therefore providing it in subclasses is highly recommended.</db:para>
</db:note>
</db:section>
<db:section xml:id="renderWindowFor">
<db:title>[static] QWindow *QQuickRenderControl::renderWindowFor(QQuickWindow *<db:emphasis>win</db:emphasis>, QPoint *<db:emphasis>offset</db:emphasis> = Q_NULLPTR)</db:title>
<db:para>Returns the real window that <db:code role="parameter">win</db:code> is being rendered to, if any.</db:para>
<db:para>If <db:code role="parameter">offset</db:code> in non-null, it is set to the offset of the rendering inside its window.</db:para>
</db:section>
<db:section xml:id="sceneChanged">
<db:title>void QQuickRenderControl::sceneChanged()</db:title>
<db:para>This signal is emitted when the scene graph is updated, meaning that <db:link xlink:href="qquickrendercontrol.xml#polishItems">polishItems</db:link>() and <db:link xlink:href="qquickrendercontrol.xml#sync">sync</db:link>() needs to be called. If <db:link xlink:href="qquickrendercontrol.xml#sync">sync</db:link>() returns true, then <db:link xlink:href="qquickrendercontrol.xml#render">render</db:link>() needs to be called.</db:para>
<db:note>
<db:para>Avoid triggering polishing, synchronization and rendering directly when this signal is emitted. Instead, prefer deferring it by using a timer for example. This will lead to better performance.</db:para>
</db:note>
</db:section>
<db:section xml:id="sync">
<db:title>bool QQuickRenderControl::sync()</db:title>
<db:para>This function is used to synchronize the QML scene with the rendering scene graph.</db:para>
<db:para>If a dedicated render thread is used, the GUI thread should be blocked for the duration of this call.</db:para>
<db:para>Returns <db:emphasis>true</db:emphasis> if the synchronization changed the scene graph.</db:para>
</db:section>
</db:section>
</db:article>
