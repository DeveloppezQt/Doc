<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en">
<db:info>
<db:title>QML Value Type and Sequence References</db:title>
<db:productname>QtQml</db:productname>
<db:edition>Qt 6.9.1 Reference Documentation</db:edition>
<db:titleabbrev>Qt Qml Reference Documentation</db:titleabbrev>
<db:abstract>
<db:para>Description of QML value type and sequence references.</db:para>
</db:abstract>
<db:pubdate>2025-06-29</db:pubdate>
<db:date>2025-06-29</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:para><db:link xlink:href="qtqml-typesystem-valuetypes.xml">QML Value Types</db:link> and <db:link xlink:href="qtqml-typesystem-sequencetypes.xml">QML Sequence Types</db:link> are necessarily passed by value. In contrast to <db:link xlink:href="qtqml-typesystem-objecttypes.xml">QML Object Types</db:link> they have no identity of themselves, but can only be accessed as properties of other objects or values, or as values returned from methods. Each such access implicitly creates a copy. Yet, in JavaScript everything is an object. There is no such concept as a value type in JavaScript. For example, if you execute font.bold = true in JavaScript, we expect the bold property of font to be set, no matter what font is. But consider the following code snippet:</db:para>
<db:programlisting language="qml">import QtQuick
Text {
    onSomethingHappened: font.bold = true
}
</db:programlisting>
<db:para>In this case we know that font is a value type. Accessing it creates a local copy by calling the getter of a <db:link xlink:href="qobject.xml#Q_PROPERTY">Q_PROPERTY</db:link>. We can then set the bold property on it, but that would usually only affect the copy, not the original <db:link xlink:href="qobject.xml#Q_PROPERTY">Q_PROPERTY</db:link>.</db:para>
<db:para>To overcome this problem, QML offers the concept of references. When you retrieve an instance of a value or sequence type from a property, the QML engine remembers the property along with the value itself. If the value is modified, it is written back to the property. This produces the illusion of an object with separate identity and makes the above case, along with many others, just work.</db:para>
<db:para>This can be rather expensive, though. If a sequence is exposed as a <db:link xlink:href="qobject.xml#Q_PROPERTY">Q_PROPERTY</db:link>, accessing any value in the sequence by index will cause the whole sequence data to be read from the property. From this sequence data, a single element is then retrieved. Similarly, modifying any value in the sequence causes the sequence data to be read. Then the modification is performed and the modified sequence is be written back to the property. A read operation can be relatively cheap if the type in question is implicitly shared. A modification always incurs at least one deep copy.</db:para>
<db:para>If you return an instance of a sequence or value type from a <db:link xlink:href="qobject.xml#Q_INVOKABLE">Q_INVOKABLE</db:link> function you avoid such overhead. Return values are not attached to any property and won't be written back.</db:para>
<db:para>Sequences of object types are passed as <db:link xlink:href="qqmllistproperty.xml">QQmlListProperty</db:link> by default. <db:link xlink:href="qqmllistproperty.xml">QQmlListProperty</db:link> is not an actual container, but only a view, or reference, to some sequential storage. Therefore, <db:link xlink:href="qqmllistproperty.xml">QQmlListProperty</db:link> is not affected by this effect. You can, however, register other sequence types for objects using <db:link xlink:href="qqmlintegration-h.xml#QML_SEQUENTIAL_CONTAINER">QML_SEQUENTIAL_CONTAINER</db:link>. Those will be affected.</db:para>
</db:article>
