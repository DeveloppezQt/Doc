<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en">
<db:info>
<db:title>QCborStreamWriter Class</db:title>
<db:productname>QtCore</db:productname>
<db:edition>Qt 6.7.2 Reference Documentation</db:edition>
<db:titleabbrev>Qt Core Reference Documentation</db:titleabbrev>
<db:abstract>
<db:para>The <db:link xlink:href="qcborstreamwriter.xml">QCborStreamWriter</db:link> class is a simple CBOR encoder operating on a one-way stream.</db:para>
<db:note>
<db:para>All functions in this class are <db:link xlink:href="threads-reentrancy.xml">reentrant</db:link>.</db:para>
</db:note>
</db:abstract>
<db:pubdate>2024-12-27</db:pubdate>
<db:date>2024-12-27</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:variablelist>
<db:varlistentry>
<db:term>Header</db:term>
<db:listitem>
<db:para>QCborStreamWriter</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>CMake</db:term>
<db:listitem>
<db:para>find_package(Qt6 REQUIRED COMPONENTS Core)</db:para>
<db:para>target_link_libraries(mytarget PRIVATE Qt6::Core)</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>qmake</db:term>
<db:listitem>
<db:para>QT += core</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Group</db:term>
<db:listitem>
<db:para>QCborStreamWriter is part of <db:simplelist><db:member><db:link xlink:href="cbor.xml">CBOR Support in Qt</db:link></db:member><db:member>qtserialization</db:member></db:simplelist></db:para>
</db:listitem>
</db:varlistentry>
</db:variablelist>
<db:section xml:id="details">
<db:title>Detailed Description</db:title>
<db:para>This class can be used to quickly encode a stream of CBOR content directly to either a <db:link xlink:href="qbytearray.xml">QByteArray</db:link> or <db:link xlink:href="qiodevice.xml">QIODevice</db:link>. CBOR is the Concise Binary Object Representation, a very compact form of binary data encoding that is compatible with JSON. It was created by the IETF Constrained RESTful Environments (CoRE) WG, which has used it in many new RFCs. It is meant to be used alongside the <db:link xlink:href="https://datatracker.ietf.org/doc/html/rfc7252">CoAP protocol</db:link>.</db:para>
<db:para><db:link xlink:href="qcborstreamwriter.xml">QCborStreamWriter</db:link> provides a StAX-like API, similar to that of <db:link xlink:href="qxmlstreamwriter.xml">QXmlStreamWriter</db:link>. It is rather low-level and requires a bit of knowledge of CBOR encoding. For a simpler API, see <db:link xlink:href="qcborvalue.xml">QCborValue</db:link> and especially the encoding function <db:link xlink:href="qcborvalue.xml#toCbor">QCborValue::toCbor</db:link>().</db:para>
<db:para>The typical use of <db:link xlink:href="qcborstreamwriter.xml">QCborStreamWriter</db:link> is to create the object on the target <db:link xlink:href="qbytearray.xml">QByteArray</db:link> or <db:link xlink:href="qiodevice.xml">QIODevice</db:link>, then call one of the <db:link xlink:href="qcborstreamwriter.xml#append">append</db:link>() overloads with the desired type to be encoded. To create arrays and maps, <db:link xlink:href="qcborstreamwriter.xml">QCborStreamWriter</db:link> provides <db:link xlink:href="qcborstreamwriter.xml#startArray">startArray</db:link>() and <db:link xlink:href="qcborstreamwriter.xml#startMap">startMap</db:link>() overloads, which must be terminated by the corresponding <db:link xlink:href="qcborstreamwriter.xml#endArray">endArray</db:link>() and <db:link xlink:href="qcborstreamwriter.xml#endMap">endMap</db:link>() functions.</db:para>
<db:para>The following example encodes the equivalent of this JSON content:</db:para>
<db:para>{ &quot;label&quot;: &quot;journald&quot;, &quot;autoDetect&quot;: false, &quot;condition&quot;: &quot;libs.journald&quot;, &quot;output&quot;: [ &quot;privateFeature&quot; ] }</db:para>
<db:programlisting language="cpp">   writer.startMap(4);    // 4 elements in the map

   writer.append(&quot;label&quot;_L1);
   writer.append(&quot;journald&quot;_L1);

   writer.append(&quot;autoDetect&quot;_L1);
   writer.append(false);

   writer.append(&quot;condition&quot;_L1);
   writer.append(&quot;libs.journald&quot;_L1);

   writer.append(&quot;output&quot;_L1);
   writer.startArray(1);
   writer.append(&quot;privateFeature&quot;_L1);
   writer.endArray();

   writer.endMap();
</db:programlisting>
<db:section xml:id="cbor-support">
<db:title>CBOR support</db:title>
<db:para><db:link xlink:href="qcborstreamwriter.xml">QCborStreamWriter</db:link> supports all CBOR features required to create canonical and strict streams. It implements almost all of the features specified in <db:link xlink:href="https://datatracker.ietf.org/doc/html/rfc7049">RFC 7049</db:link>.</db:para>
<db:para>The following table lists the CBOR features that <db:link xlink:href="qcborstreamwriter.xml">QCborStreamWriter</db:link> supports.</db:para>
<db:informaltable style="generic">
<db:thead>
<db:tr>
<db:th>
<db:para>Feature</db:para>
</db:th>
<db:th>
<db:para>Support</db:para>
</db:th>
</db:tr>
</db:thead>
<db:tr valign="top">
<db:td>
<db:para>Unsigned numbers</db:para>
</db:td>
<db:td>
<db:para>Yes (full range)</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>Negative numbers</db:para>
</db:td>
<db:td>
<db:para>Yes (full range)</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>Byte strings</db:para>
</db:td>
<db:td>
<db:para>Yes</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>Text strings</db:para>
</db:td>
<db:td>
<db:para>Yes</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>Chunked strings</db:para>
</db:td>
<db:td>
<db:para>No</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>Tags</db:para>
</db:td>
<db:td>
<db:para>Yes (arbitrary)</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>Booleans</db:para>
</db:td>
<db:td>
<db:para>Yes</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>Null</db:para>
</db:td>
<db:td>
<db:para>Yes</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>Undefined</db:para>
</db:td>
<db:td>
<db:para>Yes</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>Arbitrary simple values</db:para>
</db:td>
<db:td>
<db:para>Yes</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>Half-precision float (16-bit)</db:para>
</db:td>
<db:td>
<db:para>Yes</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>Single-precision float (32-bit)</db:para>
</db:td>
<db:td>
<db:para>Yes</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>Double-precision float (64-bit)</db:para>
</db:td>
<db:td>
<db:para>Yes</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>Infinities and NaN floating point</db:para>
</db:td>
<db:td>
<db:para>Yes</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>Determinate-length arrays and maps</db:para>
</db:td>
<db:td>
<db:para>Yes</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>Indeterminate-length arrays and maps</db:para>
</db:td>
<db:td>
<db:para>Yes</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>Map key types other than strings and integers</db:para>
</db:td>
<db:td>
<db:para>Yes (arbitrary)</db:para>
</db:td>
</db:tr>
</db:informaltable>
<db:section xml:id="canonical-cbor-encoding">
<db:title>Canonical CBOR encoding</db:title>
<db:para>Canonical CBOR encoding is defined by <db:link xlink:href="https://datatracker.ietf.org/doc/html/rfc7049#section-3.9">Section 3.9 of RFC 7049</db:link>. Canonical encoding is not a requirement for Qt's CBOR decoding functionality, but it may be required for some protocols. In particular, protocols that require the ability to reproduce the same stream identically may require this.</db:para>
<db:para>In order to be considered &quot;canonical&quot;, a CBOR stream must meet the following requirements:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para>Integers must be as small as possible. <db:link xlink:href="qcborstreamwriter.xml">QCborStreamWriter</db:link> always does this (no user action is required and it is not possible to write overlong integers).</db:para>
</db:listitem>
<db:listitem>
<db:para>Array, map and string lengths must be as short as possible. As above, <db:link xlink:href="qcborstreamwriter.xml">QCborStreamWriter</db:link> automatically does this.</db:para>
</db:listitem>
<db:listitem>
<db:para>Arrays, maps and strings must use explicit length. <db:link xlink:href="qcborstreamwriter.xml">QCborStreamWriter</db:link> always does this for strings; for arrays and maps, be sure to call <db:link xlink:href="qcborstreamwriter.xml#startArray">startArray</db:link>() and <db:link xlink:href="qcborstreamwriter.xml#startMap">startMap</db:link>() overloads with explicit length.</db:para>
</db:listitem>
<db:listitem>
<db:para>Keys in every map must be sorted in ascending order. <db:link xlink:href="qcborstreamwriter.xml">QCborStreamWriter</db:link> offers no help in this item: the developer must ensure that before calling <db:link xlink:href="qcborstreamwriter.xml#append">append</db:link>() for the map pairs.</db:para>
</db:listitem>
<db:listitem>
<db:para>Floating point values should be as small as possible. <db:link xlink:href="qcborstreamwriter.xml">QCborStreamWriter</db:link> will not convert floating point values; it is up to the developer to perform this check prior to calling <db:link xlink:href="qcborstreamwriter.xml#append">append</db:link>() (see those functions' examples).</db:para>
</db:listitem>
</db:itemizedlist>
</db:section>
<db:section xml:id="strict-cbor-mode">
<db:title>Strict CBOR mode</db:title>
<db:para>Strict mode is defined by <db:link xlink:href="https://datatracker.ietf.org/doc/html/rfc7049#section-3.10">Section 3.10 of RFC 7049</db:link>. As for Canonical encoding above, <db:link xlink:href="qcborstreamwriter.xml">QCborStreamWriter</db:link> makes it possible to create strict CBOR streams, but does not require them or validate that the output is so.</db:para>
<db:itemizedlist>
<db:listitem>
<db:para>Keys in a map must be unique. <db:link xlink:href="qcborstreamwriter.xml">QCborStreamWriter</db:link> performs no validation of map keys.</db:para>
</db:listitem>
<db:listitem>
<db:para>Tags may be required to be paired only with the correct types, according to their specification. <db:link xlink:href="qcborstreamwriter.xml">QCborStreamWriter</db:link> performs no validation of tag usage.</db:para>
</db:listitem>
<db:listitem>
<db:para>Text Strings must be properly-encoded UTF-8. <db:link xlink:href="qcborstreamwriter.xml">QCborStreamWriter</db:link> always writes proper UTF-8 for strings added with <db:link xlink:href="qcborstreamwriter.xml#append">append</db:link>(), but performs no validation for strings added with <db:link xlink:href="qcborstreamwriter.xml#appendTextString">appendTextString</db:link>().</db:para>
</db:listitem>
</db:itemizedlist>
</db:section>
<db:section xml:id="invalid-cbor-stream">
<db:title>Invalid CBOR stream</db:title>
<db:para>It is also possible to misuse <db:link xlink:href="qcborstreamwriter.xml">QCborStreamWriter</db:link> and produce invalid CBOR streams that will fail to be decoded by a receiver. The following actions will produce invalid streams:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para>Append a tag and not append the corresponding tagged value (<db:link xlink:href="qcborstreamwriter.xml">QCborStreamWriter</db:link> produces no diagnostic).</db:para>
</db:listitem>
<db:listitem>
<db:para>Append too many or too few items to an array or map with explicit length (<db:link xlink:href="qcborstreamwriter.xml#endMap">endMap</db:link>() and <db:link xlink:href="qcborstreamwriter.xml#endArray">endArray</db:link>() will return false and <db:link xlink:href="qcborstreamwriter.xml">QCborStreamWriter</db:link> will log with <db:link xlink:href="qtlogging.xml#qWarning">qWarning</db:link>()).</db:para>
</db:listitem>
</db:itemizedlist>
<db:para>{Parsing and displaying CBOR data}, {Serialization Converter}, {Saving and Loading a Game}</db:para>
</db:section>
</db:section>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qcborstreamreader.xml">QCborStreamReader</db:link></db:member>
<db:member><db:link xlink:href="qcborvalue.xml">QCborValue</db:link></db:member>
<db:member><db:link xlink:href="qxmlstreamwriter.xml">QXmlStreamWriter</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="member-function-documentation">
<db:title>Member Function Documentation</db:title>
<db:section xml:id="QCborStreamWriter">
<db:title>[explicit] QCborStreamWriter::QCborStreamWriter(QIODevice *<db:emphasis>device</db:emphasis>)</db:title>
<db:constructorsynopsis>
<db:methodname>QCborStreamWriter</db:methodname>
<db:methodparam>
<db:type>QIODevice *</db:type>
<db:parameter>device</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">constructor</db:synopsisinfo>
<db:synopsisinfo role="signature">QCborStreamWriter(QIODevice *device)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:constructorsynopsis>
<db:para>Creates a <db:link xlink:href="qcborstreamwriter.xml">QCborStreamWriter</db:link> object that will write the stream to <db:code role="parameter">device</db:code>. The device must be opened before the first <db:link xlink:href="qcborstreamwriter.xml#append">append</db:link>() call is made. This constructor can be used with any class that derives from <db:link xlink:href="qiodevice.xml">QIODevice</db:link>, such as <db:link xlink:href="qfile.xml">QFile</db:link>, <db:link xlink:href="qprocess.xml">QProcess</db:link> or <db:link xlink:href="qtcpsocket.xml">QTcpSocket</db:link>.</db:para>
<db:para><db:link xlink:href="qcborstreamwriter.xml">QCborStreamWriter</db:link> has no buffering, so every <db:link xlink:href="qcborstreamwriter.xml#append">append</db:link>() call will result in one or more calls to the device's <db:link xlink:href="qiodevice.xml#write">write</db:link>() method.</db:para>
<db:para>The following example writes an empty map to a file:</db:para>
<db:programlisting language="cpp">   QFile f(&quot;output&quot;, QIODevice::WriteOnly);
   QCborStreamWriter writer(&amp;amp;f);
   writer.startMap(0);
   writer.endMap();
</db:programlisting>
<db:para><db:link xlink:href="qcborstreamwriter.xml">QCborStreamWriter</db:link> does not take ownership of <db:code role="parameter">device</db:code>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qcborstreamwriter.xml#device">device</db:link>()</db:member>
<db:member><db:link xlink:href="qcborstreamwriter.xml#setDevice">setDevice</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="QCborStreamWriter-1">
<db:title>[explicit] QCborStreamWriter::QCborStreamWriter(QByteArray *<db:emphasis>data</db:emphasis>)</db:title>
<db:constructorsynopsis>
<db:methodname>QCborStreamWriter</db:methodname>
<db:methodparam>
<db:type>QByteArray *</db:type>
<db:parameter>data</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">constructor</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">QCborStreamWriter(QByteArray *data)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:constructorsynopsis>
<db:para>Creates a <db:link xlink:href="qcborstreamwriter.xml">QCborStreamWriter</db:link> object that will append the stream to <db:code role="parameter">data</db:code>. All streaming is done immediately to the byte array, without the need for flushing any buffers.</db:para>
<db:para>The following example writes a number to a byte array then returns it.</db:para>
<db:programlisting language="cpp">   QByteArray encodedNumber(qint64 value)
   {
       QByteArray ba;
       QCborStreamWriter writer(&amp;amp;ba);
       writer.append(value);
       return ba;
   }
</db:programlisting>
<db:para><db:link xlink:href="qcborstreamwriter.xml">QCborStreamWriter</db:link> does not take ownership of <db:code role="parameter">data</db:code>.</db:para>
</db:section>
<db:section xml:id="dtor.QCborStreamWriter">
<db:title>QCborStreamWriter::~QCborStreamWriter()</db:title>
<db:destructorsynopsis>
<db:methodname>~QCborStreamWriter</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">destructor</db:synopsisinfo>
<db:synopsisinfo role="signature">~QCborStreamWriter()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:destructorsynopsis>
<db:para>Destroys this <db:link xlink:href="qcborstreamwriter.xml">QCborStreamWriter</db:link> object and frees any resources associated.</db:para>
<db:para><db:link xlink:href="qcborstreamwriter.xml">QCborStreamWriter</db:link> does not perform error checking to see if all required items were written to the stream prior to the object being destroyed. It is the programmer's responsibility to ensure that it was done.</db:para>
</db:section>
<db:section xml:id="append">
<db:title>void QCborStreamWriter::append(quint64 <db:emphasis>u</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>append</db:methodname>
<db:methodparam>
<db:type>quint64</db:type>
<db:parameter>u</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void append(quint64 u)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>Appends the 64-bit unsigned value <db:code role="parameter">u</db:code> to the CBOR stream, creating a CBOR Unsigned Integer value. In the following example, we write the values 0, 2<db:superscript>32</db:superscript> and UINT64_MAX:</db:para>
<db:programlisting language="cpp">   writer.append(0U);
   writer.append(Q_UINT64_C(4294967296));
   writer.append(std::numeric_limits&amp;lt;quint64&amp;gt;::max());
</db:programlisting>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qcborstreamreader.xml#isUnsignedInteger">QCborStreamReader::isUnsignedInteger</db:link>()</db:member>
<db:member><db:link xlink:href="qcborstreamreader.xml#toUnsignedInteger">QCborStreamReader::toUnsignedInteger</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="append-1">
<db:title>void QCborStreamWriter::append(qint64 <db:emphasis>i</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>append</db:methodname>
<db:methodparam>
<db:type>qint64</db:type>
<db:parameter>i</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">void append(qint64 i)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>Appends the 64-bit signed value <db:code role="parameter">i</db:code> to the CBOR stream. This will create either a CBOR Unsigned Integer or CBOR NegativeInteger value based on the sign of the parameter. In the following example, we write the values 0, -1, 2<db:superscript>32</db:superscript> and INT64_MAX:</db:para>
<db:programlisting language="cpp">   writer.append(0);
   writer.append(-1);
   writer.append(Q_INT64_C(4294967296));
   writer.append(std::numeric_limits&amp;lt;qint64&amp;gt;::max());
</db:programlisting>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qcborstreamreader.xml#isInteger">QCborStreamReader::isInteger</db:link>()</db:member>
<db:member><db:link xlink:href="qcborstreamreader.xml#toInteger">QCborStreamReader::toInteger</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="append-2">
<db:title>void QCborStreamWriter::append(QCborNegativeInteger <db:emphasis>n</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>append</db:methodname>
<db:methodparam>
<db:type>QCborNegativeInteger</db:type>
<db:parameter>n</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">2</db:synopsisinfo>
<db:synopsisinfo role="signature">void append(QCborNegativeInteger n)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>Appends the 64-bit negative value <db:code role="parameter">n</db:code> to the CBOR stream. QCborNegativeInteger is a 64-bit enum that holds the absolute value of the negative number we want to write. If n is zero, the value written will be equivalent to 2<db:superscript>64</db:superscript> (that is, -18,446,744,073,709,551,616).</db:para>
<db:para>In the following example, we write the values -1, -2<db:superscript>32</db:superscript> and INT64_MIN:</db:para>
<db:programlisting language="cpp">   writer.append(QCborNegativeInteger(1));
   writer.append(QCborNegativeInteger(Q_INT64_C(4294967296)));
   writer.append(QCborNegativeInteger(-quint64(std::numeric_limits&amp;lt;qint64&amp;gt;::min())));
</db:programlisting>
<db:para>Note how this function can be used to encode numbers that cannot fit a standard computer's 64-bit signed integer like <db:link xlink:href="qttypes.xml#qint64-typedef">qint64</db:link>. That is, if <db:code role="parameter">n</db:code> is larger than std::numeric_limits&lt;qint64&gt;::max() or is 0, this will represent a negative number smaller than std::numeric_limits&lt;qint64&gt;::min().</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qcborstreamreader.xml#isNegativeInteger">QCborStreamReader::isNegativeInteger</db:link>()</db:member>
<db:member><db:link xlink:href="qcborstreamreader.xml#toNegativeInteger">QCborStreamReader::toNegativeInteger</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="append-3">
<db:title>void QCborStreamWriter::append(const QByteArray &amp;<db:emphasis>ba</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>append</db:methodname>
<db:methodparam>
<db:type>const QByteArray &amp;</db:type>
<db:parameter>ba</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">3</db:synopsisinfo>
<db:synopsisinfo role="signature">void append(const QByteArray &amp;ba)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>Appends the byte array <db:code role="parameter">ba</db:code> to the stream, creating a CBOR Byte String value. <db:link xlink:href="qcborstreamwriter.xml">QCborStreamWriter</db:link> will attempt to write the entire string in one chunk.</db:para>
<db:para>The following example will load and append the contents of a file to the stream:</db:para>
<db:programlisting language="cpp">   void writeFile(QCborStreamWriter &amp;amp;writer, const QString &amp;amp;fileName)
   {
       QFile f(fileName);
       if (f.open(QIODevice::ReadOnly))
           writer.append(f.readAll());
   }
</db:programlisting>
<db:para>As the example shows, unlike JSON, CBOR requires no escaping for binary content.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qcborstreamwriter.xml#appendByteString">appendByteString</db:link>()</db:member>
<db:member><db:link xlink:href="qcborstreamreader.xml#isByteArray">QCborStreamReader::isByteArray</db:link>()</db:member>
<db:member><db:link xlink:href="qcborstreamreader.xml#readByteArray">QCborStreamReader::readByteArray</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="append-4">
<db:title>void QCborStreamWriter::append(QLatin1StringView <db:emphasis>str</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>append</db:methodname>
<db:methodparam>
<db:type>QLatin1StringView</db:type>
<db:parameter>str</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">4</db:synopsisinfo>
<db:synopsisinfo role="signature">void append(QLatin1StringView str)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>Appends the Latin-1 string viewed by <db:code role="parameter">str</db:code> to the stream, creating a CBOR Text String value. <db:link xlink:href="qcborstreamwriter.xml">QCborStreamWriter</db:link> will attempt to write the entire string in one chunk.</db:para>
<db:para>The following example appends a simple Latin-1 string literal to the stream:</db:para>
<db:programlisting language="cpp">   writer.append(&quot;Hello, World&quot;_L1);
</db:programlisting>
<db:para><db:emphasis role="bold">Performance note</db:emphasis>: CBOR requires that all Text Strings be encoded in UTF-8, so this function will iterate over the characters in the string to determine whether the contents are US-ASCII or not. If the string is found to contain characters outside of US-ASCII, it will allocate memory and convert to UTF-8. If this check is unnecessary, use <db:link xlink:href="qcborstreamwriter.xml#appendTextString">appendTextString</db:link>() instead.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qcborstreamreader.xml#isString">QCborStreamReader::isString</db:link>()</db:member>
<db:member><db:link xlink:href="qcborstreamreader.xml#readString">QCborStreamReader::readString</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="append-5">
<db:title>void QCborStreamWriter::append(QStringView <db:emphasis>str</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>append</db:methodname>
<db:methodparam>
<db:type>QStringView</db:type>
<db:parameter>str</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">5</db:synopsisinfo>
<db:synopsisinfo role="signature">void append(QStringView str)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>Appends the text string <db:code role="parameter">str</db:code> to the stream, creating a CBOR Text String value. <db:link xlink:href="qcborstreamwriter.xml">QCborStreamWriter</db:link> will attempt to write the entire string in one chunk.</db:para>
<db:para>The following example writes an arbitrary <db:link xlink:href="qstring.xml">QString</db:link> to the stream:</db:para>
<db:programlisting language="cpp">   void writeString(QCborStreamWriter &amp;amp;writer, const QString &amp;amp;str)
   {
       writer.append(str);
   }
</db:programlisting>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qcborstreamreader.xml#isString">QCborStreamReader::isString</db:link>()</db:member>
<db:member><db:link xlink:href="qcborstreamreader.xml#readString">QCborStreamReader::readString</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="append-6">
<db:title>void QCborStreamWriter::append(QCborTag <db:emphasis>tag</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>append</db:methodname>
<db:methodparam>
<db:type>QCborTag</db:type>
<db:parameter>tag</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">6</db:synopsisinfo>
<db:synopsisinfo role="signature">void append(QCborTag tag)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>Appends the CBOR tag <db:code role="parameter">tag</db:code> to the stream, creating a CBOR Tag value. All tags must be followed by another type which they provide meaning for.</db:para>
<db:para>In the following example, we append a CBOR Tag 36 (Regular Expression) and a <db:link xlink:href="qregularexpression.xml">QRegularExpression</db:link>'s pattern to the stream:</db:para>
<db:programlisting language="cpp">   void writeRxPattern(QCborStreamWriter &amp;amp;writer, const QRegularExpression &amp;amp;rx)
   {
       writer.append(QCborTag(36));
       writer.append(rx.pattern());
   }
</db:programlisting>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qcborstreamreader.xml#isTag">QCborStreamReader::isTag</db:link>()</db:member>
<db:member><db:link xlink:href="qcborstreamreader.xml#toTag">QCborStreamReader::toTag</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="append-7">
<db:title>void QCborStreamWriter::append(QCborKnownTags <db:emphasis>tag</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>append</db:methodname>
<db:methodparam>
<db:type>QCborKnownTags</db:type>
<db:parameter>tag</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">7</db:synopsisinfo>
<db:synopsisinfo role="signature">void append(QCborKnownTags tag)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>Appends the CBOR tag <db:code role="parameter">tag</db:code> to the stream, creating a CBOR Tag value. All tags must be followed by another type which they provide meaning for.</db:para>
<db:para>In the following example, we append a CBOR Tag 1 (Unix time_t) and an integer representing the current time to the stream, obtained using the time() function:</db:para>
<db:programlisting language="cpp">   void writeCurrentTime(QCborStreamWriter &amp;amp;writer)
   {
       writer.append(QCborKnownTags::UnixTime_t);
       writer.append(time(nullptr));
   }
</db:programlisting>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qcborstreamreader.xml#isTag">QCborStreamReader::isTag</db:link>()</db:member>
<db:member><db:link xlink:href="qcborstreamreader.xml#toTag">QCborStreamReader::toTag</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="append-8">
<db:title>void QCborStreamWriter::append(QCborSimpleType <db:emphasis>st</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>append</db:methodname>
<db:methodparam>
<db:type>QCborSimpleType</db:type>
<db:parameter>st</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">8</db:synopsisinfo>
<db:synopsisinfo role="signature">void append(QCborSimpleType st)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>Appends the CBOR simple type <db:code role="parameter">st</db:code> to the stream, creating a CBOR Simple Type value. In the following example, we write the simple type for Null as well as for type 32, which Qt has no support for.</db:para>
<db:programlisting language="cpp">  writer.append(QCborSimpleType::Null);
  writer.append(QCborSimpleType(32));
</db:programlisting>
<db:note>
<db:para>Using Simple Types for which there is no specification can lead to validation errors by the remote receiver. In addition, simple type values 24 through 31 (inclusive) are reserved and must not be used.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qcborstreamreader.xml#isSimpleType">QCborStreamReader::isSimpleType</db:link>()</db:member>
<db:member><db:link xlink:href="qcborstreamreader.xml#toSimpleType">QCborStreamReader::toSimpleType</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="append-9">
<db:title>void QCborStreamWriter::append(<db:emphasis>std::nullptr_t</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>append</db:methodname>
<db:methodparam>
<db:type>std::nullptr_t</db:type>
<db:parameter></db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">9</db:synopsisinfo>
<db:synopsisinfo role="signature">void append(std::nullptr_t)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>Appends a CBOR Null value to the stream. This function is equivalent to (and implemented as): The parameter is ignored.</db:para>
<db:programlisting language="cpp">   writer.append(QCborSimpleType::Null);
</db:programlisting>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qcborstreamwriter.xml#appendNull">appendNull</db:link>()</db:member>
<db:member><db:link xlink:href="qcborstreamwriter.xml#append-8">append</db:link>(QCborSimpleType)</db:member>
<db:member><db:link xlink:href="qcborstreamreader.xml#isNull">QCborStreamReader::isNull</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="append-10">
<db:title>void QCborStreamWriter::append(qfloat16 <db:emphasis>f</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>append</db:methodname>
<db:methodparam>
<db:type>qfloat16</db:type>
<db:parameter>f</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">10</db:synopsisinfo>
<db:synopsisinfo role="signature">void append(qfloat16 f)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>Appends the floating point number <db:code role="parameter">f</db:code> to the stream, creating a CBOR 16-bit Half-Precision Floating Point value. The following code can be used to convert a C++ <db:code>float</db:code> to qfloat16 if there's no loss of precision and append it, or instead append the <db:code>float</db:code>.</db:para>
<db:programlisting language="cpp">   void writeFloat(QCborStreamWriter &amp;amp;writer, float f)
   {
       qfloat16 f16 = f;
       if (qIsNaN(f) || f16 == f)
           writer.append(f16);
       else
           writer.append(f);
   }
</db:programlisting>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qcborstreamreader.xml#isFloat16">QCborStreamReader::isFloat16</db:link>()</db:member>
<db:member><db:link xlink:href="qcborstreamreader.xml#toFloat16">QCborStreamReader::toFloat16</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="append-11">
<db:title>void QCborStreamWriter::append(float <db:emphasis>f</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>append</db:methodname>
<db:methodparam>
<db:type>float</db:type>
<db:parameter>f</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">11</db:synopsisinfo>
<db:synopsisinfo role="signature">void append(float f)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>Appends the floating point number <db:code role="parameter">f</db:code> to the stream, creating a CBOR 32-bit Single-Precision Floating Point value. The following code can be used to convert a C++ <db:code>double</db:code> to <db:code>float</db:code> if there's no loss of precision and append it, or instead append the <db:code>double</db:code>.</db:para>
<db:programlisting language="cpp">   void writeFloat(QCborStreamWriter &amp;amp;writer, double d)
   {
       float f = d;
       if (qIsNaN(d) || d == f)
           writer.append(f);
       else
           writer.append(d);
   }
</db:programlisting>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qcborstreamreader.xml#isFloat">QCborStreamReader::isFloat</db:link>()</db:member>
<db:member><db:link xlink:href="qcborstreamreader.xml#toFloat">QCborStreamReader::toFloat</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="append-12">
<db:title>void QCborStreamWriter::append(double <db:emphasis>d</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>append</db:methodname>
<db:methodparam>
<db:type>double</db:type>
<db:parameter>d</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">12</db:synopsisinfo>
<db:synopsisinfo role="signature">void append(double d)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>Appends the floating point number <db:code role="parameter">d</db:code> to the stream, creating a CBOR 64-bit Double-Precision Floating Point value. <db:link xlink:href="qcborstreamwriter.xml">QCborStreamWriter</db:link> always appends the number as-is, performing no check for whether the number is the canonical form for NaN, an infinite, whether it is denormal or if it could be written with a shorter format.</db:para>
<db:para>The following code performs all those checks, except for the denormal one, which is expected to be taken into account by the system FPU or floating point emulation directly.</db:para>
<db:programlisting language="cpp">   void writeDouble(QCborStreamWriter &amp;amp;writer, double d)
   {
       float f;
       if (qIsNaN(d)) {
           writer.append(qfloat16(qQNaN()));
       } else if (qIsInf(d)) {
           writer.append(d &amp;lt; 0 ? -qInf() : qInf());
       } else if ((f = d) == d) {
           qfloat16 f16 = f;
           if (f16 == f)
               writer.append(f16);
           else
               writer.append(f);
       } else {
           writer.append(d);
       }
   }
</db:programlisting>
<db:para>Determining if a double can be converted to an integral with no loss of precision is left as an exercise to the reader.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qcborstreamreader.xml#isDouble">QCborStreamReader::isDouble</db:link>()</db:member>
<db:member><db:link xlink:href="qcborstreamreader.xml#toDouble">QCborStreamReader::toDouble</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="append-13">
<db:title>void QCborStreamWriter::append(bool <db:emphasis>b</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>append</db:methodname>
<db:methodparam>
<db:type>bool</db:type>
<db:parameter>b</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">13</db:synopsisinfo>
<db:synopsisinfo role="signature">void append(bool b)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>Appends the boolean value <db:code role="parameter">b</db:code> to the stream, creating either a CBOR False value or a CBOR True value. This function is equivalent to (and implemented as):</db:para>
<db:programlisting language="cpp">   writer.append(b ? QCborSimpleType::True : QCborSimpleType::False);
</db:programlisting>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qcborstreamwriter.xml#appendNull">appendNull</db:link>()</db:member>
<db:member><db:link xlink:href="qcborstreamwriter.xml#appendUndefined">appendUndefined</db:link>()</db:member>
<db:member><db:link xlink:href="qcborstreamreader.xml#isBool">QCborStreamReader::isBool</db:link>()</db:member>
<db:member><db:link xlink:href="qcborstreamreader.xml#toBool">QCborStreamReader::toBool</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="append-14">
<db:title>void QCborStreamWriter::append(const char *<db:emphasis>str</db:emphasis>, qsizetype <db:emphasis>size</db:emphasis> = -1)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>append</db:methodname>
<db:methodparam>
<db:type>const char *</db:type>
<db:parameter>str</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>qsizetype</db:type>
<db:parameter>size</db:parameter>
<db:initializer>-1</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">14</db:synopsisinfo>
<db:synopsisinfo role="signature">void append(const char *str, qsizetype size)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>Appends <db:code role="parameter">size</db:code> bytes of text starting from <db:code role="parameter">str</db:code> to the stream, creating a CBOR Text String value. <db:link xlink:href="qcborstreamwriter.xml">QCborStreamWriter</db:link> will attempt to write the entire string in one chunk. If <db:code role="parameter">size</db:code> is -1, this function will write strlen(\a str) bytes.</db:para>
<db:para>The string pointed to by <db:code role="parameter">str</db:code> is expected to be properly encoded UTF-8. <db:link xlink:href="qcborstreamwriter.xml">QCborStreamWriter</db:link> performs no validation that this is the case.</db:para>
<db:para>Unlike the <db:link xlink:href="qlatin1stringview.xml">QLatin1StringView</db:link> overload of <db:link xlink:href="qcborstreamwriter.xml#append">append</db:link>(), this function is not limited to 2 GB. However, note that neither <db:link xlink:href="qcborstreamreader.xml">QCborStreamReader</db:link> nor <db:link xlink:href="qcborvalue.xml">QCborValue</db:link> support reading CBOR streams with text strings larger than 2 GB.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qcborstreamwriter.xml#append-4">append</db:link>(QLatin1StringView)</db:member>
<db:member><db:link xlink:href="qcborstreamwriter.xml#append-5">append</db:link>(QStringView)</db:member>
<db:member><db:link xlink:href="qcborstreamreader.xml#isString">QCborStreamReader::isString</db:link>()</db:member>
<db:member><db:link xlink:href="qcborstreamreader.xml#readString">QCborStreamReader::readString</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="appendByteString">
<db:title>void QCborStreamWriter::appendByteString(const char *<db:emphasis>data</db:emphasis>, qsizetype <db:emphasis>len</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>appendByteString</db:methodname>
<db:methodparam>
<db:type>const char *</db:type>
<db:parameter>data</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>qsizetype</db:type>
<db:parameter>len</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void appendByteString(const char *data, qsizetype len)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Appends <db:code role="parameter">len</db:code> bytes of data starting from <db:code role="parameter">data</db:code> to the stream, creating a CBOR Byte String value. <db:link xlink:href="qcborstreamwriter.xml">QCborStreamWriter</db:link> will attempt to write the entire string in one chunk.</db:para>
<db:para>Unlike the <db:link xlink:href="qbytearray.xml">QByteArray</db:link> overload of <db:link xlink:href="qcborstreamwriter.xml#append">append</db:link>(), this function is not limited by <db:link xlink:href="qbytearray.xml">QByteArray</db:link>'s size limits. However, note that neither <db:link xlink:href="qcborstreamreader.xml#readByteArray">QCborStreamReader::readByteArray</db:link>() nor <db:link xlink:href="qcborvalue.xml">QCborValue</db:link> support reading CBOR streams with byte arrays larger than 2 GB.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qcborstreamwriter.xml#append">append</db:link>()</db:member>
<db:member><db:link xlink:href="qcborstreamwriter.xml#appendTextString">appendTextString</db:link>()</db:member>
<db:member><db:link xlink:href="qcborstreamreader.xml#isByteArray">QCborStreamReader::isByteArray</db:link>()</db:member>
<db:member><db:link xlink:href="qcborstreamreader.xml#readByteArray">QCborStreamReader::readByteArray</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="appendNull">
<db:title>void QCborStreamWriter::appendNull()</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>appendNull</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void appendNull()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Appends a CBOR Null value to the stream. This function is equivalent to (and implemented as):</db:para>
<db:programlisting language="cpp">   writer.append(QCborSimpleType::Null);
</db:programlisting>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qcborstreamwriter.xml#append-9">append</db:link>(std::nullptr_t)</db:member>
<db:member><db:link xlink:href="qcborstreamwriter.xml#append-8">append</db:link>(QCborSimpleType)</db:member>
<db:member><db:link xlink:href="qcborstreamreader.xml#isNull">QCborStreamReader::isNull</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="appendTextString">
<db:title>void QCborStreamWriter::appendTextString(const char *<db:emphasis>utf8</db:emphasis>, qsizetype <db:emphasis>len</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>appendTextString</db:methodname>
<db:methodparam>
<db:type>const char *</db:type>
<db:parameter>utf8</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>qsizetype</db:type>
<db:parameter>len</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void appendTextString(const char *utf8, qsizetype len)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Appends <db:code role="parameter">len</db:code> bytes of text starting from <db:code role="parameter">utf8</db:code> to the stream, creating a CBOR Text String value. <db:link xlink:href="qcborstreamwriter.xml">QCborStreamWriter</db:link> will attempt to write the entire string in one chunk.</db:para>
<db:para>The string pointed to by <db:code role="parameter">utf8</db:code> is expected to be properly encoded UTF-8. <db:link xlink:href="qcborstreamwriter.xml">QCborStreamWriter</db:link> performs no validation that this is the case.</db:para>
<db:para>Unlike the <db:link xlink:href="qlatin1stringview.xml">QLatin1StringView</db:link> overload of <db:link xlink:href="qcborstreamwriter.xml#append">append</db:link>(), this function is not limited to 2 GB. However, note that neither <db:link xlink:href="qcborstreamreader.xml#readString">QCborStreamReader::readString</db:link>() nor <db:link xlink:href="qcborvalue.xml">QCborValue</db:link> support reading CBOR streams with text strings larger than 2 GB.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qcborstreamwriter.xml#append-4">append</db:link>(QLatin1StringView)</db:member>
<db:member><db:link xlink:href="qcborstreamwriter.xml#append-5">append</db:link>(QStringView)</db:member>
<db:member><db:link xlink:href="qcborstreamreader.xml#isString">QCborStreamReader::isString</db:link>()</db:member>
<db:member><db:link xlink:href="qcborstreamreader.xml#readString">QCborStreamReader::readString</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="appendUndefined">
<db:title>void QCborStreamWriter::appendUndefined()</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>appendUndefined</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void appendUndefined()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Appends a CBOR Undefined value to the stream. This function is equivalent to (and implemented as):</db:para>
<db:programlisting language="cpp">   writer.append(QCborSimpleType::Undefined);
</db:programlisting>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qcborstreamwriter.xml#append-8">append</db:link>(QCborSimpleType)</db:member>
<db:member><db:link xlink:href="qcborstreamreader.xml#isUndefined">QCborStreamReader::isUndefined</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="device">
<db:title>QIODevice *QCborStreamWriter::device() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QIODevice *</db:type>
<db:methodname>device</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QIODevice * device() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the <db:link xlink:href="qiodevice.xml">QIODevice</db:link> that this <db:link xlink:href="qcborstreamwriter.xml">QCborStreamWriter</db:link> object is writing to. The device must have previously been set with either the constructor or with <db:link xlink:href="qcborstreamwriter.xml#setDevice">setDevice</db:link>().</db:para>
<db:para>If this object was created by writing to a <db:link xlink:href="qbytearray.xml">QByteArray</db:link>, this function will return an internal instance of <db:link xlink:href="qbuffer.xml">QBuffer</db:link>, which is owned by <db:link xlink:href="qcborstreamwriter.xml">QCborStreamWriter</db:link>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qcborstreamwriter.xml#setDevice">setDevice</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="endArray">
<db:title>bool QCborStreamWriter::endArray()</db:title>
<db:methodsynopsis>
<db:type>bool</db:type>
<db:methodname>endArray</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool endArray()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Terminates the array started by either overload of <db:link xlink:href="qcborstreamwriter.xml#startArray">startArray</db:link>() and returns true if the correct number of elements was added to the array. This function must be called for every <db:link xlink:href="qcborstreamwriter.xml#startArray">startArray</db:link>() used.</db:para>
<db:para>A return of false indicates error in the application and an unrecoverable error in this stream. <db:link xlink:href="qcborstreamwriter.xml">QCborStreamWriter</db:link> also writes a warning using <db:link xlink:href="qtlogging.xml#qWarning">qWarning</db:link>() if that happens.</db:para>
<db:para>Calling this function when the current container is not an array is also an error, though <db:link xlink:href="qcborstreamwriter.xml">QCborStreamWriter</db:link> cannot currently detect this condition.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qcborstreamwriter.xml#startArray">startArray</db:link>()</db:member>
<db:member><db:link xlink:href="qcborstreamwriter.xml#startArray-1">startArray</db:link>(quint64)</db:member>
<db:member><db:link xlink:href="qcborstreamwriter.xml#endMap">endMap</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="endMap">
<db:title>bool QCborStreamWriter::endMap()</db:title>
<db:methodsynopsis>
<db:type>bool</db:type>
<db:methodname>endMap</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool endMap()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Terminates the map started by either overload of <db:link xlink:href="qcborstreamwriter.xml#startMap">startMap</db:link>() and returns true if the correct number of elements was added to the array. This function must be called for every <db:link xlink:href="qcborstreamwriter.xml#startMap">startMap</db:link>() used.</db:para>
<db:para>A return of false indicates error in the application and an unrecoverable error in this stream. <db:link xlink:href="qcborstreamwriter.xml">QCborStreamWriter</db:link> also writes a warning using <db:link xlink:href="qtlogging.xml#qWarning">qWarning</db:link>() if that happens.</db:para>
<db:para>Calling this function when the current container is not a map is also an error, though <db:link xlink:href="qcborstreamwriter.xml">QCborStreamWriter</db:link> cannot currently detect this condition.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qcborstreamwriter.xml#startMap">startMap</db:link>()</db:member>
<db:member><db:link xlink:href="qcborstreamwriter.xml#startMap-1">startMap</db:link>(quint64)</db:member>
<db:member><db:link xlink:href="qcborstreamwriter.xml#endArray">endArray</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setDevice">
<db:title>void QCborStreamWriter::setDevice(QIODevice *<db:emphasis>device</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>setDevice</db:methodname>
<db:methodparam>
<db:type>QIODevice *</db:type>
<db:parameter>device</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void setDevice(QIODevice *device)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Replaces the device or byte array that this <db:link xlink:href="qcborstreamwriter.xml">QCborStreamWriter</db:link> object is writing to with <db:code role="parameter">device</db:code>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qcborstreamwriter.xml#device">device</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="startArray">
<db:title>void QCborStreamWriter::startArray()</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>startArray</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void startArray()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Starts a CBOR Array with indeterminate length in the CBOR stream. Each startArray() call must be paired with one <db:link xlink:href="qcborstreamwriter.xml#endArray">endArray</db:link>() call and the current CBOR element extends until the end of the array.</db:para>
<db:para>The array created by this function has no explicit length. Instead, its length is implied by the elements contained in it. Note, however, that use of indeterminate-length arrays is not compliant with canonical CBOR encoding.</db:para>
<db:para>The following example appends elements from the list of strings passed as input:</db:para>
<db:programlisting language="cpp">   void appendList(QCborStreamWriter &amp;amp;writer, const QList&amp;lt;QString&amp;gt; &amp;amp;values)
   {
       writer.startArray();
       for (const QString &amp;amp;s : values)
           writer.append(s);
       writer.endArray();
   }
</db:programlisting>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qcborstreamwriter.xml#startArray-1">startArray</db:link>(quint64)</db:member>
<db:member><db:link xlink:href="qcborstreamwriter.xml#endArray">endArray</db:link>()</db:member>
<db:member><db:link xlink:href="qcborstreamwriter.xml#startMap">startMap</db:link>()</db:member>
<db:member><db:link xlink:href="qcborstreamreader.xml#isArray">QCborStreamReader::isArray</db:link>()</db:member>
<db:member><db:link xlink:href="qcborstreamreader.xml#isLengthKnown">QCborStreamReader::isLengthKnown</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="startArray-1">
<db:title>void QCborStreamWriter::startArray(quint64 <db:emphasis>count</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>startArray</db:methodname>
<db:methodparam>
<db:type>quint64</db:type>
<db:parameter>count</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">void startArray(quint64 count)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>Starts a CBOR Array with explicit length of <db:code role="parameter">count</db:code> items in the CBOR stream. Each <db:link xlink:href="qcborstreamwriter.xml#startArray">startArray</db:link> call must be paired with one <db:link xlink:href="qcborstreamwriter.xml#endArray">endArray</db:link>() call and the current CBOR element extends until the end of the array.</db:para>
<db:para>The array created by this function has an explicit length and therefore exactly <db:code role="parameter">count</db:code> items must be added to the CBOR stream. Adding fewer or more items will result in failure during <db:link xlink:href="qcborstreamwriter.xml#endArray">endArray</db:link>() and the CBOR stream will be corrupt. However, explicit-length arrays are required by canonical CBOR encoding.</db:para>
<db:para>The following example appends all strings found in the <db:link xlink:href="qstringlist.xml">QStringList</db:link> passed as input:</db:para>
<db:programlisting language="cpp">   void appendList(QCborStreamWriter &amp;amp;writer, const QStringList &amp;amp;list)
   {
       writer.startArray(list.size());
       for (const QString &amp;amp;s : list)
           writer.append(s);
       writer.endArray();
   }
</db:programlisting>
<db:para><db:emphasis role="bold">Size limitations</db:emphasis>: The parameter to this function is quint64, which would seem to allow up to 2<db:superscript>64</db:superscript>-1 elements in the array. However, both <db:link xlink:href="qcborstreamwriter.xml">QCborStreamWriter</db:link> and <db:link xlink:href="qcborstreamreader.xml">QCborStreamReader</db:link> are currently limited to 2<db:superscript>32</db:superscript>-2 items on 32-bit systems and 2<db:superscript>64</db:superscript>-2 items on 64-bit ones. Also note that <db:link xlink:href="qcborarray.xml">QCborArray</db:link> is currently limited to 2<db:superscript>27</db:superscript> elements on 32-bit platforms and 2<db:superscript>59</db:superscript> elements on 64-bit ones.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qcborstreamwriter.xml#startArray">startArray</db:link>()</db:member>
<db:member><db:link xlink:href="qcborstreamwriter.xml#endArray">endArray</db:link>()</db:member>
<db:member><db:link xlink:href="qcborstreamwriter.xml#startMap">startMap</db:link>()</db:member>
<db:member><db:link xlink:href="qcborstreamreader.xml#isArray">QCborStreamReader::isArray</db:link>()</db:member>
<db:member><db:link xlink:href="qcborstreamreader.xml#isLengthKnown">QCborStreamReader::isLengthKnown</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="startMap">
<db:title>void QCborStreamWriter::startMap()</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>startMap</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void startMap()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Starts a CBOR Map with indeterminate length in the CBOR stream. Each startMap() call must be paired with one <db:link xlink:href="qcborstreamwriter.xml#endMap">endMap</db:link>() call and the current CBOR element extends until the end of the map.</db:para>
<db:para>The map created by this function has no explicit length. Instead, its length is implied by the elements contained in it. Note, however, that use of indeterminate-length maps is not compliant with canonical CBOR encoding (canonical encoding also requires keys to be unique and in sorted order).</db:para>
<db:para>The following example appends elements from the list of int and string pairs passed as input:</db:para>
<db:programlisting language="cpp">   void appendMap(QCborStreamWriter &amp;amp;writer, const QList&amp;lt;std::pair&amp;lt;int, QString&amp;gt;&amp;gt; &amp;amp;values)
   {
       writer.startMap();
       for (const auto pair : values) {
           writer.append(pair.first)
           writer.append(pair.second);
       }
       writer.endMap();
   }
</db:programlisting>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qcborstreamwriter.xml#startMap-1">startMap</db:link>(quint64)</db:member>
<db:member><db:link xlink:href="qcborstreamwriter.xml#endMap">endMap</db:link>()</db:member>
<db:member><db:link xlink:href="qcborstreamwriter.xml#startArray">startArray</db:link>()</db:member>
<db:member><db:link xlink:href="qcborstreamreader.xml#isMap">QCborStreamReader::isMap</db:link>()</db:member>
<db:member><db:link xlink:href="qcborstreamreader.xml#isLengthKnown">QCborStreamReader::isLengthKnown</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="startMap-1">
<db:title>void QCborStreamWriter::startMap(quint64 <db:emphasis>count</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>startMap</db:methodname>
<db:methodparam>
<db:type>quint64</db:type>
<db:parameter>count</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">void startMap(quint64 count)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>Starts a CBOR Map with explicit length of <db:code role="parameter">count</db:code> items in the CBOR stream. Each <db:link xlink:href="qcborstreamwriter.xml#startMap">startMap</db:link> call must be paired with one <db:link xlink:href="qcborstreamwriter.xml#endMap">endMap</db:link>() call and the current CBOR element extends until the end of the map.</db:para>
<db:para>The map created by this function has an explicit length and therefore exactly <db:code role="parameter">count</db:code> pairs of items must be added to the CBOR stream. Adding fewer or more items will result in failure during <db:link xlink:href="qcborstreamwriter.xml#endMap">endMap</db:link>() and the CBOR stream will be corrupt. However, explicit-length map are required by canonical CBOR encoding.</db:para>
<db:para>The following example appends all strings found in the <db:link xlink:href="qmap.xml">QMap</db:link> passed as input:</db:para>
<db:programlisting language="cpp">   void appendMap(QCborStreamWriter &amp;amp;writer, const QMap&amp;lt;int, QString&amp;gt; &amp;amp;map)
   {
       writer.startMap(map.size());
       for (auto it = map.cbegin(), end = map.cend(); it != end; ++it) {
           writer.append(it.key());
           writer.append(it.value());
       }
       writer.endMap();
   }
</db:programlisting>
<db:para><db:emphasis role="bold">Size limitations</db:emphasis>: The parameter to this function is quint64, which would seem to allow up to 2<db:superscript>64</db:superscript>-1 pairs in the map. However, both <db:link xlink:href="qcborstreamwriter.xml">QCborStreamWriter</db:link> and <db:link xlink:href="qcborstreamreader.xml">QCborStreamReader</db:link> are currently limited to 2<db:superscript>31</db:superscript>-1 items on 32-bit systems and 2<db:superscript>63</db:superscript>-1 items on 64-bit ones. Also note that <db:link xlink:href="qcbormap.xml">QCborMap</db:link> is currently limited to 2<db:superscript>26</db:superscript> elements on 32-bit platforms and 2<db:superscript>58</db:superscript> on 64-bit ones.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qcborstreamwriter.xml#startMap">startMap</db:link>()</db:member>
<db:member><db:link xlink:href="qcborstreamwriter.xml#endMap">endMap</db:link>()</db:member>
<db:member><db:link xlink:href="qcborstreamwriter.xml#startArray">startArray</db:link>()</db:member>
<db:member><db:link xlink:href="qcborstreamreader.xml#isMap">QCborStreamReader::isMap</db:link>()</db:member>
<db:member><db:link xlink:href="qcborstreamreader.xml#isLengthKnown">QCborStreamReader::isLengthKnown</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
</db:section>
</db:article>
