<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en">
<db:info>
<db:title>Qt for WebAssembly</db:title>
<db:productname>QtDoc</db:productname>
<db:edition>Qt 6.6.3 Reference Documentation</db:edition>
<db:titleabbrev>Qt Reference Documentation</db:titleabbrev>
<db:abstract>
<db:para>Runs Qt applications in a secure sandbox in the browser.</db:para>
</db:abstract>
<db:pubdate>2024-12-27</db:pubdate>
<db:date>2024-12-27</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:para>Qt for Webassembly lets you to run Qt applications on the web.</db:para>
<db:para>WebAssembly (abbreviated Wasm) is a binary instruction format intended to be executed in a virtual machine, for example in a web browser.</db:para>
<db:para>With Qt for WebAssembly, you can distribute your application as a web application that runs in a browser sandbox. This approach is suitable for web distributed applications that do not require full access to host device capabilities.</db:para>
<db:note>
<db:para>Qt for WebAssembly is a supported platform, but some modules are not yet supported or are in Tech Preview. See <db:link xlink:href="wasm.xml#supported-qt-modules">Supported Qt Modules</db:link>.</db:para>
</db:note>
<db:section xml:id="getting-started-with-qt-for-webassembly">
<db:title>Getting Started with Qt for WebAssembly</db:title>
<db:para>Building Qt applications for WebAssembly is similar to building Qt for other platforms. You need to install an SDK (Emscripten), install Qt (or build Qt from source), and finally, build the application. Some differences exist, for example, Qt for WebAssembly supports fewer modules and less features than other Qt builds.</db:para>
<db:section xml:id="installing-emscripten">
<db:title>Installing Emscripten</db:title>
<db:para><db:link xlink:href="https://emscripten.org/docs/introducing_emscripten/index.html">Emscripten</db:link> is a toolchain for compiling to WebAssembly. It lets you run Qt on the web at near-native speed without browser plugins.</db:para>
<db:para>Refer to the <db:link xlink:href="https://emscripten.org/docs/getting_started/index.html">Emscripten documentation</db:link> for more information about installing the Emscripten SDK.</db:para>
<db:para>After installation, you should have the Emscripten compiler in your path. Check this with the following command:</db:para>
<db:programlisting language="cpp" role="bad">em++ --version
</db:programlisting>
<db:para>Each minor version of Qt targets a specific Emcsripten version, which remains unchanged in patch releases. Qt's binary packages are built using the target Emscripten version. Applications should use the same version since Emscripten does not guarantee <db:link xlink:href="https://github.com/emscripten-core/emscripten/blob/main/ChangeLog.md">ABI compatibility</db:link> between versions.</db:para>
<db:para>The Emcsripten versions are:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para>Qt 6.2: 2.0.14</db:para>
</db:listitem>
<db:listitem>
<db:para>Qt 6.3: 3.0.0</db:para>
</db:listitem>
<db:listitem>
<db:para>Qt 6.4: 3.1.14</db:para>
</db:listitem>
<db:listitem>
<db:para>Qt 6.5: 3.1.25</db:para>
</db:listitem>
<db:listitem>
<db:para>Qt 6.6: 3.1.37</db:para>
</db:listitem>
</db:itemizedlist>
<db:para>Use emsdk to install specific Emscripten versions. For example, to install it for Qt 6.6 enter:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para>./emsdk install 3.1.37</db:para>
</db:listitem>
<db:listitem>
<db:para>./emsdk activate 3.1.37</db:para>
</db:listitem>
</db:itemizedlist>
<db:para>On Windows, Emscripten is in your path after installation. On macOS or Linux you need to add it to your path, like this:</db:para>
<db:programlisting language="cpp" role="bad">source /path/to/emsdk/emsdk_env.sh
</db:programlisting>
<db:para>Check this with the following command:</db:para>
<db:programlisting language="cpp" role="bad">em++ --version
</db:programlisting>
<db:para>You can build Qt from source if you require more flexibility when selecting the Emcsripten version. In this case the versions above are minimum versions. Later versions are expected to work but may introduce behavior changes which require making changes to Qt.</db:para>
</db:section>
<db:section xml:id="installing-qt">
<db:title>Installing Qt</db:title>
<db:para>Download Qt from the Downloads section of your Qt account. We provide builds for Linux, macOS, and Windows as development platforms.</db:para>
<db:para>The binary builds are designed to run on as many browsers as possible, and come in single-threaded and multi-threaded versions. Non-standard features such as Wasm SIMD and Wasm exceptions are not supported by the binary builds.</db:para>
<db:anchor xml:id="wasm-building-qt-from-source"/>
</db:section>
<db:section xml:id="building-qt-from-source">
<db:title>Building Qt from Source</db:title>
<db:para>Building from source lets you set Qt configuration options such as thread support, OpenGL ES level, or SIMD support. Download the Qt sources from the Downloads section of your Qt account.</db:para>
<db:para>Configure Qt as a cross-compile build for the wasm-emscripten platform. This sets the -static, -no-feature-thread, and -no-make examples configure options. You can enable thread support with the -feature-thread, configure option. Shared library builds are not supported.</db:para>
<db:para>You need a host build of the same version of Qt and specify that path in the <db:emphasis>QT_HOST_PATH</db:emphasis> CMake variable or by using the -qt-host-path configure argument.</db:para>
<db:para>Although it should be detected, you may optionally set the <db:emphasis>CMAKE_TOOLCHAIN_FILE</db:emphasis> CMake variable to the Emscripten.cmake toolchain file that comes with Emscripten SDK. This can be done by setting the environment variable <db:emphasis>CMAKE_TOOLCHAIN_FILE</db:emphasis> or by passing CMAKE_TOOLCHAIN_FILE=/path/to/Emscripten.cmake to configure.</db:para>
<db:programlisting language="cpp" role="bad">./configure -qt-host-path /path/to/Qt -platform wasm-emscripten -prefix $PWD/qtbase
</db:programlisting>
<db:note>
<db:para>configure always uses the <db:emphasis role="bold">Ninja</db:emphasis> generator and build tool if a ninja executable is available. Ninja is cross-platform, feature-rich, performant, and recommended on all platforms. The use of other generators might work but is not officially supported.</db:para>
</db:note>
<db:para>On Windows, make sure you have MinGW in your PATH and configure with the following:</db:para>
<db:programlisting language="cpp" role="bad">configure -qt-host-path C:\Path\to\Qt -no-warnings-are-errors -platform wasm-emscripten -prefix %CD%\qtbase
</db:programlisting>
<db:para>Then build the required modules:</db:para>
<db:programlisting language="cpp" role="bad">cmake --build . -t qtbase -t qtdeclarative [-t another_module]
</db:programlisting>
</db:section>
<db:section xml:id="building-applications-on-the-command-line">
<db:title>Building Applications on the Command Line</db:title>
<db:para>Qt for WebAssembly supports building applications using qmake and make, or CMake with ninja or make.</db:para>
<db:programlisting language="cpp" role="bad">$ /path/to/qt-wasm/qtbase/bin/qt-cmake .
$ cmake --build .
</db:programlisting>
<db:para>Building the application generates several output files, including a .wasm file that contains the application and Qt code (statically linked), a .html file that can be opened in the browser to run the application.</db:para>
<db:note>
<db:para>Emscripten produces relatively large .wasm files at the &quot;-g&quot; debug level. Consider linking with &quot;-g2&quot; for debug builds.</db:para>
</db:note>
</db:section>
<db:section xml:id="running-applications">
<db:title>Running Applications</db:title>
<db:para>Running the application requires a web server. The build output files are all static content, so any web server will do. Some use cases might require special server configuration, such as providing https certificates or setting http headers required to enable multithreading support.</db:para>
<db:section xml:id="emrun">
<db:title>Emrun</db:title>
<db:para>Emscripten provides the <db:emphasis>emrun</db:emphasis> utility for test-running applications. Emrun starts a web server, launches a browser, and will also capture and forward stdout/stderr (which will normally go to the JavaScript console).</db:para>
<db:programlisting language="cpp" role="bad">/path/to/emscripten/emrun --browser=firefox appname.html
</db:programlisting>
</db:section>
<db:section xml:id="python-http-server">
<db:title>Python http.server</db:title>
<db:para>Another option is to start a development web server and then launch the web browser separately. One of the simplest options is http.server from Python:</db:para>
<db:programlisting language="cpp" role="bad">python -m http.server
</db:programlisting>
<db:para>Note that this is only a simple webserver and does not support SharedArrayBuffer required for threading, as the required COOP and COED headers mentioned below are not sent.</db:para>
</db:section>
<db:section xml:id="qtwasmserver">
<db:title>qtwasmserver</db:title>
<db:para>Qt provides a developer web server which uses <db:link xlink:href="https://github.com/FiloSottile/mkcert">mkcert</db:link> to generate https certificates. This allows testing web features which require a <db:link xlink:href="https://developer.mozilla.org/en-US/docs/Web/Security/Secure_Contexts">secure context</db:link>. Note that delivery over http://localhost is also considered secure, without requiring a certificate.</db:para>
<db:para>The web server also sets the <db:link xlink:href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cross-Origin-Opener-Policy">COOP</db:link> and <db:link xlink:href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cross-Origin-Embedder-Policy">COEP</db:link> headers to values which enables support for <db:link xlink:href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/SharedArrayBuffer">SharedArrayBuffer</db:link> and multi-threading.</db:para>
<db:para>The qtwasmserver script starts one server which binds to localhost by default. You may add additional addresses using the <db:emphasis>-a</db:emphasis> command-line argument, or use <db:emphasis>--all</db:emphasis> to bind to all available addresses.</db:para>
<db:programlisting language="cpp" role="bad">python /path/to/qtbase/util/wasm/qtwasmserver/qtwasmserver.py --all
</db:programlisting>
</db:section>
</db:section>
<db:section xml:id="building-applications-using-qt-creator">
<db:title>Building Applications using Qt Creator</db:title>
<db:para><db:link xlink:href="https://doc.qt.io/qtcreator/creator-setup-webassembly.html">Setting Up Qt Creator for WebAssembly</db:link>.</db:para>
</db:section>
<db:section xml:id="deploying-applications-on-the-web">
<db:title>Deploying Applications on the web</db:title>
<db:para>Building an application generates several files (substitute &quot;app&quot; with the application name in the following table).</db:para>
<db:informaltable style="generic">
<db:thead>
<db:tr>
<db:th>
<db:para>Generated file</db:para>
</db:th>
<db:th>
<db:para>Brief Description</db:para>
</db:th>
</db:tr>
</db:thead>
<db:tr valign="top">
<db:td>
<db:para>app.html</db:para>
</db:td>
<db:td>
<db:para>HTML container</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>qtloader.js</db:para>
</db:td>
<db:td>
<db:para>JavaScript API for loading Qt applications</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>app.js</db:para>
</db:td>
<db:td>
<db:para>JavaScript runtime generated by Emscripten</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>app.wasm</db:para>
</db:td>
<db:td>
<db:para>app binary</db:para>
</db:td>
</db:tr>
</db:informaltable>
<db:para>You can deploy <db:emphasis>app.html</db:emphasis> as-is, or discard it in favor of a custom HTML file. Smaller adjustments, such as changing the splash screen image from the Qt logo to the app logo, is also possible. In both cases, <db:emphasis>qtloader.js</db:emphasis> provides a JavaScript API for loading the application.</db:para>
<db:para>Compress the Wasm file using either gzip or brotli before deploying, as they offer better compression ratio than the other tools. See <db:link xlink:href="wasm.xml#minimizing-the-size-of-binaries">Minimizing the size of binaries</db:link> for more information.</db:para>
<db:para>Enabling certain features, such as multi-threading and SIMD, produces .wasm binaries that are incompatible with browsers that do not support the enabled feature. It is possible to work around this limitation by building multiple .wasm files and then use JavaScript feature detection to select the correct one, but note that Qt does not provide any functionality for doing this.</db:para>
</db:section>
<db:section xml:id="using-qtloader">
<db:title>Using qtloader</db:title>
<db:para>Qt provides a JavaScript API for downloading, compiling, and instantiating Qt for WebAssembly applications. This loading API wraps loading functionality provided by Emscripten, and provides additional features useful for Qt-based applications. It is implemented in the qtloader.js file. A copy of this file is written to the build directoty at build time.</db:para>
<db:para>Typical usage looks like the following:</db:para>
<db:programlisting language="cpp">const app_container_element = ...;
const instance = await qtLoad({
    qt: {
        containerElements: [ app_container_element ],
        onLoaded: () =&amp;gt; { /* handle application load completed */  },
        onExit: () =&amp;gt; {  /* handle application exit */ },
    }
});
</db:programlisting>
<db:para>The code calls the qtLoad() loader function with a configuration object. This configuration object can contain any emscripten configuration options, as well as a special &quot;qt&quot; configuration object. The qt configuration object supports the following properties:</db:para>
<db:informaltable style="generic">
<db:thead>
<db:tr>
<db:th>
<db:para>Property</db:para>
</db:th>
<db:th>
<db:para>Brief Description</db:para>
</db:th>
</db:tr>
</db:thead>
<db:tr valign="top">
<db:td>
<db:para>containerElements</db:para>
</db:td>
<db:td>
<db:para>Array of HTML container elements. The application sees these as QScreens.</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>onLoaded</db:para>
</db:td>
<db:td>
<db:para>Callback for when the application has completed loading.</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>onExit</db:para>
</db:td>
<db:td>
<db:para>Callback for when the applicataion exits.</db:para>
</db:td>
</db:tr>
</db:informaltable>
<db:para>The containerElements array is the main interface between Qt and the web page, where the html elements in this array (typically &lt;div&gt; elements) specify the location of the application content on the web page.</db:para>
<db:para>The application sees each container element as a <db:link xlink:href="qscreen.xml">QScreen</db:link> instance, and can place application windows on the screen instances as usual. Windows with the <db:link xlink:href="qt.xml#WindowState-enum">Qt::WindowFullScreen</db:link> state set use the entire screen area, while non-&quot;fullscreen&quot; windows get window decorations.</db:para>
<db:para>The qtLoad() function returns a promise, which yelds an Emscripten instance when awaited. The instance provides access to Embind exported functions. Qt exports several such functions, and these functions make up the instance API.</db:para>
</db:section>
<db:section xml:id="using-the-qt-instance-api">
<db:title>Using the Qt instance API</db:title>
<db:para>Qt provides several instance functions. Currently, these support adding and removing container elements at runtime.</db:para>
<db:informaltable style="generic">
<db:thead>
<db:tr>
<db:th>
<db:para>Property</db:para>
</db:th>
<db:th>
<db:para>Brief Description</db:para>
</db:th>
</db:tr>
</db:thead>
<db:tr valign="top">
<db:td>
<db:para>qtAddContainerElement</db:para>
</db:td>
<db:td>
<db:para>Add a container element. Adding an element will add a new <db:link xlink:href="qscreen.xml">QScreen</db:link>.</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>qtRemoveContainerElement</db:para>
</db:td>
<db:td>
<db:para>Remove a container element, and its corresponding screen.</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>qtSetContainerElements</db:para>
</db:td>
<db:td>
<db:para>Sets all container elements</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>qtResizeContainerElement</db:para>
</db:td>
<db:td>
<db:para>Make Qt pick up changes to container element size.</db:para>
</db:td>
</db:tr>
</db:informaltable>
</db:section>
<db:section xml:id="porting-to-the-qt-6-6-qtloader">
<db:title>Porting to the Qt 6.6 qtloader</db:title>
<db:para>Qt 6.6 includes a new qtloader with a simplified implementation and a smaller scope. This includes API changes which may require porting application JavaScript code. Qt provides a compatibility API to ease the transition. Depending use case there are several ways forward:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para>If you are using the generated app.html file directly then this file will be updated as well at build time. No action is needed.</db:para>
</db:listitem>
<db:listitem>
<db:para>If you are using the basic qtloader feature set then you may use the compatibility API included in Qt 6.6 as a temporary maesure. This API will be removed in a future release; you should plan on updating to use the new qtloader. Porting step 1 below is needed.</db:para>
</db:listitem>
<db:listitem>
<db:para>If you are using advanced features (such as adding container elements at runtime), then porting to the new loader or instance API required. Porting steps 1 and 2 below are needed.</db:para>
</db:listitem>
</db:itemizedlist>
<db:para><db:emphasis role="bold">Porting steps</db:emphasis></db:para>
<db:orderedlist numeration="arabic">
<db:listitem>
<db:para>Include the app.js (JavaScript runtime generated by Emscripten) from the loading html file.</db:para>
<db:programlisting language="cpp" role="bad">&amp;lt;script src=&quot;app.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
</db:programlisting>
<db:para>Before Qt 6.6, qtloader would load and evaluate this JavaScript file. This is no longer done, and the file must be included using a &lt;script&gt; tag.</db:para>
</db:listitem>
<db:listitem>
<db:para>Port to using the new JavaScript and instance API.</db:para>
</db:listitem>
</db:orderedlist>
<db:para>See documentation sections above.</db:para>
</db:section>
</db:section>
<db:section xml:id="supported-browsers">
<db:title>Supported Browsers</db:title>
<db:section xml:id="desktop">
<db:title>Desktop</db:title>
<db:para>Qt for WebAssembly is developed and tested on the following browsers:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para>Chrome</db:para>
</db:listitem>
<db:listitem>
<db:para>Firefox</db:para>
</db:listitem>
<db:listitem>
<db:para>Safari</db:para>
</db:listitem>
<db:listitem>
<db:para>Edge</db:para>
</db:listitem>
</db:itemizedlist>
<db:para>Qt should run if the browser supports WebAssembly. Qt has a fixed WebGL requirement, even if the application itself does not use hardware accelerated graphics. Browsers that support WebAssembly often support WebGL, though some browsers blacklist older or unsupported GPUs. s/<db:emphasis>qtloader.js</db:emphasis> provides APIs to check if WebGL is available.</db:para>
<db:para>Qt does not make direct use of operating system features and it makes no difference if, for example, FireFox runs on Windows or macOS. Qt does use some operating system adaptations, for example for ctrl/cmd key handling on macOS.</db:para>
</db:section>
<db:section xml:id="mobile">
<db:title>Mobile</db:title>
<db:para>Qt for WebAssembly applications runs on mobile browsers such as mobile Safari and Android Chrome.</db:para>
<db:anchor xml:id="supported-modules"/>
</db:section>
</db:section>
<db:section xml:id="supported-qt-modules">
<db:title>Supported Qt Modules</db:title>
<db:para>Qt for WebAssembly supports a subset of the Qt modules and features. Tested modules are listed below, other modules may or may not work.</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:link xlink:href="qtcore-index.xml">Qt Core</db:link></db:para>
</db:listitem>
<db:listitem>
<db:para><db:link xlink:href="qtgui-index.xml">Qt GUI</db:link></db:para>
</db:listitem>
<db:listitem>
<db:para><db:link xlink:href="qtnetwork-index.xml">Qt Network</db:link></db:para>
</db:listitem>
<db:listitem>
<db:para><db:link xlink:href="qtwidgets-index.xml">Qt Widgets</db:link></db:para>
</db:listitem>
<db:listitem>
<db:para><db:link xlink:href="qtqml-index.xml">Qt QML</db:link></db:para>
</db:listitem>
<db:listitem>
<db:para><db:link xlink:href="qtquick-index.xml">Qt Quick</db:link></db:para>
</db:listitem>
<db:listitem>
<db:para><db:link xlink:href="qtquickcontrols-index.xml">Qt Quick Controls</db:link></db:para>
</db:listitem>
<db:listitem>
<db:para><db:link xlink:href="qtquicklayouts-index.xml">Qt Quick Layouts</db:link></db:para>
</db:listitem>
<db:listitem>
<db:para><db:link xlink:href="qtcore5-index.xml">Qt 5 Core Compatibility APIs</db:link></db:para>
</db:listitem>
<db:listitem>
<db:para><db:link xlink:href="license-changes.xml#qt-image-formats">Qt Image Formats</db:link></db:para>
</db:listitem>
<db:listitem>
<db:para><db:link xlink:href="qtopengl-index.xml">Qt OpenGL</db:link></db:para>
</db:listitem>
<db:listitem>
<db:para><db:link xlink:href="qtsvg-index.xml">Qt SVG</db:link></db:para>
</db:listitem>
<db:listitem>
<db:para><db:link xlink:href="qtwebsockets-index.xml">Qt WebSockets</db:link></db:para>
</db:listitem>
</db:itemizedlist>
<db:para>In all cases, module support may not be complete and there may be additional limitations, either due to the browser sandbox or due to incompleteness of the Qt platform port. See <db:link xlink:href="wasm.xml#developing-with-qt-for-webassembly">Developing with Qt for WebAssembly</db:link> for further info.</db:para>
<db:para>Qt for WebAssembly Technology Preview modules and features. These features may require to reconfigure and build Qt. They may contain features that are still experimental in the browsers or Emscripten.</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:link xlink:href="threads.xml">Qt Threading</db:link></db:para>
</db:listitem>
<db:listitem>
<db:para><db:link xlink:href="qtconcurrent-index.xml">Qt Concurrent</db:link></db:para>
</db:listitem>
<db:listitem>
<db:para><db:link xlink:href="wasm.xml#asyncify">Emscripten Asyncify</db:link></db:para>
</db:listitem>
<db:listitem>
<db:para><db:link xlink:href="qtnetwork-programming.xml">Qt Sockets</db:link></db:para>
</db:listitem>
</db:itemizedlist>
</db:section>
<db:section xml:id="developing-with-qt-for-webassembly">
<db:title>Developing with Qt for WebAssembly</db:title>
<db:section xml:id="building-with-cmake">
<db:title>Building with CMake</db:title>
<db:para>If there is a need for Emscripten-specific configuration in CMake, the following code can be utilized:</db:para>
<db:programlisting language="cpp" role="bad">if(EMSCRIPTEN)
    # WebAssembly specific code
else()
    # other platforms
endif()
</db:programlisting>
<db:para>This code allows for the accommodation of Emscripten-specific configurations while ensuring compatibility with other platforms.</db:para>
</db:section>
<db:section xml:id="opengl-and-webgl">
<db:title>OpenGL and WebGL</db:title>
<db:para>Qt requires WebGL, also for applications which do not use OpenGL directly. All relevant browsers support WebGL, but note that some browsers blacklist certain older GPUs. The Qt loader will detect this and display an error message.</db:para>
<db:para>Qt detects WebGL as OpenGL ES, with the following version mapping:</db:para>
<db:informaltable style="generic">
<db:thead>
<db:tr>
<db:th>
<db:para>OpenGL</db:para>
</db:th>
<db:th>
<db:para>WebGL</db:para>
</db:th>
</db:tr>
</db:thead>
<db:tr valign="top">
<db:td>
<db:para>OpengL ES 2</db:para>
</db:td>
<db:td>
<db:para>WebGL 1</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>OpengL ES 3</db:para>
</db:td>
<db:td>
<db:para>WebGL 2</db:para>
</db:td>
</db:tr>
</db:informaltable>
<db:para>OpenGL ES 2 and OpenGL ES 3 are enabled by default, and can be selected through the <db:link xlink:href="qsurfaceformat.xml#setMajorVersion">QSurfaceFormat::setMajorVersion</db:link>() function.</db:para>
<db:para>Web and Desktop OpenGL differences are documented in <db:link xlink:href="https://www.khronos.org/registry/webgl/specs/latest/1.0/#6">WebGL and OpenGL Differences</db:link>. There are additional differences between WebGL 1.0 and WebGL 2.0, documented in the <db:link xlink:href="https://www.khronos.org/registry/webgl/specs/latest/2.0">WebGL 2.0 Specification</db:link>.</db:para>
<db:para>A WebGL-friendly subset of ES2 (and ES3) is used by default. If you need to use glDrawArrays and glDrawElements without bound buffers, you can enable full ES2 support by adding</db:para>
<db:programlisting language="cpp" role="bad">target_link_options(&amp;lt;your target&amp;gt; PRIVATE -s FULL_ES2=1)
</db:programlisting>
<db:para>and/or full ES3 emulation by adding</db:para>
<db:programlisting language="cpp" role="bad">target_link_options(&amp;lt;your target&amp;gt; PRIVATE -s FULL_ES3=1)
</db:programlisting>
<db:para>to your project's CMakeLists.txt.</db:para>
</db:section>
<db:section xml:id="multithreading">
<db:title>Multithreading</db:title>
<db:para>Qt for WebAssembly supports multithreading using Emscripten's <db:link xlink:href="https://emscripten.org/docs/porting/pthreads.html">Pthreads support</db:link>, where each thread is backed by a <db:link xlink:href="https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API">web worker</db:link>. Enable multithreading by installing the &quot;WebAssembly (multi-threaded)&quot; component from Qt Maintenance Tool, or by building Qt from source and passing the &quot;-feature-thread&quot; flag to configure.</db:para>
<db:para>Existing threading code can generally be reused, but may need to be modified to work around <db:link xlink:href="https://emscripten.org/docs/porting/pthreads.html#special-considerations">specifics</db:link> of the pthread implementation. Some Emscripten and Qt features are not supported, this includes the <db:link xlink:href="https://emscripten.org/docs/porting/pthreads.html#proxying">thread proxying</db:link> feature and the Qt Quick threaded render loop.</db:para>
<db:para>Be aware that it is especially important to <db:link xlink:href="https://emscripten.org/docs/porting/pthreads.html#blocking-on-the-main-browser-thread">not block the main thread</db:link> on Qt for WebAssembly, since the main thread might be required to service requests from secondary threads. For example, all timers in Qt are scheduled on the main thread, and will not fire if the main thread is blocked. Another example is that creating a new web worker (for a thread) can only be done from the main thread.</db:para>
<db:para>Emscripten provides some mitigations for this. Short-term waits such as acquiring a mutex lock is supported by busy-waiting and processing events while waiting for the lock. Longer waits on the main thread should be avoided. In particular, the common practice of calling <db:link xlink:href="qthread.xml#wait">QThread::wait</db:link>() or pthread_join() to wait for a secondary thread will not work, unless the application can guarantee that the thread (and web worker) has already been started, and will be able to complete without assistance from the main thread at the time that the wait() or join() call is made.</db:para>
<db:para>The multithreading feature requires browser support for the <db:link xlink:href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/SharedArrayBuffer">SharedArrayBuffer</db:link> API. (Normally, Emscripten stores the heap in an ArrayBuffer object. For multithreading, the heap must be shared with web workers and a SharedArrayBuffer is needed) This API is generally available in all modern browsers, but may be disabled if certain security requirements are not met. WebAssembly binaries with thread support enabled will then fail to run, also if the binary does not actually start a thread.</db:para>
<db:para>Enabling SharedArrayBuffer requires a secure browsing context (where the page is served over https:// or http://localhost), and that the page is in cross-origin isolated mode. The latter can be done by setting the so called COOP and COEP headers on the web server:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para>Cross-Origin-Opener-Policy: same-origin</db:para>
</db:listitem>
<db:listitem>
<db:para>Cross-Origin-Embedder-Policy: require-corp</db:para>
</db:listitem>
</db:itemizedlist>
</db:section>
<db:section xml:id="simd">
<db:title>SIMD</db:title>
<db:para>Emscripten supports <db:link xlink:href="https://emscripten.org/docs/porting/simd.html">WebAssembly SIMD</db:link>, which provides 128-bit SIMD types and operations for WebAssembly.</db:para>
<db:para>Build Qt from source and configure with the -feature-wasm-simd128 flag to enable; this will pass the -msimd128 flag at compile and link time. Note that Qt does not contain wasm-simd optimized code paths at this point, however enabling wasm-simd will enable compiler auto-vectorization where the compiler can use the SIMD instructions.</db:para>
<db:para>You can target WebAssembly SIMD directly using either GCC/Clang SIMD Vector Extensions or WASM SIMD128 intrinsics. For more information, see the Emscripten <db:link xlink:href="https://emscripten.org/docs/porting/simd.html"> SIMD documentation </db:link>.</db:para>
<db:para>In addition, Emscripten supports emulating/translating x86 SSE instructions to Wasm SIMD instructions. Qt does not use this emulation, as the use of SSE SIMD instructions that have no native Wasm SIMD equivalent may cause reduced performance.</db:para>
<db:para>Note that SIMD-enabled binaries are incompatible with browsers that do not support WebAssembly SIMD, also if the SIMD code paths are not called at run-time. SIMD support may need to be enabled in the browsers advanced configurations, such as 'about:config' or 'chrome:flags'</db:para>
</db:section>
<db:section xml:id="networking">
<db:title>Networking</db:title>
<db:para>Qt provides limited support for networking. In general, network protocols which are already in use on the web can be use also from Qt, while others are not directly available due to the web sandbox.</db:para>
<db:para>The following protocols are supported:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:link xlink:href="qnetworkaccessmanager.xml">QNetworkAccessManager</db:link> http requests to the web page origin server, or to a server which supports CORS. This includes <db:link xlink:href="qml-qtqml-xmlhttprequest.xml">XMLHttpRequest</db:link> from QML.</db:para>
</db:listitem>
<db:listitem>
<db:para><db:link xlink:href="qwebsocket.xml">QWebSocket</db:link> connections to any host. Note that web pages served over the secure https protocol allows websockets connections over secure wss protocol only.</db:para>
</db:listitem>
<db:listitem>
<db:para>Emulated POSIX TCP Sockets over WebSockets, using functionality provided by <db:link xlink:href="https://emscripten.org/docs/porting/networking.html#emulated-posix-tcp-sockets-over-websockets">Emscripten</db:link>. Note that this requires running a <db:link xlink:href="https://github.com/novnc/websockify">forwarding server</db:link> which handles socket translation.</db:para>
</db:listitem>
</db:itemizedlist>
<db:para>All other network protocols are not supported.</db:para>
</db:section>
<db:section xml:id="local-file-access">
<db:title>Local File Access</db:title>
<db:para>File system access is sandboxed on the web, and this has implications for how the application works with files. The Web platform provides APIs for accessing the local file system in a way which is under user control, as well as APIs for accessing persistent storage. Emscripten and Qt wraps these features and provides APIs which are easier to use from C++ and Qt-based applications.</db:para>
<db:para>The web platform provides features for accessing local files and persistent storage:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para>&lt;input type=&quot;file&quot;&gt; for showing a native open-file dialog where the user can pick a file.</db:para>
</db:listitem>
<db:listitem>
<db:para>IndexedDB provides persistent local storage (not accessible outside the browser)</db:para>
</db:listitem>
</db:itemizedlist>
<db:para>Emscripten provides several file systems with a POSIX like API. These include:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para>the MEMFS ephemeral file system which stores files in-memory</db:para>
</db:listitem>
<db:listitem>
<db:para>the IDBFS persistent file system which stores files using IndexedDB</db:para>
</db:listitem>
</db:itemizedlist>
<db:para>Emscripten mounts a temporary MEMFS filesystem to &quot;/&quot; at app startup. This means that <db:link xlink:href="qfile.xml">QFile</db:link> can be used, and will read and write files to memory by default. Qt provides other API as well:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:link xlink:href="qsettings.xml">QSettings</db:link> has an IndexedDB-based backend; Note that <db:link xlink:href="qsettings.xml">QSettings</db:link> is asynchronous on WebAssembly.</db:para>
</db:listitem>
<db:listitem>
<db:para><db:link xlink:href="https://doc.qt.io/qt-5/qfiledialog.html#getOpenFileContent">QFileDialog::getOpenFileContent() </db:link> opens a native file dialog where the user can pick a file</db:para>
</db:listitem>
<db:listitem>
<db:para><db:link xlink:href="https://doc.qt.io/qt-5/qfiledialog.html#saveFileContent">QFileDialog::saveFileContent()</db:link> saves a file to the local file system via file download}</db:para>
</db:listitem>
</db:itemizedlist>
</db:section>
<db:section xml:id="clipboard-access">
<db:title>Clipboard Access</db:title>
<db:para>Qt supports copying and pasting text to the system clipboard, with some differences due to the web sandbox. In general clipboard access require user permission, which can be obtained by handling an input event (e.g. CTRL+c), or by using the <db:link xlink:href="https://developer.mozilla.org/en-US/docs/Web/API/Clipboard_API">Clipboard API</db:link>.</db:para>
<db:para>Browsers that support the Clipboard API are preferred. Note that a requirement for this API is that the web page is served over a secure connection (e.g. https), and that some browsers my require changing configuration flags.</db:para>
<db:para>See <db:link xlink:href="https:...">caniuse</db:link> for which browsers currently support the Clipboard API. The following versions are known to work:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para>Chrome version 66 and Safari version 13.1 support the Clipboard API</db:para>
</db:listitem>
<db:listitem>
<db:para>Firefox version 90 supports the Clipboard API if you enable the following flags in 'about:config':</db:para>
<db:programlisting language="cpp" role="bad">dom.events.asyncClipboard.read
dom.events.asyncClipboard.clipboardItem
</db:programlisting>
</db:listitem>
</db:itemizedlist>
</db:section>
<db:section xml:id="fonts">
<db:title>Fonts</db:title>
<db:para>The Qt WASM module contains 3 embedded fonts: &quot;Bitstream Vera Sans&quot; (fallback font), &quot;DejaVu Sans&quot;, &quot;DejaVu Sans Mono&quot;.</db:para>
<db:para>These fonts provide a limited character set. Qt provides several options for adding additional fonts:</db:para>
<db:para>One is using <db:link xlink:href="qml-qtquick-fontloader.xml">FontLoader</db:link> in QML, which can either fetch a font by URL or using <db:link xlink:href="https://doc.qt.io/qt-6/resources.html">Qt Resource System</db:link> (the same way the usual desktop apps work).</db:para>
<db:para>The other way to use font is to add it via <db:link xlink:href="https://doc.qt.io/qt-6/qfontdatabase.html#addApplicationFontFromData">QFontDatabase::addApplicationFontFromData</db:link>.</db:para>
</db:section>
<db:section xml:id="application-startup-and-the-event-loop">
<db:title>Application Startup and the Event Loop</db:title>
<db:para>Qt for WebAssembly supports the standard Qt startup approach, where the application creates a <db:link xlink:href="qapplication.xml">QApplication</db:link> object and calls the exec function:</db:para>
<db:programlisting language="cpp">int main(int argc, char **argv)
{
    QApplication app(argc, argv);

    QWindow appWindow;

    return app.exec();
}
</db:programlisting>
<db:para>The exec() call above normally blocks and processes events until application shutdown. Unfortunately this is not possible on the web platform where blocking the main thread is not allowed. Instead, control must be returned to the browser's event loop after processing each event.</db:para>
<db:para>Qt works around this by making exec() return main thread control to the browser, while preserving the stack. From the point of view of application code, the exec() function is entered and event processing happens as usual. However, the exec() call never returns, also not on application exit.</db:para>
<db:para>This behavior is usually acceptable since the browser will free up application memory at app shutdown time. It does mean that shutdown code does not run, since the application object is leaked and its destructor does not run.</db:para>
<db:para>You can avoid this by rewriting main() to be asynchronous, which is possible since Emscripten does not exit the runtime when main() returns. Application code then omits making the exec() call, and can shut down Qt cleanly by deleting the top-level window and application objects.</db:para>
<db:programlisting language="cpp">QApplication *g_app = nullptr;
AppWindow *g_appWindow = nullptr;

int main(int argc, char **argv)
{
    g_app = new QApplication(argc, argv);
    g_appWindow = new AppWindow();
    return 0;
}
</db:programlisting>
<db:section xml:id="asyncify">
<db:title>Asyncify</db:title>
<db:para>The default build of Qt for WebAssembly does not support reentering the event loop, for example by calling <db:link xlink:href="qeventloop.xml#exec">QEventLoop::exec</db:link>() or <db:link xlink:href="qdialog.xml#exec">QDialog::exec</db:link>(), due to restrictions of the web platform.</db:para>
<db:para>Emscripten's <db:link xlink:href="https://emscripten.org/docs/porting/asyncify.html">asyncify</db:link> feature lifts these restrictions by allowing synchronous calls (like <db:link xlink:href="qeventloop.xml#exec">QEventLoop::exec</db:link>() and <db:link xlink:href="qdialog.xml#exec">QDialog::exec</db:link>()) to yield to the event loop. Nested calls are not supported, and for this reason asyncify is not used for the top-level <db:link xlink:href="qapplication.xml#exec">QApplication::exec</db:link>() call.</db:para>
<db:para>Features that require asyncify are:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para>QDialogs, QMessageBoxes with return values.</db:para>
</db:listitem>
<db:listitem>
<db:para>Drag and drop (specifically drag).</db:para>
</db:listitem>
<db:listitem>
<db:para>Nested/secondary event loops exec().</db:para>
</db:listitem>
</db:itemizedlist>
<db:para>As of Qt 6.4, Asyncify support is enabled in the binary package, but needs to be enabled for applications by adding -sASYNCIFY -Os to linker options:</db:para>
<db:para>CMake:</db:para>
<db:programlisting language="cpp" role="bad">target_link_options(&amp;lt;your target&amp;gt; PUBLIC -sASYNCIFY -Os)
</db:programlisting>
<db:para>qmake:</db:para>
<db:programlisting language="cpp" role="bad">QMAKE_LFLAGS += -sASYNCIFY -Os
</db:programlisting>
<db:para>Enabling asyncify adds overhead in the form of increased binary sizes and increased CPU usage. Build with optimizations enabled to minimize the overhead.</db:para>
</db:section>
</db:section>
<db:section xml:id="debugging-and-profiling">
<db:title>Debugging and Profiling</db:title>
<db:para>Wasm debugging is done on browser JavaScript console, debugging applications on Wasm directly within Qt Creator is not possible.</db:para>
<db:itemizedlist>
<db:listitem>
<db:para>Qt debug and logging output is printed on the JavaScript console, which can be accessed via browser &quot;Developer Tools&quot; or similar.</db:para>
</db:listitem>
<db:listitem>
<db:para>Source maps for stepping through code, can be created by re-configuring Qt with the –device-option QT_WASM_SOURCE_MAP=1, and building a debug build.</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:link xlink:href="https://developer.mozilla.org/en-US/docs/Tools/Debugger/How_to/Use_a_source_map">https://developer.mozilla.org/en-US/docs/Tools/Debugger/How_to/Use_a_source_map</db:link></db:para>
</db:listitem>
<db:listitem>
<db:para><db:link xlink:href="https://developers.google.com/web/tools/chrome-devtools/javascript/source-maps#source_maps_in_devtools_sources_panel">https://developers.google.com/web/tools/chrome-devtools/javascript/source-maps#source_maps_in_devtools_sources_panel</db:link></db:para>
</db:listitem>
</db:itemizedlist>
</db:listitem>
<db:listitem>
<db:para>Debug symbols via DWARF are also enabled if the program is linked with the -g flag (tested with Chrome)</db:para>
</db:listitem>
<db:listitem>
<db:para>This will require this extension: <db:link xlink:href="https://goo.gle/wasm-debugging-extension">https://goo.gle/wasm-debugging-extension</db:link></db:para>
</db:listitem>
<db:listitem>
<db:para>See also <db:link xlink:href="https://developer.chrome.com/blog/wasm-debugging-2020/">https://developer.chrome.com/blog/wasm-debugging-2020/</db:link></db:para>
</db:listitem>
<db:listitem>
<db:para>Mobile browsers can use remote debugging</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:link xlink:href="https://developer.mozilla.org/en-US/docs/Tools/Remote_Debugging">https://developer.mozilla.org/en-US/docs/Tools/Remote_Debugging</db:link></db:para>
</db:listitem>
<db:listitem>
<db:para><db:link xlink:href="https://developers.google.com/web/tools/chrome-devtools/remote-debugging">https://developers.google.com/web/tools/chrome-devtools/remote-debugging</db:link></db:para>
</db:listitem>
<db:listitem>
<db:para><db:link xlink:href="https://developer.apple.com/safari/tools/">https://developer.apple.com/safari/tools/</db:link></db:para>
</db:listitem>
</db:itemizedlist>
</db:listitem>
<db:listitem>
<db:para>To stop execution on a certain line and popup the browser debugger programmatically, you can add the function emscripten_debugger(); to the application source code.</db:para>
</db:listitem>
<db:listitem>
<db:para>Profiling can be accomplished by using a debug build and the JavaScript console profiling features. Qt adds –profiling-funcs to the linker arguments in debug builds, which preserve function names in profiling</db:para>
</db:listitem>
</db:itemizedlist>
<db:para>You can add more verbosity to help debug using Emscripten linker arguments:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para>-s LIBRARY_DEBUG=1 (print out library calls)</db:para>
</db:listitem>
<db:listitem>
<db:para>-s SYSCALL_DEBUG=1 (print out sys calls)</db:para>
</db:listitem>
<db:listitem>
<db:para>-s FS_LOG=1 (print out filesystem operations)</db:para>
</db:listitem>
<db:listitem>
<db:para>-s SOCKET_DEBUG (print out socket, network data transfer)</db:para>
</db:listitem>
</db:itemizedlist>
<db:para>CMake:</db:para>
<db:programlisting language="cpp" role="bad">target_link_options(&amp;lt;your target&amp;gt; PRIVATE -s LIBRARY_DEBUG=1)
</db:programlisting>
<db:para>qmake:</db:para>
<db:programlisting language="cpp" role="bad">QMAKE_LFLAGS_DEBUG += -s LIBRARY_DEBUG=1
</db:programlisting>
</db:section>
<db:section xml:id="optimizing">
<db:title>Optimizing</db:title>
<db:para>Qt for WebAssembly uses the Emscripten toolchain to generate binaries, and there are many flags that may impact performance and the size of binaries. See <db:link xlink:href="https://emscripten.org/docs/optimizing/Optimizing-Code.html">Emscripten: Optimizing Code</db:link> for more information.</db:para>
<db:para>You can pass linker and compiler flags just as for normal C++ applications:</db:para>
</db:section>
</db:section>
<db:section xml:id="using-cmake">
<db:title>Using CMake</db:title>
<db:programlisting language="cpp" role="bad">target_compile_options(&amp;lt;your target&amp;gt; PRIVATE -oz -flto)
target_link_options(&amp;lt;your target&amp;gt; PRIVATE -flto)
</db:programlisting>
</db:section>
<db:section xml:id="using-qmake">
<db:title>Using qmake</db:title>
<db:programlisting language="cpp" role="bad">QMAKE_CXXFLAGS += -oz -flto
QMAKE_LFLAGS += -flto
</db:programlisting>
<db:section xml:id="minimizing-the-size-of-binaries">
<db:title>Minimizing the size of binaries</db:title>
<db:para>In order to provide a seamless user experience, it's important to reduce the time to download and load WebAssembly applications. Smaller application binary is one of the important aspects that enable faster download. Use the following alternatives to reduce the binary size:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para>Make sure to distribute release builds. Debug builds contain debug symbols and are much bigger.</db:para>
</db:listitem>
<db:listitem>
<db:para>Enable compression on a server. The most common algorithms like gzip and Brotli work well on Wasm binaries and can drastically reduce their size.</db:para>
</db:listitem>
<db:listitem>
<db:para>Try compiler and linker flags that may results in generating smaller binaries (i.e. '-os', '-oz'). Results will vary depending on the particular application.</db:para>
</db:listitem>
<db:listitem>
<db:para>Disable unsued features when compiling Qt for WebAssembly from source (see below).</db:para>
</db:listitem>
</db:itemizedlist>
<db:section xml:id="opting-out-of-features">
<db:title>Opting out of features</db:title>
<db:para>A WebAssembly application by default links statically to the Qt libraries, enabling the compiler to eliminate dead code. However, due to Qt's dynamic nature it's not always possible for the compiler to perform such optimizations.</db:para>
<db:para>If you build Qt for WebAssembly from source, you can disable features to reduce the size of Qt binaries, and — as a result — the size of .wasm binaries. Qt disables some features by default for the WebAssembly platform, but you can also disable features that your application does not use. See <db:link xlink:href="wasm.xml#disabled-features">disabled features</db:link> for more information.</db:para>
<db:para>You can disable the following features to reduce binary size (usually by 10-15%):</db:para>
<db:informaltable style="generic">
<db:thead>
<db:tr>
<db:th>
<db:para>Configure Argument</db:para>
</db:th>
<db:th>
<db:para>Brief Description</db:para>
</db:th>
</db:tr>
</db:thead>
<db:tr valign="top">
<db:td>
<db:para>-no-feature-cssparser</db:para>
</db:td>
<db:td>
<db:para>Parser for Cascading Style Sheets.</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>-no-feature-datetimeedit</db:para>
</db:td>
<db:td>
<db:para>Editing dates and times (depends on datetimeparser).</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>-no-feature-datetimeparser</db:para>
</db:td>
<db:td>
<db:para>Parsing date-time texts.</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>-no-feature-dockwidget</db:para>
</db:td>
<db:td>
<db:para>Docking widgets inside a <db:link xlink:href="qmainwindow.xml">QMainWindow</db:link> or floating them as top-level windows on the desktop.</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>-no-feature-gestures</db:para>
</db:td>
<db:td>
<db:para>Framework for gestures.</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>-no-feature-mimetype</db:para>
</db:td>
<db:td>
<db:para>Mimetype handling.</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>-no-feature-qml-network</db:para>
</db:td>
<db:td>
<db:para>Network transparency.</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>-no-feature-qml-list-model</db:para>
</db:td>
<db:td>
<db:para><db:link xlink:href="qml-qtqml-models-listmodel.xml">ListModel</db:link> QML type.</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>-no-feature-qml-table-model</db:para>
</db:td>
<db:td>
<db:para><db:link xlink:href="qml-qt-labs-qmlmodels-tablemodel.xml">TableModel</db:link> QML type.</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>-no-feature-quick-canvas</db:para>
</db:td>
<db:td>
<db:para>Canvas item.</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>-no-feature-quick-path</db:para>
</db:td>
<db:td>
<db:para>Path elements.</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>-no-feature-quick-pathview</db:para>
</db:td>
<db:td>
<db:para><db:link xlink:href="qml-qtquick-pathview.xml">PathView</db:link> item.</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>-no-feature-quick-treeview</db:para>
</db:td>
<db:td>
<db:para><db:link xlink:href="qml-qtquick-treeview.xml">TreeView</db:link> item.</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>-no-feature-style-stylesheet</db:para>
</db:td>
<db:td>
<db:para>Widget style which is configurable via CSS.</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>-no-feature-tableview</db:para>
</db:td>
<db:td>
<db:para>Default model/view implementation of a table view.</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>-no-feature-texthtmlparser</db:para>
</db:td>
<db:td>
<db:para>Parser for HTML.</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>-no-feature-textmarkdownreader</db:para>
</db:td>
<db:td>
<db:para>Markdown (CommonMark and GitHub) reader.</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>-no-feature-textodfwriter</db:para>
</db:td>
<db:td>
<db:para>ODF writer.</db:para>
</db:td>
</db:tr>
</db:informaltable>
</db:section>
</db:section>
<db:section xml:id="wasm-exceptions">
<db:title>Wasm Exceptions</db:title>
<db:para>Qt is built without exception support by default, where throwing an exception will abort the program. <db:link xlink:href="https://emscripten.org/docs/porting/exceptions.html#webassembly-exception-handling-based-support">WebAssembly exceptions</db:link> can be enabled by building from source and passing the -feature-wasm-exceptions flag to Qt configure. This will pass the -fwasm-exceptions flag to the compiler at compile and link time. Qt does not support enabling Emscripten's support for the earlier JavaScript-based exception implementation.</db:para>
<db:para>Note that calling <db:link xlink:href="qapplication.xml#exec">QApplication::exec</db:link>() is not supported when exceptions are enabled, due to internal implementation details. Instead, write main() in the form where it returns early and does not call exec(), as described in <db:link xlink:href="wasm.xml#application-startup-and-the-event-loop">Application Startup and the Event Loop</db:link>.</db:para>
</db:section>
<db:section xml:id="shared-libraries-and-dynamic-linking-developer-preview">
<db:title>Shared Libraries and Dynamic Linking Developer Preview</db:title>
<db:para>Qt for WebAssembly uses static linking by default, where the application is deployed as a single WebAssembly file which contains the Qt libraries and application code. Dynamic linking is an alternative build mode where each library and plugin is distributed individually.</db:para>
<db:para>For instance, an application which uses Qt Quick may make use of the following libraries and plugins:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para>&lt;qtpath&gt;/lib/libQt6Core.so</db:para>
</db:listitem>
<db:listitem>
<db:para>&lt;qtpath&gt;/lib/libQt6Gui.so</db:para>
</db:listitem>
<db:listitem>
<db:para>&lt;qtpath&gt;/lib/libQt6Qml.so</db:para>
</db:listitem>
<db:listitem>
<db:para>&lt;qtpath&gt;/lib/libQt6Quick.so</db:para>
</db:listitem>
<db:listitem>
<db:para>&lt;qtpath&gt;/plugins/imageformats/libqjpeg.so</db:para>
</db:listitem>
<db:listitem>
<db:para>&lt;qtpath&gt;/plugins/imageformats/libqjgif.so</db:para>
</db:listitem>
<db:listitem>
<db:para>&lt;qtpath&gt;/qml/<db:link xlink:href="qtquick-module.xml">QtQuick</db:link>/Window/libquickwindowplugin.so</db:para>
</db:listitem>
</db:itemizedlist>
<db:para>Dynamic linking support is currently in developer preview. The implementation is suitable for prototyping and evaluation, but is not suitable for production use. Current limitations and restrictions include:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para>The Emscripten SDK must be patched. Use emsdk 3.1.37, and apply this <db:link xlink:href="https://github.com/emscripten-core/emscripten/pull/18418/commits/e9f86cebc3eb18f52e03ec67730f3edaa91d4564">patch</db:link>.</db:para>
</db:listitem>
<db:listitem>
<db:para>The Chrome browser is not supported, due it not supporting synchronous loading of wasm files larger than 4K.</db:para>
</db:listitem>
<db:listitem>
<db:para>Multithreading is not supported.</db:para>
</db:listitem>
<db:listitem>
<db:para>Asyncify is not supported.</db:para>
</db:listitem>
</db:itemizedlist>
<db:section xml:id="quick-start">
<db:title>Quick Start</db:title>
<db:para>The build and deployment procedure is slightly different than that from static wasm and shared desktop builds. Consider starting with a small example before progressing to a full application build.</db:para>
<db:orderedlist numeration="arabic">
<db:listitem>
<db:para>Build Qt from source, pass the “-shared” option to the Qt configure script.</db:para>
</db:listitem>
<db:listitem>
<db:para>Build your application using Qt from step 1.</db:para>
</db:listitem>
<db:listitem>
<db:para>Deploy the Qt installation by copying or linking to a directory named &quot;qt&quot; in the application directory</db:para>
<db:itemizedlist>
<db:listitem>
<db:para>ln -s &lt;qtpath&gt; qt</db:para>
</db:listitem>
<db:listitem>
<db:para>cp -r &lt;qtpath&gt; qt</db:para>
</db:listitem>
</db:itemizedlist>
</db:listitem>
<db:listitem>
<db:para>Create plugin preloading lists by running deployment scripts.</db:para>
<db:itemizedlist>
<db:listitem>
<db:para>&lt;qtpath&gt;/qtbase/util/wasm/preload/deploy_qt_plugins.py &lt;qtpath&gt;</db:para>
</db:listitem>
<db:listitem>
<db:para>&lt;qtpath&gt;/qtbase/util/wasm/preload/deploy_qml_imports.py &lt;qthostpath&gt; &lt;qtpath&gt;</db:para>
</db:listitem>
</db:itemizedlist>
</db:listitem>
</db:orderedlist>
</db:section>
<db:section xml:id="shared-libraries-deployment-in-depth">
<db:title>Shared Libraries Deployment in Depth</db:title>
<db:para>The shared libraries build of Qt is deployed in two stages, where the first stage makes the Qt and application build available for download from the web server, and the second stage downloads required Qt plugins and Qt Quick imports at application startup.</db:para>
<db:para>In the first step, make the Qt installation available for download from the web server. Depending on the specifics of the web server setup there may be different ways to accomplish this. In common is that the Qt loader expects to find the Qt libraries and plugins in a directory name &quot;qt&quot;, relative to the html file which loads the application.</db:para>
<db:para>If you are already copying the application to the web server as a part of deployment, then copying Qt as well is a possible option. If you are serving the application directly from its build directroy - often the case during development phases - then creating a symlink to Qt can work well.</db:para>
<db:para>Prepare for the second step by creating preload lists for Qt components such as plugins and Qt Quick imports. Preloading ensures that all required Qt components are availabe at application startup. Delayed loading, where components are dowloaded on demand, is also possbile but is not covered here.</db:para>
<db:para>Preloading is implemented by the Qt JavaScript loader, which downloads files from the web server to the in-memory file system provided by Emscripten. Which files to download is specified using json-formatted download lists. Qt provides two scripts for generating preload lists, see Quick Start section above.</db:para>
</db:section>
</db:section>
<db:section xml:id="known-issues">
<db:title>Known Issues</db:title>
<db:itemizedlist>
<db:listitem>
<db:para>Nested event loops are not supported. Applications should not call API like <db:link xlink:href="qdialog.xml#exec">QDialog::exec</db:link>() and <db:link xlink:href="qeventloop.xml#exec">QEventLoop::exec</db:link>(). Experimental feature Asyncify could be used.</db:para>
</db:listitem>
<db:listitem>
<db:para>Printing is not supported</db:para>
</db:listitem>
<db:listitem>
<db:para><db:link xlink:href="qdnslookup.xml">QDnsLookup</db:link> lookups, <db:link xlink:href="qtcpsocket.xml">QTcpSocket</db:link>, <db:link xlink:href="qssl.xml">QSsl</db:link> do not work and are not supported due to the web sandbox</db:para>
</db:listitem>
<db:listitem>
<db:para>Fonts: Wasm sandbox does not allow access to system fonts. Font files must be distributed with the application, for example in Qt resources or downloading. Qt for WebAssembly itself embeds one such font.</db:para>
</db:listitem>
<db:listitem>
<db:para>There may be artifacts of uninitialized graphics memory on some Qt Quick Controls 2 components, such as checkboxes. This can sometimes be seen on HighDPi displays.</db:para>
</db:listitem>
<db:listitem>
<db:para>Native styles for Windows and macOS are not supported as Wasm as a platform is not providing that capability</db:para>
</db:listitem>
<db:listitem>
<db:para>Link time error such as &quot;wasm-ld: error: initial memory too small&quot;, requires adjustment of the initial memory size. Use QT_WASM_INITIAL_MEMORY to set the initial size in kb, which must be a multiple of 64KB (65536). Default is 50 MB. In CMakeLists.txt: set_target_properties(&lt;target&gt; PROPERTIES QT_WASM_INITIAL_MEMORY &quot;150MB&quot;)</db:para>
</db:listitem>
<db:listitem>
<db:para>add_executable in CMakeLists.txt does not produce &lt;target&gt;.html or copy qtloader.js. Use qt_add_executable instead.</db:para>
</db:listitem>
<db:listitem>
<db:para><db:link xlink:href="qwebsocket.xml">QWebSocket</db:link> connections are supported by Emscripten only on the main thread.</db:para>
</db:listitem>
<db:listitem>
<db:para>QWebSockets for WebAssembly does not support sending ping or pong frames, as the API available to web pages and browsers does not expose this functionality.</db:para>
</db:listitem>
<db:listitem>
<db:para>Runtime error such as &quot;RangeError: Out of memory&quot; can be worked around by setting MAXIMUM_MEMORY to a value the device supports, for example</db:para>
<db:programlisting language="cpp" role="bad">target_link_options(&amp;lt;your target&amp;gt; PRIVATE -s MAXIMUM_MEMORY=1GB)
</db:programlisting>
</db:listitem>
<db:listitem>
<db:para>To use QtWebsockets, the subprotocol might need to be set to 'mqtt' for using <db:link xlink:href="qtmqtt-module.xml">QtMqtt</db:link>. Use <db:link xlink:href="qwebsockethandshakeoptions.xml">QWebSocketHandshakeOptions</db:link> when you open the <db:link xlink:href="qwebsocket.xml">QWebSocket</db:link>.</db:para>
</db:listitem>
</db:itemizedlist>
</db:section>
</db:section>
<db:section xml:id="other-topics">
<db:title>Other Topics</db:title>
<db:section xml:id="qt-configure-options-reference">
<db:title>Qt Configure Options Reference</db:title>
<db:para>The following configure options are relevant when building Qt for WebAssembly from source.</db:para>
<db:informaltable style="generic">
<db:thead>
<db:tr>
<db:th>
<db:para>Configure Argument</db:para>
</db:th>
<db:th>
<db:para>Brief Description</db:para>
</db:th>
</db:tr>
</db:thead>
<db:tr valign="top">
<db:td>
<db:para>-feature-thread</db:para>
</db:td>
<db:td>
<db:para>Multi-threaded Wasm.</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>-feature-wasm-simd128</db:para>
</db:td>
<db:td>
<db:para>Enables WebAssembly SIMD support.</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>-feature-wasm-exceptions</db:para>
</db:td>
<db:td>
<db:para>Enables WebAssembly exceptions support.</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>-feature-opengles3</db:para>
</db:td>
<db:td>
<db:para>Use opengles3 in addition to the default opengles2.</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>-device-option QT_EMSCRIPTEN_ASYNCIFY=1</db:para>
</db:td>
<db:td>
<db:para>Use asyncify.</db:para>
</db:td>
</db:tr>
</db:informaltable>
<db:anchor xml:id="disabled-features"/>
<db:para>Qt disables some features by default for the WebAssembly platform, to reduce the binary size. You can explicitly enable a feature when you configure Qt for WebAssembly:</db:para>
<db:informaltable style="generic">
<db:thead>
<db:tr>
<db:th>
<db:para>Configure Argument</db:para>
</db:th>
<db:th>
<db:para>Brief Description</db:para>
</db:th>
</db:tr>
</db:thead>
<db:tr valign="top">
<db:td>
<db:para>-feature-topleveldomain</db:para>
</db:td>
<db:td>
<db:para>Provides support for checking if a domain is a top-level domain.</db:para>
</db:td>
</db:tr>
</db:informaltable>
</db:section>
<db:section xml:id="typical-download-sizes">
<db:title>Typical Download Sizes</db:title>
<db:para>Expected footprint (download size): Wasm modules as produced by the compiler can be large, but compress well:</db:para>
<db:informaltable style="generic">
<db:thead>
<db:tr>
<db:th>
<db:para>Example</db:para>
</db:th>
<db:th>
<db:para>gzip</db:para>
</db:th>
<db:th>
<db:para>brotli</db:para>
</db:th>
</db:tr>
</db:thead>
<db:tr valign="top">
<db:td>
<db:para>helloglwindow (<db:link xlink:href="qtcore-module.xml">QtCore</db:link> + <db:link xlink:href="qtgui-module.xml">QtGui</db:link>)</db:para>
</db:td>
<db:td>
<db:para>2.8M</db:para>
</db:td>
<db:td>
<db:para>2.1M</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>wiggly widget (<db:link xlink:href="qtcore-module.xml">QtCore</db:link> + <db:link xlink:href="qtgui-module.xml">QtGui</db:link> + <db:link xlink:href="qtwidgets-module.xml">QtWidgets</db:link>)</db:para>
</db:td>
<db:td>
<db:para>4.3M</db:para>
</db:td>
<db:td>
<db:para>3.2M</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>SensorTag (<db:link xlink:href="qtcore-module.xml">QtCore</db:link> + <db:link xlink:href="qtgui-module.xml">QtGui</db:link> + <db:link xlink:href="qtwidgets-module.xml">QtWidgets</db:link> + <db:link xlink:href="qtquick-module.xml">QtQuick</db:link> + <db:link xlink:href="qtcharts-qmlmodule.xml">QtCharts</db:link>)</db:para>
</db:td>
<db:td>
<db:para>8.6M</db:para>
</db:td>
<db:td>
<db:para>6.3M</db:para>
</db:td>
</db:tr>
</db:informaltable>
<db:para>Compression is typically handled on the web server side, using standard compression features: the server compresses automatically or picks up pre-compressed versions of the files. There's generally no need to have special handling of Wasm files.</db:para>
<db:para>For more information, see <db:link xlink:href="wasm.xml#minimizing-the-size-of-binaries">Minimizing the size of binaries</db:link>.</db:para>
</db:section>
<db:section xml:id="examples">
<db:title>Examples</db:title>
<db:itemizedlist>
<db:listitem>
<db:para><db:link xlink:href="https://www.qt.io/web-assembly-example-industrial-panel">Industrial Panel Demo</db:link></db:para>
</db:listitem>
<db:listitem>
<db:para><db:link xlink:href="https://www.qt.io/web-assembly-example-slate">QMainWindow app</db:link></db:para>
</db:listitem>
<db:listitem>
<db:para><db:link xlink:href="https://www.qt.io/web-assembly-example-gallery">A gallery of available controls in Qt Quick Controls</db:link></db:para>
</db:listitem>
<db:listitem>
<db:para><db:link xlink:href="https://www.qt.io/web-assembly-example-pizza-shop">Web app for ordering pizzas</db:link></db:para>
</db:listitem>
</db:itemizedlist>
</db:section>
</db:section>
<db:section xml:id="external-resources">
<db:title>External resources</db:title>
<db:itemizedlist>
<db:listitem>
<db:para><db:link xlink:href="https://webassembly.org">WebAssembly Resource site</db:link></db:para>
</db:listitem>
</db:itemizedlist>
</db:section>
<db:section xml:id="license">
<db:title>License</db:title>
<db:para>Qt for WebAssembly is available under commercial licenses from <db:link xlink:href="http://www.qt.io/about-us/">The Qt Company</db:link>. In addition, it is available under the <db:link xlink:href="http://www.gnu.org/licenses/gpl-3.0.html">GNU General Public License, version 3</db:link>. See <db:link xlink:href="licensing.xml">Qt Licensing</db:link> for further details.</db:para>
</db:section>
</db:article>
