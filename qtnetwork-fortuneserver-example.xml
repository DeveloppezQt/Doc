<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en_US">
<db:info>
<db:title>Fortune Server Example</db:title>
<db:productname>QtNetwork</db:productname>
<db:edition>Qt 5.2.1 Reference Documentation</db:edition>
<db:titleabbrev>Qt Network Reference Documentation</db:titleabbrev>
<db:abstract>
<db:para>Demonstrates how to create a server for a network service.</db:para>
</db:abstract>
<db:pubdate>2025-06-29</db:pubdate>
<db:date>2025-06-29</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:para>This example is intended to be run alongside the <db:link xlink:href="qtnetwork-fortuneclient-example.xml">Fortune Client</db:link> example or the <db:link xlink:href="qtnetwork-blockingfortuneclient-example.xml">Blocking Fortune Client</db:link> example.</db:para>
<db:mediaobject>
<db:alt>Screenshot of the Fortune Server example</db:alt>
<db:imageobject>
<db:imagedata fileref="images/fortuneserver-example.png"/>
</db:imageobject>
</db:mediaobject>
<db:para>It uses QTcpServer to accept incoming TCP connections, and a simple <db:link xlink:href="qdatastream.xml">QDataStream</db:link> based data transfer protocol to write a fortune to the connecting client (from the <db:link xlink:href="qtnetwork-fortuneclient-example.xml">Fortune Client</db:link> example), before closing the connection.</db:para>
<db:programlisting language="cpp">class Server : public QDialog
{
    Q_OBJECT

public:
    Server(QWidget *parent = 0);

private slots:
    void sessionOpened();
    void sendFortune();

private:
    QLabel *statusLabel;
    QPushButton *quitButton;
    QTcpServer *tcpServer;
    QStringList fortunes;
    QNetworkSession *networkSession;
};
</db:programlisting>
<db:para>The server is implemented using a simple class with only one slot, for handling incoming connections.</db:para>
<db:programlisting language="cpp">    tcpServer = new QTcpServer(this);
    if (!tcpServer-&gt;listen()) {
        QMessageBox::critical(this, tr(&quot;Fortune Server&quot;),
                              tr(&quot;Unable to start the server: %1.&quot;)
                              .arg(tcpServer-&gt;errorString()));
        close();
        return;
    }
    QString ipAddress;
    QList&lt;QHostAddress&gt; ipAddressesList = QNetworkInterface::allAddresses();
    // use the first non-localhost IPv4 address
    for (int i = 0; i &lt; ipAddressesList.size(); ++i) {
        if (ipAddressesList.at(i) != QHostAddress::LocalHost &amp;&amp;
            ipAddressesList.at(i).toIPv4Address()) {
            ipAddress = ipAddressesList.at(i).toString();
            break;
        }
    }
    // if we did not find one, use IPv4 localhost
    if (ipAddress.isEmpty())
        ipAddress = QHostAddress(QHostAddress::LocalHost).toString();
    statusLabel-&gt;setText(tr(&quot;The server is running on\n\nIP: %1\nport: %2\n\n&quot;
                            &quot;Run the Fortune Client example now.&quot;)
                         .arg(ipAddress).arg(tcpServer-&gt;serverPort()));
</db:programlisting>
<db:para>In its constructor, our Server object calls QTcpServer::listen() to set up a QTcpServer to listen on all addresses, on an arbitrary port. In then displays the port QTcpServer picked in a label, so that user knows which port the fortune client should connect to.</db:para>
<db:programlisting language="cpp">    fortunes &lt;&lt; tr(&quot;You've been leading a dog's life. Stay off the furniture.&quot;)
             &lt;&lt; tr(&quot;You've got to think about tomorrow.&quot;)
             &lt;&lt; tr(&quot;You will be surprised by a loud noise.&quot;)
             &lt;&lt; tr(&quot;You will feel hungry again in another hour.&quot;)
             &lt;&lt; tr(&quot;You might have mail.&quot;)
             &lt;&lt; tr(&quot;You cannot kill time without injuring eternity.&quot;)
             &lt;&lt; tr(&quot;Computers are not intelligent. They only think they are.&quot;);
</db:programlisting>
<db:para>Our server generates a list of random fortunes that it can send to connecting clients.</db:para>
<db:programlisting language="cpp">    connect(tcpServer, SIGNAL(newConnection()), this, SLOT(sendFortune()));
</db:programlisting>
<db:para>When a client connects to our server, QTcpServer will emit QTcpServer::newConnection(). In turn, this will invoke our sendFortune() slot:</db:para>
<db:programlisting language="cpp">void Server::sendFortune()
{
    QByteArray block;
    QDataStream out(&amp;block, QIODevice::WriteOnly);
    out.setVersion(QDataStream::Qt_4_0);
</db:programlisting>
<db:para>The purpose of this slot is to select a random line from our list of fortunes, encode it into a <db:link xlink:href="qbytearray.xml">QByteArray</db:link> using <db:link xlink:href="qdatastream.xml">QDataStream</db:link>, and then write it to the connecting socket. This is a common way to transfer binary data using QTcpSocket. First we create a <db:link xlink:href="qbytearray.xml">QByteArray</db:link> and a <db:link xlink:href="qdatastream.xml">QDataStream</db:link> object, passing the bytearray to <db:link xlink:href="qdatastream.xml">QDataStream</db:link>'s constructor. We then explicitly set the protocol version of <db:link xlink:href="qdatastream.xml">QDataStream</db:link> to <db:link xlink:href="qdatastream.xml#Version-enum">QDataStream::Qt_4_0</db:link> to ensure that we can communicate with clients from future versions of Qt. (See QDataStream::setVersion().)</db:para>
<db:programlisting language="cpp">    out &lt;&lt; (quint16)0;
    out &lt;&lt; fortunes.at(qrand() % fortunes.size());
    out.device()-&gt;seek(0);
    out &lt;&lt; (quint16)(block.size() - sizeof(quint16));
</db:programlisting>
<db:para>At the start of our <db:link xlink:href="qbytearray.xml">QByteArray</db:link>, we reserve space for a 16 bit integer that will contain the total size of the data block we are sending. We continue by streaming in a random fortune. Then we seek back to the beginning of the <db:link xlink:href="qbytearray.xml">QByteArray</db:link>, and overwrite the reserved 16 bit integer value with the total size of the array. By doing this, we provide a way for clients to verify how much data they can expect before reading the whole packet.</db:para>
<db:programlisting language="cpp">    QTcpSocket *clientConnection = tcpServer-&gt;nextPendingConnection();
    connect(clientConnection, SIGNAL(disconnected()),
            clientConnection, SLOT(deleteLater()));
</db:programlisting>
<db:para>We then call QTcpServer::newPendingConnection(), which returns the QTcpSocket representing the server side of the connection. By connecting QTcpSocket::disconnected() to QObject::deleteLater(), we ensure that the socket will be deleted after disconnecting.</db:para>
<db:programlisting language="cpp">    clientConnection-&gt;write(block);
    clientConnection-&gt;disconnectFromHost();
}
</db:programlisting>
<db:para>The encoded fortune is written using QTcpSocket::write(), and we finally call QTcpSocket::disconnectFromHost(), which will close the connection after QTcpSocket has finished writing the fortune to the network. Because QTcpSocket works asynchronously, the data will be written after this function returns, and control goes back to Qt's event loop. The socket will then close, which in turn will cause QObject::deleteLater() to delete it.</db:para>
<db:section>
<db:title>List of Files</db:title>
<db:para>Files:</db:para>
<db:section>
<db:title>List of Files</db:title>
<db:itemizedlist>
<db:listitem>
<db:para><db:link xlink:href="fortuneserver/fortuneserver.pro">fortuneserver/fortuneserver.pro</db:link></db:para></db:listitem>
<db:listitem>
<db:para><db:link xlink:href="fortuneserver/main.cpp">fortuneserver/main.cpp</db:link></db:para></db:listitem>
<db:listitem>
<db:para><db:link xlink:href="fortuneserver/server.cpp">fortuneserver/server.cpp</db:link></db:para></db:listitem>
<db:listitem>
<db:para><db:link xlink:href="fortuneserver/server.h">fortuneserver/server.h</db:link></db:para></db:listitem>
</db:itemizedlist>
</db:section>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtnetwork-fortuneclient-example.xml">Fortune Client Example</db:link></db:member>
<db:member><db:link xlink:href="qtnetwork-threadedfortuneserver-example.xml">Threaded Fortune Server Example</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section></db:article>
