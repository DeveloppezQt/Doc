<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en">
<db:info>
<db:title>Fortune Server Example</db:title>
<db:productname>QtNetwork</db:productname>
<db:edition>Qt 5.11.3 Reference Documentation</db:edition>
<db:titleabbrev>Qt Network Reference Documentation</db:titleabbrev>
<db:abstract>
<db:para>Demonstrates how to create a server for a network service.</db:para>
</db:abstract>
<db:pubdate>2024-12-27</db:pubdate>
<db:date>2024-12-27</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:para>This example is intended to be run alongside the <db:link xlink:href="qtnetwork-fortuneclient-example.xml">Fortune Client</db:link> example or the <db:link xlink:href="qtnetwork-blockingfortuneclient-example.xml">Blocking Fortune Client Example</db:link>.</db:para>
<db:mediaobject>
<db:alt>Screenshot of the Fortune Server example</db:alt>
<db:imageobject>
<db:imagedata fileref="images/fortuneserver-example.png"/>
</db:imageobject>
</db:mediaobject>
<db:para>It uses <db:link xlink:href="qtcpserver.xml">QTcpServer</db:link> to accept incoming TCP connections, and a simple <db:link xlink:href="qdatastream.xml">QDataStream</db:link> based data transfer protocol to write a fortune to the connecting client (from the <db:link xlink:href="qtnetwork-fortuneclient-example.xml">Fortune Client</db:link> example), before closing the connection.</db:para>
<db:programlisting language="cpp">class Server : public QDialog
{
    Q_OBJECT

public:
    explicit Server(QWidget *parent = nullptr);

private slots:
    void sessionOpened();
    void sendFortune();

private:
    QLabel *statusLabel = nullptr;
    QTcpServer *tcpServer = nullptr;
    QVector&amp;lt;QString&amp;gt; fortunes;
    QNetworkSession *networkSession = nullptr;
};
</db:programlisting>
<db:para>The server is implemented using a simple class with only one slot, for handling incoming connections.</db:para>
<db:programlisting language="cpp">    tcpServer = new QTcpServer(this);
    if (!tcpServer-&amp;gt;listen()) {
        QMessageBox::critical(this, tr(&quot;Fortune Server&quot;),
                              tr(&quot;Unable to start the server: %1.&quot;)
                              .arg(tcpServer-&amp;gt;errorString()));
        close();
        return;
    }
    QString ipAddress;
    QList&amp;lt;QHostAddress&amp;gt; ipAddressesList = QNetworkInterface::allAddresses();
    // use the first non-localhost IPv4 address
    for (int i = 0; i &amp;lt; ipAddressesList.size(); ++i) {
        if (ipAddressesList.at(i) != QHostAddress::LocalHost &amp;amp;&amp;amp;
            ipAddressesList.at(i).toIPv4Address()) {
            ipAddress = ipAddressesList.at(i).toString();
            break;
        }
    }
    // if we did not find one, use IPv4 localhost
    if (ipAddress.isEmpty())
        ipAddress = QHostAddress(QHostAddress::LocalHost).toString();
    statusLabel-&amp;gt;setText(tr(&quot;The server is running on\n\nIP: %1\nport: %2\n\n&quot;
                            &quot;Run the Fortune Client example now.&quot;)
                         .arg(ipAddress).arg(tcpServer-&amp;gt;serverPort()));
</db:programlisting>
<db:para>In its constructor, our Server object calls <db:link xlink:href="qtcpserver.xml#listen">QTcpServer::listen</db:link>() to set up a <db:link xlink:href="qtcpserver.xml">QTcpServer</db:link> to listen on all addresses, on an arbitrary port. In then displays the port <db:link xlink:href="qtcpserver.xml">QTcpServer</db:link> picked in a label, so that user knows which port the fortune client should connect to.</db:para>
<db:programlisting language="cpp">fortunes &amp;lt;&amp;lt; tr(&quot;You've been leading a dog's life. Stay off the furniture.&quot;)
         &amp;lt;&amp;lt; tr(&quot;You've got to think about tomorrow.&quot;)
         &amp;lt;&amp;lt; tr(&quot;You will be surprised by a loud noise.&quot;)
         &amp;lt;&amp;lt; tr(&quot;You will feel hungry again in another hour.&quot;)
         &amp;lt;&amp;lt; tr(&quot;You might have mail.&quot;)
         &amp;lt;&amp;lt; tr(&quot;You cannot kill time without injuring eternity.&quot;)
         &amp;lt;&amp;lt; tr(&quot;Computers are not intelligent. They only think they are.&quot;);
</db:programlisting>
<db:para>Our server generates a list of random fortunes that it can send to connecting clients.</db:para>
<db:programlisting language="cpp">connect(tcpServer, &amp;amp;QTcpServer::newConnection, this, &amp;amp;Server::sendFortune);
</db:programlisting>
<db:para>When a client connects to our server, <db:link xlink:href="qtcpserver.xml">QTcpServer</db:link> will emit <db:link xlink:href="qtcpserver.xml#newConnection">QTcpServer::newConnection</db:link>(). In turn, this will invoke our sendFortune() slot:</db:para>
<db:programlisting language="cpp">void Server::sendFortune()
{
    QByteArray block;
    QDataStream out(&amp;amp;block, QIODevice::WriteOnly);
    out.setVersion(QDataStream::Qt_5_10);

    out &amp;lt;&amp;lt; fortunes[QRandomGenerator::global()-&amp;gt;bounded(fortunes.size())];
</db:programlisting>
<db:para>The purpose of this slot is to select a random line from our list of fortunes, encode it into a <db:link xlink:href="qbytearray.xml">QByteArray</db:link> using <db:link xlink:href="qdatastream.xml">QDataStream</db:link>, and then write it to the connecting socket. This is a common way to transfer binary data using <db:link xlink:href="qtcpsocket.xml">QTcpSocket</db:link>. First we create a <db:link xlink:href="qbytearray.xml">QByteArray</db:link> and a <db:link xlink:href="qdatastream.xml">QDataStream</db:link> object, passing the bytearray to <db:link xlink:href="qdatastream.xml">QDataStream</db:link>'s constructor. We then explicitly set the protocol version of <db:link xlink:href="qdatastream.xml">QDataStream</db:link> to <db:link xlink:href="qdatastream.xml#Version-enum">QDataStream::Qt_4_0</db:link> to ensure that we can communicate with clients from future versions of Qt (see <db:link xlink:href="qdatastream.xml#setVersion">QDataStream::setVersion</db:link>()). We continue by streaming in a random fortune.</db:para>
<db:programlisting language="cpp">    QTcpSocket *clientConnection = tcpServer-&amp;gt;nextPendingConnection();
    connect(clientConnection, &amp;amp;QAbstractSocket::disconnected,
            clientConnection, &amp;amp;QObject::deleteLater);
</db:programlisting>
<db:para>We then call <db:link xlink:href="qtcpserver.xml#nextPendingConnection">QTcpServer::nextPendingConnection</db:link>(), which returns the <db:link xlink:href="qtcpsocket.xml">QTcpSocket</db:link> representing the server side of the connection. By connecting <db:link xlink:href="qabstractsocket.xml#disconnected">QTcpSocket::disconnected</db:link>() to <db:link xlink:href="qobject.xml#deleteLater">QObject::deleteLater</db:link>(), we ensure that the socket will be deleted after disconnecting.</db:para>
<db:programlisting language="cpp">    clientConnection-&amp;gt;write(block);
    clientConnection-&amp;gt;disconnectFromHost();
}
</db:programlisting>
<db:para>The encoded fortune is written using <db:link xlink:href="qiodevice.xml#write">QTcpSocket::write</db:link>(), and we finally call <db:link xlink:href="qabstractsocket.xml#disconnectFromHost">QTcpSocket::disconnectFromHost</db:link>(), which will close the connection after <db:link xlink:href="qtcpsocket.xml">QTcpSocket</db:link> has finished writing the fortune to the network. Because <db:link xlink:href="qtcpsocket.xml">QTcpSocket</db:link> works asynchronously, the data will be written after this function returns, and control goes back to Qt's event loop. The socket will then close, which in turn will cause <db:link xlink:href="qobject.xml#deleteLater">QObject::deleteLater</db:link>() to delete it.</db:para>
<db:section>
<db:title>List of Files</db:title>
<db:para>Files:</db:para>
<db:section>
<db:title>List of Files</db:title>
<db:itemizedlist>
<db:listitem>
<db:para><db:link xlink:href="fortuneserver/fortuneserver.pro">fortuneserver/fortuneserver.pro</db:link></db:para></db:listitem>
<db:listitem>
<db:para><db:link xlink:href="fortuneserver/main.cpp">fortuneserver/main.cpp</db:link></db:para></db:listitem>
<db:listitem>
<db:para><db:link xlink:href="fortuneserver/server.cpp">fortuneserver/server.cpp</db:link></db:para></db:listitem>
<db:listitem>
<db:para><db:link xlink:href="fortuneserver/server.h">fortuneserver/server.h</db:link></db:para></db:listitem>
</db:itemizedlist>
</db:section>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtnetwork-fortuneclient-example.xml">Fortune Client Example</db:link></db:member>
<db:member><db:link xlink:href="qtnetwork-threadedfortuneserver-example.xml">Threaded Fortune Server Example</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section></db:article>
