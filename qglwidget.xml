<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en_US">
<db:info>
<db:title>QGLWidget Class</db:title>
<db:productname>qtopengl</db:productname>
<db:titleabbrev>qtopengl Reference Documentation</db:titleabbrev>
<db:abstract>
<db:para>The <db:link xlink:href="qglwidget.xml">QGLWidget</db:link> class is a widget for rendering OpenGL graphics.</db:para>
</db:abstract>
<db:pubdate>2025-06-29</db:pubdate>
<db:date>2025-06-29</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:variablelist>
<db:varlistentry>
<db:term>Header</db:term>
<db:listitem>
<db:para>QGLWidget</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Inherits</db:term>
<db:listitem>
<db:para/>
</db:listitem>
</db:varlistentry>
</db:variablelist>
<db:section xml:id="details">
<db:title>Detailed Description</db:title>
<db:para><db:link xlink:href="qglwidget.xml">QGLWidget</db:link> provides functionality for displaying OpenGL graphics integrated into a Qt application. It is very simple to use. You inherit from it and use the subclass like any other QWidget, except that you have the choice between using <db:link xlink:href="qpainter.xml">QPainter</db:link> and standard OpenGL rendering commands.</db:para>
<db:para><db:link xlink:href="qglwidget.xml">QGLWidget</db:link> provides three convenient virtual functions that you can reimplement in your subclass to perform the typical OpenGL tasks:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:link xlink:href="qglwidget.xml#paintGL">paintGL</db:link>() - Renders the OpenGL scene. Gets called whenever the widget needs to be updated.</db:para>
</db:listitem>
<db:listitem>
<db:para>resizeGL() - Sets up the OpenGL viewport, projection, etc. Gets called whenever the widget has been resized (and also when it is shown for the first time because all newly created widgets get a resize event automatically).</db:para>
</db:listitem>
<db:listitem>
<db:para><db:link xlink:href="qglwidget.xml#initializeGL">initializeGL</db:link>() - Sets up the OpenGL rendering context, defines display lists, etc. Gets called once before the first time resizeGL() or <db:link xlink:href="qglwidget.xml#paintGL">paintGL</db:link>() is called.</db:para>
</db:listitem>
</db:itemizedlist>
<db:para>Here is a rough outline of how a <db:link xlink:href="qglwidget.xml">QGLWidget</db:link> subclass might look:</db:para>
<db:programlisting language="cpp">class MyGLDrawer : public QGLWidget
{
    Q_OBJECT        // must include this if you use Qt signals/slots

public:
    MyGLDrawer(QWidget *parent)
        : QGLWidget(parent) {}

protected:

    void initializeGL()
    {
        // Set up the rendering context, define display lists etc.:
        ...
        glClearColor(0.0, 0.0, 0.0, 0.0);
        glEnable(GL_DEPTH_TEST);
        ...
    }

    void resizeGL(int w, int h)
    {
        // setup viewport, projection etc.:
        glViewport(0, 0, (GLint)w, (GLint)h);
        ...
        glFrustum(...);
        ...
    }

    void paintGL()
    {
        // draw the scene:
        ...
        glRotatef(...);
        glMaterialfv(...);
        glBegin(GL_QUADS);
        glVertex3f(...);
        glVertex3f(...);
        ...
        glEnd();
        ...
    }

};
</db:programlisting>
<db:para>If you need to trigger a repaint from places other than <db:link xlink:href="qglwidget.xml#paintGL">paintGL</db:link>() (a typical example is when using <db:link xlink:href="qtimer.xml">timers</db:link> to animate scenes), you should call the widget's updateGL() function.</db:para>
<db:para>Your widget's OpenGL rendering context is made current when <db:link xlink:href="qglwidget.xml#paintGL">paintGL</db:link>(), resizeGL(), or <db:link xlink:href="qglwidget.xml#initializeGL">initializeGL</db:link>() is called. If you need to call the standard OpenGL API functions from other places (e.g. in your widget's constructor or in your own paint functions), you must call makeCurrent() first.</db:para>
<db:para><db:link xlink:href="qglwidget.xml">QGLWidget</db:link> provides functions for requesting a new display <db:link xlink:href="qglformat.xml">format</db:link> and you can also create widgets with customized rendering <db:link xlink:href="qglcontext.xml">contexts</db:link>.</db:para>
<db:para>You can also share OpenGL display lists between <db:link xlink:href="qglwidget.xml">QGLWidget</db:link> objects (see the documentation of the <db:link xlink:href="qglwidget.xml">QGLWidget</db:link> constructors for details).</db:para>
<db:para>Note that under Windows, the <db:link xlink:href="qglcontext.xml">QGLContext</db:link> belonging to a <db:link xlink:href="qglwidget.xml">QGLWidget</db:link> has to be recreated when the <db:link xlink:href="qglwidget.xml">QGLWidget</db:link> is reparented. This is necessary due to limitations on the Windows platform. This will most likely cause problems for users that have subclassed and installed their own <db:link xlink:href="qglcontext.xml">QGLContext</db:link> on a <db:link xlink:href="qglwidget.xml">QGLWidget</db:link>. It is possible to work around this issue by putting the <db:link xlink:href="qglwidget.xml">QGLWidget</db:link> inside a dummy widget and then reparenting the dummy widget, instead of the <db:link xlink:href="qglwidget.xml">QGLWidget</db:link>. This will side-step the issue altogether, and is what we recommend for users that need this kind of functionality.</db:para>
<db:para>On Mac OS X, when Qt is built with Cocoa support, a <db:link xlink:href="qglwidget.xml">QGLWidget</db:link> can't have any sibling widgets placed ontop of itself. This is due to limitations in the Cocoa API and is not supported by Apple.</db:para>
<db:section xml:id="overlays">
<db:title>Overlays</db:title>
<db:para>The <db:link xlink:href="qglwidget.xml">QGLWidget</db:link> creates a GL overlay context in addition to the normal context if overlays are supported by the underlying system.</db:para>
<db:para>If you want to use overlays, you specify it in the <db:link xlink:href="qglformat.xml">format</db:link>. (Note: Overlay must be requested in the format passed to the <db:link xlink:href="qglwidget.xml">QGLWidget</db:link> constructor.) Your GL widget should also implement some or all of these virtual methods:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:link xlink:href="qglwidget.xml#paintOverlayGL">paintOverlayGL</db:link>()</db:para>
</db:listitem>
<db:listitem>
<db:para>resizeOverlayGL()</db:para>
</db:listitem>
<db:listitem>
<db:para><db:link xlink:href="qglwidget.xml#initializeOverlayGL">initializeOverlayGL</db:link>()</db:para>
</db:listitem>
</db:itemizedlist>
<db:para>These methods work in the same way as the normal <db:link xlink:href="qglwidget.xml#paintGL">paintGL</db:link>() etc. functions, except that they will be called when the overlay context is made current. You can explicitly make the overlay context current by using makeOverlayCurrent(), and you can access the overlay context directly (e.g. to ask for its transparent color) by calling overlayContext().</db:para>
<db:para>On X servers in which the default visual is in an overlay plane, non-GL Qt windows can also be used for overlays.</db:para>
</db:section>
<db:section xml:id="painting-techniques">
<db:title>Painting Techniques</db:title>
<db:para>As described above, subclass <db:link xlink:href="qglwidget.xml">QGLWidget</db:link> to render pure 3D content in the following way:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para>Reimplement the <db:link xlink:href="qglwidget.xml#initializeGL">QGLWidget::initializeGL</db:link>() and QGLWidget::resizeGL() to set up the OpenGL state and provide a perspective transformation.</db:para>
</db:listitem>
<db:listitem>
<db:para>Reimplement <db:link xlink:href="qglwidget.xml#paintGL">QGLWidget::paintGL</db:link>() to paint the 3D scene, calling only OpenGL functions to draw on the widget.</db:para>
</db:listitem>
</db:itemizedlist>
<db:para>It is also possible to draw 2D graphics onto a <db:link xlink:href="qglwidget.xml">QGLWidget</db:link> subclass, it is necessary to reimplement QGLWidget::paintEvent() and do the following:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para>Construct a <db:link xlink:href="qpainter.xml">QPainter</db:link> object.</db:para>
</db:listitem>
<db:listitem>
<db:para>Initialize it for use on the widget with the <db:link xlink:href="qpainter.xml#begin">QPainter::begin</db:link>() function.</db:para>
</db:listitem>
<db:listitem>
<db:para>Draw primitives using <db:link xlink:href="qpainter.xml">QPainter</db:link>'s member functions.</db:para>
</db:listitem>
<db:listitem>
<db:para>Call <db:link xlink:href="qpainter.xml#end">QPainter::end</db:link>() to finish painting.</db:para>
</db:listitem>
</db:itemizedlist>
<db:para>Overpainting 2D content on top of 3D content takes a little more effort. One approach to doing this is shown in the <db:link xlink:href="qtopengl-overpainting-example.xml">Overpainting</db:link> example.</db:para>
</db:section>
<db:section xml:id="threading">
<db:title>Threading</db:title>
<db:para>As of Qt version 4.8, support for doing threaded GL rendering has been improved. There are three scenarios that we currently support:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para>1. Buffer swapping in a thread.</db:para>
<db:para>Swapping buffers in a double buffered context may be a synchronous, locking call that may be a costly operation in some GL implementations. Especially so on embedded devices. It's not optimal to have the CPU idling while the GPU is doing a buffer swap. In those cases it is possible to do the rendering in the main thread and do the actual buffer swap in a separate thread. This can be done with the following steps:</db:para>
<db:para>1. Call doneCurrent() in the main thread when the rendering is finished.</db:para>
<db:para>2. Call <db:link xlink:href="qglcontext.xml#moveToThread">QGLContext::moveToThread</db:link>(swapThread) to transfer ownership of the context to the swapping thread.</db:para>
<db:para>3. Notify the swapping thread that it can grab the context.</db:para>
<db:para>4. Make the rendering context current in the swapping thread with makeCurrent() and then call swapBuffers().</db:para>
<db:para>5. Call doneCurrent() in the swapping thread.</db:para>
<db:para>6. Call <db:link xlink:href="qglcontext.xml#moveToThread">QGLContext::moveToThread</db:link>(qApp-&gt;thread()) and notify the main thread that swapping is done.</db:para>
<db:para>Doing this will free up the main thread so that it can continue with, for example, handling UI events or network requests. Even if there is a context swap involved, it may be preferable compared to having the main thread wait while the GPU finishes the swap operation. Note that this is highly implementation dependent.</db:para>
</db:listitem>
<db:listitem>
<db:para>2. Texture uploading in a thread.</db:para>
<db:para>Doing texture uploads in a thread may be very useful for applications handling large amounts of images that needs to be displayed, like for instance a photo gallery application. This is supported in Qt through the existing <db:link xlink:href="qglwidget.xml#bindTexture">bindTexture</db:link>() API. A simple way of doing this is to create two sharing QGLWidgets. One is made current in the main GUI thread, while the other is made current in the texture upload thread. The widget in the uploading thread is never shown, it is only used for sharing textures with the main thread. For each texture that is bound via <db:link xlink:href="qglwidget.xml#bindTexture">bindTexture</db:link>(), notify the main thread so that it can start using the texture.</db:para>
</db:listitem>
<db:listitem>
<db:para>3. Using <db:link xlink:href="qpainter.xml">QPainter</db:link> to draw into a <db:link xlink:href="qglwidget.xml">QGLWidget</db:link> in a thread.</db:para>
<db:para>In Qt 4.8, it is possible to draw into a <db:link xlink:href="qglwidget.xml">QGLWidget</db:link> using a <db:link xlink:href="qpainter.xml">QPainter</db:link> in a separate thread. Note that this is also possible for QGLPixelBuffers and QGLFramebufferObjects. Since this is only supported in the GL 2 paint engine, OpenGL 2.0 or OpenGL ES 2.0 is required.</db:para>
<db:para>QGLWidgets can only be created in the main GUI thread. This means a call to doneCurrent() is necessary to release the GL context from the main thread, before the widget can be drawn into by another thread. You then need to call <db:link xlink:href="qglcontext.xml#moveToThread">QGLContext::moveToThread</db:link>() to transfer ownership of the context to the thread in which you want to make it current. Also, the main GUI thread will dispatch resize and paint events to a <db:link xlink:href="qglwidget.xml">QGLWidget</db:link> when the widget is resized, or parts of it becomes exposed or needs redrawing. It is therefore necessary to handle those events because the default implementations inside <db:link xlink:href="qglwidget.xml">QGLWidget</db:link> will try to make the <db:link xlink:href="qglwidget.xml">QGLWidget</db:link>'s context current, which again will interfere with any threads rendering into the widget. Reimplement QGLWidget::paintEvent() and QGLWidget::resizeEvent() to notify the rendering thread that a resize or update is necessary, and be careful not to call the base class implementation. If you are rendering an animation, it might not be necessary to handle the paint event at all since the rendering thread is doing regular updates. Then it would be enough to reimplement QGLWidget::paintEvent() to do nothing.</db:para>
</db:listitem>
</db:itemizedlist>
<db:para>As a general rule when doing threaded rendering: be aware that binding and releasing contexts in different threads have to be synchronized by the user. A GL rendering context can only be current in one thread at any time. If you try to open a <db:link xlink:href="qpainter.xml">QPainter</db:link> on a <db:link xlink:href="qglwidget.xml">QGLWidget</db:link> and the widget's rendering context is current in another thread, it will fail.</db:para>
<db:para>In addition to this, rendering using raw GL calls in a separate thread is supported.</db:para>
<db:para><db:emphasis>OpenGL is a trademark of Silicon Graphics, Inc. in the United States and other countries.</db:emphasis></db:para>
</db:section>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qglpixelbuffer.xml" role="deprecated">QGLPixelBuffer</db:link></db:member>
<db:member><db:link xlink:href="qtopengl-hellogl-example.xml">Hello GL Example</db:link></db:member>
<db:member><db:link xlink:href="qtopengl-2dpainting-example.xml">2D Painting Example</db:link></db:member>
<db:member><db:link xlink:href="qtopengl-overpainting-example.xml">Overpainting Example</db:link></db:member>
<db:member><db:link xlink:href="qtopengl-grabber-example.xml">Grabber Example</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="member-function-documentation">
<db:title>Member Function Documentation</db:title>
<db:section xml:id="QGLWidget">
<db:title>[explicit] QGLWidget::QGLWidget(QWidget *<db:emphasis>parent</db:emphasis> = 0, const QGLWidget *<db:emphasis>shareWidget</db:emphasis> = 0, Qt::WindowFlags <db:emphasis>f</db:emphasis> = 0)</db:title>
<db:para>Constructs an OpenGL widget with a <db:code role="parameter">parent</db:code> widget.</db:para>
<db:para>The <db:link xlink:href="qglformat.xml#defaultFormat">default format</db:link> is used. The widget will be invalid if the system has no <db:link xlink:href="">OpenGL support</db:link>.</db:para>
<db:para>The <db:code role="parameter">parent</db:code> and widget flag, <db:code role="parameter">f</db:code>, arguments are passed to the QWidget constructor.</db:para>
<db:para>If <db:code role="parameter">shareWidget</db:code> is a valid <db:link xlink:href="qglwidget.xml">QGLWidget</db:link>, this widget will share OpenGL display lists and texture objects with <db:code role="parameter">shareWidget</db:code>. But if <db:code role="parameter">shareWidget</db:code> and this widget have different formats, sharing might not be possible. You can check whether sharing is in effect by calling isSharing().</db:para>
<db:para>The initialization of OpenGL rendering state, etc. should be done by overriding the <db:link xlink:href="qglwidget.xml#initializeGL">initializeGL</db:link>() function, rather than in the constructor of your <db:link xlink:href="qglwidget.xml">QGLWidget</db:link> subclass.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qglformat.xml#defaultFormat">QGLFormat::defaultFormat</db:link>()</db:member>
<db:member><db:link xlink:href="qtopengl-textures-example.xml">Textures Example</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="QGLWidget-1">
<db:title>[explicit] QGLWidget::QGLWidget(QGLContext *<db:emphasis>context</db:emphasis>, QWidget *<db:emphasis>parent</db:emphasis> = 0, const QGLWidget *<db:emphasis>shareWidget</db:emphasis> = 0, Qt::WindowFlags <db:emphasis>f</db:emphasis> = 0)</db:title>
<db:para>Constructs an OpenGL widget with parent <db:code role="parameter">parent</db:code>.</db:para>
<db:para>The <db:code role="parameter">context</db:code> argument is a pointer to the <db:link xlink:href="qglcontext.xml">QGLContext</db:link> that you wish to be bound to this widget. This allows you to pass in your own <db:link xlink:href="qglcontext.xml">QGLContext</db:link> sub-classes.</db:para>
<db:para>The widget will be invalid if the system has no <db:link xlink:href="">OpenGL support</db:link>.</db:para>
<db:para>The <db:code role="parameter">parent</db:code> and widget flag, <db:code role="parameter">f</db:code>, arguments are passed to the QWidget constructor.</db:para>
<db:para>If <db:code role="parameter">shareWidget</db:code> is a valid <db:link xlink:href="qglwidget.xml">QGLWidget</db:link>, this widget will share OpenGL display lists and texture objects with <db:code role="parameter">shareWidget</db:code>. But if <db:code role="parameter">shareWidget</db:code> and this widget have different formats, sharing might not be possible. You can check whether sharing is in effect by calling isSharing().</db:para>
<db:para>The initialization of OpenGL rendering state, etc. should be done by overriding the <db:link xlink:href="qglwidget.xml#initializeGL">initializeGL</db:link>() function, rather than in the constructor of your <db:link xlink:href="qglwidget.xml">QGLWidget</db:link> subclass.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qglformat.xml#defaultFormat">QGLFormat::defaultFormat</db:link>()</db:member>
<db:member><db:link xlink:href="">isValid()</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="QGLWidget-2">
<db:title>[explicit] QGLWidget::QGLWidget(const QGLFormat &amp;<db:emphasis>format</db:emphasis>, QWidget *<db:emphasis>parent</db:emphasis> = 0, const QGLWidget *<db:emphasis>shareWidget</db:emphasis> = 0, Qt::WindowFlags <db:emphasis>f</db:emphasis> = 0)</db:title>
<db:para>Constructs an OpenGL widget with parent <db:code role="parameter">parent</db:code>.</db:para>
<db:para>The <db:code role="parameter">format</db:code> argument specifies the desired <db:link xlink:href="qglformat.xml">rendering options</db:link>. If the underlying OpenGL/Window system cannot satisfy all the features requested in <db:code role="parameter">format</db:code>, the nearest subset of features will be used. After creation, the format() method will return the actual format obtained.</db:para>
<db:para>The widget will be invalid if the system has no <db:link xlink:href="">OpenGL support</db:link>.</db:para>
<db:para>The <db:code role="parameter">parent</db:code> and widget flag, <db:code role="parameter">f</db:code>, arguments are passed to the QWidget constructor.</db:para>
<db:para>If <db:code role="parameter">shareWidget</db:code> is a valid <db:link xlink:href="qglwidget.xml">QGLWidget</db:link>, this widget will share OpenGL display lists and texture objects with <db:code role="parameter">shareWidget</db:code>. But if <db:code role="parameter">shareWidget</db:code> and this widget have different formats, sharing might not be possible. You can check whether sharing is in effect by calling isSharing().</db:para>
<db:para>The initialization of OpenGL rendering state, etc. should be done by overriding the <db:link xlink:href="qglwidget.xml#initializeGL">initializeGL</db:link>() function, rather than in the constructor of your <db:link xlink:href="qglwidget.xml">QGLWidget</db:link> subclass.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qglformat.xml#defaultFormat">QGLFormat::defaultFormat</db:link>()</db:member>
<db:member><db:link xlink:href="">isValid()</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="dtor.QGLWidget">
<db:title>[virtual noexcept] QGLWidget::~QGLWidget()</db:title>
<db:para>Destroys the widget.</db:para>
</db:section>
<db:section xml:id="bindTexture">
<db:title>GLuint QGLWidget::bindTexture(const QImage &amp;<db:emphasis>image</db:emphasis>, GLenum <db:emphasis>target</db:emphasis> = GL_TEXTURE_2D, GLint <db:emphasis>format</db:emphasis> = GL_RGBA)</db:title>
<db:para>Calls QGLContext:::bindTexture(<db:code role="parameter">image</db:code>, <db:code role="parameter">target</db:code>, <db:code role="parameter">format</db:code>) on the currently set context.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qglwidget.xml#deleteTexture">deleteTexture</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="bindTexture-1">
<db:title>GLuint QGLWidget::bindTexture(const QPixmap &amp;<db:emphasis>pixmap</db:emphasis>, GLenum <db:emphasis>target</db:emphasis> = GL_TEXTURE_2D, GLint <db:emphasis>format</db:emphasis> = GL_RGBA)</db:title>
<db:para>Calls QGLContext:::<db:link xlink:href="qglwidget.xml#bindTexture">bindTexture</db:link>(<db:code role="parameter">pixmap</db:code>, <db:code role="parameter">target</db:code>, <db:code role="parameter">format</db:code>) on the currently set context.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qglwidget.xml#deleteTexture">deleteTexture</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="bindTexture-2">
<db:title>GLuint QGLWidget::bindTexture(const QString &amp;<db:emphasis>fileName</db:emphasis>)</db:title>
<db:para>This is an overloaded function.</db:para>
<db:para>Calls <db:link xlink:href="qglcontext.xml#bindTexture">QGLContext::bindTexture</db:link>(<db:code role="parameter">fileName</db:code>) on the currently set context.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qglwidget.xml#deleteTexture">deleteTexture</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="bindTexture-3">
<db:title>[since 4.6] GLuint QGLWidget::bindTexture(const QImage &amp;<db:emphasis>image</db:emphasis>, GLenum <db:emphasis>target</db:emphasis>, GLint <db:emphasis>format</db:emphasis>, QGLContext::BindOptions <db:emphasis>options</db:emphasis>)</db:title>
<db:para>This is an overloaded function.</db:para>
<db:para>The binding <db:code role="parameter">options</db:code> are a set of options used to decide how to bind the texture to the context.</db:para>
<db:para>This function was introduced in Qt 4.6.</db:para>
</db:section>
<db:section xml:id="bindTexture-4">
<db:title>[since 4.6] GLuint QGLWidget::bindTexture(const QPixmap &amp;<db:emphasis>pixmap</db:emphasis>, GLenum <db:emphasis>target</db:emphasis>, GLint <db:emphasis>format</db:emphasis>, QGLContext::BindOptions <db:emphasis>options</db:emphasis>)</db:title>
<db:para>This is an overloaded function.</db:para>
<db:para>Generates and binds a 2D GL texture to the current context, based on <db:code role="parameter">pixmap</db:code>. The generated texture id is returned and can be used in</db:para>
<db:para>The binding <db:code role="parameter">options</db:code> are a set of options used to decide how to bind the texture to the context.</db:para>
<db:para>This function was introduced in Qt 4.6.</db:para>
</db:section>
<db:section xml:id="convertToGLFormat">
<db:title>[static] QImage QGLWidget::convertToGLFormat(const QImage &amp;<db:emphasis>img</db:emphasis>)</db:title>
<db:para>Converts the image <db:code role="parameter">img</db:code> into the unnamed format expected by OpenGL functions such as glTexImage2D(). The returned image is not usable as a <db:link xlink:href="qimage.xml">QImage</db:link>, but <db:link xlink:href="qimage.xml#width">QImage::width</db:link>(), <db:link xlink:href="qimage.xml#height">QImage::height</db:link>() and <db:link xlink:href="qimage.xml#bits">QImage::bits</db:link>() may be used with OpenGL. The GL format used is <db:code>GL_RGBA</db:code>.</db:para>
</db:section>
<db:section xml:id="deleteTexture">
<db:title>void QGLWidget::deleteTexture(GLuint <db:emphasis>id</db:emphasis>)</db:title>
<db:para>Calls <db:link xlink:href="qglcontext.xml#deleteTexture">QGLContext::deleteTexture</db:link>(<db:code role="parameter">id</db:code>) on the currently set context.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qglwidget.xml#bindTexture">bindTexture</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="drawTexture">
<db:title>[since 4.4] void QGLWidget::drawTexture(const QPointF &amp;<db:emphasis>point</db:emphasis>, GLuint <db:emphasis>textureId</db:emphasis>, GLenum <db:emphasis>textureTarget</db:emphasis> = GL_TEXTURE_2D)</db:title>
<db:para>Calls the corresponding <db:link xlink:href="qglcontext.xml#drawTexture">QGLContext::drawTexture</db:link>() with <db:code role="parameter">point</db:code>, <db:code role="parameter">textureId</db:code>, and <db:code role="parameter">textureTarget</db:code> for this widget's context.</db:para>
<db:para>This function was introduced in Qt 4.4.</db:para>
</db:section>
<db:section xml:id="drawTexture-1">
<db:title>[since 4.4] void QGLWidget::drawTexture(const QRectF &amp;<db:emphasis>target</db:emphasis>, GLuint <db:emphasis>textureId</db:emphasis>, GLenum <db:emphasis>textureTarget</db:emphasis> = GL_TEXTURE_2D)</db:title>
<db:para>Calls the corresponding <db:link xlink:href="qglcontext.xml#drawTexture">QGLContext::drawTexture</db:link>() with <db:code role="parameter">target</db:code>, <db:code role="parameter">textureId</db:code>, and <db:code role="parameter">textureTarget</db:code> for this widget's context.</db:para>
<db:para>This function was introduced in Qt 4.4.</db:para>
</db:section>
<db:section xml:id="glDraw">
<db:title>[virtual protected] void QGLWidget::glDraw()</db:title>
<db:para>Executes the virtual function <db:link xlink:href="qglwidget.xml#paintGL">paintGL</db:link>().</db:para>
<db:para>The widget's rendering context will become the current context and <db:link xlink:href="qglwidget.xml#initializeGL">initializeGL</db:link>() will be called if it hasn't already been called.</db:para>
</db:section>
<db:section xml:id="glInit">
<db:title>[virtual protected] void QGLWidget::glInit()</db:title>
<db:para>Initializes OpenGL for this widget's context. Calls the virtual function <db:link xlink:href="qglwidget.xml#initializeGL">initializeGL</db:link>().</db:para>
</db:section>
<db:section xml:id="grabFrameBuffer">
<db:title>QImage QGLWidget::grabFrameBuffer(bool <db:emphasis>withAlpha</db:emphasis> = false)</db:title>
<db:para>Returns an image of the frame buffer. If <db:code role="parameter">withAlpha</db:code> is true the alpha channel is included.</db:para>
<db:para>Depending on your hardware, you can explicitly select which color buffer to grab with a glReadBuffer() call before calling this function.</db:para>
</db:section>
<db:section xml:id="initializeGL">
<db:title>[virtual protected] void QGLWidget::initializeGL()</db:title>
<db:para>This virtual function is called once before the first call to <db:link xlink:href="qglwidget.xml#paintGL">paintGL</db:link>() or resizeGL(), and then once whenever the widget has been assigned a new <db:link xlink:href="qglcontext.xml">QGLContext</db:link>. Reimplement it in a subclass.</db:para>
<db:para>This function should set up any required OpenGL context rendering flags, defining display lists, etc.</db:para>
<db:para>There is no need to call makeCurrent() because this has already been done when this function is called.</db:para>
</db:section>
<db:section xml:id="initializeOverlayGL">
<db:title>[virtual protected] void QGLWidget::initializeOverlayGL()</db:title>
<db:para>This virtual function is used in the same manner as <db:link xlink:href="qglwidget.xml#initializeGL">initializeGL</db:link>() except that it operates on the widget's overlay context instead of the widget's main context. This means that initializeOverlayGL() is called once before the first call to <db:link xlink:href="qglwidget.xml#paintOverlayGL">paintOverlayGL</db:link>() or resizeOverlayGL(). Reimplement it in a subclass.</db:para>
<db:para>This function should set up any required OpenGL context rendering flags, defining display lists, etc. for the overlay context.</db:para>
<db:para>There is no need to call makeOverlayCurrent() because this has already been done when this function is called.</db:para>
</db:section>
<db:section xml:id="paintGL">
<db:title>[virtual protected] void QGLWidget::paintGL()</db:title>
<db:para>This virtual function is called whenever the widget needs to be painted. Reimplement it in a subclass.</db:para>
<db:para>There is no need to call makeCurrent() because this has already been done when this function is called.</db:para>
</db:section>
<db:section xml:id="paintOverlayGL">
<db:title>[virtual protected] void QGLWidget::paintOverlayGL()</db:title>
<db:para>This virtual function is used in the same manner as <db:link xlink:href="qglwidget.xml#paintGL">paintGL</db:link>() except that it operates on the widget's overlay context instead of the widget's main context. This means that paintOverlayGL() is called whenever the widget's overlay needs to be painted. Reimplement it in a subclass.</db:para>
<db:para>There is no need to call makeOverlayCurrent() because this has already been done when this function is called.</db:para>
</db:section>
<db:section xml:id="qglClearColor">
<db:title>void QGLWidget::qglClearColor(const QColor &amp;<db:emphasis>c</db:emphasis>) const</db:title>
<db:para>Convenience function for specifying the clearing color to OpenGL. Calls glClearColor (in RGBA mode) or glClearIndex (in color-index mode) with the color <db:code role="parameter">c</db:code>. Applies to this widgets GL context.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qglwidget.xml#qglColor">qglColor</db:link>()</db:member>
<db:member><db:link xlink:href="">QGLContext::currentContext()</db:link></db:member>
<db:member><db:link xlink:href="qcolor.xml">QColor</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="qglColor">
<db:title>void QGLWidget::qglColor(const QColor &amp;<db:emphasis>c</db:emphasis>) const</db:title>
<db:para>Convenience function for specifying a drawing color to OpenGL. Calls glColor4 (in RGBA mode) or glIndex (in color-index mode) with the color <db:code role="parameter">c</db:code>. Applies to this widgets GL context.</db:para>
<db:note>
<db:para>This function is not supported on OpenGL/ES 2.0 systems.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qglwidget.xml#qglClearColor">qglClearColor</db:link>()</db:member>
<db:member><db:link xlink:href="">QGLContext::currentContext()</db:link></db:member>
<db:member><db:link xlink:href="qcolor.xml">QColor</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="renderPixmap">
<db:title>QPixmap QGLWidget::renderPixmap(int <db:emphasis>w</db:emphasis> = 0, int <db:emphasis>h</db:emphasis> = 0, bool <db:emphasis>useContext</db:emphasis> = false)</db:title>
<db:para>Renders the current scene on a pixmap and returns the pixmap.</db:para>
<db:para>You can use this method on both visible and invisible <db:link xlink:href="qglwidget.xml">QGLWidget</db:link> objects.</db:para>
<db:para>This method will create a pixmap and a temporary <db:link xlink:href="qglcontext.xml">QGLContext</db:link> to render on the pixmap. It will then call <db:link xlink:href="qglwidget.xml#initializeGL">initializeGL</db:link>(), resizeGL(), and <db:link xlink:href="qglwidget.xml#paintGL">paintGL</db:link>() on this context. Finally, the widget's original GL context is restored.</db:para>
<db:para>The size of the pixmap will be <db:code role="parameter">w</db:code> pixels wide and <db:code role="parameter">h</db:code> pixels high unless one of these parameters is 0 (the default), in which case the pixmap will have the same size as the widget.</db:para>
<db:para>If <db:code role="parameter">useContext</db:code> is true, this method will try to be more efficient by using the existing GL context to render the pixmap. The default is false. Only use true if you understand the risks. Note that under Windows a temporary context has to be created and usage of the <db:emphasis>useContext</db:emphasis> parameter is not supported.</db:para>
<db:para>Overlays are not rendered onto the pixmap.</db:para>
<db:para>If the GL rendering context and the desktop have different bit depths, the result will most likely look surprising.</db:para>
<db:para>Note that the creation of display lists, modifications of the view frustum etc. should be done from within <db:link xlink:href="qglwidget.xml#initializeGL">initializeGL</db:link>(). If this is not done, the temporary <db:link xlink:href="qglcontext.xml">QGLContext</db:link> will not be initialized properly, and the rendered pixmap may be incomplete/corrupted.</db:para>
</db:section>
<db:section xml:id="renderText">
<db:title>void QGLWidget::renderText(int <db:emphasis>x</db:emphasis>, int <db:emphasis>y</db:emphasis>, const QString &amp;<db:emphasis>str</db:emphasis>, const QFont &amp;<db:emphasis>font</db:emphasis> = QFont())</db:title>
<db:para>Renders the string <db:code role="parameter">str</db:code> into the GL context of this widget.</db:para>
<db:para><db:code role="parameter">x</db:code> and <db:code role="parameter">y</db:code> are specified in window coordinates, with the origin in the upper left-hand corner of the window. If <db:code role="parameter">font</db:code> is not specified, the currently set application font will be used to render the string. To change the color of the rendered text you can use the glColor() call (or the <db:link xlink:href="qglwidget.xml#qglColor">qglColor</db:link>() convenience function), just before the renderText() call.</db:para>
<db:note>
<db:para>This function clears the stencil buffer.</db:para>
</db:note>
<db:note>
<db:para>This function is not supported on OpenGL/ES systems.</db:para>
</db:note>
<db:note>
<db:para>This function temporarily disables depth-testing when the text is drawn.</db:para>
</db:note>
<db:note>
<db:para>This function can only be used inside a <db:link xlink:href="qpainter.xml#beginNativePainting">QPainter::beginNativePainting</db:link>()/<db:link xlink:href="qpainter.xml#endNativePainting">QPainter::endNativePainting</db:link>() block if a painter is active on the <db:link xlink:href="qglwidget.xml">QGLWidget</db:link>.</db:para>
</db:note>
<db:para><db:link xlink:href="qtopengl-overpainting-example.xml">Overpaint</db:link> with <db:link xlink:href="qpainter.xml#drawText">QPainter::drawText</db:link>() instead.</db:para>
</db:section>
<db:section xml:id="renderText-1">
<db:title>void QGLWidget::renderText(double <db:emphasis>x</db:emphasis>, double <db:emphasis>y</db:emphasis>, double <db:emphasis>z</db:emphasis>, const QString &amp;<db:emphasis>str</db:emphasis>, const QFont &amp;<db:emphasis>font</db:emphasis> = QFont())</db:title>
<db:para>This is an overloaded function.</db:para>
<db:para><db:code role="parameter">x</db:code>, <db:code role="parameter">y</db:code> and <db:code role="parameter">z</db:code> are specified in scene or object coordinates relative to the currently set projection and model matrices. This can be useful if you want to annotate models with text labels and have the labels move with the model as it is rotated etc.</db:para>
<db:note>
<db:para>This function is not supported on OpenGL/ES systems.</db:para>
</db:note>
<db:note>
<db:para>If depth testing is enabled before this function is called, then the drawn text will be depth-tested against the models that have already been drawn in the scene. Use <db:code>glDisable(GL_DEPTH_TEST)</db:code> before calling this function to annotate the models without depth-testing the text.</db:para>
</db:note>
<db:note>
<db:para>This function can only be used inside a <db:link xlink:href="qpainter.xml#beginNativePainting">QPainter::beginNativePainting</db:link>()/<db:link xlink:href="qpainter.xml#endNativePainting">QPainter::endNativePainting</db:link>() block if a painter is active on the <db:link xlink:href="qglwidget.xml">QGLWidget</db:link>.</db:para>
</db:note>
<db:para><db:link xlink:href="qtopengl-overpainting-example.xml">Overpaint</db:link> with <db:link xlink:href="qpainter.xml#drawText">QPainter::drawText</db:link>() instead.</db:para>
</db:section>
</db:section>
<db:section xml:id="obsolete">
<db:title>Obsolete Members for QGLWidget</db:title>
<db:para><db:emphasis role="bold">The following members of class <db:link xlink:href="qglwidget.xml">QGLWidget</db:link> are deprecated.</db:emphasis> We strongly advise against using them in new code.</db:para>
<db:section xml:id="obsolete-member-function-documentation">
<db:title>Obsolete Member Function Documentation</db:title>
<db:section xml:id="setFormat">
<db:title>[deprecated] void QGLWidget::setFormat(const QGLFormat &amp;<db:emphasis>format</db:emphasis>)</db:title>
<db:para>This function is deprecated. We strongly advise against using it in new code.</db:para>
<db:para>Sets a new format for this widget.</db:para>
<db:para>If the underlying OpenGL/Window system cannot satisfy all the features requested in <db:code role="parameter">format</db:code>, the nearest subset of features will be used. After creation, the format() method will return the actual rendering context format obtained.</db:para>
<db:para>The widget will be assigned a new <db:link xlink:href="qglcontext.xml">QGLContext</db:link>, and the <db:link xlink:href="qglwidget.xml#initializeGL">initializeGL</db:link>() function will be executed for this new context before the first resizeGL() or <db:link xlink:href="qglwidget.xml#paintGL">paintGL</db:link>().</db:para>
<db:para>This method will try to keep display list and texture object sharing in effect with other <db:link xlink:href="qglwidget.xml">QGLWidget</db:link> objects, but changing the format might make sharing impossible. Use isSharing() to see if sharing is still in effect.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="">format()</db:link></db:member>
<db:member><db:link xlink:href="">isSharing()</db:link></db:member>
<db:member><db:link xlink:href="">isValid()</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
</db:section>
</db:section>
</db:article>
