<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en">
<db:info>
<db:title>Wiggly Example</db:title>
<db:productname>QtWidgets</db:productname>
<db:edition>Qt 5.11.3 Reference Documentation</db:edition>
<db:titleabbrev>Qt Widgets Reference Documentation</db:titleabbrev>
<db:abstract>
<db:para>The Wiggly example shows how to animate a widget using <db:link xlink:href="qbasictimer.xml">QBasicTimer</db:link> and <db:link xlink:href="qobject.xml#timerEvent">timerEvent</db:link>(). In addition, the example demonstrates how to use <db:link xlink:href="qfontmetrics.xml">QFontMetrics</db:link> to determine the size of text on screen.</db:para>
</db:abstract>
<db:pubdate>2024-12-27</db:pubdate>
<db:date>2024-12-27</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:figure>
<db:title>Screenshot of the Wiggly example</db:title>
<db:mediaobject>
<db:imageobject>
<db:imagedata fileref="images/wiggly-example.png"/>
</db:imageobject>
</db:mediaobject>
</db:figure>
<db:para><db:link xlink:href="qbasictimer.xml">QBasicTimer</db:link> is a low-level class for timers. Unlike <db:link xlink:href="qtimer.xml">QTimer</db:link>, <db:link xlink:href="qbasictimer.xml">QBasicTimer</db:link> doesn't inherit from <db:link xlink:href="qobject.xml">QObject</db:link>; instead of emitting a <db:link xlink:href="qtimer.xml#timeout">timeout</db:link>() signal when a certain amount of time has passed, it sends a <db:link xlink:href="qtimerevent.xml">QTimerEvent</db:link> to a <db:link xlink:href="qobject.xml">QObject</db:link> of our choice. This makes <db:link xlink:href="qbasictimer.xml">QBasicTimer</db:link> a more lightweight alternative to <db:link xlink:href="qtimer.xml">QTimer</db:link>. Qt's built-in widgets use it internally, and it is provided in Qt's API for highly-optimized applications (such as embedded applications).</db:para>
<db:para>The example consists of two classes:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para>WigglyWidget is the custom widget displaying the text in a wiggly line.</db:para>
</db:listitem>
<db:listitem>
<db:para>Dialog is the dialog widget allowing the user to enter a text. It combines a WigglyWidget and a QLineEdit.</db:para>
</db:listitem>
</db:itemizedlist>
<db:para>We will first take a quick look at the Dialog class, then we will review the WigglyWidget class.</db:para>
<db:section xml:id="dialog-class-definition">
<db:title>Dialog Class Definition</db:title>
<db:programlisting language="cpp">class Dialog : public QDialog
{
    Q_OBJECT

public:
    explicit Dialog(QWidget *parent = 0);
};
</db:programlisting>
<db:para>The Dialog class provides a dialog widget that allows the user to enter a text. The text is then rendered by WigglyWidget.</db:para>
</db:section>
<db:section xml:id="dialog-class-implementation">
<db:title>Dialog Class Implementation</db:title>
<db:programlisting language="cpp">Dialog::Dialog(QWidget *parent)
    : QDialog(parent)
{
    WigglyWidget *wigglyWidget = new WigglyWidget;
    QLineEdit *lineEdit = new QLineEdit;

    QVBoxLayout *layout = new QVBoxLayout(this);
    layout-&amp;gt;addWidget(wigglyWidget);
    layout-&amp;gt;addWidget(lineEdit);

    connect(lineEdit, &amp;amp;QLineEdit::textChanged, wigglyWidget, &amp;amp;WigglyWidget::setText);
    lineEdit-&amp;gt;setText(tr(&quot;Hello world!&quot;));

    setWindowTitle(tr(&quot;Wiggly&quot;));
    resize(360, 145);
}
</db:programlisting>
<db:para>In the constructor we create a wiggly widget along with a <db:link xlink:href="qlineedit.xml">line edit</db:link>, and we put the two widgets in a vertical layout. We connect the line edit's <db:link xlink:href="qlineedit.xml#textChanged">textChanged</db:link>() signal to the wiggly widget's setText() slot to obtain the real time interaction with the wiggly widget. The widget's default text is &quot;Hello world!&quot;.</db:para>
</db:section>
<db:section xml:id="wigglywidget-class-definition">
<db:title>WigglyWidget Class Definition</db:title>
<db:programlisting language="cpp">class WigglyWidget : public QWidget
{
    Q_OBJECT

public:
    WigglyWidget(QWidget *parent = 0);

public slots:
    void setText(const QString &amp;amp;newText) { text = newText; }

protected:
    void paintEvent(QPaintEvent *event) override;
    void timerEvent(QTimerEvent *event) override;

private:
    QBasicTimer timer;
    QString text;
    int step;
};
</db:programlisting>
<db:para>The WigglyWidget class provides the wiggly line displaying the text. We subclass <db:link xlink:href="qwidget.xml">QWidget</db:link> and reimplement the standard <db:link xlink:href="qwidget.xml#paintEvent">paintEvent</db:link>() and <db:link xlink:href="qobject.xml#timerEvent">timerEvent</db:link>() functions to draw and update the widget. In addition we implement a public setText() slot that sets the widget's text.</db:para>
<db:para>The timer variable, of type <db:link xlink:href="qbasictimer.xml">QBasicTimer</db:link>, is used to update the widget at regular intervals, making the widget move. The text variable is used to store the currently displayed text, and step to calculate position and color for each character on the wiggly line.</db:para>
</db:section>
<db:section xml:id="wigglywidget-class-implementation">
<db:title>WigglyWidget Class Implementation</db:title>
<db:programlisting language="cpp">WigglyWidget::WigglyWidget(QWidget *parent)
    : QWidget(parent)
{
    setBackgroundRole(QPalette::Midlight);
    setAutoFillBackground(true);

    QFont newFont = font();
    newFont.setPointSize(newFont.pointSize() + 20);
    setFont(newFont);

    step = 0;
    timer.start(60, this);
}
</db:programlisting>
<db:para>In the constructor, we make the widget's background slightly lighter than the usual background using the <db:link xlink:href="qpalette.xml#ColorRole-enum">QPalette::Midlight</db:link> color role. The background role defines the brush from the widget's palette that Qt uses to paint the background. Then we enlarge the widget's font with 20 points.</db:para>
<db:para>Finally we start the timer; the call to <db:link xlink:href="qbasictimer.xml#start">QBasicTimer::start</db:link>() makes sure that <db:emphasis>this</db:emphasis> particular wiggly widget will receive the timer events generated when the timer times out (every 60 milliseconds).</db:para>
<db:programlisting language="cpp">void WigglyWidget::paintEvent(QPaintEvent * /* event */)
{
    static const int sineTable[16] = {
        0, 38, 71, 92, 100, 92, 71, 38, 0, -38, -71, -92, -100, -92, -71, -38
    };

    QFontMetrics metrics(font());
    int x = (width() - metrics.horizontalAdvance(text)) / 2;
    int y = (height() + metrics.ascent() - metrics.descent()) / 2;
    QColor color;
</db:programlisting>
<db:para>The paintEvent() function is called whenever a <db:link xlink:href="qpaintevent.xml">QPaintEvent</db:link> is sent to the widget. Paint events are sent to widgets that need to update themselves, for instance when part of a widget is exposed because a covering widget was moved. For the wiggly widget, a paint event will also be generated every 60 milliseconds from the timerEvent() slot.</db:para>
<db:para>The sineTable represents y-values of the sine curve, multiplied by 100. It is used to make the wiggly widget move along the sine curve.</db:para>
<db:para>The <db:link xlink:href="qfontmetrics.xml">QFontMetrics</db:link> object provides information about the widget's font. The x variable is the horizontal position where we start drawing the text. The y variable is the vertical position of the text's base line. Both variables are computed so that the text is horizontally and vertically centered. To compute the base line, we take into account the font's ascent (the height of the font above the base line) and font's descent (the height of the font below the base line). If the descent equals the ascent, they cancel out each other and the base line is at height() / 2.</db:para>
<db:programlisting language="cpp">    QPainter painter(this);
    for (int i = 0; i &amp;lt; text.size(); ++i) {
        int index = (step + i) % 16;
        color.setHsv((15 - index) * 16, 255, 191);
        painter.setPen(color);
        painter.drawText(x, y - ((sineTable[index] * metrics.height()) / 400),
                         QString(text[i]));
        x += metrics.horizontalAdvance(text[i]);
    }
}
</db:programlisting>
<db:para>Each time the paintEvent() function is called, we create a <db:link xlink:href="qpainter.xml">QPainter</db:link> object painter to draw the contents of the widget. For each character in text, we determine the color and the position on the wiggly line based on step. In addition, x is incremented by the character's width.</db:para>
<db:para>For simplicity, we assume that <db:link xlink:href="qfontmetrics.xml#horizontalAdvance">QFontMetrics::horizontalAdvance</db:link>(text) returns the sum of the individual character advances (<db:link xlink:href="qfontmetrics.xml#horizontalAdvance">QFontMetrics::horizontalAdvance</db:link>(text[i])). In practice, this is not always the case because <db:link xlink:href="qfontmetrics.xml#horizontalAdvance">QFontMetrics::horizontalAdvance</db:link>(text) also takes into account the kerning between certain letters (e.g., 'A' and 'V'). The result is that the text isn't perfectly centered. You can verify this by typing &quot;AVAVAVAVAVAV&quot; in the line edit.</db:para>
<db:programlisting language="cpp">void WigglyWidget::timerEvent(QTimerEvent *event)
{
    if (event-&amp;gt;timerId() == timer.timerId()) {
        ++step;
        update();
    } else {
        QWidget::timerEvent(event);
    }
</db:programlisting>
<db:para>The timerEvent() function receives all the timer events that are generated for this widget. If a timer event is sent from the widget's <db:link xlink:href="qbasictimer.xml">QBasicTimer</db:link>, we increment step to make the text move, and call <db:link xlink:href="qwidget.xml#update">QWidget::update</db:link>() to refresh the display. Any other timer event is passed on to the base class's implementation of the <db:link xlink:href="qobject.xml#timerEvent">timerEvent</db:link>() function.</db:para>
<db:para>The <db:link xlink:href="qwidget.xml#update">QWidget::update</db:link>() slot does not cause an immediate repaint; instead the slot schedules a paint event for processing when Qt returns to the main event loop. The paint events are then handled by WigglyWidget's paintEvent() function.</db:para>
</db:section>
<db:section>
<db:title>List of Files</db:title>
<db:para>Files:</db:para>
<db:section>
<db:title>List of Files</db:title>
<db:itemizedlist>
<db:listitem>
<db:para><db:link xlink:href="widgets/wiggly/dialog.cpp">widgets/wiggly/dialog.cpp</db:link></db:para></db:listitem>
<db:listitem>
<db:para><db:link xlink:href="widgets/wiggly/dialog.h">widgets/wiggly/dialog.h</db:link></db:para></db:listitem>
<db:listitem>
<db:para><db:link xlink:href="widgets/wiggly/main.cpp">widgets/wiggly/main.cpp</db:link></db:para></db:listitem>
<db:listitem>
<db:para><db:link xlink:href="widgets/wiggly/wiggly.pro">widgets/wiggly/wiggly.pro</db:link></db:para></db:listitem>
<db:listitem>
<db:para><db:link xlink:href="widgets/wiggly/wigglywidget.cpp">widgets/wiggly/wigglywidget.cpp</db:link></db:para></db:listitem>
<db:listitem>
<db:para><db:link xlink:href="widgets/wiggly/wigglywidget.h">widgets/wiggly/wigglywidget.h</db:link></db:para></db:listitem>
</db:itemizedlist>
</db:section>
</db:section></db:article>
