<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en">
<db:info>
<db:title>QRhiCommandBuffer Class</db:title>
<db:productname>QtGui</db:productname>
<db:edition>Qt 6.9.1 Reference Documentation</db:edition>
<db:titleabbrev>Qt GUI Reference Documentation</db:titleabbrev>
<db:abstract>
<db:para>Command buffer resource.</db:para>
<db:para>This class was introduced in Qt 6.6.</db:para>
</db:abstract>
<db:pubdate>2025-06-29</db:pubdate>
<db:date>2025-06-29</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:variablelist>
<db:varlistentry>
<db:term>Header</db:term>
<db:listitem>
<db:para>rhi/qrhi.h</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Since</db:term>
<db:listitem>
<db:para>Qt 6.6</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>CMake</db:term>
<db:listitem>
<db:para>find_package(Qt6 REQUIRED COMPONENTS Gui)</db:para>
<db:para>target_link_libraries(mytarget PRIVATE Qt6::GuiPrivate)</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>qmake</db:term>
<db:listitem>
<db:para>QT += gui-private</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Inherits</db:term>
<db:listitem>
<db:para><db:link xlink:href="qrhiresource.xml" xlink:role="class">QRhiResource</db:link></db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Inherited By</db:term>
<db:listitem>
<db:para/>
</db:listitem>
</db:varlistentry>
</db:variablelist>
<db:section xml:id="details">
<db:title>Detailed Description</db:title>
<db:para>Not creatable by applications at the moment. The only ways to obtain a valid <db:link xlink:href="qrhicommandbuffer.xml">QRhiCommandBuffer</db:link> are to get it from the targeted swapchain via QRhiSwapChain::currentFrameCommandBuffer(), or, in case of rendering completely offscreen, initializing one via <db:link xlink:href="qrhi.xml#beginOffscreenFrame">QRhi::beginOffscreenFrame</db:link>().</db:para>
<db:note>
<db:para>This is a RHI API with limited compatibility guarantees, see <db:link xlink:href="qrhi.xml">QRhi</db:link> for details.</db:para>
</db:note>
</db:section>
<db:section xml:id="member-type-documentation">
<db:title>Member Type Documentation</db:title>
<db:section xml:id="BeginPassFlag-enum">
<db:title>enum QRhiCommandBuffer::BeginPassFlag</db:title>
<db:bridgehead renderas="sect2">flags QRhiCommandBuffer::BeginPassFlags</db:bridgehead>
<db:para>Flag values for QRhi::beginPass()</db:para>
<db:informaltable>
<db:thead>
<db:tr>
<db:th>Constant</db:th>
<db:th>Value</db:th>
<db:th>Description</db:th>
</db:tr>
</db:thead>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qrhicommandbuffer.xml">QRhiCommandBuffer</db:link></db:emphasis>::ExternalContent</db:code></db:para>
</db:td>
<db:td><db:code>0x01</db:code></db:td>
<db:td>
<db:para>Specifies that there will be a call to <db:link xlink:href="qrhicommandbuffer.xml#beginExternal">QRhiCommandBuffer::beginExternal</db:link>() in this pass. Some backends, Vulkan in particular, will fail if this flag is not set and <db:link xlink:href="qrhicommandbuffer.xml#beginExternal">beginExternal</db:link>() is still called.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qrhicommandbuffer.xml">QRhiCommandBuffer</db:link></db:emphasis>::DoNotTrackResourcesForCompute</db:code></db:para>
</db:td>
<db:td><db:code>0x02</db:code></db:td>
<db:td>
<db:para>Specifies that there is no need to track resources used in this pass if the only purpose of such tracking is to generate barriers for compute. Implies that there are no compute passes in the frame. This is an optimization hint that may be taken into account by certain backends, OpenGL in particular, allowing them to skip certain operations. When this flag is set for a render pass in a frame, calling <db:link xlink:href="qrhicommandbuffer.xml#beginComputePass">beginComputePass</db:link>() in that frame may lead to unexpected behavior, depending on the resource dependencies between the render and compute passes.</db:para>
</db:td>
</db:tr>
</db:informaltable>
<db:para>The <db:code>BeginPassFlags</db:code> type is a typedef for <db:code><db:link xlink:href="qflags.xml">QFlags</db:link>&lt;BeginPassFlag&gt;. </db:code>It stores an OR combination of <db:code>BeginPassFlag</db:code> values.</db:para>
</db:section>
<db:section xml:id="DynamicOffset-typedef">
<db:title>[alias] QRhiCommandBuffer::DynamicOffset</db:title>
<db:para>Synonym for std::pair&lt;int, quint32&gt;. The first entry is the binding, the second is the offset in the buffer.</db:para>
</db:section>
<db:section xml:id="IndexFormat-enum">
<db:title>enum QRhiCommandBuffer::IndexFormat</db:title>
<db:para>Specifies the index data type</db:para>
<db:informaltable>
<db:thead>
<db:tr>
<db:th>Constant</db:th>
<db:th>Value</db:th>
<db:th>Description</db:th>
</db:tr>
</db:thead>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qrhicommandbuffer.xml">QRhiCommandBuffer</db:link></db:emphasis>::IndexUInt16</db:code></db:para>
</db:td>
<db:td><db:code>0</db:code></db:td>
<db:td>
<db:para>Unsigned 16-bit (quint16)</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qrhicommandbuffer.xml">QRhiCommandBuffer</db:link></db:emphasis>::IndexUInt32</db:code></db:para>
</db:td>
<db:td><db:code>1</db:code></db:td>
<db:td>
<db:para>Unsigned 32-bit (quint32)</db:para>
</db:td>
</db:tr>
</db:informaltable>
</db:section>
<db:section xml:id="VertexInput-typedef">
<db:title>[alias] QRhiCommandBuffer::VertexInput</db:title>
<db:para>Synonym for std::pair&lt;<db:link xlink:href="qrhibuffer.xml">QRhiBuffer</db:link> *, quint32&gt;. The second entry is an offset in the buffer specified by the first.</db:para>
</db:section>
</db:section>
<db:section xml:id="member-function-documentation">
<db:title>Member Function Documentation</db:title>
<db:section xml:id="beginComputePass">
<db:title>void QRhiCommandBuffer::beginComputePass(QRhiResourceUpdateBatch *<db:emphasis>resourceUpdates</db:emphasis> = nullptr, QRhiCommandBuffer::BeginPassFlags <db:emphasis>flags</db:emphasis> = {})</db:title>
<db:para>Records starting a new compute pass.</db:para>
<db:para><db:code role="parameter">resourceUpdates</db:code>, when not null, specifies a resource update batch that is to be committed and then released.</db:para>
<db:note>
<db:para>Do not assume that any state or resource bindings persist between passes.</db:para>
</db:note>
<db:note>
<db:para>A compute pass can record <db:link xlink:href="qrhicommandbuffer.xml#setComputePipeline">setComputePipeline</db:link>(), <db:link xlink:href="qrhicommandbuffer.xml#setShaderResources">setShaderResources</db:link>(), and <db:link xlink:href="qrhicommandbuffer.xml#dispatch">dispatch</db:link>() calls, not graphics ones. General functionality, such as, debug markers and <db:link xlink:href="qrhicommandbuffer.xml#beginExternal">beginExternal</db:link>() is available both in render and compute passes.</db:para>
</db:note>
<db:note>
<db:para>Compute is only available when the <db:link xlink:href="qrhi.xml#Feature-enum">Compute</db:link> feature is reported as supported.</db:para>
</db:note>
<db:para><db:code role="parameter">flags</db:code> is not currently used.</db:para>
</db:section>
<db:section xml:id="beginExternal">
<db:title>void QRhiCommandBuffer::beginExternal()</db:title>
<db:para>To be called when the application before the application is about to enqueue commands to the current pass' command buffer by calling graphics API functions directly.</db:para>
<db:note>
<db:para>This is only available when the intent was declared upfront in <db:link xlink:href="qrhicommandbuffer.xml#beginPass">beginPass</db:link>() or <db:link xlink:href="qrhicommandbuffer.xml#beginComputePass">beginComputePass</db:link>(). Therefore this function must only be called when the pass recording was started with specifying <db:link xlink:href="qrhicommandbuffer.xml#BeginPassFlag-enum">QRhiCommandBuffer::ExternalContent</db:link>.</db:para>
</db:note>
<db:para>With Vulkan, Metal, or Direct3D 12 one can query the native command buffer or encoder objects via <db:link xlink:href="qrhicommandbuffer.xml#nativeHandles">nativeHandles</db:link>() and enqueue commands to them. With OpenGL or Direct3D 11 the (device) context can be retrieved from <db:link xlink:href="qrhi.xml#nativeHandles">QRhi::nativeHandles</db:link>(). However, this must never be done without ensuring the <db:link xlink:href="qrhicommandbuffer.xml">QRhiCommandBuffer</db:link>'s state stays up-to-date. Hence the requirement for wrapping any externally added command recording between beginExternal() and <db:link xlink:href="qrhicommandbuffer.xml#endExternal">endExternal</db:link>(). Conceptually this is the same as <db:link xlink:href="qpainter.xml">QPainter</db:link>'s <db:link xlink:href="qpainter.xml#beginNativePainting">beginNativePainting</db:link>() and <db:link xlink:href="qpainter.xml#endNativePainting">endNativePainting</db:link>() functions.</db:para>
<db:para>For OpenGL in particular, this function has an additional task: it makes sure the context is made current on the current thread.</db:para>
<db:note>
<db:para>Once beginExternal() is called, no other render pass specific functions (<db:code>set*</db:code> or <db:code>draw*</db:code>) must be called on the <db:link xlink:href="qrhicommandbuffer.xml">QRhiCommandBuffer</db:link> until <db:link xlink:href="qrhicommandbuffer.xml#endExternal">endExternal</db:link>().</db:para>
</db:note>
<db:warning>
<db:para>Some backends may return a native command buffer object from <db:link xlink:href="qrhicommandbuffer.xml#nativeHandles">QRhiCommandBuffer::nativeHandles</db:link>() that is different from the primary one when inside a beginExternal() - <db:link xlink:href="qrhicommandbuffer.xml#endExternal">endExternal</db:link>() block. Therefore it is important to (re)query the native command buffer object after calling beginExternal(). In practical terms this means that with Vulkan for example the externally recorded Vulkan commands are placed onto a secondary command buffer (with VK_COMMAND_BUFFER_USAGE_RENDER_PASS_CONTINUE_BIT). <db:link xlink:href="qrhicommandbuffer.xml#nativeHandles">nativeHandles</db:link>() returns this secondary command buffer when called between begin/<db:link xlink:href="qrhicommandbuffer.xml#endExternal">endExternal</db:link>.</db:para>
</db:warning>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qrhicommandbuffer.xml#endExternal">endExternal</db:link>()</db:member>
<db:member><db:link xlink:href="qrhicommandbuffer.xml#nativeHandles">nativeHandles</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="beginPass">
<db:title>void QRhiCommandBuffer::beginPass(QRhiRenderTarget *<db:emphasis>rt</db:emphasis>, const QColor &amp;<db:emphasis>colorClearValue</db:emphasis>, const QRhiDepthStencilClearValue &amp;<db:emphasis>depthStencilClearValue</db:emphasis>, QRhiResourceUpdateBatch *<db:emphasis>resourceUpdates</db:emphasis> = nullptr, QRhiCommandBuffer::BeginPassFlags <db:emphasis>flags</db:emphasis> = {})</db:title>
<db:para>Records starting a new render pass targeting the render target <db:code role="parameter">rt</db:code>.</db:para>
<db:para><db:code role="parameter">resourceUpdates</db:code>, when not null, specifies a resource update batch that is to be committed and then released.</db:para>
<db:para>The color and depth/stencil buffers of the render target are normally cleared. The clear values are specified in <db:code role="parameter">colorClearValue</db:code> and <db:code role="parameter">depthStencilClearValue</db:code>. The exception is when the render target was created with <db:link xlink:href="qrhitexturerendertarget.xml#Flag-enum">QRhiTextureRenderTarget::PreserveColorContents</db:link> and/or <db:link xlink:href="qrhitexturerendertarget.xml#Flag-enum">QRhiTextureRenderTarget::PreserveDepthStencilContents</db:link>. The clear values are ignored then.</db:para>
<db:note>
<db:para>Enabling preserved color or depth contents leads to decreased performance depending on the underlying hardware. Mobile GPUs with tiled architecture benefit from not having to reload the previous contents into the tile buffer. Similarly, a <db:link xlink:href="qrhitexturerendertarget.xml">QRhiTextureRenderTarget</db:link> with a <db:link xlink:href="qrhitexture.xml">QRhiTexture</db:link> as the depth buffer is less efficient than a <db:link xlink:href="qrhirenderbuffer.xml">QRhiRenderBuffer</db:link> since using a depth texture triggers requiring writing the data out to it, while with renderbuffers this is not needed (as the API does not allow sampling or reading from a renderbuffer).</db:para>
</db:note>
<db:note>
<db:para>Do not assume that any state or resource bindings persist between passes.</db:para>
</db:note>
<db:note>
<db:para>The <db:link xlink:href="qrhicommandbuffer.xml">QRhiCommandBuffer</db:link>'s <db:code>set</db:code> and <db:code>draw</db:code> functions can only be called inside a pass. Also, with the exception of <db:link xlink:href="qrhicommandbuffer.xml#setGraphicsPipeline">setGraphicsPipeline</db:link>(), they expect to have a pipeline set already on the command buffer. Unspecified issues may arise otherwise, depending on the backend.</db:para>
</db:note>
<db:para>If <db:code role="parameter">rt</db:code> is a <db:link xlink:href="qrhitexturerendertarget.xml">QRhiTextureRenderTarget</db:link>, beginPass() performs a check to see if the texture and renderbuffer objects referenced from the render target are up-to-date. This is similar to what <db:link xlink:href="qrhicommandbuffer.xml#setShaderResources">setShaderResources</db:link>() does for <db:link xlink:href="qrhishaderresourcebindings.xml">QRhiShaderResourceBindings</db:link>. If any of the attachments had been rebuilt since QRhiTextureRenderTarget::create(), an implicit call to create() is made on <db:code role="parameter">rt</db:code>. Therefore, if <db:code role="parameter">rt</db:code> has a <db:link xlink:href="qrhitexture.xml">QRhiTexture</db:link> color attachment <db:code>texture</db:code>, and one needs to make the texture a different size, the following is then valid:</db:para>
<db:programlisting language="cpp">QRhiTextureRenderTarget *rt = rhi-&gt;newTextureRenderTarget({ { texture } });
rt-&gt;create();
// ...
texture-&gt;setPixelSize(new_size);
texture-&gt;create();
cb-&gt;beginPass(rt, colorClear, dsClear); // this is ok, no explicit rt-&gt;create() is required before
</db:programlisting>
<db:para><db:code role="parameter">flags</db:code> allow controlling certain advanced functionality. One commonly used flag is <db:code>ExternalContents</db:code>. This should be specified whenever <db:link xlink:href="qrhicommandbuffer.xml#beginExternal">beginExternal</db:link>() will be called within the pass started by this function.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qrhicommandbuffer.xml#endPass">endPass</db:link>()</db:member>
<db:member><db:link xlink:href="qrhicommandbuffer.xml#BeginPassFlag-enum">BeginPassFlags</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="debugMarkBegin">
<db:title>void QRhiCommandBuffer::debugMarkBegin(const QByteArray &amp;<db:emphasis>name</db:emphasis>)</db:title>
<db:para>Records a named debug group on the command buffer with the specified <db:code role="parameter">name</db:code>. This is shown in graphics debugging tools such as <db:link xlink:href="https://renderdoc.org/">RenderDoc</db:link> and <db:link xlink:href="https://developer.apple.com/xcode/">XCode</db:link>. The end of the grouping is indicated by <db:link xlink:href="qrhicommandbuffer.xml#debugMarkEnd">debugMarkEnd</db:link>().</db:para>
<db:note>
<db:para>Ignored when <db:link xlink:href="qrhi.xml#Feature-enum">QRhi::DebugMarkers</db:link> are not supported or <db:link xlink:href="qrhi.xml#Flag-enum">QRhi::EnableDebugMarkers</db:link> is not set.</db:para>
</db:note>
<db:note>
<db:para>Can be called anywhere within the frame, both inside and outside of passes.</db:para>
</db:note>
</db:section>
<db:section xml:id="debugMarkEnd">
<db:title>void QRhiCommandBuffer::debugMarkEnd()</db:title>
<db:para>Records the end of a debug group.</db:para>
<db:note>
<db:para>Ignored when <db:link xlink:href="qrhi.xml#Feature-enum">QRhi::DebugMarkers</db:link> are not supported or <db:link xlink:href="qrhi.xml#Flag-enum">QRhi::EnableDebugMarkers</db:link> is not set.</db:para>
</db:note>
<db:note>
<db:para>Can be called anywhere within the frame, both inside and outside of passes.</db:para>
</db:note>
</db:section>
<db:section xml:id="debugMarkMsg">
<db:title>void QRhiCommandBuffer::debugMarkMsg(const QByteArray &amp;<db:emphasis>msg</db:emphasis>)</db:title>
<db:para>Inserts a debug message <db:code role="parameter">msg</db:code> into the command stream.</db:para>
<db:note>
<db:para>Ignored when <db:link xlink:href="qrhi.xml#Feature-enum">QRhi::DebugMarkers</db:link> are not supported or <db:link xlink:href="qrhi.xml#Flag-enum">QRhi::EnableDebugMarkers</db:link> is not set.</db:para>
</db:note>
<db:note>
<db:para>With some backends debugMarkMsg() is only supported inside a pass and is ignored when called outside a pass. With others it is recorded anywhere within the frame.</db:para>
</db:note>
</db:section>
<db:section xml:id="dispatch">
<db:title>void QRhiCommandBuffer::dispatch(int <db:emphasis>x</db:emphasis>, int <db:emphasis>y</db:emphasis>, int <db:emphasis>z</db:emphasis>)</db:title>
<db:para>Records dispatching compute work items, with <db:code role="parameter">x</db:code>, <db:code role="parameter">y</db:code>, and <db:code role="parameter">z</db:code> specifying the number of local workgroups in the corresponding dimension.</db:para>
<db:note>
<db:para>This function can only be called inside a compute pass, meaning between a <db:link xlink:href="qrhicommandbuffer.xml#beginComputePass">beginComputePass</db:link>() and <db:link xlink:href="qrhicommandbuffer.xml#endComputePass">endComputePass</db:link>() call.</db:para>
</db:note>
<db:note>
<db:para><db:code role="parameter">x</db:code>, <db:code role="parameter">y</db:code>, and <db:code role="parameter">z</db:code> must fit the limits from the underlying graphics API implementation at run time. The maximum values are typically 65535.</db:para>
</db:note>
<db:note>
<db:para>Watch out for possible limits on the local workgroup size as well. This is specified in the shader, for example: <db:code>layout(local_size_x = 16, local_size_y = 16) in;</db:code>. For example, with OpenGL the minimum value mandated by the specification for the number of invocations in a single local work group (the product of <db:code>local_size_x</db:code>, <db:code>local_size_y</db:code>, and <db:code>local_size_z</db:code>) is 1024, while with OpenGL ES (3.1) the value may be as low as 128. This means that the example given above may be rejected by some OpenGL ES implementations as the number of invocations is 256.</db:para>
</db:note>
</db:section>
<db:section xml:id="draw">
<db:title>void QRhiCommandBuffer::draw(quint32 <db:emphasis>vertexCount</db:emphasis>, quint32 <db:emphasis>instanceCount</db:emphasis> = 1, quint32 <db:emphasis>firstVertex</db:emphasis> = 0, quint32 <db:emphasis>firstInstance</db:emphasis> = 0)</db:title>
<db:para>Records a non-indexed draw.</db:para>
<db:para>The number of vertices is specified in <db:code role="parameter">vertexCount</db:code>. For instanced drawing set <db:code role="parameter">instanceCount</db:code> to a value other than 1. <db:code role="parameter">firstVertex</db:code> is the index of the first vertex to draw. When drawing multiple instances, the first instance ID is specified by <db:code role="parameter">firstInstance</db:code>.</db:para>
<db:note>
<db:para><db:code role="parameter">firstInstance</db:code> may not be supported, and is ignored when the <db:link xlink:href="qrhi.xml#Feature-enum">QRhi::BaseInstance</db:link> feature is reported as not supported. The first ID is always 0 in that case.</db:para>
</db:note>
<db:note>
<db:para>This function can only be called inside a render pass, meaning between a <db:link xlink:href="qrhicommandbuffer.xml#beginPass">beginPass</db:link>() and <db:link xlink:href="qrhicommandbuffer.xml#endPass">endPass</db:link>() call.</db:para>
</db:note>
</db:section>
<db:section xml:id="drawIndexed">
<db:title>void QRhiCommandBuffer::drawIndexed(quint32 <db:emphasis>indexCount</db:emphasis>, quint32 <db:emphasis>instanceCount</db:emphasis> = 1, quint32 <db:emphasis>firstIndex</db:emphasis> = 0, qint32 <db:emphasis>vertexOffset</db:emphasis> = 0, quint32 <db:emphasis>firstInstance</db:emphasis> = 0)</db:title>
<db:para>Records an indexed draw.</db:para>
<db:para>The number of vertices is specified in <db:code role="parameter">indexCount</db:code>. <db:code role="parameter">firstIndex</db:code> is the base index. The effective offset in the index buffer is given by <db:code>indexOffset + firstIndex * n</db:code> where <db:code>n</db:code> is 2 or 4 depending on the index element type. <db:code>indexOffset</db:code> is specified in <db:link xlink:href="qrhicommandbuffer.xml#setVertexInput">setVertexInput</db:link>().</db:para>
<db:note>
<db:para>The effective offset in the index buffer must be 4 byte aligned with some backends (for example, Metal). With these backends the <db:link xlink:href="qrhi.xml#Feature-enum">NonFourAlignedEffectiveIndexBufferOffset</db:link> feature will be reported as not-supported.</db:para>
</db:note>
<db:para>For instanced drawing set <db:code role="parameter">instanceCount</db:code> to a value other than 1. When drawing multiple instances, the first instance ID is specified by <db:code role="parameter">firstInstance</db:code>.</db:para>
<db:note>
<db:para><db:code role="parameter">firstInstance</db:code> may not be supported, and is ignored when the <db:link xlink:href="qrhi.xml#Feature-enum">QRhi::BaseInstance</db:link> feature is reported as not supported. The first ID is always 0 in that case.</db:para>
</db:note>
<db:para><db:code role="parameter">vertexOffset</db:code> (also called <db:code>base vertex</db:code>) is a signed value that is added to the element index before indexing into the vertex buffer. Support for this is not always available, and the value is ignored when the feature <db:link xlink:href="qrhi.xml#Feature-enum">QRhi::BaseVertex</db:link> is reported as unsupported.</db:para>
<db:note>
<db:para>This function can only be called inside a render pass, meaning between a <db:link xlink:href="qrhicommandbuffer.xml#beginPass">beginPass</db:link>() and <db:link xlink:href="qrhicommandbuffer.xml#endPass">endPass</db:link>() call.</db:para>
</db:note>
</db:section>
<db:section xml:id="endComputePass">
<db:title>void QRhiCommandBuffer::endComputePass(QRhiResourceUpdateBatch *<db:emphasis>resourceUpdates</db:emphasis> = nullptr)</db:title>
<db:para>Records ending the current compute pass.</db:para>
<db:para><db:code role="parameter">resourceUpdates</db:code>, when not null, specifies a resource update batch that is to be committed and then released.</db:para>
</db:section>
<db:section xml:id="endExternal">
<db:title>void QRhiCommandBuffer::endExternal()</db:title>
<db:para>To be called once the externally added commands are recorded to the command buffer or context.</db:para>
<db:note>
<db:para>All <db:link xlink:href="qrhicommandbuffer.xml">QRhiCommandBuffer</db:link> state must be assumed as invalid after calling this function. Pipelines, vertex and index buffers, and other state must be set again if more draw calls are recorded after the external commands.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qrhicommandbuffer.xml#beginExternal">beginExternal</db:link>()</db:member>
<db:member><db:link xlink:href="qrhicommandbuffer.xml#nativeHandles">nativeHandles</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="endPass">
<db:title>void QRhiCommandBuffer::endPass(QRhiResourceUpdateBatch *<db:emphasis>resourceUpdates</db:emphasis> = nullptr)</db:title>
<db:para>Records ending the current render pass.</db:para>
<db:para><db:code role="parameter">resourceUpdates</db:code>, when not null, specifies a resource update batch that is to be committed and then released.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qrhicommandbuffer.xml#beginPass">beginPass</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="lastCompletedGpuTime">
<db:title>double QRhiCommandBuffer::lastCompletedGpuTime()</db:title>
<db:para>Returns the last available timestamp, in seconds, when <db:link xlink:href="qrhi.xml#Flag-enum">QRhi::EnableTimestamps</db:link> was enabled when creating the <db:link xlink:href="qrhi.xml">QRhi</db:link>. The value indicates the elapsed time on the GPU during the last completed frame.</db:para>
<db:note>
<db:para>Do not expect results other than 0 when the <db:link xlink:href="qrhi.xml#Feature-enum">QRhi::Timestamps</db:link> feature is not reported as supported, or when <db:link xlink:href="qrhi.xml#Flag-enum">QRhi::EnableTimestamps</db:link> was not passed to <db:link xlink:href="qrhi.xml#create">QRhi::create</db:link>(). There are exceptions to this, because with some graphics APIs (Metal) timings are available without having to perform extra operations (timestamp queries), but portable applications should always consciously opt-in to timestamp collection when they know it is needed, and call this function accordingly.</db:para>
</db:note>
<db:para>Care must be exercised with the interpretation of the value, as its precision and granularity is often not controlled by Qt, and depends on the underlying graphics API and its implementation. In particular, comparing the values between different graphics APIs and hardware is discouraged and may be meaningless.</db:para>
<db:para>When the frame was recorded with <db:link xlink:href="qrhi.xml#beginFrame">beginFrame</db:link>() and <db:link xlink:href="qrhi.xml#endFrame">endFrame</db:link>(), i.e., with a swapchain, the timing values will likely become available asynchronously. The returned value may therefore be 0 (e.g., for the first 1-2 frames) or the last known value referring to some previous frame. The value my also become 0 again under certain conditions, such as when resizing the window. It can be expected that the most up-to-date available value is retrieved in beginFrame() and becomes queriable via this function once beginFrame() returns.</db:para>
<db:note>
<db:para>Do not assume that the value refers to the previous (<db:code>currently_recorded - 1</db:code>) frame. It may refer to <db:code>currently_recorded - 2</db:code> or <db:code>currently_recorded - 3</db:code> as well. The exact behavior may depend on the graphics API and its implementation.</db:para>
</db:note>
<db:para>On the other hand, with offscreen frames the returned value is up-to-date once <db:link xlink:href="qrhi.xml#endOffscreenFrame">endOffscreenFrame</db:link>() returns, because offscreen frames reduce GPU pipelining and wait the the commands to be complete.</db:para>
<db:note>
<db:para>This means that, unlike with swapchain frames, with offscreen frames the returned value is guaranteed to refer to the frame that has just been submitted and completed. (assuming this function is called after endOffscreenFrame() but before the next beginOffscreenFrame())</db:para>
</db:note>
<db:para>Watch out for the consequences of GPU frequency scaling and GPU clock changes, depending on the platform. For example, on Windows the returned timing may vary in a quite wide range between frames with modern graphics cards, even when submitting frames with a similar, or the same workload. This is out of scope for Qt to control and solve, generally speaking. However, the D3D12 backend automatically calls <db:link xlink:href="https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12device-setstablepowerstate">ID3D12Device::SetStablePowerState()</db:link> whenever the environment variable <db:code>QT_D3D_STABLE_POWER_STATE</db:code> is set to a non-zero value. This can greatly stabilize the result. It can also have a non-insignificant effect on the CPU-side timings measured via <db:link xlink:href="qelapsedtimer.xml">QElapsedTimer</db:link> for example, especially when offscreen frames are involved.</db:para>
<db:note>
<db:para>Do not and never ship applications to production with <db:code>QT_D3D_STABLE_POWER_STATE</db:code> set. See the Windows API documentation for details.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qrhi.xml#Feature-enum">QRhi::Timestamps</db:link></db:member>
<db:member><db:link xlink:href="qrhi.xml#Flag-enum">QRhi::EnableTimestamps</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="nativeHandles">
<db:title>const QRhiNativeHandles *QRhiCommandBuffer::nativeHandles()</db:title>
<db:para>Returns a pointer to a backend-specific <db:link xlink:href="qrhinativehandles.xml">QRhiNativeHandles</db:link> subclass, such as <db:link xlink:href="qrhivulkancommandbuffernativehandles.xml">QRhiVulkanCommandBufferNativeHandles</db:link>. The returned value is <db:code>nullptr</db:code> when exposing the underlying native resources is not supported by, or not applicable to, the backend.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qrhivulkancommandbuffernativehandles.xml">QRhiVulkanCommandBufferNativeHandles</db:link></db:member>
<db:member><db:link xlink:href="qrhimetalcommandbuffernativehandles.xml">QRhiMetalCommandBufferNativeHandles</db:link></db:member>
<db:member><db:link xlink:href="qrhicommandbuffer.xml#beginExternal">beginExternal</db:link>()</db:member>
<db:member><db:link xlink:href="qrhicommandbuffer.xml#endExternal">endExternal</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="resourceType">
<db:title>[override virtual] QRhiResource::Type QRhiCommandBuffer::resourceType() const</db:title>
<db:para>Returns the resource type.</db:para>
</db:section>
<db:section xml:id="resourceUpdate">
<db:title>void QRhiCommandBuffer::resourceUpdate(QRhiResourceUpdateBatch *<db:emphasis>resourceUpdates</db:emphasis>)</db:title>
<db:para>Sometimes committing resource updates is necessary or just more convenient without starting a render pass. Calling this function with <db:code role="parameter">resourceUpdates</db:code> is an alternative to passing <db:code role="parameter">resourceUpdates</db:code> to a <db:link xlink:href="qrhicommandbuffer.xml#beginPass">beginPass</db:link>() call (or <db:link xlink:href="qrhicommandbuffer.xml#endPass">endPass</db:link>(), which would be typical in case of readbacks).</db:para>
<db:note>
<db:para>Cannot be called inside a pass.</db:para>
</db:note>
</db:section>
<db:section xml:id="setBlendConstants">
<db:title>void QRhiCommandBuffer::setBlendConstants(const QColor &amp;<db:emphasis>c</db:emphasis>)</db:title>
<db:para>Records setting the active blend constants to <db:code role="parameter">c</db:code>.</db:para>
<db:para>This can only be called when the bound pipeline has <db:link xlink:href="qrhigraphicspipeline.xml#Flag-enum">QRhiGraphicsPipeline::UsesBlendConstants</db:link> set.</db:para>
<db:note>
<db:para>This function can only be called inside a render pass, meaning between a <db:link xlink:href="qrhicommandbuffer.xml#beginPass">beginPass</db:link>() and <db:link xlink:href="qrhicommandbuffer.xml#endPass">endPass</db:link>() call.</db:para>
</db:note>
</db:section>
<db:section xml:id="setComputePipeline">
<db:title>void QRhiCommandBuffer::setComputePipeline(QRhiComputePipeline *<db:emphasis>ps</db:emphasis>)</db:title>
<db:para>Records setting a new compute pipeline <db:code role="parameter">ps</db:code>.</db:para>
<db:note>
<db:para>This function must be called before recording <db:link xlink:href="qrhicommandbuffer.xml#setShaderResources">setShaderResources</db:link>() or <db:link xlink:href="qrhicommandbuffer.xml#dispatch">dispatch</db:link>() commands on the command buffer.</db:para>
</db:note>
<db:note>
<db:para><db:link xlink:href="qrhi.xml">QRhi</db:link> will optimize out unnecessary invocations within a pass, so therefore overoptimizing to avoid calls to this function is not necessary on the applications' side.</db:para>
</db:note>
<db:note>
<db:para>This function can only be called inside a compute pass, meaning between a <db:link xlink:href="qrhicommandbuffer.xml#beginComputePass">beginComputePass</db:link>() and <db:link xlink:href="qrhicommandbuffer.xml#endComputePass">endComputePass</db:link>() call.</db:para>
</db:note>
</db:section>
<db:section xml:id="setGraphicsPipeline">
<db:title>void QRhiCommandBuffer::setGraphicsPipeline(QRhiGraphicsPipeline *<db:emphasis>ps</db:emphasis>)</db:title>
<db:para>Records setting a new graphics pipeline <db:code role="parameter">ps</db:code>.</db:para>
<db:note>
<db:para>This function must be called before recording other <db:code>set</db:code> or <db:code>draw</db:code> commands on the command buffer.</db:para>
</db:note>
<db:note>
<db:para><db:link xlink:href="qrhi.xml">QRhi</db:link> will optimize out unnecessary invocations within a pass, so therefore overoptimizing to avoid calls to this function is not necessary on the applications' side.</db:para>
</db:note>
<db:note>
<db:para>This function can only be called inside a render pass, meaning between a <db:link xlink:href="qrhicommandbuffer.xml#beginPass">beginPass</db:link>() and <db:link xlink:href="qrhicommandbuffer.xml#endPass">endPass</db:link>() call.</db:para>
</db:note>
<db:note>
<db:para>The new graphics pipeline <db:code role="parameter">ps</db:code> must be a valid pointer.</db:para>
</db:note>
</db:section>
<db:section xml:id="setScissor">
<db:title>void QRhiCommandBuffer::setScissor(const QRhiScissor &amp;<db:emphasis>scissor</db:emphasis>)</db:title>
<db:para>Records setting the active scissor rectangle specified in <db:code role="parameter">scissor</db:code>.</db:para>
<db:para>This can only be called when the bound pipeline has <db:link xlink:href="qrhigraphicspipeline.xml#Flag-enum">UsesScissor</db:link> set. When the flag is set on the active pipeline, this function must be called because scissor testing will get enabled and so a scissor rectangle must be provided.</db:para>
<db:note>
<db:para><db:link xlink:href="qrhi.xml">QRhi</db:link> assumes OpenGL-style viewport coordinates, meaning x and y are bottom-left.</db:para>
</db:note>
<db:note>
<db:para>This function can only be called inside a render pass, meaning between a <db:link xlink:href="qrhicommandbuffer.xml#beginPass">beginPass</db:link>() and <db:link xlink:href="qrhicommandbuffer.xml#endPass">endPass</db:link>() call.</db:para>
</db:note>
</db:section>
<db:section xml:id="setShaderResources">
<db:title>void QRhiCommandBuffer::setShaderResources(QRhiShaderResourceBindings *<db:emphasis>srb</db:emphasis> = nullptr, int <db:emphasis>dynamicOffsetCount</db:emphasis> = 0, const QRhiCommandBuffer::DynamicOffset *<db:emphasis>dynamicOffsets</db:emphasis> = nullptr)</db:title>
<db:para>Records binding a set of shader resources, such as, uniform buffers or textures, that are made visible to one or more shader stages.</db:para>
<db:para><db:code role="parameter">srb</db:code> can be null in which case the current graphics or compute pipeline's associated <db:link xlink:href="qrhishaderresourcebindings.xml">QRhiShaderResourceBindings</db:link> is used. When <db:code role="parameter">srb</db:code> is non-null, it must be <db:link xlink:href="qrhishaderresourcebindings.xml#isLayoutCompatible">layout-compatible</db:link>, meaning the layout (number of bindings, the type and binding number of each binding) must fully match the <db:link xlink:href="qrhishaderresourcebindings.xml">QRhiShaderResourceBindings</db:link> that was associated with the pipeline at the time of calling the pipeline's create().</db:para>
<db:para>There are cases when a seemingly unnecessary setShaderResources() call is mandatory: when rebuilding a resource referenced from <db:code role="parameter">srb</db:code>, for example changing the size of a <db:link xlink:href="qrhibuffer.xml">QRhiBuffer</db:link> followed by a QRhiBuffer::create(), this is the place where associated native objects (such as descriptor sets in case of Vulkan) are updated to refer to the current native resources that back the <db:link xlink:href="qrhibuffer.xml">QRhiBuffer</db:link>, <db:link xlink:href="qrhitexture.xml">QRhiTexture</db:link>, <db:link xlink:href="qrhisampler.xml">QRhiSampler</db:link> objects referenced from <db:code role="parameter">srb</db:code>. In this case setShaderResources() must be called even if <db:code role="parameter">srb</db:code> is the same as in the last call.</db:para>
<db:para>When <db:code role="parameter">srb</db:code> is not null, the <db:link xlink:href="qrhishaderresourcebindings.xml">QRhiShaderResourceBindings</db:link> object the pipeline was built with in create() is guaranteed to be not accessed in any form. In fact, it does not need to be valid even at this point: destroying the pipeline's associated srb after create() and instead explicitly specifying another, <db:link xlink:href="qrhishaderresourcebindings.xml#isLayoutCompatible">layout compatible</db:link> one in every setShaderResources() call is valid.</db:para>
<db:para><db:code role="parameter">dynamicOffsets</db:code> allows specifying buffer offsets for uniform buffers that were associated with <db:code role="parameter">srb</db:code> via <db:link xlink:href="qrhishaderresourcebinding.xml#uniformBufferWithDynamicOffset">QRhiShaderResourceBinding::uniformBufferWithDynamicOffset</db:link>(). This is different from providing the offset in the <db:code role="parameter">srb</db:code> itself: dynamic offsets do not require building a new <db:link xlink:href="qrhishaderresourcebindings.xml">QRhiShaderResourceBindings</db:link> for every different offset, can avoid writing the underlying descriptors (with backends where applicable), and so they may be more efficient. Each element of <db:code role="parameter">dynamicOffsets</db:code> is a <db:code>binding</db:code> - <db:code>offset</db:code> pair. <db:code role="parameter">dynamicOffsetCount</db:code> specifies the number of elements in <db:code role="parameter">dynamicOffsets</db:code>.</db:para>
<db:note>
<db:para>All offsets in <db:code role="parameter">dynamicOffsets</db:code> must be byte aligned to the value returned from <db:link xlink:href="qrhi.xml#ubufAlignment">QRhi::ubufAlignment</db:link>().</db:para>
</db:note>
<db:note>
<db:para>Some backends may limit the number of supported dynamic offsets. Avoid using a <db:code role="parameter">dynamicOffsetCount</db:code> larger than 8.</db:para>
</db:note>
<db:note>
<db:para><db:link xlink:href="qrhi.xml">QRhi</db:link> will optimize out unnecessary invocations within a pass (taking the conditions described above into account), so therefore overoptimizing to avoid calls to this function is not necessary on the applications' side.</db:para>
</db:note>
<db:note>
<db:para>This function can only be called inside a render or compute pass, meaning between a <db:link xlink:href="qrhicommandbuffer.xml#beginPass">beginPass</db:link>() and <db:link xlink:href="qrhicommandbuffer.xml#endPass">endPass</db:link>(), or <db:link xlink:href="qrhicommandbuffer.xml#beginComputePass">beginComputePass</db:link>() and <db:link xlink:href="qrhicommandbuffer.xml#endComputePass">endComputePass</db:link>().</db:para>
</db:note>
</db:section>
<db:section xml:id="setShadingRate">
<db:title>[since 6.9] void QRhiCommandBuffer::setShadingRate(const QSize &amp;<db:emphasis>coarsePixelSize</db:emphasis>)</db:title>
<db:para>Sets the shading rate for the following draw calls to <db:code role="parameter">coarsePixelSize</db:code>.</db:para>
<db:para>The default is 1x1.</db:para>
<db:para>Functional only when the <db:link xlink:href="qrhi.xml#Feature-enum">QRhi::VariableRateShading</db:link> feature is reported as supported and the <db:link xlink:href="qrhigraphicspipeline.xml">QRhiGraphicsPipeline</db:link>(s) bound on the command buffer were declaring <db:link xlink:href="qrhigraphicspipeline.xml#Flag-enum">QRhiGraphicsPipeline::UsesShadingRate</db:link> when creating them.</db:para>
<db:para>Call <db:link xlink:href="qrhi.xml#supportedShadingRates">QRhi::supportedShadingRates</db:link>() to check what shading rates are supported for a given sample count.</db:para>
<db:para>When both a <db:link xlink:href="qrhishadingratemap.xml">QRhiShadingRateMap</db:link> and this function is in use, the higher of two the shading rates are used for each tile. There is currently no control offered over the combiner behavior.</db:para>
<db:para>This function was introduced in Qt 6.9.</db:para>
</db:section>
<db:section xml:id="setStencilRef">
<db:title>void QRhiCommandBuffer::setStencilRef(quint32 <db:emphasis>refValue</db:emphasis>)</db:title>
<db:para>Records setting the active stencil reference value to <db:code role="parameter">refValue</db:code>.</db:para>
<db:para>This can only be called when the bound pipeline has <db:link xlink:href="qrhigraphicspipeline.xml#Flag-enum">QRhiGraphicsPipeline::UsesStencilRef</db:link> set.</db:para>
<db:note>
<db:para>This function can only be called inside a render pass, meaning between a <db:link xlink:href="qrhicommandbuffer.xml#beginPass">beginPass</db:link>() and <db:link xlink:href="qrhicommandbuffer.xml#endPass">endPass</db:link>() call.</db:para>
</db:note>
</db:section>
<db:section xml:id="setVertexInput">
<db:title>void QRhiCommandBuffer::setVertexInput(int <db:emphasis>startBinding</db:emphasis>, int <db:emphasis>bindingCount</db:emphasis>, const QRhiCommandBuffer::VertexInput *<db:emphasis>bindings</db:emphasis>, QRhiBuffer *<db:emphasis>indexBuf</db:emphasis> = nullptr, quint32 <db:emphasis>indexOffset</db:emphasis> = 0, QRhiCommandBuffer::IndexFormat <db:emphasis>indexFormat</db:emphasis> = IndexUInt16)</db:title>
<db:para>Records vertex input bindings.</db:para>
<db:para>The index buffer used by subsequent <db:link xlink:href="qrhicommandbuffer.xml#drawIndexed">drawIndexed</db:link>() commands is specified by <db:code role="parameter">indexBuf</db:code>, <db:code role="parameter">indexOffset</db:code>, and <db:code role="parameter">indexFormat</db:code>. <db:code role="parameter">indexBuf</db:code> can be set to null when indexed drawing is not needed.</db:para>
<db:para>Vertex buffer bindings are batched. <db:code role="parameter">startBinding</db:code> specifies the first binding number. The recorded command then binds each buffer from <db:code role="parameter">bindings</db:code> to the binding point <db:code>startBinding + i</db:code> where <db:code>i</db:code> is the index in <db:code role="parameter">bindings</db:code>. Each element in <db:code role="parameter">bindings</db:code> specifies a <db:link xlink:href="qrhibuffer.xml">QRhiBuffer</db:link> and an offset.</db:para>
<db:note>
<db:para>Some backends may limit the number of vertex buffer bindings. Avoid using a <db:code role="parameter">bindingCount</db:code> larger than 8.</db:para>
</db:note>
<db:para>Superfluous vertex input and index changes in the same pass are ignored automatically with most backends and therefore applications do not need to overoptimize to avoid calls to this function.</db:para>
<db:note>
<db:para>This function can only be called inside a render pass, meaning between a <db:link xlink:href="qrhicommandbuffer.xml#beginPass">beginPass</db:link>() and <db:link xlink:href="qrhicommandbuffer.xml#endPass">endPass</db:link>() call.</db:para>
</db:note>
<db:para>As a simple example, take a vertex shader with two inputs:</db:para>
<db:programlisting language="cpp" role="bad">layout(location = 0) in vec4 position;
layout(location = 1) in vec3 color;
</db:programlisting>
<db:para>and assume we have the data available in interleaved format, using only 2 floats for position (so 5 floats per vertex: x, y, r, g, b). A <db:link xlink:href="qrhigraphicspipeline.xml">QRhiGraphicsPipeline</db:link> for this shader can then be created using the input layout:</db:para>
<db:programlisting language="cpp">QRhiVertexInputLayout inputLayout;
inputLayout.setBindings({
    { 5 * sizeof(float) }
});
inputLayout.setAttributes({
    { 0, 0, QRhiVertexInputAttribute::Float2, 0 },
    { 0, 1, QRhiVertexInputAttribute::Float3, 2 * sizeof(float) }
});
</db:programlisting>
<db:para>Here there is one buffer binding (binding number 0), with two inputs referencing it. When recording the pass, once the pipeline is set, the vertex bindings can be specified simply like the following, assuming vbuf is the <db:link xlink:href="qrhibuffer.xml">QRhiBuffer</db:link> with all the interleaved position+color data:</db:para>
<db:programlisting language="cpp">const QRhiCommandBuffer::VertexInput vbufBinding(vbuf, 0);
cb-&gt;setVertexInput(0, 1, &amp;vbufBinding);
</db:programlisting>
</db:section>
<db:section xml:id="setViewport">
<db:title>void QRhiCommandBuffer::setViewport(const QRhiViewport &amp;<db:emphasis>viewport</db:emphasis>)</db:title>
<db:para>Records setting the active viewport rectangle specified in <db:code role="parameter">viewport</db:code>.</db:para>
<db:para>With backends where the underlying graphics API has scissoring always enabled, this function also sets the scissor to match the viewport whenever the active <db:link xlink:href="qrhigraphicspipeline.xml">QRhiGraphicsPipeline</db:link> does not have <db:link xlink:href="qrhigraphicspipeline.xml#Flag-enum">UsesScissor</db:link> set.</db:para>
<db:note>
<db:para><db:link xlink:href="qrhi.xml">QRhi</db:link> assumes OpenGL-style viewport coordinates, meaning x and y are bottom-left.</db:para>
</db:note>
<db:note>
<db:para>This function can only be called inside a render pass, meaning between a <db:link xlink:href="qrhicommandbuffer.xml#beginPass">beginPass</db:link>() and <db:link xlink:href="qrhicommandbuffer.xml#endPass">endPass</db:link>() call.</db:para>
</db:note>
</db:section>
</db:section>
</db:article>
