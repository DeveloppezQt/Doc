<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en_US">
<db:info>
<db:title>Module Definition qmldir Files</db:title>
<db:productname>QtQml</db:productname>
<db:edition>Qt 5.3.2 Reference Documentation</db:edition>
<db:titleabbrev>Qt QML Reference Documentation</db:titleabbrev>
<db:abstract>
<db:para>Defines a QML module.</db:para>
</db:abstract>
<db:pubdate>2025-06-29</db:pubdate>
<db:date>2025-06-29</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:para>There are two distinct types of qmldir files:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para>QML document directory listing files</db:para>
</db:listitem>
<db:listitem>
<db:para>QML module definition files</db:para>
</db:listitem>
</db:itemizedlist>
<db:para>This documentation covers only the second form of qmldir file. For more information about the first form of qmldir file, please see the documentation about <db:link xlink:href="qtqml-syntax-directoryimports.xml#directory-listing-qmldir-files">directory listing qmldir files</db:link>.</db:para>
<db:section xml:id="contents-of-a-module-definition-qmldir-file">
<db:title>Contents of a Module Definition qmldir File</db:title>
<db:para>A qmldir file which defines a module is a plain-text file which consists of the following commands:</db:para>
<db:informaltable style="generic">
<db:thead>
<db:tr>
<db:th>
<db:para>Command</db:para>
</db:th>
<db:th>
<db:para>Syntax</db:para>
</db:th>
<db:th>
<db:para>Usage</db:para>
</db:th>
</db:tr>
</db:thead>
<db:tr valign="top">
<db:td>
<db:para>Module Identifier Directive</db:para>
</db:td>
<db:td>
<db:programlisting language="cpp">module &lt;ModuleIdentifier&gt;
            </db:programlisting>
</db:td>
<db:td>
<db:para>Declares the module identifier of the module. The &lt;ModuleIdentifier&gt; is the (dotted URI notation) identifier for the module, which must match the module's install path.</db:para>
<db:para>The <db:link xlink:href="qtqml-modules-identifiedmodules.xml#semantics-of-identified-modules">module identifier directive</db:link> must be the first line of the file. Exactly one module identifier directive may exist in the qmldir file.</db:para>
<db:para>Example:</db:para>
<db:programlisting language="cpp">module ExampleModule
            </db:programlisting>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>Object Type Declaration</db:para>
</db:td>
<db:td>
<db:programlisting language="cpp">&lt;TypeName&gt; &lt;InitialVersion&gt; &lt;File&gt;
            </db:programlisting>
</db:td>
<db:td>
<db:para>Declares a <db:link xlink:href="qtqml-typesystem-objecttypes.xml">QML object type</db:link> to be made available by the module.</db:para>
<db:itemizedlist>
<db:listitem>
<db:para>&lt;TypeName&gt; is the type being made available</db:para>
</db:listitem>
<db:listitem>
<db:para>&lt;InitialVersion&gt; is the module version for which the type is to be made available</db:para>
</db:listitem>
<db:listitem>
<db:para>&lt;File&gt; is the (relative) file name of the QML file that defines the type</db:para>
</db:listitem>
</db:itemizedlist>
<db:para>Zero or more object type declarations may exist in the qmldir file, however each object type must have a unique type name within any particular version of the module.</db:para>
<db:para>Example:</db:para>
<db:programlisting language="cpp">MyCustomType 1.0 MyCustomType.qml
            </db:programlisting>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>Internal Object Type Declaration</db:para>
</db:td>
<db:td>
<db:programlisting language="cpp">internal &lt;TypeName&gt; &lt;File&gt;
            </db:programlisting>
</db:td>
<db:td>
<db:para>Declares an object type that is in the module but should not be made available to users of the module.</db:para>
<db:para>Zero or more internal object type declarations may exist in the qmldir file.</db:para>
<db:para>Example:</db:para>
<db:programlisting language="cpp">internal MyPrivateType MyPrivateType.qml
         </db:programlisting>
<db:para>This is necessary if the module may be imported remotely (see <db:link xlink:href="qtqml-modules-identifiedmodules.xml#remotely-installed-identified-modules">Remotely Installed Identified Modules</db:link>) because if an exported type depends on an non-exported type within the module, the engine must also load the non-exported type.</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>JavaScript Resource Declaration</db:para>
</db:td>
<db:td>
<db:programlisting language="cpp">&lt;ResourceIdentifier&gt; &lt;InitialVersion&gt; &lt;File&gt;
            </db:programlisting>
</db:td>
<db:td>
<db:para>Declares a JavaScript file to be made available by the module. The resource will be made available via the specified identifier with the specified version number.</db:para>
<db:para>Zero or more JavaScript resource declarations may exist in the qmldir file, however each JavaScript resource must have a unique identifier within any particular version of the module.</db:para>
<db:para>Example:</db:para>
<db:programlisting language="cpp">MyScript 1.0 MyScript.js
            </db:programlisting>
<db:para>See the documentation about <db:link xlink:href="qtqml-javascript-resources.xml">defining JavaScript resources</db:link> and <db:link xlink:href="qtqml-javascript-imports.xml">Importing JavaScript Resources In QML</db:link> for more information.</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>C++ Plugin Declaration</db:para>
</db:td>
<db:td>
<db:programlisting language="cpp">plugin &lt;Name&gt; [&lt;Path&gt;]
            </db:programlisting>
</db:td>
<db:td>
<db:para>Declares a plugin to be made available by the module.</db:para>
<db:itemizedlist>
<db:listitem>
<db:para>&lt;Name&gt; is the plugin library name. This is usually not the same as the file name of the plugin binary, which is platform dependent; e.g. the library MyAppTypes would produce libMyAppTypes.so on Linux and MyAppTypes.dll on Windows.</db:para>
</db:listitem>
<db:listitem>
<db:para>&lt;Path&gt; (optional) specifies either:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para>an absolute path to the directory containing the plugin file, or</db:para>
</db:listitem>
<db:listitem>
<db:para>a relative path from the directory containing the qmldir file to the directory containing the plugin file.</db:para>
</db:listitem>
</db:itemizedlist>
<db:para>By default the engine searches for the plugin library in the directory that contains the qmldir file. (The plugin search path can be queried with <db:link xlink:href="qqmlengine.xml#pluginPathList">QQmlEngine::pluginPathList</db:link>() and modified using <db:link xlink:href="qqmlengine.xml#addPluginPath">QQmlEngine::addPluginPath</db:link>().)</db:para>
</db:listitem>
</db:itemizedlist>
<db:para>Zero or more C++ plugin declarations may exist in the qmldir file, however since plugin loading is a relatively expensive operation, clients are advised to specify at most a single plugin.</db:para>
<db:para>Example:</db:para>
<db:programlisting language="cpp">plugin MyPluginLibrary
           </db:programlisting>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>C++ Plugin Class</db:para>
</db:td>
<db:td>
<db:programlisting language="cpp">classname &lt;C++ plugin class&gt;
            </db:programlisting>
</db:td>
<db:td>
<db:para>Provides the class name of the C++ plugin used by the module.</db:para>
<db:para>This information is required for all the QML modules that depend on a C++ plugin for additional functionality. Qt Quick applications built with static linking cannot resolve the module imports without this information.</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>Type Information Description File Declaration</db:para>
</db:td>
<db:td>
<db:programlisting language="cpp">typeinfo &lt;File&gt;
            </db:programlisting>
</db:td>
<db:td>
<db:para>Declares a <db:link xlink:href="qtqml-modules-qmldir.xml#writing-a-qmltypes-file">type description file</db:link> for the module that can be read by QML tools such as Qt Creator to access information about the types defined by the module's plugins. &lt;File&gt; is the (relative) file name of a .qmltypes file.</db:para>
<db:para>Example:</db:para>
<db:programlisting language="cpp">typeinfo mymodule.qmltypes
            </db:programlisting>
<db:para>Without such a file, QML tools may be unable to offer features such as code completion for the types defined in your plugins.</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>Comment</db:para>
</db:td>
<db:td>
<db:programlisting language="cpp"># &lt;Comment&gt;
            </db:programlisting>
</db:td>
<db:td>
<db:para>Declares a comment. These are ignored by the engine.</db:para>
<db:para>Example:</db:para>
<db:programlisting language="cpp"># this is a comment
            </db:programlisting>
</db:td>
</db:tr>
</db:informaltable>
<db:para>Each command in a qmldir file must be on a separate line.</db:para>
</db:section>
<db:section xml:id="versioning-semantics">
<db:title>Versioning Semantics</db:title>
<db:para>Types which are exported for a particular version are still made available if a later version is imported. If a module provides a MyButton type in version 1.0 and a MyWindow type in version 1.1, clients which import version 1.1 of the module will be able to use the MyButton type and the MyWindow type. However, the reverse is not true: a type exported for a particular version cannot be used if an earlier version is imported. If the client had imported version 1.0 of the module, they can use the MyButton type but <db:emphasis role="bold">not</db:emphasis> the MyWindow type.</db:para>
<db:para>A version cannot be imported if no types have been explicitly exported for that version. If a module provides a MyButton type in version 1.0 and a MyWindow type in version 1.1, you cannot import version 1.2 or version 2.0 of that module.</db:para>
<db:para>A type can be defined by different files in different versions. In this case, the most closely matching version will be used when imported by clients. For example, if a module had specified the following types via its qmldir file:</db:para>
<db:programlisting language="cpp">module ExampleModule
MyButton 1.0 MyButton.qml
MyButton 1.1 MyButton11.qml
MyButton 1.3 MyButton13.qml
MyButton 2.0 MyButton20.qml
MyRectangle 1.2 MyRectangle12.qml
</db:programlisting>
<db:para>a client who imports version 1.2 of ExampleModule will get the MyButton type definition provided by MyButton11.qml as it is the most closely matching (i.e., latest while not being greater than the import) version of the type, and the MyRectangle type definition provided by MyRectangle12.qml.</db:para>
<db:para>The versioning system ensures that a given QML file will work regardless of the version of installed software, since a versioned import <db:emphasis>only</db:emphasis> imports types for that version, leaving other identifiers available, even if the actual installed version might otherwise provide those identifiers.</db:para>
</db:section>
<db:section xml:id="example-of-a-qmldir-file">
<db:title>Example of a qmldir File</db:title>
<db:para>One example of a qmldir file follows:</db:para>
<db:programlisting language="cpp">module ExampleModule
CustomButton 1.0 CustomButton.qml
CustomButton 2.0 CustomButton20.qml
CustomButton 2.1 CustomButton21.qml
plugin examplemodule
MathFunctions 2.0 mathfuncs.js
</db:programlisting>
<db:para>The above qmldir file defines a module called &quot;ExampleModule&quot;. It defines the CustomButton QML object type in versions 1.1, 2.0 and 2.1 of the module, with different implementations in each version. It specifies a plugin which must be loaded by the engine when the module is imported by clients, and that plugin may register various C++-defined types with the QML type system. On Unix-like systems the QML engine will attempt to load libexamplemodule.so as a <db:link xlink:href="qqmlextensionplugin.xml">QQmlExtensionPlugin</db:link>, and on Windows it will attempt to load examplemodule.dll as a <db:link xlink:href="qqmlextensionplugin.xml">QQmlExtensionPlugin</db:link>. Finally, the qmldir file specifies a <db:link xlink:href="qtqml-javascript-resources.xml">JavaScript resource</db:link> which is only available if version 2.0 or greater of the module is imported, accessible via the MathFunctions identifier.</db:para>
<db:para>If the module is <db:link xlink:href="qtqml-modules-identifiedmodules.xml">installed</db:link> into the QML import path, clients could import and use the module in the following manner:</db:para>
<db:programlisting language="qml">import QtQuick 2.0
import ExampleModule 2.1

Rectangle {
    width: 400
    height: 400
    color: &quot;lightsteelblue&quot;

    CustomButton {
        color: &quot;gray&quot;
        text: &quot;Click Me!&quot;
        onClicked: MathFunctions.generateRandom() &gt; 10 ? color = &quot;red&quot; : color = &quot;gray&quot;;
    }
}
</db:programlisting>
<db:para>The CustomButton type used above would come from the definition specified in the CustomButton21.qml file, and the JavaScript resource identified by the MathFunctions identifier would be defined in the mathfuncs.js file.</db:para>
</db:section>
<db:section xml:id="writing-a-qmltypes-file">
<db:title>Writing a qmltypes File</db:title>
<db:para>QML modules may refer to one or more type information files in their qmldir file. These usually have the .qmltypes extension and are read by external tools to gain information about types defined in plugins.</db:para>
<db:para>As such qmltypes files have no effect on the functionality of a QML module. Their only use is to allow tools such as Qt Creator to provide code completion, error checking and other functionality to users of your module.</db:para>
<db:para>Any module that uses plugins should also ship a type description file.</db:para>
<db:para>The best way to create a qmltypes file for your module is to generate it using the qmlplugindump tool that is provided with Qt.</db:para>
<db:para>Example: If your module is in /tmp/imports/My/Module, you could run</db:para>
<db:programlisting language="cpp">qmlplugindump My.Module 1.0 /tmp/imports &gt; /tmp/imports/My/Module/mymodule.qmltypes
</db:programlisting>
<db:para>to generate type information for your module. Afterwards, add the line</db:para>
<db:programlisting language="cpp">typeinfo mymodule.qmltypes
</db:programlisting>
<db:para>to /tmp/imports/My/Module/qmldir to register it.</db:para>
<db:para>While the qmldump tool covers most cases, it does not work if:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para>The plugin uses a QQmlCustomParser. The component that uses the custom parser will not get its members documented.</db:para>
</db:listitem>
<db:listitem>
<db:para>The plugin can not be loaded. In particular if you cross-compiled the plugin for a different architecture, qmldump will not be able to load it.</db:para>
</db:listitem>
</db:itemizedlist>
<db:para>In case you have to create a qmltypes file manually or need to adjust an existing one, this is the file format:</db:para>
<db:programlisting language="qml">import QtQuick.tooling 1.1

// There always is a single Module object that contains all
// Component objects.
Module {
    // A Component object directly corresponds to a type exported
    // in a plugin with a call to qmlRegisterType.
    Component {

        // The name is a unique identifier used to refer to this type.
        // It is recommended you simply use the C++ type name.
        name: &quot;QQuickAbstractAnimation&quot;

        // The name of the prototype Component.
        prototype: &quot;QObject&quot;

        // The name of the default property.
        defaultProperty: &quot;animations&quot;

        // The name of the type containing attached properties
        // and methods.
        attachedType: &quot;QQuickAnimationAttached&quot;

        // The list of exports determines how a type can be imported.
        // Each string has the format &quot;URI/Name version&quot; and matches the
        // arguments to qmlRegisterType. Usually types are only exported
        // once, if at all.
        // If the &quot;URI/&quot; part of the string is missing that means the
        // type should be put into the package defined by the URI the
        // module was imported with.
        // For example if this module was imported with 'import Foo 4.8'
        // the Animation object would be found in the package Foo and
        // QtQuick.
        exports: [
            &quot;Animation 4.7&quot;,
            &quot;QtQuick/Animation 1.0&quot;
        ]

        // The meta object revisions for the exports specified in 'exports'.
        // Describes with revisioned properties will be visible in an export.
        // The list must have exactly the same length as the 'exports' list.
        // For example the 'animations' propery described below will only be
        // available through the QtQuick/Animation 1.0 export.
        exportMetaObjectRevisions: [0, 1]

        Property {
            name: &quot;animations&quot;;
            type: &quot;QQuickAbstractAnimation&quot;
            // defaults to false, whether this property is read only
            isReadonly: true
            // defaults to false, whether the type of this property was a pointer in C++
            isPointer: true
            // defaults to false: whether the type actually is a QQmlListProperty&lt;type&gt;
            isList: true
            // defaults to 0: the meta object revision that introduced this property
            revision: 1
        }
        Property { name: &quot;loops&quot;; type: &quot;int&quot; }
        Property { name: &quot;name&quot;; type: &quot;string&quot; }
        Property { name: &quot;loopsEnum&quot;; type: &quot;Loops&quot; }

        Enum {
            name: &quot;Loops&quot;
            values: {
                &quot;Infinite&quot;: -2,
                &quot;OnceOnly&quot;: 1
            }
        }

        // Signal and Method work the same way. The inner Parameter
        // declarations also support the isReadonly, isPointer and isList
        // attributes which mean the same as for Property
        Method { name: &quot;restart&quot; }
        Signal { name: &quot;started&quot;; revision: 2 }
        Signal {
            name: &quot;runningChanged&quot;
            Parameter { type: &quot;bool&quot; }
            Parameter { name: &quot;foo&quot;; type: &quot;bool&quot; }
        }
    }
}
</db:programlisting>
</db:section>
</db:article>
