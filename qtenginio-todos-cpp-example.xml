<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en">
<db:info>
<db:title>Enginio C++ Examples - Todos</db:title>
<db:productname>QtEnginio</db:productname>
<db:edition>Qt 5.6.3 Reference Documentation</db:edition>
<db:titleabbrev>Client library for Enginio</db:titleabbrev>
<db:abstract>
<db:para>The Todo example shows how to use the <db:link xlink:href="enginiomodel.xml">EnginioModel</db:link> with Qt Widgets.</db:para>
</db:abstract>
<db:pubdate>2025-06-29</db:pubdate>
<db:date>2025-06-29</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:para>In this example, a list of objects is displayed in a <db:link xlink:href="qtreeview.xml">QTreeView</db:link>. Each item in the list is a <db:code>Todo</db:code> object, which can be marked <db:code>Done</db:code> or <db:code>Not done</db:code>. A <db:code>Todo</db:code> can be added, removed, or altered. We will be using the classes and concepts duscussed in <db:link xlink:href="model-view-programming.xml">Model/View Programming</db:link>.</db:para>
<db:mediaobject>
<db:imageobject>
<db:imagedata fileref="images/todo-example.png"/>
</db:imageobject>
</db:mediaobject>
<db:para>In this simple schema, each <db:code>ToDo</db:code> object will have two properties: a <db:code>string</db:code> named <db:code>title</db:code> and a <db:code>bool</db:code> named <db:code>completed</db:code>. These properties are added to the default properties e.g.: creation date, which always exist.</db:para>
<db:para>A <db:code>Todo</db:code> object will look like this in <db:link xlink:href="http://json.org">JSON</db:link>:</db:para>
<db:programlisting language="cpp">{
  &quot;title&quot;: &quot;Buy Milk&quot;,
  &quot;completed&quot;: false
}
    </db:programlisting>
<db:para>A ToDo object can be created and appended to an <db:link xlink:href="enginiomodel.xml">EnginioModel</db:link> using <db:link xlink:href="enginiomodel.xml#append">append</db:link>(), as shown in <db:link xlink:href="qtenginio-todos-cpp-example.xml#mainwindow-appenditem">MainWindow::appendItem()</db:link>. Alternatively, if many ToDo objects are to be added to the model all at once, they can be inserted directly into the server database via the model's <db:link xlink:href="qml-enginio-enginioclient.xml">Enginio client</db:link>. The client is obtained from the model with <db:link xlink:href="enginiomodel.xml#client-prop">client</db:link>(). Then the ToDo objects are inserted into the server database with the client's <db:link xlink:href="qml-enginio-enginioclient.xml#create-method">create</db:link>() function. The model can then be reloaded from the server with <db:link xlink:href="enginiomodel.xml#reload">reload</db:link>().</db:para>
<db:para>But first we must create some infrastructure. Our <db:code>TodosModel</db:code> class is declared in <db:link xlink:href="">todos-cpp/todosmodel.h</db:link>. It inherits <db:link xlink:href="enginiomodel.xml">EnginioModel</db:link>, which is a <db:link xlink:href="qabstractlistmodel.xml">list model</db:link>. We add two roles to the <db:link xlink:href="enginio.xml#Role-enum">Enginio::Role enum</db:link>, chosen for the new properties, one for the ToDo <db:code>title</db:code> and one for marking a ToDo as <db:code>completed</db:code>. We assign enum values to the new roles, equating <db:code>TitleRole</db:code> to <db:link xlink:href="enginio.xml#Role-enum">Enginio::CustomPropertyRole</db:link>, which is itself equated to <db:link xlink:href="qt.xml#ItemDataRole-enum">Qt::UserRole</db:link> + 10.</db:para>
<db:programlisting language="cpp">class TodosModel : public EnginioModel
{
    Q_OBJECT

public:
    enum Role
    {
        TitleRole = Enginio::CustomPropertyRole,
        CompletedRole
    };
</db:programlisting>
<db:para>The new roles can be used for displaying and editing the values of the new properties. Views of the model also use roles from in <db:link xlink:href="qt.xml#ItemDataRole-enum">Qt::ItemDataRole</db:link> enum. The example's view is a <db:link xlink:href="qtreeview.xml">QTreeView</db:link>, as shown in the <db:link xlink:href="">MainWindow class</db:link>, which holds a pointer to the view, a pointer to the <db:link xlink:href="qml-enginio-enginioclient.xml">client</db:link>, and a pointer to the model.</db:para>
<db:para>A new <db:link xlink:href="enginiomodel.xml">EnginioModel</db:link> is empty. It automatically populates itself from the server, when its <db:link xlink:href="enginiomodel.xml#query-prop">query</db:link> and <db:link xlink:href="enginiomodel.xml#client-prop">client</db:link> properties have both been set. In the example, these properties are set in the constructor for the <db:link xlink:href="">main window</db:link>. The <db:link xlink:href="qml-enginio-enginioclient.xml">EnginioClient</db:link> is created first. Then an instance of the <db:code>ToDosModel</db:code> is created, and its client is set using <db:link xlink:href="enginiomodel.xml#client-prop">EnginioModel::setClient</db:link>(). Then the query is created as a <db:link xlink:href="qjsonobject.xml">QJsonObject</db:link>, and the model's query is set using <db:link xlink:href="enginiomodel.xml#query-prop">EnginioModel::setQuery</db:link>().</db:para>
<db:para>Once the ToDo data has been downloaded, the model resets itself, and sets up the internal data cache and roles names. <db:link xlink:href="enginiomodel.xml">EnginioModel</db:link> guesses the role names based on heuristics. It may be wrong if not all objects received from the backend have exactly the same structure. For example, a property can be missing in certain objects. To protect against such cases, we overload <db:link xlink:href="qabstractitemmodel.xml#roleNames">roleNames</db:link>(). Overriding <db:link xlink:href="qabstractitemmodel.xml#roleNames">roleNames</db:link>() can also be used to match default Qt roles to the named ones.</db:para>
<db:programlisting language="cpp">QHash&lt;int, QByteArray&gt; TodosModel::roleNames() const
{
    QHash&lt;int, QByteArray&gt; roles = EnginioModel::roleNames();
    roles.insert(TitleRole, &quot;title&quot;);
    roles.insert(Qt::DisplayRole, &quot;title&quot;);
    roles.insert(Qt::EditRole, &quot;title&quot;);
    roles.insert(CompletedRole, &quot;completed&quot;);
    return roles;
}
</db:programlisting>
<db:para>In this example, we map the <db:link xlink:href="qt.xml#ItemDataRole-enum">Qt::DisplayRole</db:link> and <db:link xlink:href="qt.xml#ItemDataRole-enum">Qt::EditRole</db:link> to the <db:code>title</db:code> property in the JSON. This way the right string is shown by default and editing works as expected.</db:para>
<db:para>Remember to always call the base class implementation to avoid situations in which the internal cache is not in sync.</db:para>
<db:para>By default <db:link xlink:href="enginiomodel.xml">EnginioModel</db:link> operates on <db:link xlink:href="qjsonvalue.xml">QJsonValue</db:link>, and that is what the <db:link xlink:href="qabstractitemmodel.xml#data">data</db:link>() function returns inside the <db:link xlink:href="qvariant.xml">QVariant</db:link>, but standard views, such as <db:link xlink:href="qlistview.xml">QListView</db:link>, use predefined roles which do not map directly to our roles. That is why we need to write a mapping between them:</db:para>
<db:programlisting language="cpp">QVariant TodosModel::data(const QModelIndex &amp;index, int role) const
{
    if (role == Qt::FontRole) {
        bool completed = EnginioModel::data(index, CompletedRole).value&lt;QJsonValue&gt;().toBool();
        QFont font;
        font.setPointSize(20);
        font.setStrikeOut(completed);
        return font;
    }

    if (role == Qt::TextColorRole) {
        bool completed = EnginioModel::data(index, CompletedRole).value&lt;QJsonValue&gt;().toBool();
        return completed ? QColor(&quot;#999&quot;) : QColor(&quot;#333&quot;);
    }

    if (role == CompletedRole)
        return EnginioModel::data(index, CompletedRole).value&lt;QJsonValue&gt;().toBool();

    // fallback to base class
    return EnginioModel::data(index, role);
}
</db:programlisting>
<db:para>As we have our model defined, we need to create an instance of <db:link xlink:href="qml-enginio-enginioclient.xml">EnginioClient</db:link>:</db:para>
<db:programlisting language="cpp">m_client = new EnginioClient(this);
m_client-&gt;setBackendId(EnginioBackendId);
</db:programlisting>
<db:para>It is used by the model to connect to the Enginio backend. Next we need to construct and configure our model too. The configuration is based on two steps, assigning an <db:link xlink:href="qml-enginio-enginioclient.xml">EnginioClient</db:link> instance and by creating a query.</db:para>
<db:programlisting language="cpp">m_model = new TodosModel(this);
m_model-&gt;setClient(m_client);

QJsonObject query;
query[&quot;objectType&quot;] = QString::fromUtf8(&quot;objects.todos&quot;);
m_model-&gt;setQuery(query);
</db:programlisting>
<db:para>The model has to be assigned to a view. In this example it is a <db:link xlink:href="qtreeview.xml">QTreeView</db:link>.</db:para>
<db:programlisting language="cpp">m_view-&gt;setModel(m_model);
</db:programlisting>
<db:para>To make the application fully functional, a way to add and remove a Todo is needed. To do so, we need to connect the correct buttons to slots for adding a new item:</db:para>
<db:anchor xml:id="mainwindow-appenditem"/>
<db:programlisting language="cpp">void MainWindow::appendItem()
{
    bool ok;
    QString text = QInputDialog::getText(this, tr(&quot;Create a new To Do&quot;)
                                         , tr(&quot;Title:&quot;), QLineEdit::Normal
                                         , &quot;&quot;, &amp;ok);
    if (ok &amp;&amp; !text.isEmpty()){
        QJsonObject object;
        object[&quot;title&quot;] = text;
        object[&quot;completed&quot;] = false; // By default a new To Do is not completed
        EnginioReply *reply = m_model-&gt;append(object);
        QObject::connect(reply, &amp;EnginioReply::finished, reply, &amp;EnginioReply::deleteLater);
    }
}
</db:programlisting>
<db:para>and for removing it:</db:para>
<db:programlisting language="cpp">void MainWindow::removeItem()
{
    QModelIndex index = m_view-&gt;currentIndex();
    EnginioReply *reply = m_model-&gt;remove(index.row());
    QObject::connect(reply, &amp;EnginioReply::finished, reply, &amp;EnginioReply::deleteLater);
}
</db:programlisting>
<db:section>
<db:title>List of Files</db:title>
<db:para>Files:</db:para>
<db:section>
<db:title>List of Files</db:title>
<db:itemizedlist>
<db:listitem>
<db:para><db:link xlink:href="todos-cpp/main.cpp">todos-cpp/main.cpp</db:link></db:para></db:listitem>
<db:listitem>
<db:para><db:link xlink:href="todos-cpp/mainwindow.cpp">todos-cpp/mainwindow.cpp</db:link></db:para></db:listitem>
<db:listitem>
<db:para><db:link xlink:href="todos-cpp/mainwindow.h">todos-cpp/mainwindow.h</db:link></db:para></db:listitem>
<db:listitem>
<db:para><db:link xlink:href="todos-cpp/todos-cpp.pro">todos-cpp/todos-cpp.pro</db:link></db:para></db:listitem>
<db:listitem>
<db:para><db:link xlink:href="todos-cpp/todosmodel.cpp">todos-cpp/todosmodel.cpp</db:link></db:para></db:listitem>
<db:listitem>
<db:para><db:link xlink:href="todos-cpp/todosmodel.h">todos-cpp/todosmodel.h</db:link></db:para></db:listitem>
</db:itemizedlist>
</db:section>
</db:section></db:article>
