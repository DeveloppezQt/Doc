<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en">
<db:info>
<db:title>Diagram Scene Example</db:title>
<db:productname>QtWidgets</db:productname>
<db:edition>Qt 6.1.3 Reference Documentation</db:edition>
<db:titleabbrev>Qt Widgets Reference Documentation</db:titleabbrev>
<db:abstract>
<db:para>Demonstrate how to use the Graphics View framework.</db:para>
</db:abstract>
<db:pubdate>2024-12-27</db:pubdate>
<db:date>2024-12-27</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:mediaobject>
<db:imageobject>
<db:imagedata fileref="images/diagramscene.png"/>
</db:imageobject>
</db:mediaobject>
<db:para>The Diagram Scene example is an application in which you can create a flowchart diagram. It is possible to add flowchart shapes and text and connect the shapes by arrows as shown in the image above. The shapes, arrows, and text can be given different colors, and it is possible to change the font, style, and underline of the text.</db:para>
<db:para>The Qt graphics view framework is designed to manage and display custom 2D graphics items. The main classes of the framework are <db:link xlink:href="qgraphicsitem.xml">QGraphicsItem</db:link>, <db:link xlink:href="qgraphicsscene.xml">QGraphicsScene</db:link> and <db:link xlink:href="qgraphicsview.xml">QGraphicsView</db:link>. The graphics scene manages the items and provides a surface for them. <db:link xlink:href="qgraphicsview.xml">QGraphicsView</db:link> is a widget that is used to render a scene on the screen. See the <db:link xlink:href="graphicsview.xml">Graphics View Framework</db:link> for a more detailed description of the framework.</db:para>
<db:para>In this example we show how to create such custom graphics scenes and items by implementing classes that inherit <db:link xlink:href="qgraphicsscene.xml">QGraphicsScene</db:link> and <db:link xlink:href="qgraphicsitem.xml">QGraphicsItem</db:link>.</db:para>
<db:para>In particular we show how to:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para>Create custom graphics items.</db:para>
</db:listitem>
<db:listitem>
<db:para>Handle mouse events and movement of items.</db:para>
</db:listitem>
<db:listitem>
<db:para>Implement a graphics scene that can manage our custom items.</db:para>
</db:listitem>
<db:listitem>
<db:para>Custom painting of items.</db:para>
</db:listitem>
<db:listitem>
<db:para>Create a movable and editable text item.</db:para>
</db:listitem>
</db:itemizedlist>
<db:para>The example consists of the following classes:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para>MainWindow creates the widgets and display them in a <db:link xlink:href="qmainwindow.xml">QMainWindow</db:link>. It also manages the interaction between the widgets and the graphics scene, view and items.</db:para>
</db:listitem>
<db:listitem>
<db:para>DiagramItem inherits <db:link xlink:href="qgraphicspolygonitem.xml">QGraphicsPolygonItem</db:link> and represents a flowchart shape.</db:para>
</db:listitem>
<db:listitem>
<db:para>TextDiagramItem inherits <db:link xlink:href="qgraphicstextitem.xml">QGraphicsTextItem</db:link> and represents text items in the diagram. The class adds support for moving the item with the mouse, which is not supported by <db:link xlink:href="qgraphicstextitem.xml">QGraphicsTextItem</db:link>.</db:para>
</db:listitem>
<db:listitem>
<db:para>Arrow inherits <db:link xlink:href="qgraphicslineitem.xml">QGraphicsLineItem</db:link> and is an arrow that connect two DiagramItems.</db:para>
</db:listitem>
<db:listitem>
<db:para>DiagramScene inherits QGraphicsDiagramScene and provides support for DiagramItem, Arrow and DiagramTextItem (In addition to the support already handled by <db:link xlink:href="qgraphicsscene.xml">QGraphicsScene</db:link>).</db:para>
</db:listitem>
</db:itemizedlist>
<db:section xml:id="mainwindow-class-definition">
<db:title>MainWindow Class Definition</db:title>
<db:programlisting language="cpp">class MainWindow : public QMainWindow
{
    Q_OBJECT

public:
   MainWindow();

private slots:
    void backgroundButtonGroupClicked(QAbstractButton *button);
    void buttonGroupClicked(QAbstractButton *button);
    void deleteItem();
    void pointerGroupClicked();
    void bringToFront();
    void sendToBack();
    void itemInserted(DiagramItem *item);
    void textInserted(QGraphicsTextItem *item);
    void currentFontChanged(const QFont &amp;amp;font);
    void fontSizeChanged(const QString &amp;amp;size);
    void sceneScaleChanged(const QString &amp;amp;scale);
    void textColorChanged();
    void itemColorChanged();
    void lineColorChanged();
    void textButtonTriggered();
    void fillButtonTriggered();
    void lineButtonTriggered();
    void handleFontChange();
    void itemSelected(QGraphicsItem *item);
    void about();

private:
    void createToolBox();
    void createActions();
    void createMenus();
    void createToolbars();
    QWidget *createBackgroundCellWidget(const QString &amp;amp;text,
                                        const QString &amp;amp;image);
    QWidget *createCellWidget(const QString &amp;amp;text,
                              DiagramItem::DiagramType type);
    QMenu *createColorMenu(const char *slot, QColor defaultColor);
    QIcon createColorToolButtonIcon(const QString &amp;amp;image, QColor color);
    QIcon createColorIcon(QColor color);

    DiagramScene *scene;
    QGraphicsView *view;

    QAction *exitAction;
    QAction *addAction;
    QAction *deleteAction;

    QAction *toFrontAction;
    QAction *sendBackAction;
    QAction *aboutAction;

    QMenu *fileMenu;
    QMenu *itemMenu;
    QMenu *aboutMenu;

    QToolBar *textToolBar;
    QToolBar *editToolBar;
    QToolBar *colorToolBar;
    QToolBar *pointerToolbar;

    QComboBox *sceneScaleCombo;
    QComboBox *itemColorCombo;
    QComboBox *textColorCombo;
    QComboBox *fontSizeCombo;
    QFontComboBox *fontCombo;

    QToolBox *toolBox;
    QButtonGroup *buttonGroup;
    QButtonGroup *pointerTypeGroup;
    QButtonGroup *backgroundButtonGroup;
    QToolButton *fontColorToolButton;
    QToolButton *fillColorToolButton;
    QToolButton *lineColorToolButton;
    QAction *boldAction;
    QAction *underlineAction;
    QAction *italicAction;
    QAction *textAction;
    QAction *fillAction;
    QAction *lineAction;
};
</db:programlisting>
<db:para>The MainWindow class creates and lays out the widgets in a <db:link xlink:href="qmainwindow.xml">QMainWindow</db:link>. The class forwards input from the widgets to the DiagramScene. It also updates its widgets when the diagram scene's text item changes, or a diagram item or a diagram text item is inserted into the scene.</db:para>
<db:para>The class also deletes items from the scene and handles the z-ordering, which decides the order in which items are drawn when they overlap each other.</db:para>
</db:section>
<db:section xml:id="mainwindow-class-implementation">
<db:title>MainWindow Class Implementation</db:title>
<db:para>We start with a look at the constructor:</db:para>
<db:programlisting language="cpp">MainWindow::MainWindow()
{
    createActions();
    createToolBox();
    createMenus();

    scene = new DiagramScene(itemMenu, this);
    scene-&amp;gt;setSceneRect(QRectF(0, 0, 5000, 5000));
    connect(scene, &amp;amp;DiagramScene::itemInserted,
            this, &amp;amp;MainWindow::itemInserted);
    connect(scene, &amp;amp;DiagramScene::textInserted,
            this, &amp;amp;MainWindow::textInserted);
    connect(scene, &amp;amp;DiagramScene::itemSelected,
            this, &amp;amp;MainWindow::itemSelected);
    createToolbars();

    QHBoxLayout *layout = new QHBoxLayout;
    layout-&amp;gt;addWidget(toolBox);
    view = new QGraphicsView(scene);
    layout-&amp;gt;addWidget(view);

    QWidget *widget = new QWidget;
    widget-&amp;gt;setLayout(layout);

    setCentralWidget(widget);
    setWindowTitle(tr(&quot;Diagramscene&quot;));
    setUnifiedTitleAndToolBarOnMac(true);
}
</db:programlisting>
<db:para>In the constructor we call methods to create the widgets and layouts of the example before we create the diagram scene. The toolbars must be created after the scene as they connect to its signals. We then lay the widgets out in the window.</db:para>
<db:para>We connect to the itemInserted() and textInserted() slots of the diagram scenes as we want to uncheck the buttons in the tool box when an item is inserted. When an item is selected in the scene we receive the itemSelected() signal. We use this to update the widgets that display font properties if the item selected is a DiagramTextItem.</db:para>
<db:para>The createToolBox() function creates and lays out the widgets of the toolBox <db:link xlink:href="qtoolbox.xml">QToolBox</db:link>. We will not examine it with a high level of detail as it does not deal with graphics framework specific functionality. Here is its implementation:</db:para>
<db:programlisting language="cpp">void MainWindow::createToolBox()
{
    buttonGroup = new QButtonGroup(this);
    buttonGroup-&amp;gt;setExclusive(false);
    connect(buttonGroup, QOverload&amp;lt;QAbstractButton *&amp;gt;::of(&amp;amp;QButtonGroup::buttonClicked),
            this, &amp;amp;MainWindow::buttonGroupClicked);
    QGridLayout *layout = new QGridLayout;
    layout-&amp;gt;addWidget(createCellWidget(tr(&quot;Conditional&quot;), DiagramItem::Conditional), 0, 0);
    layout-&amp;gt;addWidget(createCellWidget(tr(&quot;Process&quot;), DiagramItem::Step),0, 1);
    layout-&amp;gt;addWidget(createCellWidget(tr(&quot;Input/Output&quot;), DiagramItem::Io), 1, 0);
</db:programlisting>
<db:para>This part of the function sets up the tabbed widget item that contains the flowchart shapes. An exclusive <db:link xlink:href="qbuttongroup.xml">QButtonGroup</db:link> always keeps one button checked; we want the group to allow all buttons to be unchecked. We still use a button group since we can associate user data, which we use to store the diagram type, with each button. The createCellWidget() function sets up the buttons in the tabbed widget item and is examined later.</db:para>
<db:para>The buttons of the background tabbed widget item is set up in the same way, so we skip to the creation of the tool box:</db:para>
<db:programlisting language="cpp">    toolBox = new QToolBox;
    toolBox-&amp;gt;setSizePolicy(QSizePolicy(QSizePolicy::Maximum, QSizePolicy::Ignored));
    toolBox-&amp;gt;setMinimumWidth(itemWidget-&amp;gt;sizeHint().width());
    toolBox-&amp;gt;addItem(itemWidget, tr(&quot;Basic Flowchart Shapes&quot;));
    toolBox-&amp;gt;addItem(backgroundWidget, tr(&quot;Backgrounds&quot;));
}
</db:programlisting>
<db:para>We set the preferred size of the toolbox as its maximum. This way, more space is given to the graphics view.</db:para>
<db:para>Here is the createActions() function:</db:para>
<db:programlisting language="cpp">void MainWindow::createActions()
{
    toFrontAction = new QAction(QIcon(&quot;:/images/bringtofront.png&quot;),
                                tr(&quot;Bring to &amp;amp;Front&quot;), this);
    toFrontAction-&amp;gt;setShortcut(tr(&quot;Ctrl+F&quot;));
    toFrontAction-&amp;gt;setStatusTip(tr(&quot;Bring item to front&quot;));
    connect(toFrontAction, &amp;amp;QAction::triggered, this, &amp;amp;MainWindow::bringToFront);
</db:programlisting>
<db:para>We show an example of the creation of an action. The functionality the actions trigger is discussed in the slots we connect the actions to. You can see the <db:link xlink:href="qtwidgets-mainwindows-application-example.xml">application example</db:link> if you need a high-level introduction to actions.</db:para>
<db:para>The is the createMenus() function:</db:para>
<db:programlisting language="cpp">void MainWindow::createMenus()
{
    fileMenu = menuBar()-&amp;gt;addMenu(tr(&quot;&amp;amp;File&quot;));
    fileMenu-&amp;gt;addAction(exitAction);

    itemMenu = menuBar()-&amp;gt;addMenu(tr(&quot;&amp;amp;Item&quot;));
    itemMenu-&amp;gt;addAction(deleteAction);
    itemMenu-&amp;gt;addSeparator();
    itemMenu-&amp;gt;addAction(toFrontAction);
    itemMenu-&amp;gt;addAction(sendBackAction);

    aboutMenu = menuBar()-&amp;gt;addMenu(tr(&quot;&amp;amp;Help&quot;));
    aboutMenu-&amp;gt;addAction(aboutAction);
}
</db:programlisting>
<db:para>We create the three menus' of the example.</db:para>
<db:para>The createToolbars() function sets up the examples tool bars. The three <db:link xlink:href="qtoolbutton.xml">QToolButton</db:link>s in the colorToolBar, the fontColorToolButton, fillColorToolButton, and lineColorToolButton, are interesting as we create icons for them by drawing on a <db:link xlink:href="qpixmap.xml">QPixmap</db:link> with a <db:link xlink:href="qpainter.xml">QPainter</db:link>. We show how the fillColorToolButton is created. This button lets the user select a color for the diagram items.</db:para>
<db:programlisting language="cpp">void MainWindow::createToolbars()
{
    ...
    fillColorToolButton = new QToolButton;
    fillColorToolButton-&amp;gt;setPopupMode(QToolButton::MenuButtonPopup);
    fillColorToolButton-&amp;gt;setMenu(createColorMenu(SLOT(itemColorChanged()), Qt::white));
    fillAction = fillColorToolButton-&amp;gt;menu()-&amp;gt;defaultAction();
    fillColorToolButton-&amp;gt;setIcon(createColorToolButtonIcon(
                                     &quot;:/images/floodfill.png&quot;, Qt::white));
    connect(fillColorToolButton, &amp;amp;QAbstractButton::clicked,
            this, &amp;amp;MainWindow::fillButtonTriggered);
</db:programlisting>
<db:para>We set the menu of the tool button with <db:link xlink:href="qtoolbutton.xml#setMenu">setMenu</db:link>(). We need the fillAction <db:link xlink:href="qaction.xml">QAction</db:link> object to always be pointing to the selected action of the menu. The menu is created with the createColorMenu() function and, as we shall see later, contains one menu item for each color that the items can have. When the user presses the button, which trigger the <db:link xlink:href="qabstractbutton.xml#clicked">clicked</db:link>() signal, we can set the color of the selected item to the color of fillAction. It is with createColorToolButtonIcon() we create the icon for the button.</db:para>
<db:programlisting language="cpp">    ...
}
</db:programlisting>
<db:para>Here is the createBackgroundCellWidget() function:</db:para>
<db:programlisting language="cpp">QWidget *MainWindow::createBackgroundCellWidget(const QString &amp;amp;text, const QString &amp;amp;image)
{
    QToolButton *button = new QToolButton;
    button-&amp;gt;setText(text);
    button-&amp;gt;setIcon(QIcon(image));
    button-&amp;gt;setIconSize(QSize(50, 50));
    button-&amp;gt;setCheckable(true);
    backgroundButtonGroup-&amp;gt;addButton(button);

    QGridLayout *layout = new QGridLayout;
    layout-&amp;gt;addWidget(button, 0, 0, Qt::AlignHCenter);
    layout-&amp;gt;addWidget(new QLabel(text), 1, 0, Qt::AlignCenter);

    QWidget *widget = new QWidget;
    widget-&amp;gt;setLayout(layout);

    return widget;
}
</db:programlisting>
<db:para>This function creates <db:link xlink:href="qwidget.xml">QWidget</db:link>s containing a tool button and a label. The widgets created with this function are used for the background tabbed widget item in the tool box.</db:para>
<db:para>Here is the createCellWidget() function:</db:para>
<db:programlisting language="cpp">QWidget *MainWindow::createCellWidget(const QString &amp;amp;text, DiagramItem::DiagramType type)
{

    DiagramItem item(type, itemMenu);
    QIcon icon(item.image());

    QToolButton *button = new QToolButton;
    button-&amp;gt;setIcon(icon);
    button-&amp;gt;setIconSize(QSize(50, 50));
    button-&amp;gt;setCheckable(true);
    buttonGroup-&amp;gt;addButton(button, int(type));

    QGridLayout *layout = new QGridLayout;
    layout-&amp;gt;addWidget(button, 0, 0, Qt::AlignHCenter);
    layout-&amp;gt;addWidget(new QLabel(text), 1, 0, Qt::AlignCenter);

    QWidget *widget = new QWidget;
    widget-&amp;gt;setLayout(layout);

    return widget;
}
</db:programlisting>
<db:para>This function returns a <db:link xlink:href="qwidget.xml">QWidget</db:link> containing a <db:link xlink:href="qtoolbutton.xml">QToolButton</db:link> with an image of one of the DiagramItems, i.e., flowchart shapes. The image is created by the DiagramItem through the image() function. The <db:link xlink:href="qbuttongroup.xml">QButtonGroup</db:link> class lets us attach an id (int) with each button; we store the diagram's type, i.e., the DiagramItem::DiagramType enum. We use the stored diagram type when we create new diagram items for the scene. The widgets created with this function is used in the tool box.</db:para>
<db:para>Here is the createColorMenu() function:</db:para>
<db:programlisting language="cpp">QMenu *MainWindow::createColorMenu(const char *slot, QColor defaultColor)
{
    QList&amp;lt;QColor&amp;gt; colors;
    colors &amp;lt;&amp;lt; Qt::black &amp;lt;&amp;lt; Qt::white &amp;lt;&amp;lt; Qt::red &amp;lt;&amp;lt; Qt::blue &amp;lt;&amp;lt; Qt::yellow;
    QStringList names;
    names &amp;lt;&amp;lt; tr(&quot;black&quot;) &amp;lt;&amp;lt; tr(&quot;white&quot;) &amp;lt;&amp;lt; tr(&quot;red&quot;) &amp;lt;&amp;lt; tr(&quot;blue&quot;)
          &amp;lt;&amp;lt; tr(&quot;yellow&quot;);

    QMenu *colorMenu = new QMenu(this);
    for (int i = 0; i &amp;lt; colors.count(); ++i) {
        QAction *action = new QAction(names.at(i), this);
        action-&amp;gt;setData(colors.at(i));
        action-&amp;gt;setIcon(createColorIcon(colors.at(i)));
        connect(action, SIGNAL(triggered()), this, slot);
        colorMenu-&amp;gt;addAction(action);
        if (colors.at(i) == defaultColor)
            colorMenu-&amp;gt;setDefaultAction(action);
    }
    return colorMenu;
}
</db:programlisting>
<db:para>This function creates a color menu that is used as the drop-down menu for the tool buttons in the colorToolBar. We create an action for each color that we add to the menu. We fetch the actions data when we set the color of items, lines, and text.</db:para>
<db:para>Here is the createColorToolButtonIcon() function:</db:para>
<db:programlisting language="cpp">QIcon MainWindow::createColorToolButtonIcon(const QString &amp;amp;imageFile, QColor color)
{
    QPixmap pixmap(50, 80);
    pixmap.fill(Qt::transparent);
    QPainter painter(&amp;amp;pixmap);
    QPixmap image(imageFile);
    // Draw icon centred horizontally on button.
    QRect target(4, 0, 42, 43);
    QRect source(0, 0, 42, 43);
    painter.fillRect(QRect(0, 60, 50, 80), color);
    painter.drawPixmap(target, image, source);

    return QIcon(pixmap);
}
</db:programlisting>
<db:para>This function is used to create the <db:link xlink:href="qicon.xml">QIcon</db:link> of the fillColorToolButton, fontColorToolButton, and lineColorToolButton. The <db:code role="parameter">imageFile</db:code> string is either the text, flood-fill, or line symbol that is used for the buttons. Beneath the image we draw a filled rectangle using <db:code role="parameter">color</db:code>.</db:para>
<db:para>Here is the createColorIcon() function:</db:para>
<db:programlisting language="cpp">QIcon MainWindow::createColorIcon(QColor color)
{
    QPixmap pixmap(20, 20);
    QPainter painter(&amp;amp;pixmap);
    painter.setPen(Qt::NoPen);
    painter.fillRect(QRect(0, 0, 20, 20), color);

    return QIcon(pixmap);
}
</db:programlisting>
<db:para>This function creates an icon with a filled rectangle in the color of <db:code role="parameter">color</db:code>. It is used for creating icons for the color menus in the fillColorToolButton, fontColorToolButton, and lineColorToolButton.</db:para>
<db:para>Here is the backgroundButtonGroupClicked() slot:</db:para>
<db:programlisting language="cpp">void MainWindow::backgroundButtonGroupClicked(QAbstractButton *button)
{
    const QList&amp;lt;QAbstractButton *&amp;gt; buttons = backgroundButtonGroup-&amp;gt;buttons();
    for (QAbstractButton *myButton : buttons) {
        if (myButton != button)
            button-&amp;gt;setChecked(false);
    }
    QString text = button-&amp;gt;text();
    if (text == tr(&quot;Blue Grid&quot;))
        scene-&amp;gt;setBackgroundBrush(QPixmap(&quot;:/images/background1.png&quot;));
    else if (text == tr(&quot;White Grid&quot;))
        scene-&amp;gt;setBackgroundBrush(QPixmap(&quot;:/images/background2.png&quot;));
    else if (text == tr(&quot;Gray Grid&quot;))
        scene-&amp;gt;setBackgroundBrush(QPixmap(&quot;:/images/background3.png&quot;));
    else
        scene-&amp;gt;setBackgroundBrush(QPixmap(&quot;:/images/background4.png&quot;));

    scene-&amp;gt;update();
    view-&amp;gt;update();
}
</db:programlisting>
<db:para>In this function we set the <db:link xlink:href="qbrush.xml">QBrush</db:link> that is used to draw the background of the diagramscene. The background can be a grid of squares of blue, gray, or white tiles, or no grid at all. We have <db:link xlink:href="qpixmap.xml">QPixmap</db:link>s of the tiles from png files that we create the brush with.</db:para>
<db:para>When one of the buttons in the background tabbed widget item is clicked we change the brush; we find out which button it is by checking its text.</db:para>
<db:para>Here is the implementation of buttonGroupClicked():</db:para>
<db:programlisting language="cpp">void MainWindow::buttonGroupClicked(QAbstractButton *button)
{
    const QList&amp;lt;QAbstractButton *&amp;gt; buttons = buttonGroup-&amp;gt;buttons();
    for (QAbstractButton *myButton : buttons) {
        if (myButton != button)
            button-&amp;gt;setChecked(false);
    }
    const int id = buttonGroup-&amp;gt;id(button);
    if (id == InsertTextButton) {
        scene-&amp;gt;setMode(DiagramScene::InsertText);
    } else {
        scene-&amp;gt;setItemType(DiagramItem::DiagramType(id));
        scene-&amp;gt;setMode(DiagramScene::InsertItem);
    }
}
</db:programlisting>
<db:para>This slot is called when a button in buttonGroup is checked. When a button is checked the user can click on the graphics view and a DiagramItem of the selected type will be inserted into the DiagramScene. We must loop through the buttons in the group to uncheck other buttons as only one button is allowed to be checked at a time.</db:para>
<db:para>QButtonGroup assigns an id to each button. We have set the id of each button to the diagram type, as given by DiagramItem::DiagramType that will be inserted into the scene when it is clicked. We can then use the button id when we set the diagram type with setItemType(). In the case of text we assigned an id that has a value that is not in the DiagramType enum.</db:para>
<db:para>Here is the implementation of deleteItem():</db:para>
<db:programlisting language="cpp">void MainWindow::deleteItem()
{
    QList&amp;lt;QGraphicsItem *&amp;gt; selectedItems = scene-&amp;gt;selectedItems();
    for (QGraphicsItem *item : qAsConst(selectedItems)) {
        if (item-&amp;gt;type() == Arrow::Type) {
            scene-&amp;gt;removeItem(item);
            Arrow *arrow = qgraphicsitem_cast&amp;lt;Arrow *&amp;gt;(item);
            arrow-&amp;gt;startItem()-&amp;gt;removeArrow(arrow);
            arrow-&amp;gt;endItem()-&amp;gt;removeArrow(arrow);
            delete item;
        }
    }

    selectedItems = scene-&amp;gt;selectedItems();
    for (QGraphicsItem *item : qAsConst(selectedItems)) {
         if (item-&amp;gt;type() == DiagramItem::Type)
             qgraphicsitem_cast&amp;lt;DiagramItem *&amp;gt;(item)-&amp;gt;removeArrows();
         scene-&amp;gt;removeItem(item);
         delete item;
     }
}
</db:programlisting>
<db:para>This slot deletes the selected item, if any, from the scene. It deletes the arrows first in order to avoid to delete them twice. If the item to be deleted is a DiagramItem, we also need to delete arrows connected to it; we don't want arrows in the scene that aren't connected to items in both ends.</db:para>
<db:para>This is the implementation of pointerGroupClicked():</db:para>
<db:programlisting language="cpp">void MainWindow::pointerGroupClicked()
{
    scene-&amp;gt;setMode(DiagramScene::Mode(pointerTypeGroup-&amp;gt;checkedId()));
}
</db:programlisting>
<db:para>The pointerTypeGroup decides whether the scene is in ItemMove or InsertLine mode. This button group is exclusive, i.e., only one button is checked at any time. As with the buttonGroup above we have assigned an id to the buttons that matches values of the DiagramScene::Mode enum, so that we can use the id to set the correct mode.</db:para>
<db:para>Here is the bringToFront() slot:</db:para>
<db:programlisting language="cpp">void MainWindow::bringToFront()
{
    if (scene-&amp;gt;selectedItems().isEmpty())
        return;

    QGraphicsItem *selectedItem = scene-&amp;gt;selectedItems().first();
    const QList&amp;lt;QGraphicsItem *&amp;gt; overlapItems = selectedItem-&amp;gt;collidingItems();

    qreal zValue = 0;
    for (const QGraphicsItem *item : overlapItems) {
        if (item-&amp;gt;zValue() &amp;gt;= zValue &amp;amp;&amp;amp; item-&amp;gt;type() == DiagramItem::Type)
            zValue = item-&amp;gt;zValue() + 0.1;
    }
    selectedItem-&amp;gt;setZValue(zValue);
}
</db:programlisting>
<db:para>Several items may collide, i.e., overlap, with each other in the scene. This slot is called when the user requests that an item should be placed on top of the items it collides with. <db:link xlink:href="qgraphicsitem.xml">QGrapicsItems</db:link> have a z-value that decides the order in which items are stacked in the scene; you can think of it as the z-axis in a 3D coordinate system. When items collide the items with higher z-values will be drawn on top of items with lower values. When we bring an item to the front we can loop through the items it collides with and set a z-value that is higher than all of them.</db:para>
<db:para>Here is the sendToBack() slot:</db:para>
<db:programlisting language="cpp">void MainWindow::sendToBack()
{
    if (scene-&amp;gt;selectedItems().isEmpty())
        return;

    QGraphicsItem *selectedItem = scene-&amp;gt;selectedItems().first();
    const QList&amp;lt;QGraphicsItem *&amp;gt; overlapItems = selectedItem-&amp;gt;collidingItems();

    qreal zValue = 0;
    for (const QGraphicsItem *item : overlapItems) {
        if (item-&amp;gt;zValue() &amp;lt;= zValue &amp;amp;&amp;amp; item-&amp;gt;type() == DiagramItem::Type)
            zValue = item-&amp;gt;zValue() - 0.1;
    }
    selectedItem-&amp;gt;setZValue(zValue);
}
</db:programlisting>
<db:para>This slot works in the same way as bringToFront() described above, but sets a z-value that is lower than items the item that should be send to the back collides with.</db:para>
<db:para>This is the implementation of itemInserted():</db:para>
<db:programlisting language="cpp">void MainWindow::itemInserted(DiagramItem *item)
{
    pointerTypeGroup-&amp;gt;button(int(DiagramScene::MoveItem))-&amp;gt;setChecked(true);
    scene-&amp;gt;setMode(DiagramScene::Mode(pointerTypeGroup-&amp;gt;checkedId()));
    buttonGroup-&amp;gt;button(int(item-&amp;gt;diagramType()))-&amp;gt;setChecked(false);
}
</db:programlisting>
<db:para>This slot is called from the DiagramScene when an item has been added to the scene. We set the mode of the scene back to the mode before the item was inserted, which is ItemMove or InsertText depending on which button is checked in the pointerTypeGroup. We must also uncheck the button in the in the buttonGroup.</db:para>
<db:para>Here is the implementation of textInserted():</db:para>
<db:programlisting language="cpp">void MainWindow::textInserted(QGraphicsTextItem *)
{
    buttonGroup-&amp;gt;button(InsertTextButton)-&amp;gt;setChecked(false);
    scene-&amp;gt;setMode(DiagramScene::Mode(pointerTypeGroup-&amp;gt;checkedId()));
}
</db:programlisting>
<db:para>We simply set the mode of the scene back to the mode it had before the text was inserted.</db:para>
<db:para>Here is the currentFontChanged() slot:</db:para>
<db:programlisting language="cpp">void MainWindow::currentFontChanged(const QFont &amp;amp;)
{
    handleFontChange();
}
</db:programlisting>
<db:para>When the user requests a font change, by using one of the widgets in the fontToolBar, we create a new <db:link xlink:href="qfont.xml">QFont</db:link> object and set its properties to match the state of the widgets. This is done in handleFontChange(), so we simply call that slot.</db:para>
<db:para>Here is the fontSizeChanged() slot:</db:para>
<db:programlisting language="cpp">void MainWindow::fontSizeChanged(const QString &amp;amp;)
{
    handleFontChange();
}
</db:programlisting>
<db:para>When the user requests a font change, by using one of the widgets in the fontToolBar, we create a new <db:link xlink:href="qfont.xml">QFont</db:link> object and set its properties to match the state of the widgets. This is done in handleFontChange(), so we simply call that slot.</db:para>
<db:para>Here is the implementation of sceneScaleChanged():</db:para>
<db:programlisting language="cpp">void MainWindow::sceneScaleChanged(const QString &amp;amp;scale)
{
    double newScale = scale.left(scale.indexOf(tr(&quot;%&quot;))).toDouble() / 100.0;
    QTransform oldMatrix = view-&amp;gt;transform();
    view-&amp;gt;resetTransform();
    view-&amp;gt;translate(oldMatrix.dx(), oldMatrix.dy());
    view-&amp;gt;scale(newScale, newScale);
}
</db:programlisting>
<db:para>The user can increase or decrease the scale, with the sceneScaleCombo, the scene is drawn in. It is not the scene itself that changes its scale, but only the view.</db:para>
<db:para>Here is the textColorChanged() slot:</db:para>
<db:programlisting language="cpp">void MainWindow::textColorChanged()
{
    textAction = qobject_cast&amp;lt;QAction *&amp;gt;(sender());
    fontColorToolButton-&amp;gt;setIcon(createColorToolButtonIcon(
                                     &quot;:/images/textpointer.png&quot;,
                                     qvariant_cast&amp;lt;QColor&amp;gt;(textAction-&amp;gt;data())));
    textButtonTriggered();
}
</db:programlisting>
<db:para>This slot is called when an item in the drop-down menu of the fontColorToolButton is pressed. We need to change the icon on the button to the color of the selected <db:link xlink:href="qaction.xml">QAction</db:link>. We keep a pointer to the selected action in textAction. It is in textButtonTriggered() we change the text color to the color of textAction, so we call that slot.</db:para>
<db:para>Here is the itemColorChanged() implementation:</db:para>
<db:programlisting language="cpp">void MainWindow::itemColorChanged()
{
    fillAction = qobject_cast&amp;lt;QAction *&amp;gt;(sender());
    fillColorToolButton-&amp;gt;setIcon(createColorToolButtonIcon(
                                     &quot;:/images/floodfill.png&quot;,
                                     qvariant_cast&amp;lt;QColor&amp;gt;(fillAction-&amp;gt;data())));
    fillButtonTriggered();
}
</db:programlisting>
<db:para>This slot handles requests for changing the color of DiagramItems in the same manner as textColorChanged() does for DiagramTextItems.</db:para>
<db:para>Here is the implementation of lineColorChanged():</db:para>
<db:programlisting language="cpp">void MainWindow::lineColorChanged()
{
    lineAction = qobject_cast&amp;lt;QAction *&amp;gt;(sender());
    lineColorToolButton-&amp;gt;setIcon(createColorToolButtonIcon(
                                     &quot;:/images/linecolor.png&quot;,
                                     qvariant_cast&amp;lt;QColor&amp;gt;(lineAction-&amp;gt;data())));
    lineButtonTriggered();
}
</db:programlisting>
<db:para>This slot handles requests for changing the color of Arrows in the same manner that textColorChanged() does it for DiagramTextItems.</db:para>
<db:para>Here is the textButtonTriggered() slot:</db:para>
<db:programlisting language="cpp">void MainWindow::textButtonTriggered()
{
    scene-&amp;gt;setTextColor(qvariant_cast&amp;lt;QColor&amp;gt;(textAction-&amp;gt;data()));
}
</db:programlisting>
<db:para>textAction points to the <db:link xlink:href="qaction.xml">QAction</db:link> of the currently selected menu item in the fontColorToolButton's color drop-down menu. We have set the data of the action to the <db:link xlink:href="qcolor.xml">QColor</db:link> the action represents, so we can simply fetch this when we set the color of text with setTextColor().</db:para>
<db:para>Here is the fillButtonTriggered() slot:</db:para>
<db:programlisting language="cpp">void MainWindow::fillButtonTriggered()
{
    scene-&amp;gt;setItemColor(qvariant_cast&amp;lt;QColor&amp;gt;(fillAction-&amp;gt;data()));
}
</db:programlisting>
<db:para>fillAction points to the selected menu item in the drop-down menu of fillColorToolButton(). We can therefore use the data of this action when we set the item color with setItemColor().</db:para>
<db:para>Here is the lineButtonTriggered() slot:</db:para>
<db:programlisting language="cpp">void MainWindow::lineButtonTriggered()
{
    scene-&amp;gt;setLineColor(qvariant_cast&amp;lt;QColor&amp;gt;(lineAction-&amp;gt;data()));
}
</db:programlisting>
<db:para>lineAction point to the selected item in the drop-down menu of lineColorToolButton. We use its data when we set the arrow color with setLineColor().</db:para>
<db:para>Here is the handleFontChange() function:</db:para>
<db:programlisting language="cpp">void MainWindow::handleFontChange()
{
    QFont font = fontCombo-&amp;gt;currentFont();
    font.setPointSize(fontSizeCombo-&amp;gt;currentText().toInt());
    font.setWeight(boldAction-&amp;gt;isChecked() ? QFont::Bold : QFont::Normal);
    font.setItalic(italicAction-&amp;gt;isChecked());
    font.setUnderline(underlineAction-&amp;gt;isChecked());

    scene-&amp;gt;setFont(font);
}
</db:programlisting>
<db:para>handleFontChange() is called when any of the widgets that show font properties changes. We create a new <db:link xlink:href="qfont.xml">QFont</db:link> object and set its properties based on the widgets. We then call the setFont() function of DiagramScene; it is the scene that set the font of the DiagramTextItems it manages.</db:para>
<db:para>Here is the itemSelected() slot:</db:para>
<db:programlisting language="cpp">void MainWindow::itemSelected(QGraphicsItem *item)
{
    DiagramTextItem *textItem =
    qgraphicsitem_cast&amp;lt;DiagramTextItem *&amp;gt;(item);

    QFont font = textItem-&amp;gt;font();
    fontCombo-&amp;gt;setCurrentFont(font);
    fontSizeCombo-&amp;gt;setEditText(QString().setNum(font.pointSize()));
    boldAction-&amp;gt;setChecked(font.weight() == QFont::Bold);
    italicAction-&amp;gt;setChecked(font.italic());
    underlineAction-&amp;gt;setChecked(font.underline());
}
</db:programlisting>
<db:para>This slot is called when an item in the DiagramScene is selected. In the case of this example it is only text items that emit signals when they are selected, so we do not need to check what kind of graphics <db:code role="parameter">item</db:code> is.</db:para>
<db:para>We set the state of the widgets to match the properties of the font of the selected text item.</db:para>
<db:para>This is the about() slot:</db:para>
<db:programlisting language="cpp">void MainWindow::about()
{
    QMessageBox::about(this, tr(&quot;About Diagram Scene&quot;),
                       tr(&quot;The &amp;lt;b&amp;gt;Diagram Scene&amp;lt;/b&amp;gt; example shows &quot;
                          &quot;use of the graphics framework.&quot;));
}
</db:programlisting>
<db:para>This slot displays an about box for the example when the user selects the about menu item from the help menu.</db:para>
</db:section>
<db:section xml:id="diagramscene-class-definition">
<db:title>DiagramScene Class Definition</db:title>
<db:para>The DiagramScene class inherits <db:link xlink:href="qgraphicsscene.xml">QGraphicsScene</db:link> and adds functionality to handle DiagramItems, Arrows, and DiagramTextItems in addition to the items handled by its super class.</db:para>
<db:programlisting language="cpp">class DiagramScene : public QGraphicsScene
{
    Q_OBJECT

public:
    enum Mode { InsertItem, InsertLine, InsertText, MoveItem };

    explicit DiagramScene(QMenu *itemMenu, QObject *parent = nullptr);
    QFont font() const { return myFont; }
    QColor textColor() const { return myTextColor; }
    QColor itemColor() const { return myItemColor; }
    QColor lineColor() const { return myLineColor; }
    void setLineColor(const QColor &amp;amp;color);
    void setTextColor(const QColor &amp;amp;color);
    void setItemColor(const QColor &amp;amp;color);
    void setFont(const QFont &amp;amp;font);

public slots:
    void setMode(Mode mode);
    void setItemType(DiagramItem::DiagramType type);
    void editorLostFocus(DiagramTextItem *item);

signals:
    void itemInserted(DiagramItem *item);
    void textInserted(QGraphicsTextItem *item);
    void itemSelected(QGraphicsItem *item);

protected:
    void mousePressEvent(QGraphicsSceneMouseEvent *mouseEvent) override;
    void mouseMoveEvent(QGraphicsSceneMouseEvent *mouseEvent) override;
    void mouseReleaseEvent(QGraphicsSceneMouseEvent *mouseEvent) override;

private:
    bool isItemChange(int type) const;

    DiagramItem::DiagramType myItemType;
    QMenu *myItemMenu;
    Mode myMode;
    bool leftButtonDown;
    QPointF startPoint;
    QGraphicsLineItem *line;
    QFont myFont;
    DiagramTextItem *textItem;
    QColor myTextColor;
    QColor myItemColor;
    QColor myLineColor;
};
</db:programlisting>
<db:para>In the DiagramScene a mouse click can give three different actions: the item under the mouse can be moved, an item may be inserted, or an arrow may be connected between to diagram items. Which action a mouse click has depends on the mode, given by the Mode enum, the scene is in. The mode is set with the setMode() function.</db:para>
<db:para>The scene also sets the color of its items and the font of its text items. The colors and font used by the scene can be set with the setLineColor(), setTextColor(), setItemColor() and setFont() functions. The type of DiagramItem, given by the DiagramItem::DiagramType function, to be created when an item is inserted is set with the setItemType() slot.</db:para>
<db:para>The MainWindow and DiagramScene share responsibility for the examples functionality. MainWindow handles the following tasks: the deletion of items, text, and arrows; moving diagram items to the back and front; and setting the scale of the scene.</db:para>
</db:section>
<db:section xml:id="diagramscene-class-implementation">
<db:title>DiagramScene Class Implementation</db:title>
<db:para>We start with the constructor:</db:para>
<db:programlisting language="cpp">DiagramScene::DiagramScene(QMenu *itemMenu, QObject *parent)
    : QGraphicsScene(parent)
{
    myItemMenu = itemMenu;
    myMode = MoveItem;
    myItemType = DiagramItem::Step;
    line = nullptr;
    textItem = nullptr;
    myItemColor = Qt::white;
    myTextColor = Qt::black;
    myLineColor = Qt::black;
}
</db:programlisting>
<db:para>The scene uses myItemMenu to set the context menu when it creates DiagramItems. We set the default mode to DiagramScene::MoveItem as this gives the default behavior of <db:link xlink:href="qgraphicsscene.xml">QGraphicsScene</db:link>.</db:para>
<db:para>Here is the setLineColor() function:</db:para>
<db:programlisting language="cpp">void DiagramScene::setLineColor(const QColor &amp;amp;color)
{
    myLineColor = color;
    if (isItemChange(Arrow::Type)) {
        Arrow *item = qgraphicsitem_cast&amp;lt;Arrow *&amp;gt;(selectedItems().first());
        item-&amp;gt;setColor(myLineColor);
        update();
    }
}
</db:programlisting>
<db:para>The isItemChange function returns true if an Arrow item is selected in the scene in which case we want to change its color. When the DiagramScene creates and adds new arrows to the scene it will also use the new <db:code role="parameter">color</db:code>.</db:para>
<db:para>Here is the setTextColor() function:</db:para>
<db:programlisting language="cpp">void DiagramScene::setTextColor(const QColor &amp;amp;color)
{
    myTextColor = color;
    if (isItemChange(DiagramTextItem::Type)) {
        DiagramTextItem *item = qgraphicsitem_cast&amp;lt;DiagramTextItem *&amp;gt;(selectedItems().first());
        item-&amp;gt;setDefaultTextColor(myTextColor);
    }
}
</db:programlisting>
<db:para>This function sets the color of DiagramTextItems equal to the way setLineColor() sets the color of Arrows.</db:para>
<db:para>Here is the setItemColor() function:</db:para>
<db:programlisting language="cpp">void DiagramScene::setItemColor(const QColor &amp;amp;color)
{
    myItemColor = color;
    if (isItemChange(DiagramItem::Type)) {
        DiagramItem *item = qgraphicsitem_cast&amp;lt;DiagramItem *&amp;gt;(selectedItems().first());
        item-&amp;gt;setBrush(myItemColor);
    }
}
</db:programlisting>
<db:para>This function sets the color the scene will use when creating DiagramItems. It also changes the color of a selected DiagramItem.</db:para>
<db:para>This is the implementation of setFont():</db:para>
<db:programlisting language="cpp">void DiagramScene::setFont(const QFont &amp;amp;font)
{
    myFont = font;

    if (isItemChange(DiagramTextItem::Type)) {
        QGraphicsTextItem *item = qgraphicsitem_cast&amp;lt;DiagramTextItem *&amp;gt;(selectedItems().first());
        //At this point the selection can change so the first selected item might not be a DiagramTextItem
        if (item)
            item-&amp;gt;setFont(myFont);
    }
}
</db:programlisting>
<db:para>Set the font to use for new and selected, if a text item is selected, DiagramTextItems.</db:para>
<db:para>This is the implementation of editorLostFocus() slot:</db:para>
<db:programlisting language="cpp">void DiagramScene::editorLostFocus(DiagramTextItem *item)
{
    QTextCursor cursor = item-&amp;gt;textCursor();
    cursor.clearSelection();
    item-&amp;gt;setTextCursor(cursor);

    if (item-&amp;gt;toPlainText().isEmpty()) {
        removeItem(item);
        item-&amp;gt;deleteLater();
    }
}
</db:programlisting>
<db:para>DiagramTextItems emit a signal when they lose focus, which is connected to this slot. We remove the item if it has no text. If not, we would leak memory and confuse the user as the items will be edited when pressed on by the mouse.</db:para>
<db:para>The mousePressEvent() function handles mouse press event's different depending on which mode the DiagramScene is in. We examine its implementation for each mode:</db:para>
<db:programlisting language="cpp">void DiagramScene::mousePressEvent(QGraphicsSceneMouseEvent *mouseEvent)
{
    if (mouseEvent-&amp;gt;button() != Qt::LeftButton)
        return;

    DiagramItem *item;
    switch (myMode) {
        case InsertItem:
            item = new DiagramItem(myItemType, myItemMenu);
            item-&amp;gt;setBrush(myItemColor);
            addItem(item);
            item-&amp;gt;setPos(mouseEvent-&amp;gt;scenePos());
            emit itemInserted(item);
            break;
</db:programlisting>
<db:para>We simply create a new DiagramItem and add it to the scene at the position the mouse was pressed. Note that the origin of its local coordinate system will be under the mouse pointer position.</db:para>
<db:programlisting language="cpp">        case InsertLine:
            line = new QGraphicsLineItem(QLineF(mouseEvent-&amp;gt;scenePos(),
                                        mouseEvent-&amp;gt;scenePos()));
            line-&amp;gt;setPen(QPen(myLineColor, 2));
            addItem(line);
            break;
</db:programlisting>
<db:para>The user adds Arrows to the scene by stretching a line between the items the arrow should connect. The start of the line is fixed in the place the user clicked the mouse and the end follows the mouse pointer as long as the button is held down. When the user releases the mouse button an Arrow will be added to the scene if there is a DiagramItem under the start and end of the line. We will see how this is implemented later; here we simply add the line.</db:para>
<db:programlisting language="cpp">        case InsertText:
            textItem = new DiagramTextItem();
            textItem-&amp;gt;setFont(myFont);
            textItem-&amp;gt;setTextInteractionFlags(Qt::TextEditorInteraction);
            textItem-&amp;gt;setZValue(1000.0);
            connect(textItem, &amp;amp;DiagramTextItem::lostFocus,
                    this, &amp;amp;DiagramScene::editorLostFocus);
            connect(textItem, &amp;amp;DiagramTextItem::selectedChange,
                    this, &amp;amp;DiagramScene::itemSelected);
            addItem(textItem);
            textItem-&amp;gt;setDefaultTextColor(myTextColor);
            textItem-&amp;gt;setPos(mouseEvent-&amp;gt;scenePos());
            emit textInserted(textItem);
</db:programlisting>
<db:para>The DiagramTextItem is editable when the <db:link xlink:href="qt.xml#TextInteractionFlag-enum">Qt::TextEditorInteraction</db:link> flag is set, else it is movable by the mouse. We always want the text to be drawn on top of the other items in the scene, so we set the value to a number higher than other items in the scene.</db:para>
<db:programlisting language="cpp">    default:
        ;
    }
    QGraphicsScene::mousePressEvent(mouseEvent);
}
</db:programlisting>
<db:para>We are in MoveItem mode if we get to the default switch; we can then call the <db:link xlink:href="qgraphicsscene.xml">QGraphicsScene</db:link> implementation, which handles movement of items with the mouse. We make this call even if we are in another mode making it possible to add an item and then keep the mouse button pressed down and start moving the item. In the case of text items, this is not possible as they do not propagate mouse events when they are editable.</db:para>
<db:para>This is the mouseMoveEvent() function:</db:para>
<db:programlisting language="cpp">void DiagramScene::mouseMoveEvent(QGraphicsSceneMouseEvent *mouseEvent)
{
    if (myMode == InsertLine &amp;amp;&amp;amp; line != nullptr) {
        QLineF newLine(line-&amp;gt;line().p1(), mouseEvent-&amp;gt;scenePos());
        line-&amp;gt;setLine(newLine);
    } else if (myMode == MoveItem) {
        QGraphicsScene::mouseMoveEvent(mouseEvent);
    }
}
</db:programlisting>
<db:para>We must draw the line if we are in InsertMode and the mouse button is pressed down (the line is not 0). As discussed in mousePressEvent() the line is drawn from the position the mouse was pressed to the current position of the mouse.</db:para>
<db:para>If we are in MoveItem mode, we call the <db:link xlink:href="qgraphicsscene.xml">QGraphicsScene</db:link> implementation, which handles movement of items.</db:para>
<db:para>In the mouseReleaseEvent() function we need to check if an arrow should be added to the scene:</db:para>
<db:programlisting language="cpp">void DiagramScene::mouseReleaseEvent(QGraphicsSceneMouseEvent *mouseEvent)
{
    if (line != nullptr &amp;amp;&amp;amp; myMode == InsertLine) {
        QList&amp;lt;QGraphicsItem *&amp;gt; startItems = items(line-&amp;gt;line().p1());
        if (startItems.count() &amp;amp;&amp;amp; startItems.first() == line)
            startItems.removeFirst();
        QList&amp;lt;QGraphicsItem *&amp;gt; endItems = items(line-&amp;gt;line().p2());
        if (endItems.count() &amp;amp;&amp;amp; endItems.first() == line)
            endItems.removeFirst();

        removeItem(line);
        delete line;
</db:programlisting>
<db:para>First we need to get the items (if any) under the line's start and end points. The line itself is the first item at these points, so we remove it from the lists. As a precaution, we check if the lists are empty, but this should never happen.</db:para>
<db:programlisting language="cpp">        if (startItems.count() &amp;gt; 0 &amp;amp;&amp;amp; endItems.count() &amp;gt; 0 &amp;amp;&amp;amp;
            startItems.first()-&amp;gt;type() == DiagramItem::Type &amp;amp;&amp;amp;
            endItems.first()-&amp;gt;type() == DiagramItem::Type &amp;amp;&amp;amp;
            startItems.first() != endItems.first()) {
            DiagramItem *startItem = qgraphicsitem_cast&amp;lt;DiagramItem *&amp;gt;(startItems.first());
            DiagramItem *endItem = qgraphicsitem_cast&amp;lt;DiagramItem *&amp;gt;(endItems.first());
            Arrow *arrow = new Arrow(startItem, endItem);
            arrow-&amp;gt;setColor(myLineColor);
            startItem-&amp;gt;addArrow(arrow);
            endItem-&amp;gt;addArrow(arrow);
            arrow-&amp;gt;setZValue(-1000.0);
            addItem(arrow);
            arrow-&amp;gt;updatePosition();
        }
    }
</db:programlisting>
<db:para>Now we check if there are two different DiagramItems under the lines start and end points. If there are we can create an Arrow with the two items. The arrow is then added to each item and finally the scene. The arrow must be updated to adjust its start and end points to the items. We set the z-value of the arrow to -1000.0 because we always want it to be drawn under the items.</db:para>
<db:programlisting language="cpp">    line = nullptr;
    QGraphicsScene::mouseReleaseEvent(mouseEvent);
}
</db:programlisting>
<db:para>Here is the isItemChange() function:</db:para>
<db:programlisting language="cpp">bool DiagramScene::isItemChange(int type) const
{
    const QList&amp;lt;QGraphicsItem *&amp;gt; items = selectedItems();
    const auto cb = [type](const QGraphicsItem *item) { return item-&amp;gt;type() == type; };
    return std::find_if(items.begin(), items.end(), cb) != items.end();
}
</db:programlisting>
<db:para>The scene has single selection, i.e., only one item can be selected at any given time. The for loop will then loop one time with the selected item or none if no item is selected. isItemChange() is used to check whether a selected item exists and also is of the specified diagram <db:code role="parameter">type</db:code>.</db:para>
</db:section>
<db:section xml:id="diagramitem-class-definition">
<db:title>DiagramItem Class Definition</db:title>
<db:programlisting language="cpp">class DiagramItem : public QGraphicsPolygonItem
{
public:
    enum { Type = UserType + 15 };
    enum DiagramType { Step, Conditional, StartEnd, Io };

    DiagramItem(DiagramType diagramType, QMenu *contextMenu, QGraphicsItem *parent = nullptr);

    void removeArrow(Arrow *arrow);
    void removeArrows();
    DiagramType diagramType() const { return myDiagramType; }
    QPolygonF polygon() const { return myPolygon; }
    void addArrow(Arrow *arrow);
    QPixmap image() const;
    int type() const override { return Type; }

protected:
    void contextMenuEvent(QGraphicsSceneContextMenuEvent *event) override;
    QVariant itemChange(GraphicsItemChange change, const QVariant &amp;amp;value) override;

private:
    DiagramType myDiagramType;
    QPolygonF myPolygon;
    QMenu *myContextMenu;
    QList&amp;lt;Arrow *&amp;gt; arrows;
};
</db:programlisting>
<db:para>The DiagramItem represents a flowchart shape in the DiagramScene. It inherits <db:link xlink:href="qgraphicspolygonitem.xml">QGraphicsPolygonItem</db:link> and has a polygon for each shape. The enum DiagramType has a value for each of the flowchart shapes.</db:para>
<db:para>The class has a list of the arrows that are connected to it. This is necessary because only the item knows when it is being moved (with the itemChanged() function) at which time the arrows must be updated. The item can also draw itself onto a <db:link xlink:href="qpixmap.xml">QPixmap</db:link> with the image() function. This is used for the tool buttons in MainWindow, see createColorToolButtonIcon() in MainWindow.</db:para>
<db:para>The Type enum is a unique identifier of the class. It is used by qgraphicsitem_cast(), which does dynamic casts of graphics items. The UserType constant is the minimum value a custom graphics item type can be.</db:para>
</db:section>
<db:section xml:id="diagramitem-class-implementation">
<db:title>DiagramItem Class Implementation</db:title>
<db:para>We start with a look at the constructor:</db:para>
<db:programlisting language="cpp">DiagramItem::DiagramItem(DiagramType diagramType, QMenu *contextMenu,
                         QGraphicsItem *parent)
    : QGraphicsPolygonItem(parent), myDiagramType(diagramType)
    , myContextMenu(contextMenu)
{
    QPainterPath path;
    switch (myDiagramType) {
        case StartEnd:
            path.moveTo(200, 50);
            path.arcTo(150, 0, 50, 50, 0, 90);
            path.arcTo(50, 0, 50, 50, 90, 90);
            path.arcTo(50, 50, 50, 50, 180, 90);
            path.arcTo(150, 50, 50, 50, 270, 90);
            path.lineTo(200, 25);
            myPolygon = path.toFillPolygon();
            break;
        case Conditional:
            myPolygon &amp;lt;&amp;lt; QPointF(-100, 0) &amp;lt;&amp;lt; QPointF(0, 100)
                      &amp;lt;&amp;lt; QPointF(100, 0) &amp;lt;&amp;lt; QPointF(0, -100)
                      &amp;lt;&amp;lt; QPointF(-100, 0);
            break;
        case Step:
            myPolygon &amp;lt;&amp;lt; QPointF(-100, -100) &amp;lt;&amp;lt; QPointF(100, -100)
                      &amp;lt;&amp;lt; QPointF(100, 100) &amp;lt;&amp;lt; QPointF(-100, 100)
                      &amp;lt;&amp;lt; QPointF(-100, -100);
            break;
        default:
            myPolygon &amp;lt;&amp;lt; QPointF(-120, -80) &amp;lt;&amp;lt; QPointF(-70, 80)
                      &amp;lt;&amp;lt; QPointF(120, 80) &amp;lt;&amp;lt; QPointF(70, -80)
                      &amp;lt;&amp;lt; QPointF(-120, -80);
            break;
    }
    setPolygon(myPolygon);
    setFlag(QGraphicsItem::ItemIsMovable, true);
    setFlag(QGraphicsItem::ItemIsSelectable, true);
    setFlag(QGraphicsItem::ItemSendsGeometryChanges, true);
}
</db:programlisting>
<db:para>In the constructor we create the items polygon according to <db:code role="parameter">diagramType</db:code>. <db:link xlink:href="qgraphicsitem.xml">QGraphicsItem</db:link>s are not movable or selectable by default, so we must set these properties.</db:para>
<db:para>Here is the removeArrow() function:</db:para>
<db:programlisting language="cpp">void DiagramItem::removeArrow(Arrow *arrow)
{
    arrows.removeAll(arrow);
}
</db:programlisting>
<db:para>removeArrow() is used to remove Arrow items when they or DiagramItems they are connected to are removed from the scene.</db:para>
<db:para>Here is the removeArrows() function:</db:para>
<db:programlisting language="cpp">void DiagramItem::removeArrows()
{
    // need a copy here since removeArrow() will
    // modify the arrows container
    const auto arrowsCopy = arrows;
    for (Arrow *arrow : arrowsCopy) {
        arrow-&amp;gt;startItem()-&amp;gt;removeArrow(arrow);
        arrow-&amp;gt;endItem()-&amp;gt;removeArrow(arrow);
        scene()-&amp;gt;removeItem(arrow);
        delete arrow;
    }
}
</db:programlisting>
<db:para>This function is called when the item is removed from the scene and removes all arrows that are connected to this item. The arrow must be removed from the arrows list of both its start and end item. Since either the start or the end item is the object where this function is currently called, we have to make sure to work on a copy of arrows since removeArrow() is modifying this container.</db:para>
<db:para>Here is the addArrow() function:</db:para>
<db:programlisting language="cpp">void DiagramItem::addArrow(Arrow *arrow)
{
    arrows.append(arrow);
}
</db:programlisting>
<db:para>This function simply adds the <db:code role="parameter">arrow</db:code> to the items arrows list.</db:para>
<db:para>Here is the image() function:</db:para>
<db:programlisting language="cpp">QPixmap DiagramItem::image() const
{
    QPixmap pixmap(250, 250);
    pixmap.fill(Qt::transparent);
    QPainter painter(&amp;amp;pixmap);
    painter.setPen(QPen(Qt::black, 8));
    painter.translate(125, 125);
    painter.drawPolyline(myPolygon);

    return pixmap;
}
</db:programlisting>
<db:para>This function draws the polygon of the item onto a <db:link xlink:href="qpixmap.xml">QPixmap</db:link>. In this example we use this to create icons for the tool buttons in the tool box.</db:para>
<db:para>Here is the contextMenuEvent() function:</db:para>
<db:programlisting language="cpp">void DiagramItem::contextMenuEvent(QGraphicsSceneContextMenuEvent *event)
{
    scene()-&amp;gt;clearSelection();
    setSelected(true);
    myContextMenu-&amp;gt;exec(event-&amp;gt;screenPos());
}
</db:programlisting>
<db:para>We show the context menu. As right mouse clicks, which shows the menu, don't select items by default we set the item selected with <db:link xlink:href="qgraphicsitem.xml#setSelected">setSelected</db:link>(). This is necessary since an item must be selected to change its elevation with the bringToFront and sendToBack actions.</db:para>
<db:para>This is the implementation of itemChange():</db:para>
<db:programlisting language="cpp">QVariant DiagramItem::itemChange(GraphicsItemChange change, const QVariant &amp;amp;value)
{
    if (change == QGraphicsItem::ItemPositionChange) {
        for (Arrow *arrow : qAsConst(arrows))
            arrow-&amp;gt;updatePosition();
    }

    return value;
}
</db:programlisting>
<db:para>If the item has moved, we need to update the positions of the arrows connected to it. The implementation of <db:link xlink:href="qgraphicsitem.xml">QGraphicsItem</db:link> does nothing, so we just return <db:code role="parameter">value</db:code>.</db:para>
</db:section>
<db:section xml:id="diagramtextitem-class-definition">
<db:title>DiagramTextItem Class Definition</db:title>
<db:para>The TextDiagramItem class inherits <db:link xlink:href="qgraphicstextitem.xml">QGraphicsTextItem</db:link> and adds the possibility to move editable text items. Editable QGraphicsTextItems are designed to be fixed in place and editing starts when the user single clicks on the item. With DiagramTextItem the editing starts with a double click leaving single click available to interact with and move it.</db:para>
<db:programlisting language="cpp">class DiagramTextItem : public QGraphicsTextItem
{
    Q_OBJECT

public:
    enum { Type = UserType + 3 };

    DiagramTextItem(QGraphicsItem *parent = nullptr);

    int type() const override { return Type; }

signals:
    void lostFocus(DiagramTextItem *item);
    void selectedChange(QGraphicsItem *item);

protected:
    QVariant itemChange(GraphicsItemChange change, const QVariant &amp;amp;value) override;
    void focusOutEvent(QFocusEvent *event) override;
    void mouseDoubleClickEvent(QGraphicsSceneMouseEvent *event) override;
};
</db:programlisting>
<db:para>We use itemChange() and focusOutEvent() to notify the DiagramScene when the text item loses focus and gets selected.</db:para>
<db:para>We reimplement the functions that handle mouse events to make it possible to alter the mouse behavior of <db:link xlink:href="qgraphicstextitem.xml">QGraphicsTextItem</db:link>.</db:para>
</db:section>
<db:section xml:id="diagramtextitem-implementation">
<db:title>DiagramTextItem Implementation</db:title>
<db:para>We start with the constructor:</db:para>
<db:programlisting language="cpp">DiagramTextItem::DiagramTextItem(QGraphicsItem *parent)
    : QGraphicsTextItem(parent)
{
    setFlag(QGraphicsItem::ItemIsMovable);
    setFlag(QGraphicsItem::ItemIsSelectable);
}
</db:programlisting>
<db:para>We simply set the item movable and selectable, as these flags are off by default.</db:para>
<db:para>Here is the itemChange() function:</db:para>
<db:programlisting language="cpp">QVariant DiagramTextItem::itemChange(GraphicsItemChange change,
                     const QVariant &amp;amp;value)
{
    if (change == QGraphicsItem::ItemSelectedHasChanged)
        emit selectedChange(this);
    return value;
}
</db:programlisting>
<db:para>When the item is selected we emit the selectedChanged signal. The MainWindow uses this signal to update the widgets that display font properties to the font of the selected text item.</db:para>
<db:para>Here is the focusOutEvent() function:</db:para>
<db:programlisting language="cpp">void DiagramTextItem::focusOutEvent(QFocusEvent *event)
{
    setTextInteractionFlags(Qt::NoTextInteraction);
    emit lostFocus(this);
    QGraphicsTextItem::focusOutEvent(event);
}
</db:programlisting>
<db:para>DiagramScene uses the signal emitted when the text item loses focus to remove the item if it is empty, i.e., it contains no text.</db:para>
<db:para>This is the implementation of mouseDoubleClickEvent():</db:para>
<db:programlisting language="cpp">void DiagramTextItem::mouseDoubleClickEvent(QGraphicsSceneMouseEvent *event)
{
    if (textInteractionFlags() == Qt::NoTextInteraction)
        setTextInteractionFlags(Qt::TextEditorInteraction);
    QGraphicsTextItem::mouseDoubleClickEvent(event);
}
</db:programlisting>
<db:para>When we receive a double click event, we make the item editable by calling <db:link xlink:href="qgraphicstextitem.xml#setTextInteractionFlags">QGraphicsTextItem::setTextInteractionFlags</db:link>(). We then forward the double-click to the item itself.</db:para>
</db:section>
<db:section xml:id="arrow-class-definition">
<db:title>Arrow Class Definition</db:title>
<db:para>The Arrow class is a graphics item that connects two DiagramItems. It draws an arrow head to one of the items. To achieve this the item needs to paint itself and also re implement methods used by the graphics scene to check for collisions and selections. The class inherits QGraphicsLine item, and draws the arrowhead and moves with the items it connects.</db:para>
<db:programlisting language="cpp">class Arrow : public QGraphicsLineItem
{
public:
    enum { Type = UserType + 4 };

    Arrow(DiagramItem *startItem, DiagramItem *endItem,
          QGraphicsItem *parent = nullptr);

    int type() const override { return Type; }
    QRectF boundingRect() const override;
    QPainterPath shape() const override;
    void setColor(const QColor &amp;amp;color) { myColor = color; }
    DiagramItem *startItem() const { return myStartItem; }
    DiagramItem *endItem() const { return myEndItem; }

    void updatePosition();

protected:
    void paint(QPainter *painter, const QStyleOptionGraphicsItem *option,
               QWidget *widget = nullptr) override;

private:
    DiagramItem *myStartItem;
    DiagramItem *myEndItem;
    QPolygonF arrowHead;
    QColor myColor = Qt::black;
};
</db:programlisting>
<db:para>The item's color can be set with setColor().</db:para>
<db:para>boundingRect() and shape() are reimplemented from <db:link xlink:href="qgraphicslineitem.xml">QGraphicsLineItem</db:link> and are used by the scene to check for collisions and selections.</db:para>
<db:para>Calling updatePosition() causes the arrow to recalculate its position and arrow head angle. paint() is reimplemented so that we can paint an arrow rather than just a line between items.</db:para>
<db:para>myStartItem and myEndItem are the diagram items that the arrow connects. The arrow is drawn with its head to the end item. arrowHead is a polygon with three vertices's we use to draw the arrow head.</db:para>
</db:section>
<db:section xml:id="arrow-class-implementation">
<db:title>Arrow Class Implementation</db:title>
<db:para>The constructor of the Arrow class looks like this:</db:para>
<db:programlisting language="cpp">Arrow::Arrow(DiagramItem *startItem, DiagramItem *endItem, QGraphicsItem *parent)
    : QGraphicsLineItem(parent), myStartItem(startItem), myEndItem(endItem)
{
    setFlag(QGraphicsItem::ItemIsSelectable, true);
    setPen(QPen(myColor, 2, Qt::SolidLine, Qt::RoundCap, Qt::RoundJoin));
}
</db:programlisting>
<db:para>We set the start and end diagram items of the arrow. The arrow head will be drawn where the line intersects the end item.</db:para>
<db:para>Here is the boundingRect() function:</db:para>
<db:programlisting language="cpp">QRectF Arrow::boundingRect() const
{
    qreal extra = (pen().width() + 20) / 2.0;

    return QRectF(line().p1(), QSizeF(line().p2().x() - line().p1().x(),
                                      line().p2().y() - line().p1().y()))
        .normalized()
        .adjusted(-extra, -extra, extra, extra);
}
</db:programlisting>
<db:para>We need to reimplement this function because the arrow is larger than the bounding rectangle of the <db:link xlink:href="qgraphicslineitem.xml">QGraphicsLineItem</db:link>. The graphics scene uses the bounding rectangle to know which regions of the scene to update.</db:para>
<db:para>Here is the shape() function:</db:para>
<db:programlisting language="cpp">QPainterPath Arrow::shape() const
{
    QPainterPath path = QGraphicsLineItem::shape();
    path.addPolygon(arrowHead);
    return path;
}
</db:programlisting>
<db:para>The shape function returns a <db:link xlink:href="qpainterpath.xml">QPainterPath</db:link> that is the exact shape of the item. The <db:link xlink:href="qgraphicslineitem.xml#shape">QGraphicsLineItem::shape</db:link>() returns a path with a line drawn with the current pen, so we only need to add the arrow head. This function is used to check for collisions and selections with the mouse.</db:para>
<db:para>Here is the updatePosition() slot:</db:para>
<db:programlisting language="cpp">void Arrow::updatePosition()
{
    QLineF line(mapFromItem(myStartItem, 0, 0), mapFromItem(myEndItem, 0, 0));
    setLine(line);
}
</db:programlisting>
<db:para>This slot updates the arrow by setting the start and end points of its line to the center of the items it connects.</db:para>
<db:para>Here is the paint() function:</db:para>
<db:programlisting language="cpp">void Arrow::paint(QPainter *painter, const QStyleOptionGraphicsItem *,
                  QWidget *)
{
    if (myStartItem-&amp;gt;collidesWithItem(myEndItem))
        return;

    QPen myPen = pen();
    myPen.setColor(myColor);
    qreal arrowSize = 20;
    painter-&amp;gt;setPen(myPen);
    painter-&amp;gt;setBrush(myColor);
</db:programlisting>
<db:para>If the start and end items collide we do not draw the arrow; the algorithm we use to find the point the arrow should be drawn at may fail if the items collide.</db:para>
<db:para>We first set the pen and brush we will use for drawing the arrow.</db:para>
<db:programlisting language="cpp">    QLineF centerLine(myStartItem-&amp;gt;pos(), myEndItem-&amp;gt;pos());
    QPolygonF endPolygon = myEndItem-&amp;gt;polygon();
    QPointF p1 = endPolygon.first() + myEndItem-&amp;gt;pos();
    QPointF intersectPoint;
    for (int i = 1; i &amp;lt; endPolygon.count(); ++i) {
        QPointF p2 = endPolygon.at(i) + myEndItem-&amp;gt;pos();
        QLineF polyLine = QLineF(p1, p2);
        QLineF::IntersectionType intersectionType =
            polyLine.intersects(centerLine, &amp;amp;intersectPoint);
        if (intersectionType == QLineF::BoundedIntersection)
            break;
        p1 = p2;
    }

    setLine(QLineF(intersectPoint, myStartItem-&amp;gt;pos()));
</db:programlisting>
<db:para>We then need to find the position at which to draw the arrowhead. The head should be drawn where the line and the end item intersects. This is done by taking the line between each point in the polygon and check if it intersects with the line of the arrow. Since the line start and end points are set to the center of the items the arrow line should intersect one and only one of the lines of the polygon. Note that the points in the polygon are relative to the local coordinate system of the item. We must therefore add the position of the end item to make the coordinates relative to the scene.</db:para>
<db:programlisting language="cpp">    double angle = std::atan2(-line().dy(), line().dx());

    QPointF arrowP1 = line().p1() + QPointF(sin(angle + M_PI / 3) * arrowSize,
                                    cos(angle + M_PI / 3) * arrowSize);
    QPointF arrowP2 = line().p1() + QPointF(sin(angle + M_PI - M_PI / 3) * arrowSize,
                                    cos(angle + M_PI - M_PI / 3) * arrowSize);

    arrowHead.clear();
    arrowHead &amp;lt;&amp;lt; line().p1() &amp;lt;&amp;lt; arrowP1 &amp;lt;&amp;lt; arrowP2;
</db:programlisting>
<db:para>We calculate the angle between the x-axis and the line of the arrow. We need to turn the arrow head to this angle so that it follows the direction of the arrow. If the angle is negative we must turn the direction of the arrow.</db:para>
<db:para>We can then calculate the three points of the arrow head polygon. One of the points is the end of the line, which now is the intersection between the arrow line and the end polygon. Then we clear the arrowHead polygon from the previous calculated arrow head and set these new points.</db:para>
<db:programlisting language="cpp">    painter-&amp;gt;drawLine(line());
    painter-&amp;gt;drawPolygon(arrowHead);
    if (isSelected()) {
        painter-&amp;gt;setPen(QPen(myColor, 1, Qt::DashLine));
        QLineF myLine = line();
        myLine.translate(0, 4.0);
        painter-&amp;gt;drawLine(myLine);
        myLine.translate(0,-8.0);
        painter-&amp;gt;drawLine(myLine);
    }
}
</db:programlisting>
<db:para>If the line is selected, we draw two dotted lines that are parallel with the line of the arrow. We do not use the default implementation, which uses <db:link xlink:href="qgraphicsitem.xml#boundingRect">boundingRect</db:link>() because the <db:link xlink:href="qrect.xml">QRect</db:link> bounding rectangle is considerably larger than the line.</db:para>
</db:section>
<db:section>
<db:title>Example project</db:title>
<db:para><db:link xlink:href="https://code.qt.io/cgit/qt/qtbase.git/tree/examples/widgets/graphicsview/diagramscene?h=6.1">Example project @ code.qt.io</db:link></db:para>
</db:section>
</db:article>
