<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en">
<db:info>
<db:title>qt_query_qml_module</db:title>
<db:productname>QtQml</db:productname>
<db:edition>Qt 6.9.1 Reference Documentation</db:edition>
<db:titleabbrev>Qt Qml Reference Documentation</db:titleabbrev>
<db:abstract>
<db:para>Retrieve information about a QML module.</db:para>
</db:abstract>
<db:pubdate>2025-06-29</db:pubdate>
<db:date>2025-06-29</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:para>Retrieve information about a QML module.</db:para>
<db:para>The command is defined in the Qml component of the Qt6 package, which can be loaded like so:</db:para>
<db:programlisting language="cpp" role="bad">find_package(Qt6 REQUIRED COMPONENTS Qml)
</db:programlisting>
<db:para>This command was introduced in Qt 6.3.</db:para>
<db:section xml:id="synopsis">
<db:title>Synopsis</db:title>
<db:programlisting language="cpp" role="bad">qt_query_qml_module(
    target
    [URI uri_var]
    [VERSION version_var]
    [PLUGIN_TARGET plugin_target_var]
    [TARGET_PATH target_path_var]
    [MODULE_RESOURCE_PATH module_resource_path_var]
    [QMLDIR qmldir_var]
    [TYPEINFO typeinfo_var]
    [QML_FILES qml_files_var]
    [QML_FILES_DEPLOY_PATHS qml_files_deploy_paths_var]
    [QML_FILES_PREFIX_OVERRIDES qml_files_prefix_overrides_var]
    [RESOURCES resources_var]
    [RESOURCES_DEPLOY_PATHS resources_deploy_paths_var]
    [RESOURCES_PREFIX_OVERRIDES resources_prefix_overrides_var]
)
</db:programlisting>
<db:para>If <db:link xlink:href="">versionless commands</db:link> are disabled, use qt6_query_qml_module() instead. It supports the same set of arguments as this command.</db:para>
</db:section>
<db:section xml:id="description">
<db:title>Description</db:title>
<db:para>This command is used to obtain information about a QML module target. That target must have previously been created by or passed to an earlier call to <db:link xlink:href="qt-add-qml-module.xml">qt_add_qml_module()</db:link>. The target cannot be an imported target.</db:para>
<db:para>The information provided by this command enables the caller to deploy all parts of a single QML module. The project should install the target and the associated plugin target (if the module has one and it is separate from the backing target) using the standard <db:link xlink:href="https://cmake.org/cmake/help/latest/command/install.html#targets">install(TARGETS)</db:link> command. Everything else can be deployed with <db:link xlink:href="https://cmake.org/cmake/help/latest/command/install.html#files">install(FILES)</db:link>.</db:para>
</db:section>
<db:section xml:id="arguments">
<db:title>Arguments</db:title>
<db:para>Each of the optional arguments specifies the name of a variable in which to store the corresponding QML module property.</db:para>
<db:para>URI and VERSION provide the module's uri and version respectively.</db:para>
<db:para>PLUGIN_TARGET can be used to obtain the name of the plugin target for the QML module. Not all QML modules have a plugin, so the value returned for this option could be an empty string. If the QML module has no separate backing target, then target will be the same as the plugin target.</db:para>
<db:para>TARGET_PATH is the URI with dots (.) replaced by forward slashes (/). It represents the path below the base QML module installation directory where this QML module's qmldir file (and possibly others) should be deployed. The QML module installation directory serves as a QML import path where the QML engine will look for QML modules. The default base QML module installation directory used by <db:link xlink:href="qt-generate-deploy-qml-app-script.xml">qt_generate_deploy_qml_app_script()</db:link> is qml. A project using a deployment script can use <db:link xlink:href="cmake-variable-qt-deploy-qml-dir.xml">QT_DEPLOY_QML_DIR</db:link> rather than hard-coding this location (also see <db:link xlink:href="cmake-variable-qt-deploy-prefix.xml">QT_DEPLOY_PREFIX</db:link>).</db:para>
<db:para>MODULE_RESOURCE_PATH provides the resource path under which the QML module's compiled-in files can be found. It is formed from <db:link xlink:href="qt-add-qml-module.xml">qt_add_qml_module()</db:link>'s RESOURCE_PREFIX concatenated with the module's TARGET_PATH. The queried value should not be used for deployment, but may be helpful in matching up resource paths with file system locations, if needed.</db:para>
<db:para>QMLDIR provides the path to the qmldir file. When deploying the QML module, this file should be copied to the target path. In a deployment script, this location can be obtained using ${QT_DEPLOY_PREFIX}/${QT_DEPLOY_QML_DIR}.</db:para>
<db:para>TYPEINFO provides the path to the module's typeinfo file, if it has one. It will be an empty string if the module has no typeinfo file. The typeinfo file should be deployed to the same path as the qmldir file.</db:para>
<db:para>QML_FILES provides a list of all files added to the QML module through one of the following methods:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para>As QML_FILES arguments in <db:link xlink:href="qt-add-qml-module.xml">qt_add_qml_module()</db:link>.</db:para>
</db:listitem>
<db:listitem>
<db:para>As FILES arguments in <db:link xlink:href="qt-target-qml-sources.xml">qt_target_qml_sources()</db:link>.</db:para>
</db:listitem>
</db:itemizedlist>
<db:para>All files will be recorded with absolute paths.</db:para>
<db:para>QML_FILES_DEPLOY_PATHS provides a list with exactly the same number of elements as QML_FILES. Each element of the QML_FILES_DEPLOY_PATHS list is the path below the target path where the corresponding element of QML_FILES should be deployed. The paths in QML_FILES_DEPLOY_PATHS include the file name, since this could be different to the file name in QML_FILES due to the use of resource aliases (see <db:link xlink:href="qt-target-qml-sources.xml#qt-resource-alias">QT_RESOURCE_ALIAS</db:link>).</db:para>
<db:para>Entries in QML_FILES_DEPLOY_PATHS can also be an empty string. Any file added using <db:link xlink:href="qt-target-qml-sources.xml">qt_target_qml_sources()</db:link> with a custom PREFIX will have no deploy path, since using a custom prefix typically means the file sits outside of the QML module's target path.</db:para>
<db:para>QML_FILES_PREFIX_OVERRIDES provides another list with exactly the same number of elements as QML_FILES. Where a file has been added with a custom prefix as described in the preceding paragraph, its corresponding entry in the QML_FILES_PREFIX_OVERRIDES list will contain the custom prefix used. For all other files, their list entries will be an empty string.</db:para>
<db:note>
<db:para>As a special case, if there is only one file in the QML_FILES list, then QML_FILES_DEPLOY_PATHS or QML_FILES_PREFIX_OVERRIDES may be an empty string depending on whether that file has a custom prefix. This is because CMake's way of representing lists and strings means that it is impossible to distinguish between an empty string and a list with a single empty element.</db:para>
</db:note>
<db:para>The RESOURCES, RESOURCES_DEPLOY_PATHS, and RESOURCES_PREFIX_OVERRIDES options are analogous to those for QML_FILES discussed above. RESOURCES provides a list of all files added to the QML module as RESOURCES arguments to either <db:link xlink:href="qt-add-qml-module.xml">qt_add_qml_module()</db:link> or <db:link xlink:href="qt-target-qml-sources.xml">qt_target_qml_sources()</db:link>. All paths will be absolute. The meaning and usage of RESOURCES_DEPLOY_PATHS and RESOURCES_PREFIX_OVERRIDES follows the same patterns as QML_FILES_DEPLOY_PATHS and QML_FILES_PREFIX_OVERRIDES respectively.</db:para>
</db:section>
<db:section xml:id="example">
<db:title>Example</db:title>
<db:programlisting language="cpp" role="bad">cmake_minimum_required(VERSION 3.16...3.22)
project(MyThings)

find_package(Qt6 6.3 REQUIRED COMPONENTS Core Qml)

set(module_name &quot;MyThings&quot;)
qt_add_qml_module(${module_name}
    URI My.Things
    VERSION 1.3
    RESOURCE_PREFIX org.mycompany/imports
    QML_FILES
        First.qml
        Second.qml
    RESOURCES
        Third.txt
)

qt_query_qml_module(${module_name}
    URI module_uri
    VERSION module_version
    PLUGIN_TARGET module_plugin_target
    TARGET_PATH module_target_path
    QMLDIR module_qmldir
    TYPEINFO module_typeinfo
    QML_FILES module_qml_files
    QML_FILES_DEPLOY_PATHS qml_files_deploy_paths
    RESOURCES module_resources
    RESOURCES_DEPLOY_PATHS resources_deploy_paths
)

message(&quot;My QML module URI is: ${module_uri}&quot;)
message(&quot;My QML module version is: ${module_version}&quot;)

# Install the QML module backing library
set(staging_prefix &quot;staging&quot;)
install(TARGETS ${module_name}
    ARCHIVE DESTINATION &quot;${staging_prefix}/${CMAKE_INSTALL_LIBDIR}&quot;
    LIBRARY DESTINATION &quot;${staging_prefix}/${CMAKE_INSTALL_LIBDIR}&quot;
    RUNTIME DESTINATION &quot;${staging_prefix}/${CMAKE_INSTALL_BINDIR}&quot;
)
set(module_dir &quot;${staging_prefix}/qml/${module_target_path}&quot;)

# Install the QML module runtime loadable plugin
install(TARGETS &quot;${module_plugin_target}&quot;
    LIBRARY DESTINATION &quot;${module_dir}&quot;
    RUNTIME DESTINATION &quot;${module_dir}&quot;
)

# Install the QML module meta information.
install(FILES &quot;${module_qmldir}&quot;   DESTINATION &quot;${module_dir}&quot;)
install(FILES &quot;${module_typeinfo}&quot; DESTINATION &quot;${module_dir}&quot;)

# Install QML files, possibly renamed.
list(LENGTH module_qml_files num_files)
math(EXPR last_index &quot;${num_files} - 1&quot;)
foreach(i RANGE 0 ${last_index})
    list(GET module_qml_files       ${i} src_file)
    list(GET qml_files_deploy_paths ${i} deploy_path)
    get_filename_component(dst_name &quot;${deploy_path}&quot; NAME)
    get_filename_component(dest_dir &quot;${deploy_path}&quot; DIRECTORY)
    install(FILES &quot;${src_file}&quot; DESTINATION &quot;${module_dir}/${dest_dir}&quot; RENAME &quot;${dst_name}&quot;)
endforeach()

# Install resources, possibly renamed.
list(LENGTH module_resources num_files)
math(EXPR last_index &quot;${num_files} - 1&quot;)
foreach(i RANGE 0 ${last_index})
    list(GET module_resources       ${i} src_file)
    list(GET resources_deploy_paths ${i} deploy_path)
    get_filename_component(dst_name &quot;${deploy_path}&quot; NAME)
    get_filename_component(dest_dir &quot;${deploy_path}&quot; DIRECTORY)
    install(FILES &quot;${src_file}&quot; DESTINATION &quot;${module_dir}/${dest_dir}&quot; RENAME &quot;${dst_name}&quot;)
endforeach()
</db:programlisting>
</db:section>
</db:article>
