<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en">
<db:info>
<db:title>Qt Quick Demo - RESTful API client</db:title>
<db:productname>QtDoc</db:productname>
<db:edition>Qt 6.6.3 Reference Documentation</db:edition>
<db:titleabbrev>Qt Reference Documentation</db:titleabbrev>
<db:abstract>
<db:para>Example of how to create a RESTful API QML client.</db:para>
</db:abstract>
<db:pubdate>2024-12-27</db:pubdate>
<db:date>2024-12-27</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:mediaobject>
<db:imageobject>
<db:imagedata fileref="images/colorpalette_listing.png"/>
</db:imageobject>
</db:mediaobject>
<db:para>This example shows how to create a basic QML RESTful API client with an imaginary color palette service. The application uses RESTful communication with the selected server to request and send data. The REST service is provided as a QML element whose child elements wrap the individual JSON data APIs provided by the server.</db:para>
<db:section xml:id="application-functionality">
<db:title>Application functionality</db:title>
<db:para>The example provides the following basic functionalities:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para>Select the server to communicate with</db:para>
</db:listitem>
<db:listitem>
<db:para>List users and colors</db:para>
</db:listitem>
<db:listitem>
<db:para>Login and logout users</db:para>
</db:listitem>
<db:listitem>
<db:para>Modify and create new colors</db:para>
</db:listitem>
</db:itemizedlist>
<db:section xml:id="server-selection">
<db:title>Server selection</db:title>
<db:para>At start the application presents the options for the color palette server to communicate with. The predefined options are:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:link xlink:href="https://reqres.in">reqres.in</db:link>, a publicly available REST API test service</db:para>
</db:listitem>
<db:listitem>
<db:para><db:link xlink:href="qthttpserver-colorpalette-example.xml">Qt-based REST API server example</db:link> in <db:link xlink:href="qthttpserver-module.xml">QtHttpServer</db:link></db:para>
</db:listitem>
</db:itemizedlist>
<db:para>Once selected, the RESTful API client issues a test HTTP GET to the color API to check if the service is accessible.</db:para>
<db:mediaobject>
<db:imageobject>
<db:imagedata fileref="images/colorpalette_urlselection.png"/>
</db:imageobject>
</db:mediaobject>
<db:para>One major difference between the two predefined API options is that the <db:link xlink:href="qthttpserver-colorpalette-example.xml">Qt-based REST API server example</db:link> is a stateful application which allows modifying colors, whereas the <db:emphasis>reqres.in</db:emphasis> is a stateless API testing service. In other words, when using the <db:emphasis>reqres.in</db:emphasis> backend, modifying the colors has no impact on the UI.</db:para>
</db:section>
<db:section xml:id="list-users-and-colors">
<db:title>List users and colors</db:title>
<db:para>The users and colors are paginated resources on the server-side. This means that the server provides the data in chunks called <db:emphasis>pages</db:emphasis>. The UI listing reflects this pagination and views the data on pages.</db:para>
<db:para>Viewing the data on UI is done with standard QML views:</db:para>
<db:programlisting language="qml">ListView {
    model: colors.data
</db:programlisting>
<db:para>Where the model is a list of JSON data received from the server.</db:para>
</db:section>
<db:section xml:id="logging-in">
<db:title>Logging in</db:title>
<db:para>Logging in happens via the login function provided by the login QML element:</db:para>
<db:programlisting language="qml">loginService.login({&quot;email&quot; : userInfo.modelData.email,
                    &quot;password&quot; : &quot;apassword&quot;,
                    &quot;id&quot; : userInfo.modelData.id})
</db:programlisting>
<db:para>Under the hood the login sends a HTTP POST request. Upon receiving a successful response the authorization token is extracted from the response, which in turn is then used in subsequent HTTP requests which require the token.</db:para>
</db:section>
<db:section xml:id="editing-colors">
<db:title>Editing colors</db:title>
<db:para>Editing and adding new colors is done in a popup:</db:para>
<db:mediaobject>
<db:imageobject>
<db:imagedata fileref="images/colorpalette_editing.png"/>
</db:imageobject>
</db:mediaobject>
<db:para>Note that uploading the color changes to the server requires that a user has logged in.</db:para>
</db:section>
</db:section>
<db:section xml:id="rest-implementation">
<db:title>REST implementation</db:title>
<db:para>The example illustrates one way to compose a REST service from individual resource elements. In this example the resources are the paginated <db:emphasis>user</db:emphasis> and <db:emphasis>color</db:emphasis> resources plus the login service. The resource elements are bound together by the base URL (server URL) and the shared network access manager.</db:para>
<db:para>The basis of the REST service is the <db:emphasis>RestService</db:emphasis> element whose children items compose the actual service:</db:para>
<db:programlisting language="qml">RestService {
    id: paletteService

    PaginatedResource {
        id: users
        path: &quot;/api/users&quot;
    }

    PaginatedResource {
        id: colors
        path: &quot;/api/unknown&quot;
    }

    BasicLogin {
        id: loginService
        loginPath: &quot;/api/login&quot;
        logoutPath: &quot;/api/logout&quot;
    }
}
</db:programlisting>
<db:para>Upon instantiation the <db:emphasis>RestService</db:emphasis> element loops its children elements and sets them up to use the same network access manager. This way the individual resources share the same access details such as the server URL and authorization token.</db:para>
<db:para>The actual communication is done with a rest access manager which implements some convenience functionality to deal specifically with HTTP REST APIs and effectively deals with sending and receiving the <db:link xlink:href="qnetworkrequest.xml">QNetworkRequest</db:link> and <db:link xlink:href="qnetworkreply.xml">QNetworkReply</db:link> as needed.</db:para>
</db:section>
<db:section xml:id="running-the-example">
<db:title>Running the Example</db:title>
<db:para>To run the example from <db:link xlink:href="https://doc.qt.io/qtcreator/index.html">Qt Creator</db:link>, open the <db:guilabel>Welcome</db:guilabel> mode and select the example from <db:guilabel>Examples</db:guilabel>. For more information, visit <db:link xlink:href="https://doc.qt.io/qtcreator/creator-build-example-application.html">Building and Running an Example</db:link>.</db:para>
</db:section>
<db:section>
<db:title>Example project</db:title>
<db:para><db:link xlink:href="https://code.qt.io/cgit/qt/qtdoc.git/tree/examples/demos/colorpaletteclient?h=6.6">Example project @ code.qt.io</db:link></db:para>
</db:section>
</db:article>
