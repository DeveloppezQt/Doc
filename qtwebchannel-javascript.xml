<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en">
<db:info>
<db:title>Qt WebChannel JavaScript API</db:title>
<db:productname>QtWebChannel</db:productname>
<db:edition>Qt 5.12.12 Reference Documentation</db:edition>
<db:titleabbrev>Qt WebChannel Reference Documentation</db:titleabbrev>
<db:abstract>
<db:para>This page explains how to use the JavaScript <db:link xlink:href="qwebchannel.xml">QWebChannel</db:link> API in HTML clients.</db:para>
</db:abstract>
<db:pubdate>2024-12-27</db:pubdate>
<db:date>2024-12-27</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:section xml:id="setting-up-the-javascript-api">
<db:title>Setting up the JavaScript API</db:title>
<db:para>To communicate with a <db:link xlink:href="qwebchannel.xml">QWebChannel</db:link> or <db:link xlink:href="qml-qtwebchannel-webchannel.xml">WebChannel</db:link>, a client must use and set up the JavaScript API provided by <db:code>qwebchannel.js</db:code>. For clients run inside <db:link xlink:href="qtwebengine-index.xml">Qt WebEngine</db:link>, you can load the file via <db:code>qrc:///qtwebchannel/qwebchannel.js</db:code>. For external clients, you need to copy the file to your web server. Then instantiate a <db:link xlink:href="qwebchannel.xml">QWebChannel</db:link> object and pass it a transport object and a callback function, which will be invoked once the initialization of the channel finishes and the published objects become available.</db:para>
<db:para>The transport object implements a minimal message passing interface. It should be an object with a <db:code>send()</db:code> function, which takes a stringified JSON message and transmits it to the server-side <db:link xlink:href="qwebchannelabstracttransport.xml">QWebChannelAbstractTransport</db:link> object. Furthermore, its <db:code>onmessage</db:code> property should be called when a message from the server was received. Alternatively, you can use a <db:link xlink:href="qtwebsockets-index.xml">WebSocket</db:link> to implement the interface.</db:para>
<db:para>Note that the JavaScript <db:link xlink:href="qwebchannel.xml">QWebChannel</db:link> object should be constructed once the transport object is fully operational. In case of a <db:link xlink:href="qml-qtwebsockets-websocket.xml">WebSocket</db:link>, that means you should create the <db:link xlink:href="qwebchannel.xml">QWebChannel</db:link> in the socket's <db:code>onopen</db:code> handler. Take a look at the <db:link xlink:href="qtwebchannel-standalone-example.xml">Qt WebChannel Standalone Example</db:link> to see how this is done.</db:para>
</db:section>
<db:section xml:id="interacting-with-qobjects">
<db:title>Interacting with QObjects</db:title>
<db:para>Once the callback passed to the <db:link xlink:href="qwebchannel.xml">QWebChannel</db:link> object is invoked, the channel has finished initialization and all published objects are accessible to the HTML client via the <db:code>channel.objects</db:code> property. Thus, assuming an object was published with the identifier &quot;foo&quot;, then we can interact with it as shown in the example below. Note that all communication between the HTML client and the QML/C++ server is asynchronous. Properties are cached on the HTML side. Furthermore keep in mind that only QML/C++ data types which can be converted to JSON will be (de-)serialized properly and thus accessible to HTML clients.</db:para>
<db:programlisting language="cpp">new QWebChannel(yourTransport, function(channel) {

    // Connect to a signal:
    channel.objects.foo.mySignal.connect(function() {
        // This callback will be invoked whenever the signal is emitted on the C++/QML side.
        console.log(arguments);
    });

    // To make the object known globally, assign it to the window object, i.e.:
    window.foo = channel.objects.foo;

    // Invoke a method:
    foo.myMethod(arg1, arg2, function(returnValue) {
        // This callback will be invoked when myMethod has a return value. Keep in mind that
        // the communication is asynchronous, hence the need for this callback.
        console.log(returnValue);
    });

    // Read a property value, which is cached on the client side:
    console.log(foo.myProperty);

    // Writing a property will instantly update the client side cache.
    // The remote end will be notified about the change asynchronously
    foo.myProperty = &quot;Hello World!&quot;;

    // To get notified about remote property changes,
    // simply connect to the corresponding notify signal:
    foo.onMyPropertyChanged.connect(function(newValue) {
        console.log(newValue);
    });

    // One can also access enums that are marked with Q_ENUM:
    console.log(foo.MyEnum.MyEnumerator);
});
    </db:programlisting>
</db:section>
</db:article>
