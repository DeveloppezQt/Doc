<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en">
<db:info>
<db:title>Qt WebChannel JavaScript API</db:title>
<db:productname>QtWebChannel</db:productname>
<db:edition>Qt 6.7.2 Reference Documentation</db:edition>
<db:titleabbrev>Qt WebChannel Reference Documentation</db:titleabbrev>
<db:abstract>
<db:para>This page explains how to use the JavaScript <db:link xlink:href="qwebchannel.xml">QWebChannel</db:link> API in HTML clients.</db:para>
</db:abstract>
<db:pubdate>2024-12-27</db:pubdate>
<db:date>2024-12-27</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:section xml:id="setting-up-the-javascript-api">
<db:title>Setting up the JavaScript API</db:title>
<db:para>To communicate with a <db:link xlink:href="qwebchannel.xml">QWebChannel</db:link> or <db:link xlink:href="qml-qtwebchannel-webchannel.xml">WebChannel</db:link>, a client must use and set up the JavaScript API provided by <db:code>qwebchannel.js</db:code>. For clients run inside <db:link xlink:href="qtwebengine-index.xml">Qt WebEngine</db:link>, you can load the file via <db:code>qrc:///qtwebchannel/qwebchannel.js</db:code>. For external clients, you need to copy the file to your web server. Then instantiate a <db:link xlink:href="qwebchannel.xml">QWebChannel</db:link> object and pass it a transport object and a callback function, which will be invoked once the initialization of the channel finishes and the published objects become available. An optional third argument contains an array of converter wrapper functions or a single one.</db:para>
<db:para>The transport object implements a minimal message passing interface. It should be an object with a <db:code>send()</db:code> function, which takes a stringified JSON message and transmits it to the server-side <db:link xlink:href="qwebchannelabstracttransport.xml">QWebChannelAbstractTransport</db:link> object. Furthermore, its <db:code>onmessage</db:code> property should be called when a message from the server was received. Alternatively, you can use a <db:link xlink:href="qtwebsockets-index.xml">WebSocket</db:link> to implement the interface.</db:para>
<db:para>Note that the JavaScript <db:link xlink:href="qwebchannel.xml">QWebChannel</db:link> object should be constructed once the transport object is fully operational. In case of a WebSocket, that means you should create the <db:link xlink:href="qwebchannel.xml">QWebChannel</db:link> in the socket's <db:code>onopen</db:code> handler. Take a look at the <db:link xlink:href="qtwebchannel-standalone-example.xml">Qt WebChannel Standalone Example</db:link> to see how this is done.</db:para>
<db:note>
<db:para>Only a single <db:code>QWebChannel</db:code> object per transport can be created in the same page.</db:para>
</db:note>
<db:para>A converter wrapper function is either a string with the name of a built-in converter or a user supplied function that takes the object to process as an argument and returns the resultant type or undefined if the function does not apply. If undefined is returned the next converter is processed. If there are no converters that returns a value other than undefined, processing proceeds as normal. &quot;Date&quot; is the only currently built-in converter function. It takes a string with an ISO 8601 date and returns a new Date object if the syntax is right and the date is valid.</db:para>
</db:section>
<db:section xml:id="interacting-with-qobjects">
<db:title>Interacting with QObjects</db:title>
<db:para>Once the callback passed to the <db:link xlink:href="qwebchannel.xml">QWebChannel</db:link> object is invoked, the channel has finished initialization and all published objects are accessible to the HTML client via the <db:code>channel.objects</db:code> property. Thus, assuming an object was published with the identifier &quot;foo&quot;, then we can interact with it as shown in the example below. Note that all communication between the HTML client and the QML/C++ server is asynchronous. Properties are cached on the HTML side. Furthermore keep in mind that only QML/C++ data types which can be converted to JSON will be (de-)serialized properly and thus accessible to HTML clients.</db:para>
<db:programlisting language="cpp">new QWebChannel(yourTransport, function(channel) {

    // Connect to a signal:
    channel.objects.foo.mySignal.connect(function() {
        // This callback will be invoked whenever the signal is emitted on the C++/QML side.
        console.log(arguments);
    });

    // To make the object known globally, assign it to the window object, i.e.:
    window.foo = channel.objects.foo;

    // Invoke a method:
    foo.myMethod(arg1, arg2, function(returnValue) {
        // This callback will be invoked when myMethod has a return value. Keep in mind that
        // the communication is asynchronous, hence the need for this callback.
        console.log(returnValue);
    });

    // Read a property value, which is cached on the client side:
    console.log(foo.myProperty);

    // Writing a property will instantly update the client side cache.
    // The remote end will be notified about the change asynchronously
    foo.myProperty = &quot;Hello World!&quot;;

    // To get notified about remote property changes,
    // simply connect to the corresponding notify signal:
    foo.myPropertyChanged.connect(function() {
        console.log(foo.myProperty);
    });

    // One can also access enums that are marked with Q_ENUM:
    console.log(foo.MyEnum.MyEnumerator);
});
    </db:programlisting>
<db:section xml:id="overloaded-methods-and-signals">
<db:title>Overloaded methods and signals</db:title>
<db:para>When you publish a <db:code>QObject</db:code> that has overloaded methods, <db:link xlink:href="qwebchannel.xml">QWebChannel</db:link> will resolve method invocations to the best match. Note that due to JavaScript's type system, there is only a single 'number' type which maps best to a C++ 'double'. When overloads differ only in the type of a number-like parameter, <db:link xlink:href="qwebchannel.xml">QWebChannel</db:link> will always choose that overload which best matches the JavaScript 'number' type. When you connect to an overloaded signal, the <db:link xlink:href="qwebchannel.xml">QWebChannel</db:link> client will by default only connect to the first signal overload of that name. Additionally, overloads of methods and signals can explicitly be requested by their complete <db:code>QMetaMethod</db:code> signature. Assume we have the following <db:code>QObject</db:code> subclass on the C++ side:</db:para>
<db:programlisting language="cpp">class Foo : public QObject
{
    Q_OBJECT
slots:
    void foo(int i);
    void foo(double d);
    void foo(const QString &amp;amp;str);
    void foo(const QString &amp;amp;str, int i);

signals:
    void bar(int i);
    void bar(const QString &amp;amp;str);
    void bar(const QString &amp;amp;str, int i);
};
</db:programlisting>
<db:para>Then you can interact with this class on the JavaScript side like this:</db:para>
<db:programlisting language="cpp">// methods
foo.foo(42); // will call the method named foo which best matches the JavaScript number parameter, i.e. foo(double d)
foo.foo(&quot;asdf&quot;); // will call foo(const QString &amp;amp;str)
foo.foo(&quot;asdf&quot;, 42); // will call foo(const QString &amp;amp;str, int i)
foo[&quot;foo(int)&quot;](42); // explicitly call foo(int i), *not* foo(double d)
foo[&quot;foo(QString)&quot;](&quot;asdf&quot;); // explicitly call foo(const QString &amp;amp;str)
foo[&quot;foo(QString,int)&quot;](&quot;asdf&quot;, 42); // explicitly call foo(const QString &amp;amp;str, int i)

// signals
foo.bar.connect(...); // connect to first signal named bar, i.e. bar(int i)
foo[&quot;bar(int)&quot;].connect(...); // connect explicitly to bar(int i)
foo[&quot;bar(QString)&quot;].connect(...); // connect explicitly to bar(const QString &amp;amp;str)
foo[&quot;bar(QString,int)&quot;].connect(...); // connect explicitly to bar(const QString &amp;amp;str, int i)
</db:programlisting>
</db:section>
</db:section>
</db:article>
