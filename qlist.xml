<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en">
<db:info>
<db:title>QList Class</db:title>
<db:subtitle>template &lt;typename T&gt; class QList</db:subtitle>
<db:productname>QtCore</db:productname>
<db:edition>Qt 6.8.3 Reference Documentation</db:edition>
<db:titleabbrev>Qt Core Reference Documentation</db:titleabbrev>
<db:abstract>
<db:para>The <db:link xlink:href="qlist.xml">QList</db:link> class is a template class that provides a dynamic array.</db:para>
<db:note>
<db:para>All functions in this class are reentrant.</db:para>
</db:note>
</db:abstract>
<db:pubdate>2025-06-29</db:pubdate>
<db:date>2025-06-29</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:variablelist>
<db:varlistentry>
<db:term>Header</db:term>
<db:listitem>
<db:para>QList</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>CMake</db:term>
<db:listitem>
<db:para>find_package(Qt6 REQUIRED COMPONENTS Core)</db:para>
<db:para>target_link_libraries(mytarget PRIVATE Qt6::Core)</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>qmake</db:term>
<db:listitem>
<db:para>QT += core</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Inherited By</db:term>
<db:listitem>
<db:para><db:link xlink:href="qbytearraylist.xml" xlink:role="class">QByteArrayList</db:link>, <db:link xlink:href="qitemselection.xml" xlink:role="class">QItemSelection</db:link>, <db:link xlink:href="qqueue.xml" xlink:role="class">QQueue</db:link>, <db:link xlink:href="qstack.xml" xlink:role="class">QStack</db:link>, <db:link xlink:href="qstringlist.xml" xlink:role="class">QStringList</db:link>, <db:link xlink:href="qvector.xml" xlink:role="class">QVector</db:link>, and <db:link xlink:href="qxmlstreamattributes.xml" xlink:role="class">QXmlStreamAttributes</db:link></db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Group</db:term>
<db:listitem>
<db:para>QList is part of <db:simplelist><db:member>tools</db:member><db:member><db:link xlink:href="shared.xml">Implicitly Shared Classes</db:link></db:member></db:simplelist>
</db:para>
</db:listitem>
</db:varlistentry>
</db:variablelist>
<db:section xml:id="details">
<db:title>Detailed Description</db:title>
<db:para><db:link xlink:href="qlist.xml">QList</db:link>&lt;T&gt; is one of Qt's generic <db:link xlink:href="containers.xml">container classes</db:link>. It stores its items in adjacent memory locations and provides fast index-based access. <db:link xlink:href="qvector.xml">QVector</db:link>&lt;T&gt; used to be a different class in Qt 5, but is now a simple alias to <db:link xlink:href="qlist.xml">QList</db:link>.</db:para>
<db:para><db:link xlink:href="qlist.xml">QList</db:link>&lt;T&gt; and <db:link xlink:href="qvarlengtharray.xml">QVarLengthArray</db:link>&lt;T&gt; provide similar APIs and functionality. They are often interchangeable, but there are performance consequences. Here is an overview of use cases:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:link xlink:href="qlist.xml">QList</db:link> should be your default first choice.</db:para>
</db:listitem>
<db:listitem>
<db:para><db:link xlink:href="qvarlengtharray.xml">QVarLengthArray</db:link> provides an array that reserves space on the stack, but can dynamically grow onto the heap if required. It's good to use for short lived containers that are usually small.</db:para>
</db:listitem>
<db:listitem>
<db:para>If you need a real linked list, which guarantees <db:link xlink:href="containers.xml#algorithmic-complexity">constant time</db:link> insertions mid-list and uses iterators to items rather than indexes, use std::list.</db:para>
</db:listitem>
</db:itemizedlist>
<db:note>
<db:para><db:link xlink:href="qlist.xml">QList</db:link> and <db:link xlink:href="qvarlengtharray.xml">QVarLengthArray</db:link> both guarantee C-compatible array layout.</db:para>
</db:note>
<db:note>
<db:para><db:link xlink:href="qlist.xml">QList</db:link> in Qt 5 did not always have a C-compatible array layout and we often recommended to use <db:link xlink:href="qvector.xml">QVector</db:link> instead for more predictable performance. This is not the case in Qt 6 anymore, where both classes now share an implementation and can be used interchangeably.</db:para>
</db:note>
<db:para>Here's an example of a <db:link xlink:href="qlist.xml">QList</db:link> that stores integers and a <db:link xlink:href="qlist.xml">QList</db:link> that stores <db:link xlink:href="qstring.xml">QString</db:link> values:</db:para>
<db:programlisting language="cpp">QList&lt;int&gt; integerList;
QList&lt;QString&gt; stringList;
</db:programlisting>
<db:para><db:link xlink:href="qlist.xml">QList</db:link> stores its items in an array of continuous memory. Typically, lists are created with an initial size. For example, the following code constructs a <db:link xlink:href="qlist.xml">QList</db:link> with 200 elements:</db:para>
<db:programlisting language="cpp">QList&lt;QString&gt; list(200);
</db:programlisting>
<db:para>The elements are automatically initialized with a <db:link xlink:href="containers.xml#default-constructed-value">default-constructed value</db:link>. If you want to initialize the list with a different value, pass that value as the second argument to the constructor:</db:para>
<db:programlisting language="cpp">QList&lt;QString&gt; list(200, &quot;Pass&quot;);
</db:programlisting>
<db:para>You can also call <db:link xlink:href="qlist.xml#fill">fill</db:link>() at any time to fill the list with a value.</db:para>
<db:para><db:link xlink:href="qlist.xml">QList</db:link> uses 0-based indexes, just like C++ arrays. To access the item at a particular index position, you can use operator[](). On non-const lists, operator[]() returns a reference to the item that can be used on the left side of an assignment:</db:para>
<db:programlisting language="cpp">if (list[0] == &quot;Liz&quot;)
    list[0] = &quot;Elizabeth&quot;;
</db:programlisting>
<db:para>For read-only access, an alternative syntax is to use <db:link xlink:href="qlist.xml#at">at</db:link>():</db:para>
<db:programlisting language="cpp">for (qsizetype i = 0; i &lt; list.size(); ++i) {
    if (list.at(i) == &quot;Alfonso&quot;)
        cout &lt;&lt; &quot;Found Alfonso at position &quot; &lt;&lt; i &lt;&lt; endl;
}
</db:programlisting>
<db:para><db:link xlink:href="qlist.xml#at">at</db:link>() can be faster than operator[](), because it never causes a <db:link xlink:href="implicit-sharing.xml#deep-copy">deep copy</db:link> to occur.</db:para>
<db:para>Another way to access the data stored in a <db:link xlink:href="qlist.xml">QList</db:link> is to call <db:link xlink:href="qlist.xml#data">data</db:link>(). The function returns a pointer to the first item in the list. You can use the pointer to directly access and modify the elements stored in the list. The pointer is also useful if you need to pass a <db:link xlink:href="qlist.xml">QList</db:link> to a function that accepts a plain C++ array.</db:para>
<db:para>If you want to find all occurrences of a particular value in a list, use <db:link xlink:href="qlist.xml#indexOf">indexOf</db:link>() or <db:link xlink:href="qlist.xml#lastIndexOf">lastIndexOf</db:link>(). The former searches forward starting from a given index position, the latter searches backward. Both return the index of the matching item if they found one; otherwise, they return -1. For example:</db:para>
<db:programlisting language="cpp">qsizetype i = list.indexOf(&quot;Harumi&quot;);
if (i != -1)
    cout &lt;&lt; &quot;First occurrence of Harumi is at position &quot; &lt;&lt; i &lt;&lt; endl;
</db:programlisting>
<db:para>If you simply want to check whether a list contains a particular value, use <db:link xlink:href="qlist.xml#contains">contains</db:link>(). If you want to find out how many times a particular value occurs in the list, use <db:link xlink:href="qlist.xml#count-1">count</db:link>().</db:para>
<db:para><db:link xlink:href="qlist.xml">QList</db:link> provides these basic functions to add, move, and remove items: <db:link xlink:href="qlist.xml#insert">insert</db:link>(), <db:link xlink:href="qlist.xml#replace">replace</db:link>(), <db:link xlink:href="qlist.xml#remove">remove</db:link>(), <db:link xlink:href="qlist.xml#prepend">prepend</db:link>(), <db:link xlink:href="qlist.xml#append">append</db:link>(). With the exception of <db:link xlink:href="qlist.xml#append">append</db:link>(), <db:link xlink:href="qlist.xml#prepend">prepend</db:link>() and <db:link xlink:href="qlist.xml#replace">replace</db:link>(), these functions can be slow (<db:link xlink:href="containers.xml#linear-time">linear time</db:link>) for large lists, because they require moving many items in the list by one position in memory. If you want a container class that provides fast insertion/removal in the middle, use std::list instead.</db:para>
<db:para>Unlike plain C++ arrays, QLists can be resized at any time by calling <db:link xlink:href="qlist.xml#resize">resize</db:link>(). If the new size is larger than the old size, <db:link xlink:href="qlist.xml">QList</db:link> might need to reallocate the whole list. <db:link xlink:href="qlist.xml">QList</db:link> tries to reduce the number of reallocations by preallocating up to twice as much memory as the actual data needs.</db:para>
<db:para>If you're building a <db:link xlink:href="qlist.xml">QList</db:link> gradually and know in advance approximately how many elements it will contain, you can call <db:link xlink:href="qlist.xml#reserve">reserve</db:link>(), asking <db:link xlink:href="qlist.xml">QList</db:link> to preallocate a certain amount of memory. You can also call <db:link xlink:href="qlist.xml#capacity">capacity</db:link>() to find out how much memory the <db:link xlink:href="qlist.xml">QList</db:link> actually has allocated.</db:para>
<db:para>Note that using non-const operators and functions can cause <db:link xlink:href="qlist.xml">QList</db:link> to do a deep copy of the data, due to <db:link xlink:href="implicit-sharing.xml">implicit sharing</db:link>.</db:para>
<db:para><db:link xlink:href="qlist.xml">QList</db:link>'s value type must be an <db:link xlink:href="containers.xml#assignable-data-type">assignable data type</db:link>. This covers most data types that are commonly used, but the compiler won't let you, for example, store a QWidget as a value; instead, store a QWidget *. A few functions have additional requirements; for example, <db:link xlink:href="qlist.xml#indexOf">indexOf</db:link>() and <db:link xlink:href="qlist.xml#lastIndexOf">lastIndexOf</db:link>() expect the value type to support <db:code>operator==()</db:code>. These requirements are documented on a per-function basis.</db:para>
<db:para>For iterating over the items, see <db:link xlink:href="containers.xml#iterating-over-containers">Iterating over Containers</db:link>. For using <db:link xlink:href="qlist.xml">QList</db:link> with functions from <db:code>&lt;algorithm&gt;</db:code> header, such as <db:code>std::sort()</db:code>, <db:code>std::reverse()</db:code>, and <db:code>std::count_if()</db:code>, see <db:link xlink:href="containers.xml#qt-containers-and-std-algorithms">Qt containers and std algorithms</db:link>.</db:para>
<db:para>In addition to <db:link xlink:href="qlist.xml">QList</db:link>, Qt also provides <db:link xlink:href="qvarlengtharray.xml">QVarLengthArray</db:link>, a very low-level class with little functionality that is optimized for speed.</db:para>
<db:section xml:id="more-information-on-using-qt-containers">
<db:title>More Information on Using Qt Containers</db:title>
<db:para>For a detailed discussion comparing Qt containers with each other and with STL containers, see <db:link xlink:href="https://marcmutz.wordpress.com/effective-qt/containers/">Understand the Qt Containers</db:link>.</db:para>
</db:section>
<db:section xml:id="maximum-size-and-out-of-memory-conditions">
<db:title>Maximum size and out-of-memory conditions</db:title>
<db:para>The maximum size of <db:link xlink:href="qlist.xml">QList</db:link> depends on the architecture. Most 64-bit systems can allocate more than 2 GB of memory, with a typical limit of 2^63 bytes. The actual value also depends on the overhead required for managing the data block. As a result, you can expect the maximum size of 2 GB minus overhead on 32-bit platforms, and 2^63 bytes minus overhead on 64-bit platforms. The number of elements that can be stored in a <db:link xlink:href="qlist.xml">QList</db:link> is this maximum size divided by the size of a stored element.</db:para>
<db:para>When memory allocation fails, <db:link xlink:href="qlist.xml">QList</db:link> uses the <db:link xlink:href="qtassert-qtcore-proxy.xml#Q_CHECK_PTR">Q_CHECK_PTR</db:link> macro, which throws a <db:code>std::bad_alloc</db:code> exception if the application is being compiled with exception support. If exceptions are disabled, then running out of memory is undefined behavior.</db:para>
<db:para>Note that the operating system may impose further limits on applications holding a lot of allocated memory, especially large, contiguous blocks. Such considerations, the configuration of such behavior or any mitigation are outside the scope of the Qt API.</db:para>
</db:section>
</db:section>
<db:section xml:id="member-type-documentation">
<db:title>Member Type Documentation</db:title>
<db:section xml:id="ConstIterator-typedef">
<db:title>[alias] QList::ConstIterator</db:title>
<db:para>Qt-style synonym for <db:link xlink:href="qlist-const-iterator.xml">QList::const_iterator</db:link>.</db:para>
</db:section>
<db:section xml:id="Iterator-typedef">
<db:title>[alias] QList::Iterator</db:title>
<db:para>Qt-style synonym for <db:link xlink:href="qlist-iterator.xml">QList::iterator</db:link>.</db:para>
</db:section>
<db:section xml:id="const_pointer-typedef">
<db:title>[alias] QList::const_pointer</db:title>
<db:para>Provided for STL compatibility.</db:para>
</db:section>
<db:section xml:id="const_reference-typedef">
<db:title>[alias] QList::const_reference</db:title>
<db:para>Provided for STL compatibility.</db:para>
</db:section>
<db:section xml:id="const_reverse_iterator-typedef">
<db:title>[alias] QList::const_reverse_iterator</db:title>
<db:para>The QList::const_reverse_iterator typedef provides an STL-style const reverse iterator for <db:link xlink:href="qlist.xml">QList</db:link>.</db:para>
<db:warning>
<db:para>Iterators on implicitly shared containers do not work exactly like STL-iterators. You should avoid copying a container while iterators are active on that container. For more information, read <db:link xlink:href="containers.xml#implicit-sharing-iterator-problem">Implicit sharing iterator problem</db:link>.</db:para>
</db:warning>
<db:warning>
<db:para>Iterators are invalidated when <db:link xlink:href="qlist.xml">QList</db:link> is modified. Consider that all iterators are invalidated by default. Exceptions to this rule are explicitly documented.</db:para>
</db:warning>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qlist.xml#rbegin">QList::rbegin</db:link>()</db:member>
<db:member><db:link xlink:href="qlist.xml#rend">QList::rend</db:link>()</db:member>
<db:member><db:link xlink:href="qlist.xml#reverse_iterator-typedef">QList::reverse_iterator</db:link></db:member>
<db:member><db:link xlink:href="qlist-const-iterator.xml">QList::const_iterator</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="difference_type-typedef">
<db:title>[alias] QList::difference_type</db:title>
<db:para>Provided for STL compatibility.</db:para>
</db:section>
<db:section xml:id="parameter_type-typedef">
<db:title>[alias] QList::parameter_type</db:title>
</db:section>
<db:section xml:id="pointer-typedef">
<db:title>[alias] QList::pointer</db:title>
<db:para>Provided for STL compatibility.</db:para>
</db:section>
<db:section xml:id="reference-typedef">
<db:title>[alias] QList::reference</db:title>
<db:para>Provided for STL compatibility.</db:para>
</db:section>
<db:section xml:id="reverse_iterator-typedef">
<db:title>[alias] QList::reverse_iterator</db:title>
<db:para>The QList::reverse_iterator typedef provides an STL-style non-const reverse iterator for <db:link xlink:href="qlist.xml">QList</db:link>.</db:para>
<db:warning>
<db:para>Iterators on implicitly shared containers do not work exactly like STL-iterators. You should avoid copying a container while iterators are active on that container. For more information, read <db:link xlink:href="containers.xml#implicit-sharing-iterator-problem">Implicit sharing iterator problem</db:link>.</db:para>
</db:warning>
<db:warning>
<db:para>Iterators are invalidated when <db:link xlink:href="qlist.xml">QList</db:link> is modified. Consider that all iterators are invalidated by default. Exceptions to this rule are explicitly documented.</db:para>
</db:warning>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qlist.xml#rbegin">QList::rbegin</db:link>()</db:member>
<db:member><db:link xlink:href="qlist.xml#rend">QList::rend</db:link>()</db:member>
<db:member><db:link xlink:href="qlist.xml#const_reverse_iterator-typedef">QList::const_reverse_iterator</db:link></db:member>
<db:member><db:link xlink:href="qlist-iterator.xml">QList::iterator</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="rvalue_ref-typedef">
<db:title>[alias] QList::rvalue_ref</db:title>
</db:section>
<db:section xml:id="size_type-typedef">
<db:title>[alias] QList::size_type</db:title>
<db:para>Provided for STL compatibility.</db:para>
</db:section>
<db:section xml:id="value_type-typedef">
<db:title>[alias] QList::value_type</db:title>
<db:para>Provided for STL compatibility.</db:para>
</db:section>
</db:section>
<db:section xml:id="member-function-documentation">
<db:title>Member Function Documentation</db:title>
<db:section xml:id="resize">
<db:title>[since 6.0] void QList::resize(qsizetype <db:emphasis>size</db:emphasis>)</db:title>
<db:bridgehead renderas="sect2" xml:id="resize-1">[since 6.0] void QList::resize(qsizetype <db:emphasis>size</db:emphasis>, QList&lt;T&gt;::parameter_type <db:emphasis>c</db:emphasis>)</db:bridgehead>
<db:para>Sets the size of the list to <db:code role="parameter">size</db:code>. If <db:code role="parameter">size</db:code> is greater than the current size, elements are added to the end; the new elements are initialized with either a <db:link xlink:href="containers.xml#default-constructed-value">default-constructed value</db:link> or <db:code role="parameter">c</db:code>. If <db:code role="parameter">size</db:code> is less than the current size, elements are removed from the end.</db:para>
<db:para>If this list is not shared, the <db:link xlink:href="qlist.xml#capacity">capacity</db:link>() is preserved. Use <db:link xlink:href="qlist.xml#squeeze">squeeze</db:link>() to shed excess capacity.</db:para>
<db:note>
<db:para>In Qt versions prior to 5.7 (for <db:link xlink:href="qvector.xml">QVector</db:link>; <db:link xlink:href="qlist.xml">QList</db:link> lacked a <db:link xlink:href="qlist.xml#resize">resize</db:link>() until 6.0), this function released the memory used by the list instead of preserving the capacity.</db:para>
</db:note>
<db:para>This function was introduced in Qt 6.0.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qlist.xml#size">size</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="prepend">
<db:title>void QList::prepend(QList&lt;T&gt;::parameter_type <db:emphasis>value</db:emphasis>)</db:title>
<db:bridgehead renderas="sect2" xml:id="prepend-1">void QList::prepend(QList&lt;T&gt;::rvalue_ref <db:emphasis>value</db:emphasis>)</db:bridgehead>
<db:para>Inserts <db:code role="parameter">value</db:code> at the beginning of the list.</db:para>
<db:para>Example:</db:para>
<db:programlisting language="cpp">QList&lt;QString&gt; list;
list.prepend(&quot;one&quot;);
list.prepend(&quot;two&quot;);
list.prepend(&quot;three&quot;);
// list: [&quot;three&quot;, &quot;two&quot;, &quot;one&quot;]
</db:programlisting>
<db:para>This is the same as list.insert(0, <db:code role="parameter">value</db:code>).</db:para>
<db:para>Normally this operation is relatively fast (amortized <db:link xlink:href="containers.xml#constant-time">constant time</db:link>). <db:link xlink:href="qlist.xml">QList</db:link> is able to allocate extra memory at the beginning of the list data and grow in that direction without reallocating or moving the data on each operation. However if you want a container class with a guarantee of <db:link xlink:href="containers.xml#constant-time">constant time</db:link> prepend, use std::list instead, but prefer <db:link xlink:href="qlist.xml">QList</db:link> otherwise.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qlist.xml#append">append</db:link>()</db:member>
<db:member><db:link xlink:href="qlist.xml#insert">insert</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="emplaceBack">
<db:title>QList&lt;T&gt;::reference QList::emplaceBack(Args &amp;&amp;... <db:emphasis>args</db:emphasis>)</db:title>
<db:bridgehead renderas="sect2" xml:id="emplace_back">QList&lt;T&gt;::reference QList::emplace_back(Args &amp;&amp;... <db:emphasis>args</db:emphasis>)</db:bridgehead>
<db:para>Adds a new element to the end for the container. This new element is constructed in-place using <db:code role="parameter">args</db:code> as the arguments for its construction.</db:para>
<db:para>Returns a reference to the new element.</db:para>
<db:para>Example:</db:para>
<db:programlisting language="cpp">QList&lt;QString&gt; list{&quot;one&quot;, &quot;two&quot;};
list.emplaceBack(3, 'a');
qDebug() &lt;&lt; list;
// list: [&quot;one&quot;, &quot;two&quot;, &quot;aaa&quot;]
</db:programlisting>
<db:para>It is also possible to access a newly created object by using returned reference:</db:para>
<db:programlisting language="cpp">QList&lt;QString&gt; list;
auto &amp;ref = list.emplaceBack();
ref = &quot;one&quot;;
// list: [&quot;one&quot;]
</db:programlisting>
<db:para>This is the same as list.emplace(list.<db:link xlink:href="qlist.xml#size">size</db:link>(), <db:code role="parameter">args</db:code>).</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qlist.xml#emplace">emplace</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="insert">
<db:title>QList&lt;T&gt;::iterator QList::insert(qsizetype <db:emphasis>i</db:emphasis>, QList&lt;T&gt;::parameter_type <db:emphasis>value</db:emphasis>)</db:title>
<db:bridgehead renderas="sect2" xml:id="insert-1">QList&lt;T&gt;::iterator QList::insert(qsizetype <db:emphasis>i</db:emphasis>, QList&lt;T&gt;::rvalue_ref <db:emphasis>value</db:emphasis>)</db:bridgehead>
<db:para>Inserts <db:code role="parameter">value</db:code> at index position <db:code role="parameter">i</db:code> in the list. If <db:code role="parameter">i</db:code> is 0, the value is prepended to the list. If <db:code role="parameter">i</db:code> is <db:link xlink:href="qlist.xml#size">size</db:link>(), the value is appended to the list.</db:para>
<db:para>Example:</db:para>
<db:programlisting language="cpp">QList&lt;QString&gt; list = {&quot;alpha&quot;, &quot;beta&quot;, &quot;delta&quot;};
list.insert(2, &quot;gamma&quot;);
// list: [&quot;alpha&quot;, &quot;beta&quot;, &quot;gamma&quot;, &quot;delta&quot;]
</db:programlisting>
<db:para>For large lists, this operation can be slow (<db:link xlink:href="containers.xml#linear-time">linear time</db:link>), because it requires moving all the items at indexes <db:code role="parameter">i</db:code> and above by one position further in memory. If you want a container class that provides a fast <db:link xlink:href="qlist.xml#insert">insert</db:link>() function, use std::list instead.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qlist.xml#append">append</db:link>()</db:member>
<db:member><db:link xlink:href="qlist.xml#prepend">prepend</db:link>()</db:member>
<db:member><db:link xlink:href="qlist.xml#remove">remove</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="insert-3">
<db:title>QList&lt;T&gt;::iterator QList::insert(QList&lt;T&gt;::const_iterator <db:emphasis>before</db:emphasis>, QList&lt;T&gt;::parameter_type <db:emphasis>value</db:emphasis>)</db:title>
<db:bridgehead renderas="sect2" xml:id="insert-4">QList&lt;T&gt;::iterator QList::insert(QList&lt;T&gt;::const_iterator <db:emphasis>before</db:emphasis>, QList&lt;T&gt;::rvalue_ref <db:emphasis>value</db:emphasis>)</db:bridgehead>
<db:para>This is an overloaded function.</db:para>
<db:para>Inserts <db:code role="parameter">value</db:code> in front of the item pointed to by the iterator <db:code role="parameter">before</db:code>. Returns an iterator pointing at the inserted item.</db:para>
</db:section>
<db:section xml:id="replace">
<db:title>void QList::replace(qsizetype <db:emphasis>i</db:emphasis>, QList&lt;T&gt;::parameter_type <db:emphasis>value</db:emphasis>)</db:title>
<db:bridgehead renderas="sect2" xml:id="replace-1">void QList::replace(qsizetype <db:emphasis>i</db:emphasis>, QList&lt;T&gt;::rvalue_ref <db:emphasis>value</db:emphasis>)</db:bridgehead>
<db:para>Replaces the item at index position <db:code role="parameter">i</db:code> with <db:code role="parameter">value</db:code>.</db:para>
<db:para><db:code role="parameter">i</db:code> must be a valid index position in the list (i.e., 0 &lt;= <db:code role="parameter">i</db:code> &lt; <db:link xlink:href="qlist.xml#size">size</db:link>()).</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qlist.xml#operator-5b-5d">operator[]</db:link>()</db:member>
<db:member><db:link xlink:href="qlist.xml#remove">remove</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="push_front">
<db:title>void QList::push_front(QList&lt;T&gt;::parameter_type <db:emphasis>value</db:emphasis>)</db:title>
<db:bridgehead renderas="sect2" xml:id="push_front-1">void QList::push_front(QList&lt;T&gt;::rvalue_ref <db:emphasis>value</db:emphasis>)</db:bridgehead>
<db:para>This function is provided for STL compatibility. It is equivalent to prepend(<db:code role="parameter">value</db:code>).</db:para>
</db:section>
<db:section xml:id="maxSize">
<db:title>[static constexpr, since 6.8] qsizetype QList::maxSize()</db:title>
<db:bridgehead renderas="sect2" xml:id="max_size">[constexpr noexcept, since 6.8] qsizetype QList::max_size() const</db:bridgehead>
<db:para>It returns the maximum number of elements that the list can theoretically hold. In practice, the number can be much smaller, limited by the amount of memory available to the system.</db:para>
<db:para>This function was introduced in Qt 6.8.</db:para>
</db:section>
<db:section xml:id="operator-2b">
<db:title>QList&lt;T&gt; QList::operator+(QList&lt;T&gt; &amp;&amp;<db:emphasis>other</db:emphasis>) &amp;&amp;</db:title>
<db:bridgehead renderas="sect2" xml:id="operator-2b-1">QList&lt;T&gt; QList::operator+(const QList&lt;T&gt; &amp;<db:emphasis>other</db:emphasis>) &amp;&amp;</db:bridgehead>
<db:bridgehead renderas="sect2" xml:id="operator-2b-2">QList&lt;T&gt; QList::operator+(QList&lt;T&gt; &amp;&amp;<db:emphasis>other</db:emphasis>) const &amp;</db:bridgehead>
<db:bridgehead renderas="sect2" xml:id="operator-2b-3">QList&lt;T&gt; QList::operator+(const QList&lt;T&gt; &amp;<db:emphasis>other</db:emphasis>) const &amp;</db:bridgehead>
<db:para>Returns a list that contains all the items in this list followed by all the items in the <db:code role="parameter">other</db:code> list.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qlist.xml#operator-2b-eq">operator+=</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="QList">
<db:title>QList::QList()</db:title>
<db:para>Constructs an empty list.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qlist.xml#resize">resize</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="QList-3">
<db:title>[explicit] QList::QList(qsizetype <db:emphasis>size</db:emphasis>)</db:title>
<db:para>Constructs a list with an initial size of <db:code role="parameter">size</db:code> elements.</db:para>
<db:para>The elements are initialized with a <db:link xlink:href="containers.xml#default-constructed-value">default-constructed value</db:link>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qlist.xml#resize">resize</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="QList-4">
<db:title>QList::QList(std::initializer_list&lt;T&gt; <db:emphasis>args</db:emphasis>)</db:title>
<db:para>Constructs a list from the std::initializer_list given by <db:code role="parameter">args</db:code>.</db:para>
</db:section>
<db:section xml:id="QList-5">
<db:title>QList::QList(InputIterator <db:emphasis>first</db:emphasis>, InputIterator <db:emphasis>last</db:emphasis>)</db:title>
<db:para>Constructs a list with the contents in the iterator range [<db:code role="parameter">first</db:code>, <db:code role="parameter">last</db:code>).</db:para>
<db:note>
<db:para>This constructor only participates in overload resolution if <db:code>InputIterator</db:code> meets the requirements of a <db:link xlink:href="https://en.cppreference.com/w/cpp/named_req/InputIterator">LegacyInputIterator</db:link>.</db:para>
</db:note>
<db:para>The value type of <db:code>InputIterator</db:code> must be convertible to <db:code>T</db:code>.</db:para>
</db:section>
<db:section xml:id="QList-6">
<db:title>QList::QList(qsizetype <db:emphasis>size</db:emphasis>, QList&lt;T&gt;::parameter_type <db:emphasis>value</db:emphasis>)</db:title>
<db:para>Constructs a list with an initial size of <db:code role="parameter">size</db:code> elements. Each element is initialized with <db:code role="parameter">value</db:code>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qlist.xml#resize">resize</db:link>()</db:member>
<db:member><db:link xlink:href="qlist.xml#fill">fill</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="QList-7">
<db:title>[since 6.8] QList::QList(qsizetype <db:emphasis>size</db:emphasis>, <db:emphasis>Qt::Initialization</db:emphasis>)</db:title>
<db:para>Constructs a list with an initial size of <db:code role="parameter">size</db:code> elements.</db:para>
<db:para><db:link xlink:href="qlist.xml">QList</db:link> will make an attempt at <db:emphasis role="bold">not initializing</db:emphasis> the elements.</db:para>
<db:para>Specifically:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para>if <db:code>T</db:code> has a constructor that accepts <db:code>Qt::Uninitialized</db:code>, that constructor will be used to initialize the elements;</db:para>
</db:listitem>
<db:listitem>
<db:para>otherwise, each element is default constructed. For trivially constructible types (such as <db:code>int</db:code>, <db:code>float</db:code>, etc.) this is equivalent to not initializing them.</db:para>
</db:listitem>
</db:itemizedlist>
<db:para>This function was introduced in Qt 6.8.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qlist.xml#resizeForOverwrite">resizeForOverwrite</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="QList-2">
<db:title>[default] QList::QList(const QList&lt;T&gt; &amp;<db:emphasis>other</db:emphasis>)</db:title>
<db:para>Constructs a copy of <db:code role="parameter">other</db:code>.</db:para>
<db:para>This operation takes <db:link xlink:href="containers.xml#algorithmic-complexity">constant time</db:link>, because <db:link xlink:href="qlist.xml">QList</db:link> is <db:link xlink:href="implicit-sharing.xml">implicitly shared</db:link>. This makes returning a <db:link xlink:href="qlist.xml">QList</db:link> from a function very fast. If a shared instance is modified, it will be copied (copy-on-write), and that takes <db:link xlink:href="containers.xml#algorithmic-complexity">linear time</db:link>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qlist.xml#operator-eq">operator=</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="QList-1">
<db:title>[default] QList::QList(QList&lt;T&gt; &amp;&amp;<db:emphasis>other</db:emphasis>)</db:title>
<db:para>Move-constructs a <db:link xlink:href="qlist.xml">QList</db:link> instance, making it point at the same object that <db:code role="parameter">other</db:code> was pointing to.</db:para>
</db:section>
<db:section xml:id="dtor.QList">
<db:title>[default] QList::~QList()</db:title>
<db:para>Destroys the list.</db:para>
</db:section>
<db:section xml:id="append">
<db:title>void QList::append(QList&lt;T&gt;::parameter_type <db:emphasis>value</db:emphasis>)</db:title>
<db:para>Inserts <db:code role="parameter">value</db:code> at the end of the list.</db:para>
<db:para>Example:</db:para>
<db:programlisting language="cpp">QList&lt;QString&gt; list;
list.append(&quot;one&quot;);
list.append(&quot;two&quot;);
QString three = &quot;three&quot;;
list.append(three);
// list: [&quot;one&quot;, &quot;two&quot;, &quot;three&quot;]
// three: &quot;three&quot;
</db:programlisting>
<db:para>This is the same as calling resize(<db:link xlink:href="qlist.xml#size">size</db:link>() + 1) and assigning <db:code role="parameter">value</db:code> to the new last element in the list.</db:para>
<db:para>This operation is relatively fast, because <db:link xlink:href="qlist.xml">QList</db:link> typically allocates more memory than necessary, so it can grow without reallocating the entire list each time.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qlist.xml#operator-lt-lt">operator&lt;&lt;</db:link>()</db:member>
<db:member><db:link xlink:href="qlist.xml#prepend">prepend</db:link>()</db:member>
<db:member><db:link xlink:href="qlist.xml#insert">insert</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="append-2">
<db:title>[since 6.0] void QList::append(QList&lt;T&gt; &amp;&amp;<db:emphasis>value</db:emphasis>)</db:title>
<db:para>This is an overloaded function.</db:para>
<db:para>Moves the items of the <db:code role="parameter">value</db:code> list to the end of this list.</db:para>
<db:para>This function was introduced in Qt 6.0.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qlist.xml#operator-lt-lt">operator&lt;&lt;</db:link>()</db:member>
<db:member><db:link xlink:href="qlist.xml#operator-2b-eq">operator+=</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="append-3">
<db:title>void QList::append(QList&lt;T&gt;::rvalue_ref <db:emphasis>value</db:emphasis>)</db:title>
<db:para>This is an overloaded function.</db:para>
<db:para>Example:</db:para>
<db:programlisting language="cpp">QList&lt;QString&gt; list;
list.append(&quot;one&quot;);
list.append(&quot;two&quot;);
QString three = &quot;three&quot;;
list.append(std::move(three));
// list: [&quot;one&quot;, &quot;two&quot;, &quot;three&quot;]
// three: &quot;&quot;
</db:programlisting>
</db:section>
<db:section xml:id="append-4">
<db:title>void QList::append(const QList&lt;T&gt; &amp;<db:emphasis>value</db:emphasis>)</db:title>
<db:para>This is an overloaded function.</db:para>
<db:para>Appends the items of the <db:code role="parameter">value</db:code> list to this list.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qlist.xml#operator-lt-lt">operator&lt;&lt;</db:link>()</db:member>
<db:member><db:link xlink:href="qlist.xml#operator-2b-eq">operator+=</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="assign">
<db:title>[since 6.6] QList&lt;T&gt; &amp;QList::assign(std::initializer_list&lt;T&gt; <db:emphasis>l</db:emphasis>)</db:title>
<db:para>Replaces the contents of this list with a copy of the elements of <db:code role="parameter">l</db:code>.</db:para>
<db:para>The size of this list will be equal to the number of elements in <db:code role="parameter">l</db:code>.</db:para>
<db:para>This function only allocates memory if the number of elements in <db:code role="parameter">l</db:code> exceeds the capacity of this list or this list is shared.</db:para>
<db:para>This function was introduced in Qt 6.6.</db:para>
</db:section>
<db:section xml:id="assign-1">
<db:title>[since 6.6] QList&lt;T&gt; &amp;QList::assign(InputIterator <db:emphasis>first</db:emphasis>, InputIterator <db:emphasis>last</db:emphasis>)</db:title>
<db:para>Replaces the contents of this list with a copy of the elements in the iterator range [<db:code role="parameter">first</db:code>, <db:code role="parameter">last</db:code>).</db:para>
<db:para>The size of this list will be equal to the number of elements in the range [<db:code role="parameter">first</db:code>, <db:code role="parameter">last</db:code>).</db:para>
<db:para>This function will only allocate memory if the number of elements in the range exceeds the capacity of this list or this list is shared.</db:para>
<db:note>
<db:para>This function overload only participates in overload resolution if <db:code>InputIterator</db:code> meets the requirements of a <db:link xlink:href="https://en.cppreference.com/w/cpp/named_req/InputIterator">LegacyInputIterator</db:link>.</db:para>
</db:note>
<db:note>
<db:para>The behavior is undefined if either argument is an iterator into *this.</db:para>
</db:note>
<db:para>This function was introduced in Qt 6.6.</db:para>
</db:section>
<db:section xml:id="assign-2">
<db:title>[since 6.6] QList&lt;T&gt; &amp;QList::assign(qsizetype <db:emphasis>n</db:emphasis>, QList&lt;T&gt;::parameter_type <db:emphasis>t</db:emphasis>)</db:title>
<db:para>Replaces the contents of this list with <db:code role="parameter">n</db:code> copies of <db:code role="parameter">t</db:code>.</db:para>
<db:para>The size of this list will be equal to <db:code role="parameter">n</db:code>.</db:para>
<db:para>This function will only allocate memory if <db:code role="parameter">n</db:code> exceeds the capacity of the list or this list is shared.</db:para>
<db:para>This function was introduced in Qt 6.6.</db:para>
</db:section>
<db:section xml:id="at">
<db:title>[noexcept] QList&lt;T&gt;::const_reference QList::at(qsizetype <db:emphasis>i</db:emphasis>) const</db:title>
<db:para>Returns the item at index position <db:code role="parameter">i</db:code> in the list.</db:para>
<db:para><db:code role="parameter">i</db:code> must be a valid index position in the list (i.e., 0 &lt;= <db:code role="parameter">i</db:code> &lt; <db:link xlink:href="qlist.xml#size">size</db:link>()).</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qlist.xml#value">value</db:link>()</db:member>
<db:member><db:link xlink:href="qlist.xml#operator-5b-5d">operator[]</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="back">
<db:title>QList&lt;T&gt;::reference QList::back()</db:title>
<db:para>This function is provided for STL compatibility. It is equivalent to <db:link xlink:href="qlist.xml#last">last</db:link>().</db:para>
</db:section>
<db:section xml:id="back-1">
<db:title>[noexcept] QList&lt;T&gt;::const_reference QList::back() const</db:title>
<db:para>This is an overloaded function.</db:para>
</db:section>
<db:section xml:id="begin">
<db:title>QList&lt;T&gt;::iterator QList::begin()</db:title>
<db:para>Returns an <db:link xlink:href="containers.xml#stl-style-iterators">STL-style iterator</db:link> pointing to the first item in the list.</db:para>
<db:warning>
<db:para>The returned iterator is invalidated on detachment or when the <db:link xlink:href="qlist.xml">QList</db:link> is modified.</db:para>
</db:warning>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qlist.xml#constBegin">constBegin</db:link>()</db:member>
<db:member><db:link xlink:href="qlist.xml#end">end</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="begin-1">
<db:title>[noexcept] QList&lt;T&gt;::const_iterator QList::begin() const</db:title>
<db:para>This is an overloaded function.</db:para>
</db:section>
<db:section xml:id="capacity">
<db:title>qsizetype QList::capacity() const</db:title>
<db:para>Returns the maximum number of items that can be stored in the list without forcing a reallocation.</db:para>
<db:para>The sole purpose of this function is to provide a means of fine tuning <db:link xlink:href="qlist.xml">QList</db:link>'s memory usage. In general, you will rarely ever need to call this function. If you want to know how many items are in the list, call <db:link xlink:href="qlist.xml#size">size</db:link>().</db:para>
<db:note>
<db:para>a statically allocated list will report a capacity of 0, even if it's not empty.</db:para>
</db:note>
<db:warning>
<db:para>The free space position in the allocated memory block is undefined. In other words, you should not assume that the free memory is always located at the end of the list. You can call <db:link xlink:href="qlist.xml#reserve">reserve</db:link>() to ensure that there is enough space at the end.</db:para>
</db:warning>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qlist.xml#reserve">reserve</db:link>()</db:member>
<db:member><db:link xlink:href="qlist.xml#squeeze">squeeze</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="cbegin">
<db:title>[noexcept] QList&lt;T&gt;::const_iterator QList::cbegin() const</db:title>
<db:para>Returns a const <db:link xlink:href="containers.xml#stl-style-iterators">STL-style iterator</db:link> pointing to the first item in the list.</db:para>
<db:warning>
<db:para>The returned iterator is invalidated on detachment or when the <db:link xlink:href="qlist.xml">QList</db:link> is modified.</db:para>
</db:warning>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qlist.xml#begin">begin</db:link>()</db:member>
<db:member><db:link xlink:href="qlist.xml#cend">cend</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="cend">
<db:title>[noexcept] QList&lt;T&gt;::const_iterator QList::cend() const</db:title>
<db:para>Returns a const <db:link xlink:href="containers.xml#stl-style-iterators">STL-style iterator</db:link> pointing just after the last item in the list.</db:para>
<db:warning>
<db:para>The returned iterator is invalidated on detachment or when the <db:link xlink:href="qlist.xml">QList</db:link> is modified.</db:para>
</db:warning>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qlist.xml#cbegin">cbegin</db:link>()</db:member>
<db:member><db:link xlink:href="qlist.xml#end">end</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="clear">
<db:title>void QList::clear()</db:title>
<db:para>Removes all the elements from the list.</db:para>
<db:para>If this list is not shared, the <db:link xlink:href="qlist.xml#capacity">capacity</db:link>() is preserved. Use <db:link xlink:href="qlist.xml#squeeze">squeeze</db:link>() to shed excess capacity.</db:para>
<db:note>
<db:para>In Qt versions prior to 5.7 (for <db:link xlink:href="qvector.xml">QVector</db:link>) and 6.0 (for <db:link xlink:href="qlist.xml">QList</db:link>), this function released the memory used by the list instead of preserving the capacity.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qlist.xml#resize">resize</db:link>()</db:member>
<db:member><db:link xlink:href="qlist.xml#squeeze">squeeze</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="constBegin">
<db:title>[noexcept] QList&lt;T&gt;::const_iterator QList::constBegin() const</db:title>
<db:para>Returns a const <db:link xlink:href="containers.xml#stl-style-iterators">STL-style iterator</db:link> pointing to the first item in the list.</db:para>
<db:warning>
<db:para>The returned iterator is invalidated on detachment or when the <db:link xlink:href="qlist.xml">QList</db:link> is modified.</db:para>
</db:warning>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qlist.xml#begin">begin</db:link>()</db:member>
<db:member><db:link xlink:href="qlist.xml#constEnd">constEnd</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="constData">
<db:title>[noexcept] QList&lt;T&gt;::const_pointer QList::constData() const</db:title>
<db:para>Returns a const pointer to the data stored in the list. The pointer can be used to access the items in the list.</db:para>
<db:warning>
<db:para>The pointer is invalidated on detachment or when the <db:link xlink:href="qlist.xml">QList</db:link> is modified.</db:para>
</db:warning>
<db:para>This function is mostly useful to pass a list to a function that accepts a plain C++ array.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qlist.xml#data">data</db:link>()</db:member>
<db:member><db:link xlink:href="qlist.xml#operator-5b-5d">operator[]</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="constEnd">
<db:title>[noexcept] QList&lt;T&gt;::const_iterator QList::constEnd() const</db:title>
<db:para>Returns a const <db:link xlink:href="containers.xml#stl-style-iterators">STL-style iterator</db:link> pointing just after the last item in the list.</db:para>
<db:warning>
<db:para>The returned iterator is invalidated on detachment or when the <db:link xlink:href="qlist.xml">QList</db:link> is modified.</db:para>
</db:warning>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qlist.xml#constBegin">constBegin</db:link>()</db:member>
<db:member><db:link xlink:href="qlist.xml#end">end</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="constFirst">
<db:title>[noexcept] const T &amp;QList::constFirst() const</db:title>
<db:para>Returns a const reference to the first item in the list. This function assumes that the list isn't empty.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qlist.xml#constLast">constLast</db:link>()</db:member>
<db:member><db:link xlink:href="qlist.xml#isEmpty">isEmpty</db:link>()</db:member>
<db:member><db:link xlink:href="qlist.xml#first">first</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="constLast">
<db:title>[noexcept] const T &amp;QList::constLast() const</db:title>
<db:para>Returns a const reference to the last item in the list. This function assumes that the list isn't empty.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qlist.xml#constFirst">constFirst</db:link>()</db:member>
<db:member><db:link xlink:href="qlist.xml#isEmpty">isEmpty</db:link>()</db:member>
<db:member><db:link xlink:href="qlist.xml#last">last</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="contains">
<db:title>[noexcept] bool QList::contains(const AT &amp;<db:emphasis>value</db:emphasis>) const</db:title>
<db:para>Returns <db:code>true</db:code> if the list contains an occurrence of <db:code role="parameter">value</db:code>; otherwise returns <db:code>false</db:code>.</db:para>
<db:para>This function requires the value type to have an implementation of <db:code>operator==()</db:code>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qlist.xml#indexOf">indexOf</db:link>()</db:member>
<db:member><db:link xlink:href="qlist.xml#count-1">count</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="count">
<db:title>[noexcept] qsizetype QList::count(const AT &amp;<db:emphasis>value</db:emphasis>) const</db:title>
<db:para>Returns the number of occurrences of <db:code role="parameter">value</db:code> in the list.</db:para>
<db:para>This function requires the value type to have an implementation of <db:code>operator==()</db:code>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qlist.xml#contains">contains</db:link>()</db:member>
<db:member><db:link xlink:href="qlist.xml#indexOf">indexOf</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="count-1">
<db:title>[noexcept] qsizetype QList::count() const</db:title>
<db:para>This is an overloaded function.</db:para>
<db:para>Same as <db:link xlink:href="qlist.xml#size">size</db:link>().</db:para>
</db:section>
<db:section xml:id="crbegin">
<db:title>[noexcept] QList&lt;T&gt;::const_reverse_iterator QList::crbegin() const</db:title>
<db:para>Returns a const <db:link xlink:href="containers.xml#stl-style-iterators">STL-style</db:link> reverse iterator pointing to the first item in the list, in reverse order.</db:para>
<db:warning>
<db:para>The returned iterator is invalidated on detachment or when the <db:link xlink:href="qlist.xml">QList</db:link> is modified.</db:para>
</db:warning>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qlist.xml#begin">begin</db:link>()</db:member>
<db:member><db:link xlink:href="qlist.xml#rbegin">rbegin</db:link>()</db:member>
<db:member><db:link xlink:href="qlist.xml#rend">rend</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="crend">
<db:title>[noexcept] QList&lt;T&gt;::const_reverse_iterator QList::crend() const</db:title>
<db:para>Returns a const <db:link xlink:href="containers.xml#stl-style-iterators">STL-style</db:link> reverse iterator pointing just after the last item in the list, in reverse order.</db:para>
<db:warning>
<db:para>The returned iterator is invalidated on detachment or when the <db:link xlink:href="qlist.xml">QList</db:link> is modified.</db:para>
</db:warning>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qlist.xml#end">end</db:link>()</db:member>
<db:member><db:link xlink:href="qlist.xml#rend">rend</db:link>()</db:member>
<db:member><db:link xlink:href="qlist.xml#rbegin">rbegin</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="data">
<db:title>QList&lt;T&gt;::pointer QList::data()</db:title>
<db:para>Returns a pointer to the data stored in the list. The pointer can be used to access and modify the items in the list.</db:para>
<db:para>Example:</db:para>
<db:programlisting language="cpp">QList&lt;int&gt; list(10);
int *data = list.data();
for (qsizetype i = 0; i &lt; 10; ++i)
    data[i] = 2 * i;
</db:programlisting>
<db:warning>
<db:para>The pointer is invalidated on detachment or when the <db:link xlink:href="qlist.xml">QList</db:link> is modified.</db:para>
</db:warning>
<db:para>This function is mostly useful to pass a list to a function that accepts a plain C++ array.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qlist.xml#constData">constData</db:link>()</db:member>
<db:member><db:link xlink:href="qlist.xml#operator-5b-5d">operator[]</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="data-1">
<db:title>[noexcept] QList&lt;T&gt;::const_pointer QList::data() const</db:title>
<db:para>This is an overloaded function.</db:para>
</db:section>
<db:section xml:id="emplace">
<db:title>QList&lt;T&gt;::iterator QList::emplace(qsizetype <db:emphasis>i</db:emphasis>, Args &amp;&amp;... <db:emphasis>args</db:emphasis>)</db:title>
<db:para>Extends the container by inserting a new element at position <db:code role="parameter">i</db:code>. This new element is constructed in-place using <db:code role="parameter">args</db:code> as the arguments for its construction.</db:para>
<db:para>Returns an iterator to the new element.</db:para>
<db:para>Example:</db:para>
<db:programlisting language="cpp">QList&lt;QString&gt; list{&quot;a&quot;, &quot;ccc&quot;};
list.emplace(1, 2, 'b');
// list: [&quot;a&quot;, &quot;bb&quot;, &quot;ccc&quot;]
</db:programlisting>
<db:note>
<db:para>It is guaranteed that the element will be created in place at the beginning, but after that it might be copied or moved to the right position.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qlist.xml#emplaceBack">emplaceBack</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="emplace-1">
<db:title>QList&lt;T&gt;::iterator QList::emplace(QList&lt;T&gt;::const_iterator <db:emphasis>before</db:emphasis>, Args &amp;&amp;... <db:emphasis>args</db:emphasis>)</db:title>
<db:para>This is an overloaded function.</db:para>
<db:para>Creates a new element in front of the item pointed to by the iterator <db:code role="parameter">before</db:code>. This new element is constructed in-place using <db:code role="parameter">args</db:code> as the arguments for its construction.</db:para>
<db:para>Returns an iterator to the new element.</db:para>
</db:section>
<db:section xml:id="empty">
<db:title>[noexcept] bool QList::empty() const</db:title>
<db:para>This function is provided for STL compatibility. It is equivalent to <db:link xlink:href="qlist.xml#isEmpty">isEmpty</db:link>(), returning <db:code>true</db:code> if the list is empty; otherwise returns <db:code>false</db:code>.</db:para>
</db:section>
<db:section xml:id="end">
<db:title>QList&lt;T&gt;::iterator QList::end()</db:title>
<db:para>Returns an <db:link xlink:href="containers.xml#stl-style-iterators">STL-style iterator</db:link> pointing just after the last item in the list.</db:para>
<db:warning>
<db:para>The returned iterator is invalidated on detachment or when the <db:link xlink:href="qlist.xml">QList</db:link> is modified.</db:para>
</db:warning>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qlist.xml#begin">begin</db:link>()</db:member>
<db:member><db:link xlink:href="qlist.xml#constEnd">constEnd</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="end-1">
<db:title>[noexcept] QList&lt;T&gt;::const_iterator QList::end() const</db:title>
<db:para>This is an overloaded function.</db:para>
</db:section>
<db:section xml:id="endsWith">
<db:title>bool QList::endsWith(QList&lt;T&gt;::parameter_type <db:emphasis>value</db:emphasis>) const</db:title>
<db:para>Returns <db:code>true</db:code> if this list is not empty and its last item is equal to <db:code role="parameter">value</db:code>; otherwise returns <db:code>false</db:code>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qlist.xml#isEmpty">isEmpty</db:link>()</db:member>
<db:member><db:link xlink:href="qlist.xml#last">last</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="erase">
<db:title>QList&lt;T&gt;::iterator QList::erase(QList&lt;T&gt;::const_iterator <db:emphasis>pos</db:emphasis>)</db:title>
<db:para>Removes the item pointed to by the iterator <db:code role="parameter">pos</db:code> from the list, and returns an iterator to the next item in the list (which may be <db:link xlink:href="qlist.xml#end">end</db:link>()).</db:para>
<db:para>Element removal will preserve the list's capacity and not reduce the amount of allocated memory. To shed extra capacity and free as much memory as possible, call <db:link xlink:href="qlist.xml#squeeze">squeeze</db:link>().</db:para>
<db:note>
<db:para>When <db:link xlink:href="qlist.xml">QList</db:link> is not <db:link xlink:href="implicit-sharing.xml">implicitly shared</db:link>, this function only invalidates iterators at or after the specified position.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qlist.xml#insert">insert</db:link>()</db:member>
<db:member><db:link xlink:href="qlist.xml#remove">remove</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="erase-2">
<db:title>QList&lt;T&gt;::iterator QList::erase(QList&lt;T&gt;::const_iterator <db:emphasis>begin</db:emphasis>, QList&lt;T&gt;::const_iterator <db:emphasis>end</db:emphasis>)</db:title>
<db:para>This is an overloaded function.</db:para>
<db:para>Removes all the items from <db:code role="parameter">begin</db:code> up to (but not including) <db:code role="parameter">end</db:code>. Returns an iterator to the same item that <db:code role="parameter">end</db:code> referred to before the call.</db:para>
<db:para>Element removal will preserve the list's capacity and not reduce the amount of allocated memory. To shed extra capacity and free as much memory as possible, call <db:link xlink:href="qlist.xml#squeeze">squeeze</db:link>().</db:para>
<db:note>
<db:para>When <db:link xlink:href="qlist.xml">QList</db:link> is not <db:link xlink:href="implicit-sharing.xml">implicitly shared</db:link>, this function only invalidates iterators at or after the specified position.</db:para>
</db:note>
</db:section>
<db:section xml:id="fill">
<db:title>QList&lt;T&gt; &amp;QList::fill(QList&lt;T&gt;::parameter_type <db:emphasis>value</db:emphasis>, qsizetype <db:emphasis>size</db:emphasis> = -1)</db:title>
<db:para>Assigns <db:code role="parameter">value</db:code> to all items in the list. If <db:code role="parameter">size</db:code> is different from -1 (the default), the list is resized to <db:code role="parameter">size</db:code> beforehand.</db:para>
<db:para>Example:</db:para>
<db:programlisting language="cpp">QList&lt;QString&gt; list(3);
list.fill(&quot;Yes&quot;);
// list: [&quot;Yes&quot;, &quot;Yes&quot;, &quot;Yes&quot;]

list.fill(&quot;oh&quot;, 5);
// list: [&quot;oh&quot;, &quot;oh&quot;, &quot;oh&quot;, &quot;oh&quot;, &quot;oh&quot;]
</db:programlisting>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qlist.xml#resize">resize</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="first">
<db:title>T &amp;QList::first()</db:title>
<db:para>Returns a reference to the first item in the list. This function assumes that the list isn't empty.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qlist.xml#last">last</db:link>()</db:member>
<db:member><db:link xlink:href="qlist.xml#isEmpty">isEmpty</db:link>()</db:member>
<db:member><db:link xlink:href="qlist.xml#constFirst">constFirst</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="first-1">
<db:title>[since 6.0] QList&lt;T&gt; QList::first(qsizetype <db:emphasis>n</db:emphasis>) const</db:title>
<db:para>Returns a sub-list that contains the first <db:code role="parameter">n</db:code> elements of this list.</db:para>
<db:note>
<db:para>The behavior is undefined when <db:code role="parameter">n</db:code> &lt; 0 or <db:code role="parameter">n</db:code> &gt; <db:link xlink:href="qlist.xml#size">size</db:link>().</db:para>
</db:note>
<db:para>This function was introduced in Qt 6.0.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qlist.xml#last">last</db:link>()</db:member>
<db:member><db:link xlink:href="qlist.xml#sliced">sliced</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="first-2">
<db:title>[noexcept] const T &amp;QList::first() const</db:title>
<db:para>This is an overloaded function.</db:para>
</db:section>
<db:section xml:id="front">
<db:title>QList&lt;T&gt;::reference QList::front()</db:title>
<db:para>This function is provided for STL compatibility. It is equivalent to <db:link xlink:href="qlist.xml#first">first</db:link>().</db:para>
</db:section>
<db:section xml:id="front-1">
<db:title>[noexcept] QList&lt;T&gt;::const_reference QList::front() const</db:title>
<db:para>This is an overloaded function.</db:para>
</db:section>
<db:section xml:id="indexOf">
<db:title>[noexcept] qsizetype QList::indexOf(const AT &amp;<db:emphasis>value</db:emphasis>, qsizetype <db:emphasis>from</db:emphasis> = 0) const</db:title>
<db:para>Returns the index position of the first occurrence of <db:code role="parameter">value</db:code> in the list, searching forward from index position <db:code role="parameter">from</db:code>. Returns -1 if no item matched.</db:para>
<db:para>Example:</db:para>
<db:programlisting language="cpp">QList&lt;QString&gt; list{&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;B&quot;, &quot;A&quot;};
list.indexOf(&quot;B&quot;);            // returns 1
list.indexOf(&quot;B&quot;, 1);         // returns 1
list.indexOf(&quot;B&quot;, 2);         // returns 3
list.indexOf(&quot;X&quot;);            // returns -1
</db:programlisting>
<db:para>This function requires the value type to have an implementation of <db:code>operator==()</db:code>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qlist.xml#lastIndexOf">lastIndexOf</db:link>()</db:member>
<db:member><db:link xlink:href="qlist.xml#contains">contains</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="insert-2">
<db:title>QList&lt;T&gt;::iterator QList::insert(QList&lt;T&gt;::const_iterator <db:emphasis>before</db:emphasis>, qsizetype <db:emphasis>count</db:emphasis>, QList&lt;T&gt;::parameter_type <db:emphasis>value</db:emphasis>)</db:title>
<db:para>Inserts <db:code role="parameter">count</db:code> copies of <db:code role="parameter">value</db:code> in front of the item pointed to by the iterator <db:code role="parameter">before</db:code>. Returns an iterator pointing at the first of the inserted items.</db:para>
</db:section>
<db:section xml:id="insert-5">
<db:title>QList&lt;T&gt;::iterator QList::insert(qsizetype <db:emphasis>i</db:emphasis>, qsizetype <db:emphasis>count</db:emphasis>, QList&lt;T&gt;::parameter_type <db:emphasis>value</db:emphasis>)</db:title>
<db:para>This is an overloaded function.</db:para>
<db:para>Inserts <db:code role="parameter">count</db:code> copies of <db:code role="parameter">value</db:code> at index position <db:code role="parameter">i</db:code> in the list.</db:para>
<db:para>Example:</db:para>
<db:programlisting language="cpp">QList&lt;double&gt; list = {2.718, 1.442, 0.4342};
list.insert(1, 3, 9.9);
// list: [2.718, 9.9, 9.9, 9.9, 1.442, 0.4342]
</db:programlisting>
</db:section>
<db:section xml:id="isEmpty">
<db:title>[noexcept] bool QList::isEmpty() const</db:title>
<db:para>Returns <db:code>true</db:code> if the list has size 0; otherwise returns <db:code>false</db:code>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qlist.xml#size">size</db:link>()</db:member>
<db:member><db:link xlink:href="qlist.xml#resize">resize</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="last">
<db:title>T &amp;QList::last()</db:title>
<db:para>Returns a reference to the last item in the list. This function assumes that the list isn't empty.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qlist.xml#first">first</db:link>()</db:member>
<db:member><db:link xlink:href="qlist.xml#isEmpty">isEmpty</db:link>()</db:member>
<db:member><db:link xlink:href="qlist.xml#constLast">constLast</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="last-1">
<db:title>[since 6.0] QList&lt;T&gt; QList::last(qsizetype <db:emphasis>n</db:emphasis>) const</db:title>
<db:para>Returns a sub-list that contains the last <db:code role="parameter">n</db:code> elements of this list.</db:para>
<db:note>
<db:para>The behavior is undefined when <db:code role="parameter">n</db:code> &lt; 0 or <db:code role="parameter">n</db:code> &gt; <db:link xlink:href="qlist.xml#size">size</db:link>().</db:para>
</db:note>
<db:para>This function was introduced in Qt 6.0.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qlist.xml#first">first</db:link>()</db:member>
<db:member><db:link xlink:href="qlist.xml#sliced">sliced</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="last-2">
<db:title>[noexcept] const T &amp;QList::last() const</db:title>
<db:para>This is an overloaded function.</db:para>
</db:section>
<db:section xml:id="lastIndexOf">
<db:title>[noexcept] qsizetype QList::lastIndexOf(const AT &amp;<db:emphasis>value</db:emphasis>, qsizetype <db:emphasis>from</db:emphasis> = -1) const</db:title>
<db:para>Returns the index position of the last occurrence of the value <db:code role="parameter">value</db:code> in the list, searching backward from index position <db:code role="parameter">from</db:code>. If <db:code role="parameter">from</db:code> is -1 (the default), the search starts at the last item. Returns -1 if no item matched.</db:para>
<db:para>Example:</db:para>
<db:programlisting language="cpp">QList&lt;QString&gt; list = {&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;B&quot;, &quot;A&quot;};
list.lastIndexOf(&quot;B&quot;);        // returns 3
list.lastIndexOf(&quot;B&quot;, 3);     // returns 3
list.lastIndexOf(&quot;B&quot;, 2);     // returns 1
list.lastIndexOf(&quot;X&quot;);        // returns -1
</db:programlisting>
<db:para>This function requires the value type to have an implementation of <db:code>operator==()</db:code>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qlist.xml#indexOf">indexOf</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="length">
<db:title>[noexcept] qsizetype QList::length() const</db:title>
<db:para>Same as <db:link xlink:href="qlist.xml#size">size</db:link>() and <db:link xlink:href="qlist.xml#count-1">count</db:link>().</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qlist.xml#size">size</db:link>()</db:member>
<db:member><db:link xlink:href="qlist.xml#count-1">count</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="mid">
<db:title>QList&lt;T&gt; QList::mid(qsizetype <db:emphasis>pos</db:emphasis>, qsizetype <db:emphasis>length</db:emphasis> = -1) const</db:title>
<db:para>Returns a sub-list which contains elements from this list, starting at position <db:code role="parameter">pos</db:code>. If <db:code role="parameter">length</db:code> is -1 (the default), all elements after <db:code role="parameter">pos</db:code> are included; otherwise <db:code role="parameter">length</db:code> elements (or all remaining elements if there are less than <db:code role="parameter">length</db:code> elements) are included.</db:para>
</db:section>
<db:section xml:id="move">
<db:title>void QList::move(qsizetype <db:emphasis>from</db:emphasis>, qsizetype <db:emphasis>to</db:emphasis>)</db:title>
<db:para>Moves the item at index position <db:code role="parameter">from</db:code> to index position <db:code role="parameter">to</db:code>.</db:para>
</db:section>
<db:section xml:id="pop_back">
<db:title>[noexcept] void QList::pop_back()</db:title>
<db:para>This function is provided for STL compatibility. It is equivalent to <db:link xlink:href="qlist.xml#removeLast">removeLast</db:link>().</db:para>
</db:section>
<db:section xml:id="pop_front">
<db:title>[noexcept] void QList::pop_front()</db:title>
<db:para>This function is provided for STL compatibility. It is equivalent to <db:link xlink:href="qlist.xml#removeFirst">removeFirst</db:link>().</db:para>
</db:section>
<db:section xml:id="push_back">
<db:title>void QList::push_back(QList&lt;T&gt;::parameter_type <db:emphasis>value</db:emphasis>)</db:title>
<db:para>This function is provided for STL compatibility. It is equivalent to append(<db:code role="parameter">value</db:code>).</db:para>
</db:section>
<db:section xml:id="push_back-1">
<db:title>void QList::push_back(QList&lt;T&gt;::rvalue_ref <db:emphasis>value</db:emphasis>)</db:title>
<db:para>This is an overloaded function.</db:para>
</db:section>
<db:section xml:id="rbegin">
<db:title>QList&lt;T&gt;::reverse_iterator QList::rbegin()</db:title>
<db:para>Returns a <db:link xlink:href="containers.xml#stl-style-iterators">STL-style</db:link> reverse iterator pointing to the first item in the list, in reverse order.</db:para>
<db:warning>
<db:para>The returned iterator is invalidated on detachment or when the <db:link xlink:href="qlist.xml">QList</db:link> is modified.</db:para>
</db:warning>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qlist.xml#begin">begin</db:link>()</db:member>
<db:member><db:link xlink:href="qlist.xml#crbegin">crbegin</db:link>()</db:member>
<db:member><db:link xlink:href="qlist.xml#rend">rend</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="rbegin-1">
<db:title>[noexcept] QList&lt;T&gt;::const_reverse_iterator QList::rbegin() const</db:title>
<db:para>This is an overloaded function.</db:para>
</db:section>
<db:section xml:id="remove">
<db:title>void QList::remove(qsizetype <db:emphasis>i</db:emphasis>, qsizetype <db:emphasis>n</db:emphasis> = 1)</db:title>
<db:para>Removes <db:code role="parameter">n</db:code> elements from the list, starting at index position <db:code role="parameter">i</db:code>.</db:para>
<db:para>Element removal will preserve the list's capacity and not reduce the amount of allocated memory. To shed extra capacity and free as much memory as possible, call <db:link xlink:href="qlist.xml#squeeze">squeeze</db:link>().</db:para>
<db:note>
<db:para>When <db:link xlink:href="qlist.xml">QList</db:link> is not <db:link xlink:href="implicit-sharing.xml">implicitly shared</db:link>, this function only invalidates iterators at or after the specified position.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qlist.xml#insert">insert</db:link>()</db:member>
<db:member><db:link xlink:href="qlist.xml#replace">replace</db:link>()</db:member>
<db:member><db:link xlink:href="qlist.xml#fill">fill</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="removeAll">
<db:title>qsizetype QList::removeAll(const AT &amp;<db:emphasis>t</db:emphasis>)</db:title>
<db:para>Removes all elements that compare equal to <db:code role="parameter">t</db:code> from the list. Returns the number of elements removed, if any.</db:para>
<db:para>Element removal will preserve the list's capacity and not reduce the amount of allocated memory. To shed extra capacity and free as much memory as possible, call <db:link xlink:href="qlist.xml#squeeze">squeeze</db:link>().</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qlist.xml#removeOne">removeOne</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="removeAt">
<db:title>void QList::removeAt(qsizetype <db:emphasis>i</db:emphasis>)</db:title>
<db:para>Removes the element at index position <db:code role="parameter">i</db:code>. Equivalent to</db:para>
<db:programlisting language="cpp">remove(i);
</db:programlisting>
<db:para>Element removal will preserve the list's capacity and not reduce the amount of allocated memory. To shed extra capacity and free as much memory as possible, call <db:link xlink:href="qlist.xml#squeeze">squeeze</db:link>().</db:para>
<db:note>
<db:para>When <db:link xlink:href="qlist.xml">QList</db:link> is not <db:link xlink:href="implicit-sharing.xml">implicitly shared</db:link>, this function only invalidates iterators at or after the specified position.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qlist.xml#remove">remove</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="removeFirst">
<db:title>[noexcept] void QList::removeFirst()</db:title>
<db:para>Removes the first item in the list. Calling this function is equivalent to calling remove(0). The list must not be empty. If the list can be empty, call <db:link xlink:href="qlist.xml#isEmpty">isEmpty</db:link>() before calling this function.</db:para>
<db:para>Element removal will preserve the list's capacity and not reduce the amount of allocated memory. To shed extra capacity and free as much memory as possible, call <db:link xlink:href="qlist.xml#squeeze">squeeze</db:link>().</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qlist.xml#remove">remove</db:link>()</db:member>
<db:member><db:link xlink:href="qlist.xml#takeFirst">takeFirst</db:link>()</db:member>
<db:member><db:link xlink:href="qlist.xml#isEmpty">isEmpty</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="removeIf">
<db:title>[since 6.1] qsizetype QList::removeIf(Predicate <db:emphasis>pred</db:emphasis>)</db:title>
<db:para>Removes all elements for which the predicate <db:code role="parameter">pred</db:code> returns true from the list. Returns the number of elements removed, if any.</db:para>
<db:para>This function was introduced in Qt 6.1.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qlist.xml#removeAll">removeAll</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="removeLast">
<db:title>[noexcept] void QList::removeLast()</db:title>
<db:para>Removes the last item in the list. Calling this function is equivalent to calling remove(<db:link xlink:href="qlist.xml#size">size</db:link>() - 1). The list must not be empty. If the list can be empty, call <db:link xlink:href="qlist.xml#isEmpty">isEmpty</db:link>() before calling this function.</db:para>
<db:para>Element removal will preserve the list's capacity and not reduce the amount of allocated memory. To shed extra capacity and free as much memory as possible, call <db:link xlink:href="qlist.xml#squeeze">squeeze</db:link>().</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qlist.xml#remove">remove</db:link>()</db:member>
<db:member><db:link xlink:href="qlist.xml#takeLast">takeLast</db:link>()</db:member>
<db:member><db:link xlink:href="qlist.xml#removeFirst">removeFirst</db:link>()</db:member>
<db:member><db:link xlink:href="qlist.xml#isEmpty">isEmpty</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="removeOne">
<db:title>bool QList::removeOne(const AT &amp;<db:emphasis>t</db:emphasis>)</db:title>
<db:para>Removes the first element that compares equal to <db:code role="parameter">t</db:code> from the list. Returns whether an element was, in fact, removed.</db:para>
<db:para>Element removal will preserve the list's capacity and not reduce the amount of allocated memory. To shed extra capacity and free as much memory as possible, call <db:link xlink:href="qlist.xml#squeeze">squeeze</db:link>().</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qlist.xml#removeAll">removeAll</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="rend">
<db:title>QList&lt;T&gt;::reverse_iterator QList::rend()</db:title>
<db:para>Returns a <db:link xlink:href="containers.xml#stl-style-iterators">STL-style</db:link> reverse iterator pointing just after the last item in the list, in reverse order.</db:para>
<db:warning>
<db:para>The returned iterator is invalidated on detachment or when the <db:link xlink:href="qlist.xml">QList</db:link> is modified.</db:para>
</db:warning>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qlist.xml#end">end</db:link>()</db:member>
<db:member><db:link xlink:href="qlist.xml#crend">crend</db:link>()</db:member>
<db:member><db:link xlink:href="qlist.xml#rbegin">rbegin</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="rend-1">
<db:title>[noexcept] QList&lt;T&gt;::const_reverse_iterator QList::rend() const</db:title>
<db:para>This is an overloaded function.</db:para>
</db:section>
<db:section xml:id="reserve">
<db:title>void QList::reserve(qsizetype <db:emphasis>size</db:emphasis>)</db:title>
<db:para>Attempts to allocate memory for at least <db:code role="parameter">size</db:code> elements.</db:para>
<db:para>If you know in advance how large the list will be, you should call this function to prevent reallocations and memory fragmentation. If you resize the list often, you are also likely to get better performance.</db:para>
<db:para>If in doubt about how much space shall be needed, it is usually better to use an upper bound as <db:code role="parameter">size</db:code>, or a high estimate of the most likely size, if a strict upper bound would be much bigger than this. If <db:code role="parameter">size</db:code> is an underestimate, the list will grow as needed once the reserved size is exceeded, which may lead to a larger allocation than your best overestimate would have and will slow the operation that triggers it.</db:para>
<db:warning>
<db:para>reserve() reserves memory but does not change the size of the list. Accessing data beyond the current end of the list is undefined behavior. If you need to access memory beyond the current end of the list, use <db:link xlink:href="qlist.xml#resize">resize</db:link>().</db:para>
</db:warning>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qlist.xml#squeeze">squeeze</db:link>()</db:member>
<db:member><db:link xlink:href="qlist.xml#capacity">capacity</db:link>()</db:member>
<db:member><db:link xlink:href="qlist.xml#resize">resize</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="resizeForOverwrite">
<db:title>[since 6.8] void QList::resizeForOverwrite(qsizetype <db:emphasis>size</db:emphasis>)</db:title>
<db:para>Sets the size of the list to <db:code role="parameter">size</db:code>. If <db:code role="parameter">size</db:code> is less than the current size, elements are removed from the end. If <db:code role="parameter">size</db:code> is greater than the current size, elements are added to the end; <db:link xlink:href="qlist.xml">QList</db:link> will make an attempt at <db:emphasis role="bold">not initializing</db:emphasis> these new elements.</db:para>
<db:para>Specifically:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para>if <db:code>T</db:code> has a constructor that accepts <db:code>Qt::Uninitialized</db:code>, that constructor will be used to initialize the elements;</db:para>
</db:listitem>
<db:listitem>
<db:para>otherwise, each element is default constructed. For trivially constructible types (such as <db:code>int</db:code>, <db:code>float</db:code>, etc.) this is equivalent to not initializing them.</db:para>
</db:listitem>
</db:itemizedlist>
<db:para>This function was introduced in Qt 6.8.</db:para>
</db:section>
<db:section xml:id="shrink_to_fit">
<db:title>void QList::shrink_to_fit()</db:title>
<db:para>This function is provided for STL compatibility. It is equivalent to <db:link xlink:href="qlist.xml#squeeze">squeeze</db:link>().</db:para>
</db:section>
<db:section xml:id="size">
<db:title>[noexcept] qsizetype QList::size() const</db:title>
<db:para>Returns the number of items in the list.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qlist.xml#isEmpty">isEmpty</db:link>()</db:member>
<db:member><db:link xlink:href="qlist.xml#resize">resize</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="sliced">
<db:title>[since 6.0] QList&lt;T&gt; QList::sliced(qsizetype <db:emphasis>pos</db:emphasis>, qsizetype <db:emphasis>n</db:emphasis>) const</db:title>
<db:para>Returns a sub-list that contains <db:code role="parameter">n</db:code> elements of this list, starting at position <db:code role="parameter">pos</db:code>.</db:para>
<db:note>
<db:para>The behavior is undefined when <db:code role="parameter">pos</db:code> &lt; 0, <db:code role="parameter">n</db:code> &lt; 0, or <db:code role="parameter">pos</db:code> + <db:code role="parameter">n</db:code> &gt; <db:link xlink:href="qlist.xml#size">size</db:link>().</db:para>
</db:note>
<db:para>This function was introduced in Qt 6.0.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qlist.xml#first">first</db:link>()</db:member>
<db:member><db:link xlink:href="qlist.xml#last">last</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="sliced-1">
<db:title>[since 6.0] QList&lt;T&gt; QList::sliced(qsizetype <db:emphasis>pos</db:emphasis>) const</db:title>
<db:para>This is an overloaded function.</db:para>
<db:para>Returns a sub-list that contains the elements of this list starting at position <db:code role="parameter">pos</db:code> and extending to its end.</db:para>
<db:note>
<db:para>The behavior is undefined when <db:code role="parameter">pos</db:code> &lt; 0 or <db:code role="parameter">pos</db:code> &gt; <db:link xlink:href="qlist.xml#size">size</db:link>().</db:para>
</db:note>
<db:para>This function was introduced in Qt 6.0.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qlist.xml#first">first</db:link>()</db:member>
<db:member><db:link xlink:href="qlist.xml#last">last</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="squeeze">
<db:title>void QList::squeeze()</db:title>
<db:para>Releases any memory not required to store the items.</db:para>
<db:para>The sole purpose of this function is to provide a means of fine tuning <db:link xlink:href="qlist.xml">QList</db:link>'s memory usage. In general, you will rarely ever need to call this function.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qlist.xml#reserve">reserve</db:link>()</db:member>
<db:member><db:link xlink:href="qlist.xml#capacity">capacity</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="startsWith">
<db:title>bool QList::startsWith(QList&lt;T&gt;::parameter_type <db:emphasis>value</db:emphasis>) const</db:title>
<db:para>Returns <db:code>true</db:code> if this list is not empty and its first item is equal to <db:code role="parameter">value</db:code>; otherwise returns <db:code>false</db:code>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qlist.xml#isEmpty">isEmpty</db:link>()</db:member>
<db:member><db:link xlink:href="qlist.xml#first">first</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="swap">
<db:title>[noexcept] void QList::swap(QList&lt;T&gt; &amp;<db:emphasis>other</db:emphasis>)</db:title>
<db:para>Swaps this list with <db:code role="parameter">other</db:code>. This operation is very fast and never fails.</db:para>
</db:section>
<db:section xml:id="swapItemsAt">
<db:title>void QList::swapItemsAt(qsizetype <db:emphasis>i</db:emphasis>, qsizetype <db:emphasis>j</db:emphasis>)</db:title>
<db:para>Exchange the item at index position <db:code role="parameter">i</db:code> with the item at index position <db:code role="parameter">j</db:code>. This function assumes that both <db:code role="parameter">i</db:code> and <db:code role="parameter">j</db:code> are at least 0 but less than <db:link xlink:href="qlist.xml#size">size</db:link>(). To avoid failure, test that both <db:code role="parameter">i</db:code> and <db:code role="parameter">j</db:code> are at least 0 and less than <db:link xlink:href="qlist.xml#size">size</db:link>().</db:para>
</db:section>
<db:section xml:id="takeAt">
<db:title>T QList::takeAt(qsizetype <db:emphasis>i</db:emphasis>)</db:title>
<db:para>Removes the element at index position <db:code role="parameter">i</db:code> and returns it.</db:para>
<db:para>Equivalent to</db:para>
<db:programlisting language="cpp">T t = at(i);
remove(i);
return t;
</db:programlisting>
<db:note>
<db:para>When <db:link xlink:href="qlist.xml">QList</db:link> is not <db:link xlink:href="implicit-sharing.xml">implicitly shared</db:link>, this function only invalidates iterators at or after the specified position.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qlist.xml#takeFirst">takeFirst</db:link>()</db:member>
<db:member><db:link xlink:href="qlist.xml#takeLast">takeLast</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="takeFirst">
<db:title>QList&lt;T&gt;::value_type QList::takeFirst()</db:title>
<db:para>Removes the first item in the list and returns it. This function assumes the list is not empty. To avoid failure, call <db:link xlink:href="qlist.xml#isEmpty">isEmpty</db:link>() before calling this function.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qlist.xml#takeLast">takeLast</db:link>()</db:member>
<db:member><db:link xlink:href="qlist.xml#removeFirst">removeFirst</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="takeLast">
<db:title>QList&lt;T&gt;::value_type QList::takeLast()</db:title>
<db:para>Removes the last item in the list and returns it. This function assumes the list is not empty. To avoid failure, call <db:link xlink:href="qlist.xml#isEmpty">isEmpty</db:link>() before calling this function.</db:para>
<db:para>If you don't use the return value, <db:link xlink:href="qlist.xml#removeLast">removeLast</db:link>() is more efficient.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qlist.xml#takeFirst">takeFirst</db:link>()</db:member>
<db:member><db:link xlink:href="qlist.xml#removeLast">removeLast</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="value">
<db:title>T QList::value(qsizetype <db:emphasis>i</db:emphasis>) const</db:title>
<db:para>Returns the value at index position <db:code role="parameter">i</db:code> in the list.</db:para>
<db:para>If the index <db:code role="parameter">i</db:code> is out of bounds, the function returns a <db:link xlink:href="containers.xml#default-constructed-value">default-constructed value</db:link>. If you are certain that <db:code role="parameter">i</db:code> is within bounds, you can use <db:link xlink:href="qlist.xml#at">at</db:link>() instead, which is slightly faster.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qlist.xml#at">at</db:link>()</db:member>
<db:member><db:link xlink:href="qlist.xml#operator-5b-5d">operator[]</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="value-1">
<db:title>T QList::value(qsizetype <db:emphasis>i</db:emphasis>, QList&lt;T&gt;::parameter_type <db:emphasis>defaultValue</db:emphasis>) const</db:title>
<db:para>This is an overloaded function.</db:para>
<db:para>If the index <db:code role="parameter">i</db:code> is out of bounds, the function returns <db:code role="parameter">defaultValue</db:code>.</db:para>
</db:section>
<db:section xml:id="operator-not-eq">
<db:title>bool QList::operator!=(const QList&lt;T&gt; &amp;<db:emphasis>other</db:emphasis>) const</db:title>
<db:para>Returns <db:code>true</db:code> if <db:code role="parameter">other</db:code> is not equal to this list; otherwise returns <db:code>false</db:code>.</db:para>
<db:para>Two lists are considered equal if they contain the same values in the same order.</db:para>
<db:para>This function requires the value type to have an implementation of <db:code>operator==()</db:code>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qlist.xml#operator-eq-eq">operator==</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="operator-2b-eq">
<db:title>QList&lt;T&gt; &amp;QList::operator+=(const QList&lt;T&gt; &amp;<db:emphasis>other</db:emphasis>)</db:title>
<db:para>Appends the items of the <db:code role="parameter">other</db:code> list to this list and returns a reference to this list.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qlist.xml#operator-2b">operator+</db:link>()</db:member>
<db:member><db:link xlink:href="qlist.xml#append">append</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="operator-2b-eq-1">
<db:title>[since 6.0] QList&lt;T&gt; &amp;QList::operator+=(QList&lt;T&gt; &amp;&amp;<db:emphasis>other</db:emphasis>)</db:title>
<db:para>This is an overloaded function.</db:para>
<db:para>This function was introduced in Qt 6.0.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qlist.xml#operator-2b">operator+</db:link>()</db:member>
<db:member><db:link xlink:href="qlist.xml#append">append</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="operator-2b-eq-2">
<db:title>QList&lt;T&gt; &amp;QList::operator+=(QList&lt;T&gt;::parameter_type <db:emphasis>value</db:emphasis>)</db:title>
<db:para>This is an overloaded function.</db:para>
<db:para>Appends <db:code role="parameter">value</db:code> to the list.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qlist.xml#append">append</db:link>()</db:member>
<db:member><db:link xlink:href="qlist.xml#operator-lt-lt">operator&lt;&lt;</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="operator-2b-eq-3">
<db:title>QList&lt;T&gt; &amp;QList::operator+=(QList&lt;T&gt;::rvalue_ref <db:emphasis>value</db:emphasis>)</db:title>
<db:para>This is an overloaded function.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qlist.xml#append">append</db:link>()</db:member>
<db:member><db:link xlink:href="qlist.xml#operator-lt-lt">operator&lt;&lt;</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="operator-lt">
<db:title>bool QList::operator&lt;(const QList&lt;T&gt; &amp;<db:emphasis>other</db:emphasis>) const</db:title>
<db:para>Returns <db:code>true</db:code> if this list is <db:link xlink:href="http://en.cppreference.com/w/cpp/algorithm/lexicographical_compare">lexically less than</db:link> <db:code role="parameter">other</db:code>; otherwise returns <db:code>false</db:code>.</db:para>
<db:para>This function requires the value type to have an implementation of <db:code>operator&lt;()</db:code>.</db:para>
</db:section>
<db:section xml:id="operator-lt-lt">
<db:title>QList&lt;T&gt; &amp;QList::operator&lt;&lt;(QList&lt;T&gt;::parameter_type <db:emphasis>value</db:emphasis>)</db:title>
<db:para>Appends <db:code role="parameter">value</db:code> to the list and returns a reference to this list.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qlist.xml#append">append</db:link>()</db:member>
<db:member><db:link xlink:href="qlist.xml#operator-2b-eq">operator+=</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="operator-lt-lt-1">
<db:title>QList&lt;T&gt; &amp;QList::operator&lt;&lt;(const QList&lt;T&gt; &amp;<db:emphasis>other</db:emphasis>)</db:title>
<db:para>Appends <db:code role="parameter">other</db:code> to the list and returns a reference to the list.</db:para>
</db:section>
<db:section xml:id="operator-lt-lt-2">
<db:title>[since 6.0] QList&lt;T&gt; &amp;QList::operator&lt;&lt;(QList&lt;T&gt; &amp;&amp;<db:emphasis>other</db:emphasis>)</db:title>
<db:para>This is an overloaded function.</db:para>
<db:para>This function was introduced in Qt 6.0.</db:para>
</db:section>
<db:section xml:id="operator-lt-lt-3">
<db:title>QList&lt;T&gt; &amp;QList::operator&lt;&lt;(QList&lt;T&gt;::rvalue_ref <db:emphasis>value</db:emphasis>)</db:title>
<db:para>This is an overloaded function.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qlist.xml#append">append</db:link>()</db:member>
<db:member><db:link xlink:href="qlist.xml#operator-2b-eq">operator+=</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="operator-lt-eq">
<db:title>bool QList::operator&lt;=(const QList&lt;T&gt; &amp;<db:emphasis>other</db:emphasis>) const</db:title>
<db:para>Returns <db:code>true</db:code> if this list is <db:link xlink:href="http://en.cppreference.com/w/cpp/algorithm/lexicographical_compare">lexically less than or equal to</db:link> <db:code role="parameter">other</db:code>; otherwise returns <db:code>false</db:code>.</db:para>
<db:para>This function requires the value type to have an implementation of <db:code>operator&lt;()</db:code>.</db:para>
</db:section>
<db:section xml:id="operator-eq">
<db:title>[default] QList&lt;T&gt; &amp;QList::operator=(QList&lt;T&gt; &amp;&amp;<db:emphasis>other</db:emphasis>)</db:title>
<db:para>Move-assigns <db:code role="parameter">other</db:code> to this <db:link xlink:href="qlist.xml">QList</db:link> instance.</db:para>
</db:section>
<db:section xml:id="operator-eq-1">
<db:title>[default] QList&lt;T&gt; &amp;QList::operator=(const QList&lt;T&gt; &amp;<db:emphasis>other</db:emphasis>)</db:title>
<db:para>Assigns <db:code role="parameter">other</db:code> to this list and returns a reference to this list.</db:para>
</db:section>
<db:section xml:id="operator-eq-2">
<db:title>QList&lt;T&gt; &amp;QList::operator=(std::initializer_list&lt;T&gt; <db:emphasis>args</db:emphasis>)</db:title>
<db:para>Assigns the collection of values in <db:code role="parameter">args</db:code> to this <db:link xlink:href="qlist.xml">QList</db:link> instance.</db:para>
</db:section>
<db:section xml:id="operator-eq-eq">
<db:title>bool QList::operator==(const QList&lt;T&gt; &amp;<db:emphasis>other</db:emphasis>) const</db:title>
<db:para>Returns <db:code>true</db:code> if <db:code role="parameter">other</db:code> is equal to this list; otherwise returns <db:code>false</db:code>.</db:para>
<db:para>Two lists are considered equal if they contain the same values in the same order.</db:para>
<db:para>This function requires the value type to have an implementation of <db:code>operator==()</db:code>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qlist.xml#operator-not-eq">operator!=</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="operator-gt">
<db:title>bool QList::operator&gt;(const QList&lt;T&gt; &amp;<db:emphasis>other</db:emphasis>) const</db:title>
<db:para>Returns <db:code>true</db:code> if this list is <db:link xlink:href="http://en.cppreference.com/w/cpp/algorithm/lexicographical_compare">lexically greater than</db:link> <db:code role="parameter">other</db:code>; otherwise returns <db:code>false</db:code>.</db:para>
<db:para>This function requires the value type to have an implementation of <db:code>operator&lt;()</db:code>.</db:para>
</db:section>
<db:section xml:id="operator-gt-eq">
<db:title>bool QList::operator&gt;=(const QList&lt;T&gt; &amp;<db:emphasis>other</db:emphasis>) const</db:title>
<db:para>Returns <db:code>true</db:code> if this list is <db:link xlink:href="http://en.cppreference.com/w/cpp/algorithm/lexicographical_compare">lexically greater than or equal to</db:link> <db:code role="parameter">other</db:code>; otherwise returns <db:code>false</db:code>.</db:para>
<db:para>This function requires the value type to have an implementation of <db:code>operator&lt;()</db:code>.</db:para>
</db:section>
<db:section xml:id="operator-5b-5d">
<db:title>QList&lt;T&gt;::reference QList::operator[](qsizetype <db:emphasis>i</db:emphasis>)</db:title>
<db:para>Returns the item at index position <db:code role="parameter">i</db:code> as a modifiable reference.</db:para>
<db:para><db:code role="parameter">i</db:code> must be a valid index position in the list (i.e., 0 &lt;= <db:code role="parameter">i</db:code> &lt; <db:link xlink:href="qlist.xml#size">size</db:link>()).</db:para>
<db:para>Note that using non-const operators can cause <db:link xlink:href="qlist.xml">QList</db:link> to do a deep copy.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qlist.xml#at">at</db:link>()</db:member>
<db:member><db:link xlink:href="qlist.xml#value">value</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="operator-5b-5d-1">
<db:title>[noexcept] QList&lt;T&gt;::const_reference QList::operator[](qsizetype <db:emphasis>i</db:emphasis>) const</db:title>
<db:para>This is an overloaded function.</db:para>
<db:para>Same as at(<db:code role="parameter">i</db:code>).</db:para>
</db:section>
</db:section>
<db:section xml:id="related-non-members">
<db:title>Related Non-Members</db:title>
<db:section xml:id="erase-1">
<db:title>[since 6.1] qsizetype erase(QList&lt;T&gt; &amp;<db:emphasis>list</db:emphasis>, const AT &amp;<db:emphasis>t</db:emphasis>)</db:title>
<db:para>Removes all elements that compare equal to <db:code role="parameter">t</db:code> from the list <db:code role="parameter">list</db:code>. Returns the number of elements removed, if any.</db:para>
<db:note>
<db:para>Unlike <db:link xlink:href="qlist.xml#removeAll">QList::removeAll</db:link>, <db:code role="parameter">t</db:code> is not allowed to be a reference to an element inside <db:code role="parameter">list</db:code>. If you cannot be sure that this is not the case, take a copy of <db:code role="parameter">t</db:code> and call this function with the copy.</db:para>
</db:note>
<db:para>This function was introduced in Qt 6.1.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qlist.xml#removeAll">QList::removeAll</db:link>()</db:member>
<db:member><db:link xlink:href="qlist.xml#erase_if-2">erase_if</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="erase_if-2">
<db:title>[since 6.1] qsizetype erase_if(QList&lt;T&gt; &amp;<db:emphasis>list</db:emphasis>, Predicate <db:emphasis>pred</db:emphasis>)</db:title>
<db:para>Removes all elements for which the predicate <db:code role="parameter">pred</db:code> returns true from the list <db:code role="parameter">list</db:code>. Returns the number of elements removed, if any.</db:para>
<db:para>This function was introduced in Qt 6.1.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qlist.xml#erase">erase</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="qHash-19">
<db:title>[noexcept(...)] size_t qHash(const QList&lt;T&gt; &amp;<db:emphasis>key</db:emphasis>, size_t <db:emphasis>seed</db:emphasis> = 0)</db:title>
<db:para>Returns the hash value for <db:code role="parameter">key</db:code>, using <db:code role="parameter">seed</db:code> to seed the calculation.</db:para>
<db:para>Type <db:code>T</db:code> must be supported by qHash().</db:para>
</db:section>
<db:section xml:id="operator-lt-lt-4">
<db:title>QDataStream &amp;operator&lt;&lt;(QDataStream &amp;<db:emphasis>out</db:emphasis>, const QList&lt;T&gt; &amp;<db:emphasis>list</db:emphasis>)</db:title>
<db:para>Writes the list <db:code role="parameter">list</db:code> to stream <db:code role="parameter">out</db:code>.</db:para>
<db:para>This function requires the value type to implement <db:code>operator&lt;&lt;()</db:code>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="datastreamformat.xml">Format of the QDataStream operators</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="operator-gt-gt-10">
<db:title>QDataStream &amp;operator&gt;&gt;(QDataStream &amp;<db:emphasis>in</db:emphasis>, QList&lt;T&gt; &amp;<db:emphasis>list</db:emphasis>)</db:title>
<db:para>Reads a list from stream <db:code role="parameter">in</db:code> into <db:code role="parameter">list</db:code>.</db:para>
<db:para>This function requires the value type to implement <db:code>operator&gt;&gt;()</db:code>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="datastreamformat.xml">Format of the QDataStream operators</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
</db:section>
<db:section xml:id="obsolete">
<db:title>Obsolete Members for QList</db:title>
<db:para><db:emphasis role="bold">The following members of class <db:link xlink:href="qlist.xml">QList</db:link> are deprecated.</db:emphasis> We strongly advise against using them in new code.</db:para>
<db:section xml:id="obsolete-member-function-documentation">
<db:title>Obsolete Member Function Documentation</db:title>
<db:section xml:id="toList">
<db:title>[noexcept, deprecated] QList&lt;T&gt; QList::toList() const</db:title>
<db:bridgehead renderas="sect2" xml:id="toVector">[noexcept, deprecated] QList&lt;T&gt; QList::toVector() const</db:bridgehead>
<db:para>This function is deprecated. We strongly advise against using it in new code.</db:para>
<db:para>A no-op in Qt 6. Provided for backwards compatibility with Qt 5, where <db:link xlink:href="qlist.xml">QList</db:link> and <db:link xlink:href="qvector.xml">QVector</db:link> where two different types.</db:para>
<db:para>Returns this list.</db:para>
</db:section>
<db:section xml:id="fromList">
<db:title>[static noexcept, deprecated] QList&lt;T&gt; QList::fromList(const QList&lt;T&gt; &amp;<db:emphasis>list</db:emphasis>)</db:title>
<db:bridgehead renderas="sect2" xml:id="fromVector">[static noexcept, deprecated] QList&lt;T&gt; QList::fromVector(const QList&lt;T&gt; &amp;<db:emphasis>list</db:emphasis>)</db:bridgehead>
<db:para>This function is deprecated. We strongly advise against using it in new code.</db:para>
<db:para>A no-op in Qt 6. Provided for backwards compatibility with Qt 5, where <db:link xlink:href="qlist.xml">QList</db:link> and <db:link xlink:href="qvector.xml">QVector</db:link> were two different types.</db:para>
<db:para>Returns this list.</db:para>
</db:section>
</db:section>
</db:section>
</db:article>
