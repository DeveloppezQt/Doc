<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en">
<db:info>
<db:title>QList Class</db:title>
<db:subtitle>template &lt;typename T&gt; class QList</db:subtitle>
<db:productname>QtCore</db:productname>
<db:edition>Qt 6.6.3 Reference Documentation</db:edition>
<db:titleabbrev>Qt Core Reference Documentation</db:titleabbrev>
<db:abstract>
<db:para>The <db:link xlink:href="qlist.xml">QList</db:link> class is a template class that provides a dynamic array.</db:para>
<db:note>
<db:para>All functions in this class are <db:link xlink:href="threads-reentrancy.xml">reentrant</db:link>.</db:para>
</db:note>
</db:abstract>
<db:pubdate>2024-12-27</db:pubdate>
<db:date>2024-12-27</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:variablelist>
<db:varlistentry>
<db:term>Header</db:term>
<db:listitem>
<db:para>QList</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>CMake</db:term>
<db:listitem>
<db:para>find_package(Qt6 REQUIRED COMPONENTS Core)</db:para>
<db:para>target_link_libraries(mytarget PRIVATE Qt6::Core)</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>qmake</db:term>
<db:listitem>
<db:para>QT += core</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Inherited By</db:term>
<db:listitem>
<db:para><db:link xlink:href="qbluetoothserviceinfo-alternative.xml" xlink:role="class">QBluetoothServiceInfo::Alternative</db:link>, <db:link xlink:href="qbluetoothserviceinfo-sequence.xml" xlink:role="class">QBluetoothServiceInfo::Sequence</db:link>, <db:link xlink:href="qbytearraylist.xml" xlink:role="class">QByteArrayList</db:link>, <db:link xlink:href="qitemselection.xml" xlink:role="class">QItemSelection</db:link>, <db:link xlink:href="qndefmessage.xml" xlink:role="class">QNdefMessage</db:link>, <db:link xlink:href="qpolygon.xml" xlink:role="class">QPolygon</db:link>, <db:link xlink:href="qpolygonf.xml" xlink:role="class">QPolygonF</db:link>, <db:link xlink:href="qqueue.xml" xlink:role="class">QQueue</db:link>, <db:link xlink:href="qsignalspy.xml" xlink:role="class">QSignalSpy</db:link>, <db:link xlink:href="qstack.xml" xlink:role="class">QStack</db:link>, <db:link xlink:href="qstringlist.xml" xlink:role="class">QStringList</db:link>, <db:link xlink:href="qtesteventlist.xml" xlink:role="class">QTestEventList</db:link>, <db:link xlink:href="qvector.xml" xlink:role="class">QVector</db:link>, <db:link xlink:href="qvulkaninfovector.xml" xlink:role="class">QVulkanInfoVector</db:link>, and <db:link xlink:href="qxmlstreamattributes.xml" xlink:role="class">QXmlStreamAttributes</db:link></db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Group</db:term>
<db:listitem>
<db:para>QList is part of <db:simplelist><db:member>tools</db:member><db:member><db:link xlink:href="shared.xml">Implicitly Shared Classes</db:link></db:member></db:simplelist></db:para>
</db:listitem>
</db:varlistentry>
</db:variablelist>
<db:section xml:id="details">
<db:title>Detailed Description</db:title>
<db:para><db:link xlink:href="qlist.xml">QList</db:link>&lt;T&gt; is one of Qt's generic <db:link xlink:href="containers.xml">container classes</db:link>. It stores its items in adjacent memory locations and provides fast index-based access. <db:link xlink:href="qvector.xml">QVector</db:link>&lt;T&gt; used to be a different class in Qt 5, but is now a simple alias to <db:link xlink:href="qlist.xml">QList</db:link>.</db:para>
<db:para><db:link xlink:href="qlist.xml">QList</db:link>&lt;T&gt; and <db:link xlink:href="qvarlengtharray.xml">QVarLengthArray</db:link>&lt;T&gt; provide similar APIs and functionality. They are often interchangeable, but there are performance consequences. Here is an overview of use cases:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:link xlink:href="qlist.xml">QList</db:link> should be your default first choice.</db:para>
</db:listitem>
<db:listitem>
<db:para><db:link xlink:href="qvarlengtharray.xml">QVarLengthArray</db:link> provides an array that reserves space on the stack, but can dynamically grow onto the heap if required. It's good to use for short lived containers that are usually small.</db:para>
</db:listitem>
<db:listitem>
<db:para>If you need a real linked list, which guarantees <db:link xlink:href="containers.xml#algorithmic-complexity">constant time</db:link> insertions mid-list and uses iterators to items rather than indexes, use std::list.</db:para>
</db:listitem>
</db:itemizedlist>
<db:note>
<db:para><db:link xlink:href="qlist.xml">QList</db:link> and <db:link xlink:href="qvarlengtharray.xml">QVarLengthArray</db:link> both guarantee C-compatible array layout.</db:para>
</db:note>
<db:note>
<db:para><db:link xlink:href="qlist.xml">QList</db:link> in Qt 5 did not always have a C-compatible array layout and we often recommended to use <db:link xlink:href="qvector.xml">QVector</db:link> instead for more predictable performance. This is not the case in Qt 6 anymore, where both classes now share an implementation and can be used interchangeably.</db:para>
</db:note>
<db:para>Here's an example of a <db:link xlink:href="qlist.xml">QList</db:link> that stores integers and a <db:link xlink:href="qlist.xml">QList</db:link> that stores <db:link xlink:href="qstring.xml">QString</db:link> values:</db:para>
<db:programlisting language="cpp">QList&amp;lt;int&amp;gt; integerList;
QList&amp;lt;QString&amp;gt; stringList;
</db:programlisting>
<db:para><db:link xlink:href="qlist.xml">QList</db:link> stores its items in an array of continuous memory. Typically, lists are created with an initial size. For example, the following code constructs a <db:link xlink:href="qlist.xml">QList</db:link> with 200 elements:</db:para>
<db:programlisting language="cpp">QList&amp;lt;QString&amp;gt; list(200);
</db:programlisting>
<db:para>The elements are automatically initialized with a <db:link xlink:href="containers.xml#default-constructed-value">default-constructed value</db:link>. If you want to initialize the list with a different value, pass that value as the second argument to the constructor:</db:para>
<db:programlisting language="cpp">QList&amp;lt;QString&amp;gt; list(200, &quot;Pass&quot;);
</db:programlisting>
<db:para>You can also call <db:link xlink:href="qlist.xml#fill">fill</db:link>() at any time to fill the list with a value.</db:para>
<db:para><db:link xlink:href="qlist.xml">QList</db:link> uses 0-based indexes, just like C++ arrays. To access the item at a particular index position, you can use operator[](). On non-const lists, operator[]() returns a reference to the item that can be used on the left side of an assignment:</db:para>
<db:programlisting language="cpp">if (list[0] == &quot;Liz&quot;)
    list[0] = &quot;Elizabeth&quot;;
</db:programlisting>
<db:para>For read-only access, an alternative syntax is to use <db:link xlink:href="qlist.xml#at">at</db:link>():</db:para>
<db:programlisting language="cpp">for (qsizetype i = 0; i &amp;lt; list.size(); ++i) {
    if (list.at(i) == &quot;Alfonso&quot;)
        cout &amp;lt;&amp;lt; &quot;Found Alfonso at position &quot; &amp;lt;&amp;lt; i &amp;lt;&amp;lt; endl;
}
</db:programlisting>
<db:para><db:link xlink:href="qlist.xml#at">at</db:link>() can be faster than operator[](), because it never causes a <db:link xlink:href="implicit-sharing.xml#deep-copy">deep copy</db:link> to occur.</db:para>
<db:para>Another way to access the data stored in a <db:link xlink:href="qlist.xml">QList</db:link> is to call <db:link xlink:href="qlist.xml#data">data</db:link>(). The function returns a pointer to the first item in the list. You can use the pointer to directly access and modify the elements stored in the list. The pointer is also useful if you need to pass a <db:link xlink:href="qlist.xml">QList</db:link> to a function that accepts a plain C++ array.</db:para>
<db:para>If you want to find all occurrences of a particular value in a list, use <db:link xlink:href="qlist.xml#indexOf">indexOf</db:link>() or <db:link xlink:href="qlist.xml#lastIndexOf">lastIndexOf</db:link>(). The former searches forward starting from a given index position, the latter searches backward. Both return the index of the matching item if they found one; otherwise, they return -1. For example:</db:para>
<db:programlisting language="cpp">qsizetype i = list.indexOf(&quot;Harumi&quot;);
if (i != -1)
    cout &amp;lt;&amp;lt; &quot;First occurrence of Harumi is at position &quot; &amp;lt;&amp;lt; i &amp;lt;&amp;lt; endl;
</db:programlisting>
<db:para>If you simply want to check whether a list contains a particular value, use <db:link xlink:href="qlist.xml#contains">contains</db:link>(). If you want to find out how many times a particular value occurs in the list, use <db:link xlink:href="qlist.xml#count-1">count</db:link>().</db:para>
<db:para><db:link xlink:href="qlist.xml">QList</db:link> provides these basic functions to add, move, and remove items: <db:link xlink:href="qlist.xml#insert">insert</db:link>(), <db:link xlink:href="qlist.xml#replace">replace</db:link>(), <db:link xlink:href="qlist.xml#remove">remove</db:link>(), <db:link xlink:href="qlist.xml#prepend">prepend</db:link>(), <db:link xlink:href="qlist.xml#append">append</db:link>(). With the exception of <db:link xlink:href="qlist.xml#append">append</db:link>(), <db:link xlink:href="qlist.xml#prepend">prepend</db:link>() and <db:link xlink:href="qlist.xml#replace">replace</db:link>(), these functions can be slow (<db:link xlink:href="containers.xml#linear-time">linear time</db:link>) for large lists, because they require moving many items in the list by one position in memory. If you want a container class that provides fast insertion/removal in the middle, use std::list instead.</db:para>
<db:para>Unlike plain C++ arrays, QLists can be resized at any time by calling <db:link xlink:href="qlist.xml#resize">resize</db:link>(). If the new size is larger than the old size, <db:link xlink:href="qlist.xml">QList</db:link> might need to reallocate the whole list. <db:link xlink:href="qlist.xml">QList</db:link> tries to reduce the number of reallocations by preallocating up to twice as much memory as the actual data needs.</db:para>
<db:para>If you're building a <db:link xlink:href="qlist.xml">QList</db:link> gradually and know in advance approximately how many elements it will contain, you can call <db:link xlink:href="qlist.xml#reserve">reserve</db:link>(), asking <db:link xlink:href="qlist.xml">QList</db:link> to preallocate a certain amount of memory. You can also call <db:link xlink:href="qlist.xml#capacity">capacity</db:link>() to find out how much memory the <db:link xlink:href="qlist.xml">QList</db:link> actually has allocated.</db:para>
<db:para>Note that using non-const operators and functions can cause <db:link xlink:href="qlist.xml">QList</db:link> to do a deep copy of the data, due to <db:link xlink:href="implicit-sharing.xml">implicit sharing</db:link>.</db:para>
<db:para><db:link xlink:href="qlist.xml">QList</db:link>'s value type must be an <db:link xlink:href="containers.xml#assignable-data-type">assignable data type</db:link>. This covers most data types that are commonly used, but the compiler won't let you, for example, store a <db:link xlink:href="qwidget.xml">QWidget</db:link> as a value; instead, store a <db:link xlink:href="qwidget.xml">QWidget</db:link> *. A few functions have additional requirements; for example, <db:link xlink:href="qlist.xml#indexOf">indexOf</db:link>() and <db:link xlink:href="qlist.xml#lastIndexOf">lastIndexOf</db:link>() expect the value type to support <db:code>operator==()</db:code>. These requirements are documented on a per-function basis.</db:para>
<db:para>For iterating over the items, see <db:link xlink:href="containers.xml#iterating-over-containers">Iterating over Containers</db:link>.</db:para>
<db:para>In addition to <db:link xlink:href="qlist.xml">QList</db:link>, Qt also provides <db:link xlink:href="qvarlengtharray.xml">QVarLengthArray</db:link>, a very low-level class with little functionality that is optimized for speed.</db:para>
<db:section xml:id="more-information-on-using-qt-containers">
<db:title>More Information on Using Qt Containers</db:title>
<db:para>For a detailed discussion comparing Qt containers with each other and with STL containers, see <db:link xlink:href="https://marcmutz.wordpress.com/effective-qt/containers/">Understand the Qt Containers</db:link>.</db:para>
</db:section>
<db:section xml:id="maximum-size-and-out-of-memory-conditions">
<db:title>Maximum size and out-of-memory conditions</db:title>
<db:para>The maximum size of <db:link xlink:href="qlist.xml">QList</db:link> depends on the architecture. Most 64-bit systems can allocate more than 2 GB of memory, with a typical limit of 2^63 bytes. The actual value also depends on the overhead required for managing the data block. As a result, you can expect the maximum size of 2 GB minus overhead on 32-bit platforms, and 2^63 bytes minus overhead on 64-bit platforms. The number of elements that can be stored in a <db:link xlink:href="qlist.xml">QList</db:link> is this maximum size divided by the size of a stored element.</db:para>
<db:para>When memory allocation fails, <db:link xlink:href="qlist.xml">QList</db:link> uses the <db:link xlink:href="qtassert-proxy.xml#Q_CHECK_PTR">Q_CHECK_PTR</db:link> macro, which throws a <db:code>std::bad_alloc</db:code> exception if the application is being compiled with exception support. If exceptions are disabled, then running out of memory is undefined behavior.</db:para>
<db:para>Note that the operating system may impose further limits on applications holding a lot of allocated memory, especially large, contiguous blocks. Such considerations, the configuration of such behavior or any mitigation are outside the scope of the Qt API.</db:para>
</db:section>
</db:section>
<db:section xml:id="member-type-documentation">
<db:title>Member Type Documentation</db:title>
<db:section xml:id="ConstIterator-typedef">
<db:title>[alias] QList::ConstIterator</db:title>
<db:typedefsynopsis>
<db:typedefname>ConstIterator</db:typedefname>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:typedefsynopsis>
<db:para>Qt-style synonym for <db:link xlink:href="qlist-const-iterator.xml">QList::const_iterator</db:link>.</db:para>
</db:section>
<db:section xml:id="Iterator-typedef">
<db:title>[alias] QList::Iterator</db:title>
<db:typedefsynopsis>
<db:typedefname>Iterator</db:typedefname>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:typedefsynopsis>
<db:para>Qt-style synonym for <db:link xlink:href="qlist-iterator.xml">QList::iterator</db:link>.</db:para>
</db:section>
<db:section xml:id="const_pointer-typedef">
<db:title>[alias] QList::const_pointer</db:title>
<db:typedefsynopsis>
<db:typedefname>const_pointer</db:typedefname>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:typedefsynopsis>
<db:para>Provided for STL compatibility.</db:para>
</db:section>
<db:section xml:id="const_reference-typedef">
<db:title>[alias] QList::const_reference</db:title>
<db:typedefsynopsis>
<db:typedefname>const_reference</db:typedefname>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:typedefsynopsis>
<db:para>Provided for STL compatibility.</db:para>
</db:section>
<db:section xml:id="const_reverse_iterator-typedef">
<db:title>[alias] QList::const_reverse_iterator</db:title>
<db:typedefsynopsis>
<db:typedefname>const_reverse_iterator</db:typedefname>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:typedefsynopsis>
<db:para>The QList::const_reverse_iterator typedef provides an STL-style const reverse iterator for <db:link xlink:href="qlist.xml">QList</db:link>.</db:para>
<db:warning>
<db:para>Iterators on implicitly shared containers do not work exactly like STL-iterators. You should avoid copying a container while iterators are active on that container. For more information, read <db:link xlink:href="containers.xml#implicit-sharing-iterator-problem">Implicit sharing iterator problem</db:link>.</db:para>
</db:warning>
<db:warning>
<db:para>Iterators are invalidated when <db:link xlink:href="qlist.xml">QList</db:link> is modified. Consider that all iterators are invalidated by default. Exceptions to this rule are explicitly documented.</db:para>
</db:warning>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qlist.xml#rbegin">QList::rbegin</db:link>()</db:member>
<db:member><db:link xlink:href="qlist.xml#rend">QList::rend</db:link>()</db:member>
<db:member><db:link xlink:href="qlist.xml#reverse_iterator-typedef">QList::reverse_iterator</db:link></db:member>
<db:member><db:link xlink:href="qlist-const-iterator.xml">QList::const_iterator</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="difference_type-typedef">
<db:title>[alias] QList::difference_type</db:title>
<db:typedefsynopsis>
<db:typedefname>difference_type</db:typedefname>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:typedefsynopsis>
<db:para>Provided for STL compatibility.</db:para>
</db:section>
<db:section xml:id="parameter_type-typedef">
<db:title>[alias] QList::parameter_type</db:title>
<db:typedefsynopsis>
<db:typedefname>parameter_type</db:typedefname>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:typedefsynopsis>
</db:section>
<db:section xml:id="pointer-typedef">
<db:title>[alias] QList::pointer</db:title>
<db:typedefsynopsis>
<db:typedefname>pointer</db:typedefname>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:typedefsynopsis>
<db:para>Provided for STL compatibility.</db:para>
</db:section>
<db:section xml:id="reference-typedef">
<db:title>[alias] QList::reference</db:title>
<db:typedefsynopsis>
<db:typedefname>reference</db:typedefname>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:typedefsynopsis>
<db:para>Provided for STL compatibility.</db:para>
</db:section>
<db:section xml:id="reverse_iterator-typedef">
<db:title>[alias] QList::reverse_iterator</db:title>
<db:typedefsynopsis>
<db:typedefname>reverse_iterator</db:typedefname>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:typedefsynopsis>
<db:para>The QList::reverse_iterator typedef provides an STL-style non-const reverse iterator for <db:link xlink:href="qlist.xml">QList</db:link>.</db:para>
<db:warning>
<db:para>Iterators on implicitly shared containers do not work exactly like STL-iterators. You should avoid copying a container while iterators are active on that container. For more information, read <db:link xlink:href="containers.xml#implicit-sharing-iterator-problem">Implicit sharing iterator problem</db:link>.</db:para>
</db:warning>
<db:warning>
<db:para>Iterators are invalidated when <db:link xlink:href="qlist.xml">QList</db:link> is modified. Consider that all iterators are invalidated by default. Exceptions to this rule are explicitly documented.</db:para>
</db:warning>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qlist.xml#rbegin">QList::rbegin</db:link>()</db:member>
<db:member><db:link xlink:href="qlist.xml#rend">QList::rend</db:link>()</db:member>
<db:member><db:link xlink:href="qlist.xml#const_reverse_iterator-typedef">QList::const_reverse_iterator</db:link></db:member>
<db:member><db:link xlink:href="qlist-iterator.xml">QList::iterator</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="rvalue_ref-typedef">
<db:title>[alias] QList::rvalue_ref</db:title>
<db:typedefsynopsis>
<db:typedefname>rvalue_ref</db:typedefname>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:typedefsynopsis>
</db:section>
<db:section xml:id="size_type-typedef">
<db:title>[alias] QList::size_type</db:title>
<db:typedefsynopsis>
<db:typedefname>size_type</db:typedefname>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:typedefsynopsis>
<db:para>Provided for STL compatibility.</db:para>
</db:section>
<db:section xml:id="value_type-typedef">
<db:title>[alias] QList::value_type</db:title>
<db:typedefsynopsis>
<db:typedefname>value_type</db:typedefname>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:typedefsynopsis>
<db:para>Provided for STL compatibility.</db:para>
</db:section>
</db:section>
<db:section xml:id="member-function-documentation">
<db:title>Member Function Documentation</db:title>
<db:section xml:id="resize">
<db:title>[since 6.0] void QList::resize(qsizetype <db:emphasis>size</db:emphasis>)</db:title>
<db:bridgehead renderas="sect2" xml:id="resize-1">[since 6.0] void QList::resize(qsizetype <db:emphasis>size</db:emphasis>, QList::parameter_type <db:emphasis>c</db:emphasis>)</db:bridgehead>
<db:para>Sets the size of the list to <db:code role="parameter">size</db:code>. If <db:code role="parameter">size</db:code> is greater than the current size, elements are added to the end; the new elements are initialized with either a <db:link xlink:href="containers.xml#default-constructed-value">default-constructed value</db:link> or <db:code role="parameter">c</db:code>. If <db:code role="parameter">size</db:code> is less than the current size, elements are removed from the end.</db:para>
<db:para>If this list is not shared, the <db:link xlink:href="qlist.xml#capacity">capacity</db:link>() is preserved. Use <db:link xlink:href="qlist.xml#squeeze">squeeze</db:link>() to shed excess capacity.</db:para>
<db:note>
<db:para>In Qt versions prior to 5.7 (for <db:link xlink:href="qvector.xml">QVector</db:link>; <db:link xlink:href="qlist.xml">QList</db:link> lacked a <db:link xlink:href="qlist.xml#resize">resize</db:link>() until 6.0), this function released the memory used by the list instead of preserving the capacity.</db:para>
</db:note>
<db:para>This function was introduced in Qt 6.0.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qlist.xml#size">size</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="prepend-1">
<db:title>void QList::prepend(QList::parameter_type <db:emphasis>value</db:emphasis>)</db:title>
<db:bridgehead renderas="sect2" xml:id="prepend">void QList::prepend(QList::rvalue_ref <db:emphasis>value</db:emphasis>)</db:bridgehead>
<db:para>Inserts <db:code role="parameter">value</db:code> at the beginning of the list.</db:para>
<db:para>Example:</db:para>
<db:programlisting language="cpp">QList&amp;lt;QString&amp;gt; list;
list.prepend(&quot;one&quot;);
list.prepend(&quot;two&quot;);
list.prepend(&quot;three&quot;);
// list: [&quot;three&quot;, &quot;two&quot;, &quot;one&quot;]
</db:programlisting>
<db:para>This is the same as list.insert(0, <db:code role="parameter">value</db:code>).</db:para>
<db:para>Normally this operation is relatively fast (amortized <db:link xlink:href="containers.xml#constant-time">constant time</db:link>). <db:link xlink:href="qlist.xml">QList</db:link> is able to allocate extra memory at the beginning of the list data and grow in that direction without reallocating or moving the data on each operation. However if you want a container class with a guarantee of <db:link xlink:href="containers.xml#constant-time">constant time</db:link> prepend, use std::list instead, but prefer <db:link xlink:href="qlist.xml">QList</db:link> otherwise.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qlist.xml#append">append</db:link>()</db:member>
<db:member><db:link xlink:href="qlist.xml#insert">insert</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="emplaceBack">
<db:title>QList::reference QList::emplaceBack(Args &amp;&amp;... <db:emphasis>args</db:emphasis>)</db:title>
<db:bridgehead renderas="sect2" xml:id="emplace_back">QList::reference QList::emplace_back(Args &amp;&amp;... <db:emphasis>args</db:emphasis>)</db:bridgehead>
<db:para>Adds a new element to the end for the container. This new element is constructed in-place using <db:code role="parameter">args</db:code> as the arguments for its construction.</db:para>
<db:para>Returns a reference to the new element.</db:para>
<db:para>Example:</db:para>
<db:programlisting language="cpp">QList&amp;lt;QString&amp;gt; list{&quot;one&quot;, &quot;two&quot;};
list.emplaceBack(3, 'a');
qDebug() &amp;lt;&amp;lt; list;
// list: [&quot;one&quot;, &quot;two&quot;, &quot;aaa&quot;]
</db:programlisting>
<db:para>It is also possible to access a newly created object by using returned reference:</db:para>
<db:programlisting language="cpp">QList&amp;lt;QString&amp;gt; list;
auto &amp;amp;ref = list.emplaceBack();
ref = &quot;one&quot;;
// list: [&quot;one&quot;]
</db:programlisting>
<db:para>This is the same as list.emplace(list.<db:link xlink:href="qlist.xml#size">size</db:link>(), <db:code role="parameter">args</db:code>).</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qlist.xml#emplace">emplace</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="insert">
<db:title>QList::iterator QList::insert(qsizetype <db:emphasis>i</db:emphasis>, QList::parameter_type <db:emphasis>value</db:emphasis>)</db:title>
<db:bridgehead renderas="sect2" xml:id="insert-5">QList::iterator QList::insert(qsizetype <db:emphasis>i</db:emphasis>, QList::rvalue_ref <db:emphasis>value</db:emphasis>)</db:bridgehead>
<db:para>Inserts <db:code role="parameter">value</db:code> at index position <db:code role="parameter">i</db:code> in the list. If <db:code role="parameter">i</db:code> is 0, the value is prepended to the list. If <db:code role="parameter">i</db:code> is <db:link xlink:href="qlist.xml#size">size</db:link>(), the value is appended to the list.</db:para>
<db:para>Example:</db:para>
<db:programlisting language="cpp">QList&amp;lt;QString&amp;gt; list = {&quot;alpha&quot;, &quot;beta&quot;, &quot;delta&quot;};
list.insert(2, &quot;gamma&quot;);
// list: [&quot;alpha&quot;, &quot;beta&quot;, &quot;gamma&quot;, &quot;delta&quot;]
</db:programlisting>
<db:para>For large lists, this operation can be slow (<db:link xlink:href="containers.xml#linear-time">linear time</db:link>), because it requires moving all the items at indexes <db:code role="parameter">i</db:code> and above by one position further in memory. If you want a container class that provides a fast <db:link xlink:href="qlist.xml#insert">insert</db:link>() function, use std::list instead.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qlist.xml#append">append</db:link>()</db:member>
<db:member><db:link xlink:href="qlist.xml#prepend">prepend</db:link>()</db:member>
<db:member><db:link xlink:href="qlist.xml#remove">remove</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="insert-2">
<db:title>QList::iterator QList::insert(QList::const_iterator <db:emphasis>before</db:emphasis>, QList::parameter_type <db:emphasis>value</db:emphasis>)</db:title>
<db:bridgehead renderas="sect2" xml:id="insert-4">QList::iterator QList::insert(QList::const_iterator <db:emphasis>before</db:emphasis>, QList::rvalue_ref <db:emphasis>value</db:emphasis>)</db:bridgehead>
<db:para>This is an overloaded function.</db:para>
<db:para>Inserts <db:code role="parameter">value</db:code> in front of the item pointed to by the iterator <db:code role="parameter">before</db:code>. Returns an iterator pointing at the inserted item.</db:para>
</db:section>
<db:section xml:id="replace">
<db:title>void QList::replace(qsizetype <db:emphasis>i</db:emphasis>, QList::parameter_type <db:emphasis>value</db:emphasis>)</db:title>
<db:bridgehead renderas="sect2" xml:id="replace-1">void QList::replace(qsizetype <db:emphasis>i</db:emphasis>, QList::rvalue_ref <db:emphasis>value</db:emphasis>)</db:bridgehead>
<db:para>Replaces the item at index position <db:code role="parameter">i</db:code> with <db:code role="parameter">value</db:code>.</db:para>
<db:para><db:code role="parameter">i</db:code> must be a valid index position in the list (i.e., 0 &lt;= <db:code role="parameter">i</db:code> &lt; <db:link xlink:href="qlist.xml#size">size</db:link>()).</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qlist.xml#operator-5b-5d">operator[]</db:link>()</db:member>
<db:member><db:link xlink:href="qlist.xml#remove">remove</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="push_front-1">
<db:title>void QList::push_front(QList::parameter_type <db:emphasis>value</db:emphasis>)</db:title>
<db:bridgehead renderas="sect2" xml:id="push_front">void QList::push_front(QList::rvalue_ref <db:emphasis>value</db:emphasis>)</db:bridgehead>
<db:para>This function is provided for STL compatibility. It is equivalent to prepend(<db:code role="parameter">value</db:code>).</db:para>
</db:section>
<db:section xml:id="operator-2b-3">
<db:title>QList&lt;T&gt; QList::operator+(QList&lt;T&gt; &amp;&amp;<db:emphasis>other</db:emphasis>) &amp;&amp;</db:title>
<db:bridgehead renderas="sect2" xml:id="operator-2b-1">QList&lt;T&gt; QList::operator+(const QList&lt;T&gt; &amp;<db:emphasis>other</db:emphasis>) &amp;&amp;</db:bridgehead>
<db:bridgehead renderas="sect2" xml:id="operator-2b-2">QList&lt;T&gt; QList::operator+(QList&lt;T&gt; &amp;&amp;<db:emphasis>other</db:emphasis>) const &amp;</db:bridgehead>
<db:bridgehead renderas="sect2" xml:id="operator-2b">QList&lt;T&gt; QList::operator+(const QList&lt;T&gt; &amp;<db:emphasis>other</db:emphasis>) const &amp;</db:bridgehead>
<db:para>Returns a list that contains all the items in this list followed by all the items in the <db:code role="parameter">other</db:code> list.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qlist.xml#operator-2b-eq">operator+=</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="QList-1">
<db:title>QList::QList()</db:title>
<db:constructorsynopsis>
<db:methodname>QList</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">constructor</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">QList()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:constructorsynopsis>
<db:para>Constructs an empty list.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qlist.xml#resize">resize</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="QList-2">
<db:title>[explicit] QList::QList(qsizetype <db:emphasis>size</db:emphasis>)</db:title>
<db:constructorsynopsis>
<db:methodname>QList</db:methodname>
<db:methodparam>
<db:type>qsizetype</db:type>
<db:parameter>size</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">constructor</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">2</db:synopsisinfo>
<db:synopsisinfo role="signature">QList(qsizetype size)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:constructorsynopsis>
<db:para>Constructs a list with an initial size of <db:code role="parameter">size</db:code> elements.</db:para>
<db:para>The elements are initialized with a <db:link xlink:href="containers.xml#default-constructed-value">default-constructed value</db:link>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qlist.xml#resize">resize</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="QList-3">
<db:title>QList::QList(qsizetype <db:emphasis>size</db:emphasis>, QList::parameter_type <db:emphasis>value</db:emphasis>)</db:title>
<db:constructorsynopsis>
<db:methodname>QList</db:methodname>
<db:methodparam>
<db:type>qsizetype</db:type>
<db:parameter>size</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>QList::parameter_type</db:type>
<db:parameter>value</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">constructor</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">3</db:synopsisinfo>
<db:synopsisinfo role="signature">QList(qsizetype size, QList::parameter_type value)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:constructorsynopsis>
<db:para>Constructs a list with an initial size of <db:code role="parameter">size</db:code> elements. Each element is initialized with <db:code role="parameter">value</db:code>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qlist.xml#resize">resize</db:link>()</db:member>
<db:member><db:link xlink:href="qlist.xml#fill">fill</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="QList-4">
<db:title>QList::QList(std::initializer_list&lt;T&gt; <db:emphasis>args</db:emphasis>)</db:title>
<db:constructorsynopsis>
<db:methodname>QList</db:methodname>
<db:methodparam>
<db:type>std::initializer_list&lt;T&gt;</db:type>
<db:parameter>args</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">constructor</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">4</db:synopsisinfo>
<db:synopsisinfo role="signature">QList(std::initializer_list&lt;T&gt; args)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:constructorsynopsis>
<db:para>Constructs a list from the std::initializer_list given by <db:code role="parameter">args</db:code>.</db:para>
</db:section>
<db:section xml:id="QList-5">
<db:title>QList::QList(InputIterator <db:emphasis>first</db:emphasis>, InputIterator <db:emphasis>last</db:emphasis>)</db:title>
<db:constructorsynopsis>
<db:methodname>QList</db:methodname>
<db:methodparam>
<db:type>InputIterator</db:type>
<db:parameter>first</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>InputIterator</db:type>
<db:parameter>last</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">constructor</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">5</db:synopsisinfo>
<db:synopsisinfo role="signature">QList(InputIterator first, InputIterator last)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:constructorsynopsis>
<db:para>Constructs a list with the contents in the iterator range [<db:code role="parameter">first</db:code>, <db:code role="parameter">last</db:code>).</db:para>
<db:note>
<db:para>This constructor only participates in overload resolution if <db:code>InputIterator</db:code> meets the requirements of a <db:link xlink:href="https://en.cppreference.com/w/cpp/named_req/InputIterator">LegacyInputIterator</db:link>.</db:para>
</db:note>
<db:para>The value type of <db:code>InputIterator</db:code> must be convertible to <db:code>T</db:code>.</db:para>
</db:section>
<db:section xml:id="QList-7">
<db:title>[default] QList::QList(QList&lt;T&gt; &amp;&amp;<db:emphasis>other</db:emphasis>)</db:title>
<db:constructorsynopsis>
<db:methodname>QList</db:methodname>
<db:methodparam>
<db:type>QList&lt;T&gt; &amp;&amp;</db:type>
<db:parameter>other</db:parameter>
</db:methodparam>
<db:modifier>default</db:modifier>
<db:synopsisinfo role="meta">constructor</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">7</db:synopsisinfo>
<db:synopsisinfo role="signature">QList(QList&lt;T&gt; &amp;&amp;other) = default</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:constructorsynopsis>
<db:para>Move-constructs a <db:link xlink:href="qlist.xml">QList</db:link> instance, making it point at the same object that <db:code role="parameter">other</db:code> was pointing to.</db:para>
</db:section>
<db:section xml:id="QList-8">
<db:title>[default] QList::QList(const QList&lt;T&gt; &amp;<db:emphasis>other</db:emphasis>)</db:title>
<db:constructorsynopsis>
<db:methodname>QList</db:methodname>
<db:methodparam>
<db:type>const QList&lt;T&gt; &amp;</db:type>
<db:parameter>other</db:parameter>
</db:methodparam>
<db:modifier>default</db:modifier>
<db:synopsisinfo role="meta">constructor</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">8</db:synopsisinfo>
<db:synopsisinfo role="signature">QList(const QList&lt;T&gt; &amp;other) = default</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:constructorsynopsis>
<db:para>Constructs a copy of <db:code role="parameter">other</db:code>.</db:para>
<db:para>This operation takes <db:link xlink:href="containers.xml#algorithmic-complexity">constant time</db:link>, because <db:link xlink:href="qlist.xml">QList</db:link> is <db:link xlink:href="implicit-sharing.xml">implicitly shared</db:link>. This makes returning a <db:link xlink:href="qlist.xml">QList</db:link> from a function very fast. If a shared instance is modified, it will be copied (copy-on-write), and that takes <db:link xlink:href="containers.xml#algorithmic-complexity">linear time</db:link>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qlist.xml#operator-eq">operator=</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="dtor.QList">
<db:title>[default] QList::~QList()</db:title>
<db:destructorsynopsis>
<db:methodname>~QList</db:methodname>
<db:void/>
<db:modifier>default</db:modifier>
<db:synopsisinfo role="meta">destructor</db:synopsisinfo>
<db:synopsisinfo role="signature">~QList() = default</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:destructorsynopsis>
<db:para>Destroys the list.</db:para>
</db:section>
<db:section xml:id="append">
<db:title>void QList::append(QList::parameter_type <db:emphasis>value</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>append</db:methodname>
<db:methodparam>
<db:type>QList::parameter_type</db:type>
<db:parameter>value</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void append(QList::parameter_type value)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Inserts <db:code role="parameter">value</db:code> at the end of the list.</db:para>
<db:para>Example:</db:para>
<db:programlisting language="cpp">QList&amp;lt;QString&amp;gt; list;
list.append(&quot;one&quot;);
list.append(&quot;two&quot;);
QString three = &quot;three&quot;;
list.append(three);
// list: [&quot;one&quot;, &quot;two&quot;, &quot;three&quot;]
// three: &quot;three&quot;
</db:programlisting>
<db:para>This is the same as calling resize(<db:link xlink:href="qlist.xml#size">size</db:link>() + 1) and assigning <db:code role="parameter">value</db:code> to the new last element in the list.</db:para>
<db:para>This operation is relatively fast, because <db:link xlink:href="qlist.xml">QList</db:link> typically allocates more memory than necessary, so it can grow without reallocating the entire list each time.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qlist.xml#operator-lt-lt">operator&lt;&lt;</db:link>()</db:member>
<db:member><db:link xlink:href="qlist.xml#prepend">prepend</db:link>()</db:member>
<db:member><db:link xlink:href="qlist.xml#insert">insert</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="append-2">
<db:title>void QList::append(QList::rvalue_ref <db:emphasis>value</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>append</db:methodname>
<db:methodparam>
<db:type>QList::rvalue_ref</db:type>
<db:parameter>value</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">2</db:synopsisinfo>
<db:synopsisinfo role="signature">void append(QList::rvalue_ref value)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>Example:</db:para>
<db:programlisting language="cpp">QList&amp;lt;QString&amp;gt; list;
list.append(&quot;one&quot;);
list.append(&quot;two&quot;);
QString three = &quot;three&quot;;
list.append(std::move(three));
// list: [&quot;one&quot;, &quot;two&quot;, &quot;three&quot;]
// three: &quot;&quot;
</db:programlisting>
</db:section>
<db:section xml:id="append-3">
<db:title>void QList::append(const QList&lt;T&gt; &amp;<db:emphasis>value</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>append</db:methodname>
<db:methodparam>
<db:type>const QList&lt;T&gt; &amp;</db:type>
<db:parameter>value</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">3</db:synopsisinfo>
<db:synopsisinfo role="signature">void append(const QList&lt;T&gt; &amp;value)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>Appends the items of the <db:code role="parameter">value</db:code> list to this list.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qlist.xml#operator-lt-lt">operator&lt;&lt;</db:link>()</db:member>
<db:member><db:link xlink:href="qlist.xml#operator-2b-eq">operator+=</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="append-4">
<db:title>[since 6.0] void QList::append(QList&lt;T&gt; &amp;&amp;<db:emphasis>value</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>append</db:methodname>
<db:methodparam>
<db:type>QList&lt;T&gt; &amp;&amp;</db:type>
<db:parameter>value</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">4</db:synopsisinfo>
<db:synopsisinfo role="signature">void append(QList&lt;T&gt; &amp;&amp;value)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>Moves the items of the <db:code role="parameter">value</db:code> list to the end of this list.</db:para>
<db:para>This function was introduced in Qt 6.0.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qlist.xml#operator-lt-lt">operator&lt;&lt;</db:link>()</db:member>
<db:member><db:link xlink:href="qlist.xml#operator-2b-eq">operator+=</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="assign">
<db:title>[since 6.6] QList&lt;T&gt; &amp;QList::assign(qsizetype <db:emphasis>n</db:emphasis>, QList::parameter_type <db:emphasis>t</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>QList&lt;T&gt; &amp;</db:type>
<db:methodname>assign</db:methodname>
<db:methodparam>
<db:type>qsizetype</db:type>
<db:parameter>n</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>QList::parameter_type</db:type>
<db:parameter>t</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QList&lt;T&gt; &amp; assign(qsizetype n, QList::parameter_type t)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Replaces the contents of this list with <db:code role="parameter">n</db:code> copies of <db:code role="parameter">t</db:code>.</db:para>
<db:para>The size of this list will be equal to <db:code role="parameter">n</db:code>.</db:para>
<db:para>This function will only allocate memory if <db:code role="parameter">n</db:code> exceeds the capacity of the list or this list is shared.</db:para>
<db:para>This function was introduced in Qt 6.6.</db:para>
</db:section>
<db:section xml:id="assign-1">
<db:title>[since 6.6] QList&lt;T&gt; &amp;QList::assign(InputIterator <db:emphasis>first</db:emphasis>, InputIterator <db:emphasis>last</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>QList&lt;T&gt; &amp;</db:type>
<db:methodname>assign</db:methodname>
<db:methodparam>
<db:type>InputIterator</db:type>
<db:parameter>first</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>InputIterator</db:type>
<db:parameter>last</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">QList&lt;T&gt; &amp; assign(InputIterator first, InputIterator last)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Replaces the contents of this list with a copy of the elements in the iterator range [<db:code role="parameter">first</db:code>, <db:code role="parameter">last</db:code>).</db:para>
<db:para>The size of this list will be equal to the number of elements in the range [<db:code role="parameter">first</db:code>, <db:code role="parameter">last</db:code>).</db:para>
<db:para>This function will only allocate memory if the number of elements in the range exceeds the capacity of this list or this list is shared.</db:para>
<db:note>
<db:para>This function overload only participates in overload resolution if <db:code>InputIterator</db:code> meets the requirements of a <db:link xlink:href="https://en.cppreference.com/w/cpp/named_req/InputIterator">LegacyInputIterator</db:link>.</db:para>
</db:note>
<db:note>
<db:para>The behavior is undefined if either argument is an iterator into *this.</db:para>
</db:note>
<db:para>This function was introduced in Qt 6.6.</db:para>
</db:section>
<db:section xml:id="assign-2">
<db:title>[since 6.6] QList&lt;T&gt; &amp;QList::assign(std::initializer_list&lt;T&gt; <db:emphasis>l</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>QList&lt;T&gt; &amp;</db:type>
<db:methodname>assign</db:methodname>
<db:methodparam>
<db:type>std::initializer_list&lt;T&gt;</db:type>
<db:parameter>l</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">2</db:synopsisinfo>
<db:synopsisinfo role="signature">QList&lt;T&gt; &amp; assign(std::initializer_list&lt;T&gt; l)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Replaces the contents of this list with a copy of the elements of <db:code role="parameter">l</db:code>.</db:para>
<db:para>The size of this list will be equal to the number of elements in <db:code role="parameter">l</db:code>.</db:para>
<db:para>This function only allocates memory if the number of elements in <db:code role="parameter">l</db:code> exceeds the capacity of this list or this list is shared.</db:para>
<db:para>This function was introduced in Qt 6.6.</db:para>
</db:section>
<db:section xml:id="at">
<db:title>QList::const_reference QList::at(qsizetype <db:emphasis>i</db:emphasis>) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QList::const_reference</db:type>
<db:methodname>at</db:methodname>
<db:methodparam>
<db:type>qsizetype</db:type>
<db:parameter>i</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QList::const_reference at(qsizetype i) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the item at index position <db:code role="parameter">i</db:code> in the list.</db:para>
<db:para><db:code role="parameter">i</db:code> must be a valid index position in the list (i.e., 0 &lt;= <db:code role="parameter">i</db:code> &lt; <db:link xlink:href="qlist.xml#size">size</db:link>()).</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qlist.xml#value">value</db:link>()</db:member>
<db:member><db:link xlink:href="qlist.xml#operator-5b-5d">operator[]</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="back">
<db:title>QList::reference QList::back()</db:title>
<db:methodsynopsis>
<db:type>QList::reference</db:type>
<db:methodname>back</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QList::reference back()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This function is provided for STL compatibility. It is equivalent to <db:link xlink:href="qlist.xml#last">last</db:link>().</db:para>
</db:section>
<db:section xml:id="back-1">
<db:title>QList::const_reference QList::back() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QList::const_reference</db:type>
<db:methodname>back</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">QList::const_reference back() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
</db:section>
<db:section xml:id="begin">
<db:title>QList::iterator QList::begin()</db:title>
<db:methodsynopsis>
<db:type>QList::iterator</db:type>
<db:methodname>begin</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QList::iterator begin()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns an <db:link xlink:href="containers.xml#stl-style-iterators">STL-style iterator</db:link> pointing to the first item in the list.</db:para>
<db:warning>
<db:para>The returned iterator is invalidated on detachment or when the <db:link xlink:href="qlist.xml">QList</db:link> is modified.</db:para>
</db:warning>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qlist.xml#constBegin">constBegin</db:link>()</db:member>
<db:member><db:link xlink:href="qlist.xml#end">end</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="begin-1">
<db:title>QList::const_iterator QList::begin() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QList::const_iterator</db:type>
<db:methodname>begin</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">QList::const_iterator begin() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
</db:section>
<db:section xml:id="capacity">
<db:title>qsizetype QList::capacity() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>qsizetype</db:type>
<db:methodname>capacity</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">qsizetype capacity() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the maximum number of items that can be stored in the list without forcing a reallocation.</db:para>
<db:para>The sole purpose of this function is to provide a means of fine tuning <db:link xlink:href="qlist.xml">QList</db:link>'s memory usage. In general, you will rarely ever need to call this function. If you want to know how many items are in the list, call <db:link xlink:href="qlist.xml#size">size</db:link>().</db:para>
<db:note>
<db:para>a statically allocated list will report a capacity of 0, even if it's not empty.</db:para>
</db:note>
<db:warning>
<db:para>The free space position in the allocated memory block is undefined. In other words, you should not assume that the free memory is always located at the end of the list. You can call <db:link xlink:href="qlist.xml#reserve">reserve</db:link>() to ensure that there is enough space at the end.</db:para>
</db:warning>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qlist.xml#reserve">reserve</db:link>()</db:member>
<db:member><db:link xlink:href="qlist.xml#squeeze">squeeze</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="cbegin">
<db:title>QList::const_iterator QList::cbegin() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QList::const_iterator</db:type>
<db:methodname>cbegin</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QList::const_iterator cbegin() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns a const <db:link xlink:href="containers.xml#stl-style-iterators">STL-style iterator</db:link> pointing to the first item in the list.</db:para>
<db:warning>
<db:para>The returned iterator is invalidated on detachment or when the <db:link xlink:href="qlist.xml">QList</db:link> is modified.</db:para>
</db:warning>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qlist.xml#begin">begin</db:link>()</db:member>
<db:member><db:link xlink:href="qlist.xml#cend">cend</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="cend">
<db:title>QList::const_iterator QList::cend() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QList::const_iterator</db:type>
<db:methodname>cend</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QList::const_iterator cend() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns a const <db:link xlink:href="containers.xml#stl-style-iterators">STL-style iterator</db:link> pointing just after the last item in the list.</db:para>
<db:warning>
<db:para>The returned iterator is invalidated on detachment or when the <db:link xlink:href="qlist.xml">QList</db:link> is modified.</db:para>
</db:warning>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qlist.xml#cbegin">cbegin</db:link>()</db:member>
<db:member><db:link xlink:href="qlist.xml#end">end</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="clear">
<db:title>void QList::clear()</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>clear</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void clear()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Removes all the elements from the list.</db:para>
<db:para>If this list is not shared, the <db:link xlink:href="qlist.xml#capacity">capacity</db:link>() is preserved. Use <db:link xlink:href="qlist.xml#squeeze">squeeze</db:link>() to shed excess capacity.</db:para>
<db:note>
<db:para>In Qt versions prior to 5.7 (for <db:link xlink:href="qvector.xml">QVector</db:link>) and 6.0 (for <db:link xlink:href="qlist.xml">QList</db:link>), this function released the memory used by the list instead of preserving the capacity.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qlist.xml#resize">resize</db:link>()</db:member>
<db:member><db:link xlink:href="qlist.xml#squeeze">squeeze</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="constBegin">
<db:title>QList::const_iterator QList::constBegin() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QList::const_iterator</db:type>
<db:methodname>constBegin</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QList::const_iterator constBegin() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns a const <db:link xlink:href="containers.xml#stl-style-iterators">STL-style iterator</db:link> pointing to the first item in the list.</db:para>
<db:warning>
<db:para>The returned iterator is invalidated on detachment or when the <db:link xlink:href="qlist.xml">QList</db:link> is modified.</db:para>
</db:warning>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qlist.xml#begin">begin</db:link>()</db:member>
<db:member><db:link xlink:href="qlist.xml#constEnd">constEnd</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="constData">
<db:title>QList::const_pointer QList::constData() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QList::const_pointer</db:type>
<db:methodname>constData</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QList::const_pointer constData() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns a const pointer to the data stored in the list. The pointer can be used to access the items in the list.</db:para>
<db:warning>
<db:para>The pointer is invalidated on detachment or when the <db:link xlink:href="qlist.xml">QList</db:link> is modified.</db:para>
</db:warning>
<db:para>This function is mostly useful to pass a list to a function that accepts a plain C++ array.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qlist.xml#data">data</db:link>()</db:member>
<db:member><db:link xlink:href="qlist.xml#operator-5b-5d">operator[]</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="constEnd">
<db:title>QList::const_iterator QList::constEnd() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QList::const_iterator</db:type>
<db:methodname>constEnd</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QList::const_iterator constEnd() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns a const <db:link xlink:href="containers.xml#stl-style-iterators">STL-style iterator</db:link> pointing just after the last item in the list.</db:para>
<db:warning>
<db:para>The returned iterator is invalidated on detachment or when the <db:link xlink:href="qlist.xml">QList</db:link> is modified.</db:para>
</db:warning>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qlist.xml#constBegin">constBegin</db:link>()</db:member>
<db:member><db:link xlink:href="qlist.xml#end">end</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="constFirst">
<db:title>const T &amp;QList::constFirst() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>const T &amp;</db:type>
<db:methodname>constFirst</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">const T &amp; constFirst() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns a const reference to the first item in the list. This function assumes that the list isn't empty.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qlist.xml#constLast">constLast</db:link>()</db:member>
<db:member><db:link xlink:href="qlist.xml#isEmpty">isEmpty</db:link>()</db:member>
<db:member><db:link xlink:href="qlist.xml#first">first</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="constLast">
<db:title>const T &amp;QList::constLast() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>const T &amp;</db:type>
<db:methodname>constLast</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">const T &amp; constLast() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns a const reference to the last item in the list. This function assumes that the list isn't empty.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qlist.xml#constFirst">constFirst</db:link>()</db:member>
<db:member><db:link xlink:href="qlist.xml#isEmpty">isEmpty</db:link>()</db:member>
<db:member><db:link xlink:href="qlist.xml#last">last</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="contains">
<db:title>bool QList::contains(const AT &amp;<db:emphasis>value</db:emphasis>) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>bool</db:type>
<db:methodname>contains</db:methodname>
<db:methodparam>
<db:type>const AT &amp;</db:type>
<db:parameter>value</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool contains(const AT &amp;value) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns <db:code>true</db:code> if the list contains an occurrence of <db:code role="parameter">value</db:code>; otherwise returns <db:code>false</db:code>.</db:para>
<db:para>This function requires the value type to have an implementation of <db:code>operator==()</db:code>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qlist.xml#indexOf">indexOf</db:link>()</db:member>
<db:member><db:link xlink:href="qlist.xml#count-1">count</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="count">
<db:title>qsizetype QList::count(const AT &amp;<db:emphasis>value</db:emphasis>) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>qsizetype</db:type>
<db:methodname>count</db:methodname>
<db:methodparam>
<db:type>const AT &amp;</db:type>
<db:parameter>value</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">qsizetype count(const AT &amp;value) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the number of occurrences of <db:code role="parameter">value</db:code> in the list.</db:para>
<db:para>This function requires the value type to have an implementation of <db:code>operator==()</db:code>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qlist.xml#contains">contains</db:link>()</db:member>
<db:member><db:link xlink:href="qlist.xml#indexOf">indexOf</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="count-1">
<db:title>qsizetype QList::count() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>qsizetype</db:type>
<db:methodname>count</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">qsizetype count() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>Same as <db:link xlink:href="qlist.xml#size">size</db:link>().</db:para>
</db:section>
<db:section xml:id="crbegin">
<db:title>QList::const_reverse_iterator QList::crbegin() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QList::const_reverse_iterator</db:type>
<db:methodname>crbegin</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QList::const_reverse_iterator crbegin() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns a const <db:link xlink:href="containers.xml#stl-style-iterators">STL-style</db:link> reverse iterator pointing to the first item in the list, in reverse order.</db:para>
<db:warning>
<db:para>The returned iterator is invalidated on detachment or when the <db:link xlink:href="qlist.xml">QList</db:link> is modified.</db:para>
</db:warning>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qlist.xml#begin">begin</db:link>()</db:member>
<db:member><db:link xlink:href="qlist.xml#rbegin">rbegin</db:link>()</db:member>
<db:member><db:link xlink:href="qlist.xml#rend">rend</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="crend">
<db:title>QList::const_reverse_iterator QList::crend() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QList::const_reverse_iterator</db:type>
<db:methodname>crend</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QList::const_reverse_iterator crend() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns a const <db:link xlink:href="containers.xml#stl-style-iterators">STL-style</db:link> reverse iterator pointing just after the last item in the list, in reverse order.</db:para>
<db:warning>
<db:para>The returned iterator is invalidated on detachment or when the <db:link xlink:href="qlist.xml">QList</db:link> is modified.</db:para>
</db:warning>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qlist.xml#end">end</db:link>()</db:member>
<db:member><db:link xlink:href="qlist.xml#rend">rend</db:link>()</db:member>
<db:member><db:link xlink:href="qlist.xml#rbegin">rbegin</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="data">
<db:title>QList::pointer QList::data()</db:title>
<db:methodsynopsis>
<db:type>QList::pointer</db:type>
<db:methodname>data</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QList::pointer data()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns a pointer to the data stored in the list. The pointer can be used to access and modify the items in the list.</db:para>
<db:para>Example:</db:para>
<db:programlisting language="cpp">QList&amp;lt;int&amp;gt; list(10);
int *data = list.data();
for (qsizetype i = 0; i &amp;lt; 10; ++i)
    data[i] = 2 * i;
</db:programlisting>
<db:warning>
<db:para>The pointer is invalidated on detachment or when the <db:link xlink:href="qlist.xml">QList</db:link> is modified.</db:para>
</db:warning>
<db:para>This function is mostly useful to pass a list to a function that accepts a plain C++ array.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qlist.xml#constData">constData</db:link>()</db:member>
<db:member><db:link xlink:href="qlist.xml#operator-5b-5d">operator[]</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="data-1">
<db:title>QList::const_pointer QList::data() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QList::const_pointer</db:type>
<db:methodname>data</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">QList::const_pointer data() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
</db:section>
<db:section xml:id="emplace">
<db:title>QList::iterator QList::emplace(qsizetype <db:emphasis>i</db:emphasis>, Args &amp;&amp;... <db:emphasis>args</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>QList::iterator</db:type>
<db:methodname>emplace</db:methodname>
<db:methodparam>
<db:type>qsizetype</db:type>
<db:parameter>i</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>Args &amp;&amp;...</db:type>
<db:parameter>args</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QList::iterator emplace(qsizetype i, Args &amp;&amp;... args)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Extends the container by inserting a new element at position <db:code role="parameter">i</db:code>. This new element is constructed in-place using <db:code role="parameter">args</db:code> as the arguments for its construction.</db:para>
<db:para>Returns an iterator to the new element.</db:para>
<db:para>Example:</db:para>
<db:programlisting language="cpp">QList&amp;lt;QString&amp;gt; list{&quot;a&quot;, &quot;ccc&quot;};
list.emplace(1, 2, 'b');
// list: [&quot;a&quot;, &quot;bb&quot;, &quot;ccc&quot;]
</db:programlisting>
<db:note>
<db:para>It is guaranteed that the element will be created in place at the beginning, but after that it might be copied or moved to the right position.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qlist.xml#emplaceBack">emplaceBack</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="emplace-1">
<db:title>QList::iterator QList::emplace(QList::const_iterator <db:emphasis>before</db:emphasis>, Args &amp;&amp;... <db:emphasis>args</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>QList::iterator</db:type>
<db:methodname>emplace</db:methodname>
<db:methodparam>
<db:type>QList::const_iterator</db:type>
<db:parameter>before</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>Args &amp;&amp;...</db:type>
<db:parameter>args</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">QList::iterator emplace(QList::const_iterator before, Args &amp;&amp;... args)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>Creates a new element in front of the item pointed to by the iterator <db:code role="parameter">before</db:code>. This new element is constructed in-place using <db:code role="parameter">args</db:code> as the arguments for its construction.</db:para>
<db:para>Returns an iterator to the new element.</db:para>
</db:section>
<db:section xml:id="empty">
<db:title>bool QList::empty() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>bool</db:type>
<db:methodname>empty</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool empty() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This function is provided for STL compatibility. It is equivalent to <db:link xlink:href="qlist.xml#isEmpty">isEmpty</db:link>(), returning <db:code>true</db:code> if the list is empty; otherwise returns <db:code>false</db:code>.</db:para>
</db:section>
<db:section xml:id="end">
<db:title>QList::iterator QList::end()</db:title>
<db:methodsynopsis>
<db:type>QList::iterator</db:type>
<db:methodname>end</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QList::iterator end()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns an <db:link xlink:href="containers.xml#stl-style-iterators">STL-style iterator</db:link> pointing just after the last item in the list.</db:para>
<db:warning>
<db:para>The returned iterator is invalidated on detachment or when the <db:link xlink:href="qlist.xml">QList</db:link> is modified.</db:para>
</db:warning>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qlist.xml#begin">begin</db:link>()</db:member>
<db:member><db:link xlink:href="qlist.xml#constEnd">constEnd</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="end-1">
<db:title>QList::const_iterator QList::end() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QList::const_iterator</db:type>
<db:methodname>end</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">QList::const_iterator end() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
</db:section>
<db:section xml:id="endsWith">
<db:title>bool QList::endsWith(QList::parameter_type <db:emphasis>value</db:emphasis>) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>bool</db:type>
<db:methodname>endsWith</db:methodname>
<db:methodparam>
<db:type>QList::parameter_type</db:type>
<db:parameter>value</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool endsWith(QList::parameter_type value) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns <db:code>true</db:code> if this list is not empty and its last item is equal to <db:code role="parameter">value</db:code>; otherwise returns <db:code>false</db:code>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qlist.xml#isEmpty">isEmpty</db:link>()</db:member>
<db:member><db:link xlink:href="qlist.xml#last">last</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="erase">
<db:title>QList::iterator QList::erase(QList::const_iterator <db:emphasis>pos</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>QList::iterator</db:type>
<db:methodname>erase</db:methodname>
<db:methodparam>
<db:type>QList::const_iterator</db:type>
<db:parameter>pos</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QList::iterator erase(QList::const_iterator pos)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Removes the item pointed to by the iterator <db:code role="parameter">pos</db:code> from the list, and returns an iterator to the next item in the list (which may be <db:link xlink:href="qlist.xml#end">end</db:link>()).</db:para>
<db:para>Element removal will preserve the list's capacity and not reduce the amount of allocated memory. To shed extra capacity and free as much memory as possible, call <db:link xlink:href="qlist.xml#squeeze">squeeze</db:link>().</db:para>
<db:note>
<db:para>When <db:link xlink:href="qlist.xml">QList</db:link> is not <db:link xlink:href="implicit-sharing.xml">implicitly shared</db:link>, this function only invalidates iterators at or after the specified position.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qlist.xml#insert">insert</db:link>()</db:member>
<db:member><db:link xlink:href="qlist.xml#remove">remove</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="erase-1">
<db:title>QList::iterator QList::erase(QList::const_iterator <db:emphasis>begin</db:emphasis>, QList::const_iterator <db:emphasis>end</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>QList::iterator</db:type>
<db:methodname>erase</db:methodname>
<db:methodparam>
<db:type>QList::const_iterator</db:type>
<db:parameter>begin</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>QList::const_iterator</db:type>
<db:parameter>end</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">QList::iterator erase(QList::const_iterator begin, QList::const_iterator end)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>Removes all the items from <db:code role="parameter">begin</db:code> up to (but not including) <db:code role="parameter">end</db:code>. Returns an iterator to the same item that <db:code role="parameter">end</db:code> referred to before the call.</db:para>
<db:para>Element removal will preserve the list's capacity and not reduce the amount of allocated memory. To shed extra capacity and free as much memory as possible, call <db:link xlink:href="qlist.xml#squeeze">squeeze</db:link>().</db:para>
<db:note>
<db:para>When <db:link xlink:href="qlist.xml">QList</db:link> is not <db:link xlink:href="implicit-sharing.xml">implicitly shared</db:link>, this function only invalidates iterators at or after the specified position.</db:para>
</db:note>
</db:section>
<db:section xml:id="fill">
<db:title>QList&lt;T&gt; &amp;QList::fill(QList::parameter_type <db:emphasis>value</db:emphasis>, qsizetype <db:emphasis>size</db:emphasis> = -1)</db:title>
<db:methodsynopsis>
<db:type>QList&lt;T&gt; &amp;</db:type>
<db:methodname>fill</db:methodname>
<db:methodparam>
<db:type>QList::parameter_type</db:type>
<db:parameter>value</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>qsizetype</db:type>
<db:parameter>size</db:parameter>
<db:initializer>-1</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QList&lt;T&gt; &amp; fill(QList::parameter_type value, qsizetype size)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Assigns <db:code role="parameter">value</db:code> to all items in the list. If <db:code role="parameter">size</db:code> is different from -1 (the default), the list is resized to <db:code role="parameter">size</db:code> beforehand.</db:para>
<db:para>Example:</db:para>
<db:programlisting language="cpp">QList&amp;lt;QString&amp;gt; list(3);
list.fill(&quot;Yes&quot;);
// list: [&quot;Yes&quot;, &quot;Yes&quot;, &quot;Yes&quot;]

list.fill(&quot;oh&quot;, 5);
// list: [&quot;oh&quot;, &quot;oh&quot;, &quot;oh&quot;, &quot;oh&quot;, &quot;oh&quot;]
</db:programlisting>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qlist.xml#resize">resize</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="first">
<db:title>T &amp;QList::first()</db:title>
<db:methodsynopsis>
<db:type>T &amp;</db:type>
<db:methodname>first</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">T &amp; first()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns a reference to the first item in the list. This function assumes that the list isn't empty.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qlist.xml#last">last</db:link>()</db:member>
<db:member><db:link xlink:href="qlist.xml#isEmpty">isEmpty</db:link>()</db:member>
<db:member><db:link xlink:href="qlist.xml#constFirst">constFirst</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="first-1">
<db:title>const T &amp;QList::first() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>const T &amp;</db:type>
<db:methodname>first</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">const T &amp; first() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
</db:section>
<db:section xml:id="first-2">
<db:title>[since 6.0] QList&lt;T&gt; QList::first(qsizetype <db:emphasis>n</db:emphasis>) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QList&lt;T&gt;</db:type>
<db:methodname>first</db:methodname>
<db:methodparam>
<db:type>qsizetype</db:type>
<db:parameter>n</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">2</db:synopsisinfo>
<db:synopsisinfo role="signature">QList&lt;T&gt; first(qsizetype n) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns a sub-list that contains the first <db:code role="parameter">n</db:code> elements of this list.</db:para>
<db:note>
<db:para>The behavior is undefined when <db:code role="parameter">n</db:code> &lt; 0 or <db:code role="parameter">n</db:code> &gt; <db:link xlink:href="qlist.xml#size">size</db:link>().</db:para>
</db:note>
<db:para>This function was introduced in Qt 6.0.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qlist.xml#last">last</db:link>()</db:member>
<db:member><db:link xlink:href="qlist.xml#sliced">sliced</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="front">
<db:title>QList::reference QList::front()</db:title>
<db:methodsynopsis>
<db:type>QList::reference</db:type>
<db:methodname>front</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QList::reference front()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This function is provided for STL compatibility. It is equivalent to <db:link xlink:href="qlist.xml#first">first</db:link>().</db:para>
</db:section>
<db:section xml:id="front-1">
<db:title>QList::const_reference QList::front() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QList::const_reference</db:type>
<db:methodname>front</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">QList::const_reference front() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
</db:section>
<db:section xml:id="indexOf">
<db:title>qsizetype QList::indexOf(const AT &amp;<db:emphasis>value</db:emphasis>, qsizetype <db:emphasis>from</db:emphasis> = 0) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>qsizetype</db:type>
<db:methodname>indexOf</db:methodname>
<db:methodparam>
<db:type>const AT &amp;</db:type>
<db:parameter>value</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>qsizetype</db:type>
<db:parameter>from</db:parameter>
<db:initializer>0</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">qsizetype indexOf(const AT &amp;value, qsizetype from) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the index position of the first occurrence of <db:code role="parameter">value</db:code> in the list, searching forward from index position <db:code role="parameter">from</db:code>. Returns -1 if no item matched.</db:para>
<db:para>Example:</db:para>
<db:programlisting language="cpp">QList&amp;lt;QString&amp;gt; list{&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;B&quot;, &quot;A&quot;};
list.indexOf(&quot;B&quot;);            // returns 1
list.indexOf(&quot;B&quot;, 1);         // returns 1
list.indexOf(&quot;B&quot;, 2);         // returns 3
list.indexOf(&quot;X&quot;);            // returns -1
</db:programlisting>
<db:para>This function requires the value type to have an implementation of <db:code>operator==()</db:code>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qlist.xml#lastIndexOf">lastIndexOf</db:link>()</db:member>
<db:member><db:link xlink:href="qlist.xml#contains">contains</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="insert-1">
<db:title>QList::iterator QList::insert(qsizetype <db:emphasis>i</db:emphasis>, qsizetype <db:emphasis>count</db:emphasis>, QList::parameter_type <db:emphasis>value</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>QList::iterator</db:type>
<db:methodname>insert</db:methodname>
<db:methodparam>
<db:type>qsizetype</db:type>
<db:parameter>i</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>qsizetype</db:type>
<db:parameter>count</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>QList::parameter_type</db:type>
<db:parameter>value</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">QList::iterator insert(qsizetype i, qsizetype count, QList::parameter_type value)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>Inserts <db:code role="parameter">count</db:code> copies of <db:code role="parameter">value</db:code> at index position <db:code role="parameter">i</db:code> in the list.</db:para>
<db:para>Example:</db:para>
<db:programlisting language="cpp">QList&amp;lt;double&amp;gt; list = {2.718, 1.442, 0.4342};
list.insert(1, 3, 9.9);
// list: [2.718, 9.9, 9.9, 9.9, 1.442, 0.4342]
</db:programlisting>
</db:section>
<db:section xml:id="insert-3">
<db:title>QList::iterator QList::insert(QList::const_iterator <db:emphasis>before</db:emphasis>, qsizetype <db:emphasis>count</db:emphasis>, QList::parameter_type <db:emphasis>value</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>QList::iterator</db:type>
<db:methodname>insert</db:methodname>
<db:methodparam>
<db:type>QList::const_iterator</db:type>
<db:parameter>before</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>qsizetype</db:type>
<db:parameter>count</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>QList::parameter_type</db:type>
<db:parameter>value</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">3</db:synopsisinfo>
<db:synopsisinfo role="signature">QList::iterator insert(QList::const_iterator before, qsizetype count, QList::parameter_type value)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Inserts <db:code role="parameter">count</db:code> copies of <db:code role="parameter">value</db:code> in front of the item pointed to by the iterator <db:code role="parameter">before</db:code>. Returns an iterator pointing at the first of the inserted items.</db:para>
</db:section>
<db:section xml:id="isEmpty">
<db:title>bool QList::isEmpty() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>bool</db:type>
<db:methodname>isEmpty</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool isEmpty() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns <db:code>true</db:code> if the list has size 0; otherwise returns <db:code>false</db:code>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qlist.xml#size">size</db:link>()</db:member>
<db:member><db:link xlink:href="qlist.xml#resize">resize</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="last">
<db:title>T &amp;QList::last()</db:title>
<db:methodsynopsis>
<db:type>T &amp;</db:type>
<db:methodname>last</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">T &amp; last()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns a reference to the last item in the list. This function assumes that the list isn't empty.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qlist.xml#first">first</db:link>()</db:member>
<db:member><db:link xlink:href="qlist.xml#isEmpty">isEmpty</db:link>()</db:member>
<db:member><db:link xlink:href="qlist.xml#constLast">constLast</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="last-1">
<db:title>const T &amp;QList::last() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>const T &amp;</db:type>
<db:methodname>last</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">const T &amp; last() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
</db:section>
<db:section xml:id="last-2">
<db:title>[since 6.0] QList&lt;T&gt; QList::last(qsizetype <db:emphasis>n</db:emphasis>) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QList&lt;T&gt;</db:type>
<db:methodname>last</db:methodname>
<db:methodparam>
<db:type>qsizetype</db:type>
<db:parameter>n</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">2</db:synopsisinfo>
<db:synopsisinfo role="signature">QList&lt;T&gt; last(qsizetype n) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns a sub-list that contains the last <db:code role="parameter">n</db:code> elements of this list.</db:para>
<db:note>
<db:para>The behavior is undefined when <db:code role="parameter">n</db:code> &lt; 0 or <db:code role="parameter">n</db:code> &gt; <db:link xlink:href="qlist.xml#size">size</db:link>().</db:para>
</db:note>
<db:para>This function was introduced in Qt 6.0.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qlist.xml#first">first</db:link>()</db:member>
<db:member><db:link xlink:href="qlist.xml#sliced">sliced</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="lastIndexOf">
<db:title>qsizetype QList::lastIndexOf(const AT &amp;<db:emphasis>value</db:emphasis>, qsizetype <db:emphasis>from</db:emphasis> = -1) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>qsizetype</db:type>
<db:methodname>lastIndexOf</db:methodname>
<db:methodparam>
<db:type>const AT &amp;</db:type>
<db:parameter>value</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>qsizetype</db:type>
<db:parameter>from</db:parameter>
<db:initializer>-1</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">qsizetype lastIndexOf(const AT &amp;value, qsizetype from) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the index position of the last occurrence of the value <db:code role="parameter">value</db:code> in the list, searching backward from index position <db:code role="parameter">from</db:code>. If <db:code role="parameter">from</db:code> is -1 (the default), the search starts at the last item. Returns -1 if no item matched.</db:para>
<db:para>Example:</db:para>
<db:programlisting language="cpp">QList&amp;lt;QString&amp;gt; list = {&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;B&quot;, &quot;A&quot;};
list.lastIndexOf(&quot;B&quot;);        // returns 3
list.lastIndexOf(&quot;B&quot;, 3);     // returns 3
list.lastIndexOf(&quot;B&quot;, 2);     // returns 1
list.lastIndexOf(&quot;X&quot;);        // returns -1
</db:programlisting>
<db:para>This function requires the value type to have an implementation of <db:code>operator==()</db:code>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qlist.xml#indexOf">indexOf</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="length">
<db:title>qsizetype QList::length() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>qsizetype</db:type>
<db:methodname>length</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">qsizetype length() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Same as <db:link xlink:href="qlist.xml#size">size</db:link>() and <db:link xlink:href="qlist.xml#count-1">count</db:link>().</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qlist.xml#size">size</db:link>()</db:member>
<db:member><db:link xlink:href="qlist.xml#count-1">count</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="mid">
<db:title>QList&lt;T&gt; QList::mid(qsizetype <db:emphasis>pos</db:emphasis>, qsizetype <db:emphasis>length</db:emphasis> = -1) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QList&lt;T&gt;</db:type>
<db:methodname>mid</db:methodname>
<db:methodparam>
<db:type>qsizetype</db:type>
<db:parameter>pos</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>qsizetype</db:type>
<db:parameter>length</db:parameter>
<db:initializer>-1</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QList&lt;T&gt; mid(qsizetype pos, qsizetype length) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns a sub-list which contains elements from this list, starting at position <db:code role="parameter">pos</db:code>. If <db:code role="parameter">length</db:code> is -1 (the default), all elements after <db:code role="parameter">pos</db:code> are included; otherwise <db:code role="parameter">length</db:code> elements (or all remaining elements if there are less than <db:code role="parameter">length</db:code> elements) are included.</db:para>
</db:section>
<db:section xml:id="move">
<db:title>void QList::move(qsizetype <db:emphasis>from</db:emphasis>, qsizetype <db:emphasis>to</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>move</db:methodname>
<db:methodparam>
<db:type>qsizetype</db:type>
<db:parameter>from</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>qsizetype</db:type>
<db:parameter>to</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void move(qsizetype from, qsizetype to)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Moves the item at index position <db:code role="parameter">from</db:code> to index position <db:code role="parameter">to</db:code>.</db:para>
</db:section>
<db:section xml:id="pop_back">
<db:title>void QList::pop_back()</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>pop_back</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void pop_back()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This function is provided for STL compatibility. It is equivalent to <db:link xlink:href="qlist.xml#removeLast">removeLast</db:link>().</db:para>
</db:section>
<db:section xml:id="pop_front">
<db:title>void QList::pop_front()</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>pop_front</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void pop_front()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This function is provided for STL compatibility. It is equivalent to <db:link xlink:href="qlist.xml#removeFirst">removeFirst</db:link>().</db:para>
</db:section>
<db:section xml:id="push_back">
<db:title>void QList::push_back(QList::parameter_type <db:emphasis>value</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>push_back</db:methodname>
<db:methodparam>
<db:type>QList::parameter_type</db:type>
<db:parameter>value</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void push_back(QList::parameter_type value)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This function is provided for STL compatibility. It is equivalent to append(<db:code role="parameter">value</db:code>).</db:para>
</db:section>
<db:section xml:id="push_back-1">
<db:title>void QList::push_back(QList::rvalue_ref <db:emphasis>value</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>push_back</db:methodname>
<db:methodparam>
<db:type>QList::rvalue_ref</db:type>
<db:parameter>value</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">void push_back(QList::rvalue_ref value)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
</db:section>
<db:section xml:id="rbegin">
<db:title>QList::reverse_iterator QList::rbegin()</db:title>
<db:methodsynopsis>
<db:type>QList::reverse_iterator</db:type>
<db:methodname>rbegin</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QList::reverse_iterator rbegin()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns a <db:link xlink:href="containers.xml#stl-style-iterators">STL-style</db:link> reverse iterator pointing to the first item in the list, in reverse order.</db:para>
<db:warning>
<db:para>The returned iterator is invalidated on detachment or when the <db:link xlink:href="qlist.xml">QList</db:link> is modified.</db:para>
</db:warning>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qlist.xml#begin">begin</db:link>()</db:member>
<db:member><db:link xlink:href="qlist.xml#crbegin">crbegin</db:link>()</db:member>
<db:member><db:link xlink:href="qlist.xml#rend">rend</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="rbegin-1">
<db:title>QList::const_reverse_iterator QList::rbegin() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QList::const_reverse_iterator</db:type>
<db:methodname>rbegin</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">QList::const_reverse_iterator rbegin() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
</db:section>
<db:section xml:id="remove">
<db:title>void QList::remove(qsizetype <db:emphasis>i</db:emphasis>, qsizetype <db:emphasis>n</db:emphasis> = 1)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>remove</db:methodname>
<db:methodparam>
<db:type>qsizetype</db:type>
<db:parameter>i</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>qsizetype</db:type>
<db:parameter>n</db:parameter>
<db:initializer>1</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void remove(qsizetype i, qsizetype n)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Removes <db:code role="parameter">n</db:code> elements from the list, starting at index position <db:code role="parameter">i</db:code>.</db:para>
<db:para>Element removal will preserve the list's capacity and not reduce the amount of allocated memory. To shed extra capacity and free as much memory as possible, call <db:link xlink:href="qlist.xml#squeeze">squeeze</db:link>().</db:para>
<db:note>
<db:para>When <db:link xlink:href="qlist.xml">QList</db:link> is not <db:link xlink:href="implicit-sharing.xml">implicitly shared</db:link>, this function only invalidates iterators at or after the specified position.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qlist.xml#insert">insert</db:link>()</db:member>
<db:member><db:link xlink:href="qlist.xml#replace">replace</db:link>()</db:member>
<db:member><db:link xlink:href="qlist.xml#fill">fill</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="removeAll">
<db:title>qsizetype QList::removeAll(const AT &amp;<db:emphasis>t</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>qsizetype</db:type>
<db:methodname>removeAll</db:methodname>
<db:methodparam>
<db:type>const AT &amp;</db:type>
<db:parameter>t</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">qsizetype removeAll(const AT &amp;t)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Removes all elements that compare equal to <db:code role="parameter">t</db:code> from the list. Returns the number of elements removed, if any.</db:para>
<db:para>Element removal will preserve the list's capacity and not reduce the amount of allocated memory. To shed extra capacity and free as much memory as possible, call <db:link xlink:href="qlist.xml#squeeze">squeeze</db:link>().</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qlist.xml#removeOne">removeOne</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="removeAt">
<db:title>void QList::removeAt(qsizetype <db:emphasis>i</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>removeAt</db:methodname>
<db:methodparam>
<db:type>qsizetype</db:type>
<db:parameter>i</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void removeAt(qsizetype i)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Removes the element at index position <db:code role="parameter">i</db:code>. Equivalent to</db:para>
<db:programlisting language="cpp">remove(i);
</db:programlisting>
<db:para>Element removal will preserve the list's capacity and not reduce the amount of allocated memory. To shed extra capacity and free as much memory as possible, call <db:link xlink:href="qlist.xml#squeeze">squeeze</db:link>().</db:para>
<db:note>
<db:para>When <db:link xlink:href="qlist.xml">QList</db:link> is not <db:link xlink:href="implicit-sharing.xml">implicitly shared</db:link>, this function only invalidates iterators at or after the specified position.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qlist.xml#remove">remove</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="removeFirst">
<db:title>void QList::removeFirst()</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>removeFirst</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void removeFirst()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Removes the first item in the list. Calling this function is equivalent to calling remove(0). The list must not be empty. If the list can be empty, call <db:link xlink:href="qlist.xml#isEmpty">isEmpty</db:link>() before calling this function.</db:para>
<db:para>Element removal will preserve the list's capacity and not reduce the amount of allocated memory. To shed extra capacity and free as much memory as possible, call <db:link xlink:href="qlist.xml#squeeze">squeeze</db:link>().</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qlist.xml#remove">remove</db:link>()</db:member>
<db:member><db:link xlink:href="qlist.xml#takeFirst">takeFirst</db:link>()</db:member>
<db:member><db:link xlink:href="qlist.xml#isEmpty">isEmpty</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="removeIf">
<db:title>[since 6.1] qsizetype QList::removeIf(Predicate <db:emphasis>pred</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>qsizetype</db:type>
<db:methodname>removeIf</db:methodname>
<db:methodparam>
<db:type>Predicate</db:type>
<db:parameter>pred</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">qsizetype removeIf(Predicate pred)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Removes all elements for which the predicate <db:code role="parameter">pred</db:code> returns true from the list. Returns the number of elements removed, if any.</db:para>
<db:para>This function was introduced in Qt 6.1.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qlist.xml#removeAll">removeAll</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="removeLast">
<db:title>void QList::removeLast()</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>removeLast</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void removeLast()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Removes the last item in the list. Calling this function is equivalent to calling remove(<db:link xlink:href="qlist.xml#size">size</db:link>() - 1). The list must not be empty. If the list can be empty, call <db:link xlink:href="qlist.xml#isEmpty">isEmpty</db:link>() before calling this function.</db:para>
<db:para>Element removal will preserve the list's capacity and not reduce the amount of allocated memory. To shed extra capacity and free as much memory as possible, call <db:link xlink:href="qlist.xml#squeeze">squeeze</db:link>().</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qlist.xml#remove">remove</db:link>()</db:member>
<db:member><db:link xlink:href="qlist.xml#takeLast">takeLast</db:link>()</db:member>
<db:member><db:link xlink:href="qlist.xml#removeFirst">removeFirst</db:link>()</db:member>
<db:member><db:link xlink:href="qlist.xml#isEmpty">isEmpty</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="removeOne">
<db:title>bool QList::removeOne(const AT &amp;<db:emphasis>t</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>bool</db:type>
<db:methodname>removeOne</db:methodname>
<db:methodparam>
<db:type>const AT &amp;</db:type>
<db:parameter>t</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool removeOne(const AT &amp;t)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Removes the first element that compares equal to <db:code role="parameter">t</db:code> from the list. Returns whether an element was, in fact, removed.</db:para>
<db:para>Element removal will preserve the list's capacity and not reduce the amount of allocated memory. To shed extra capacity and free as much memory as possible, call <db:link xlink:href="qlist.xml#squeeze">squeeze</db:link>().</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qlist.xml#removeAll">removeAll</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="rend">
<db:title>QList::reverse_iterator QList::rend()</db:title>
<db:methodsynopsis>
<db:type>QList::reverse_iterator</db:type>
<db:methodname>rend</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QList::reverse_iterator rend()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns a <db:link xlink:href="containers.xml#stl-style-iterators">STL-style</db:link> reverse iterator pointing just after the last item in the list, in reverse order.</db:para>
<db:warning>
<db:para>The returned iterator is invalidated on detachment or when the <db:link xlink:href="qlist.xml">QList</db:link> is modified.</db:para>
</db:warning>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qlist.xml#end">end</db:link>()</db:member>
<db:member><db:link xlink:href="qlist.xml#crend">crend</db:link>()</db:member>
<db:member><db:link xlink:href="qlist.xml#rbegin">rbegin</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="rend-1">
<db:title>QList::const_reverse_iterator QList::rend() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QList::const_reverse_iterator</db:type>
<db:methodname>rend</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">QList::const_reverse_iterator rend() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
</db:section>
<db:section xml:id="reserve">
<db:title>void QList::reserve(qsizetype <db:emphasis>size</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>reserve</db:methodname>
<db:methodparam>
<db:type>qsizetype</db:type>
<db:parameter>size</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void reserve(qsizetype size)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Attempts to allocate memory for at least <db:code role="parameter">size</db:code> elements.</db:para>
<db:para>If you know in advance how large the list will be, you should call this function to prevent reallocations and memory fragmentation. If you resize the list often, you are also likely to get better performance.</db:para>
<db:para>If in doubt about how much space shall be needed, it is usually better to use an upper bound as <db:code role="parameter">size</db:code>, or a high estimate of the most likely size, if a strict upper bound would be much bigger than this. If <db:code role="parameter">size</db:code> is an underestimate, the list will grow as needed once the reserved size is exceeded, which may lead to a larger allocation than your best overestimate would have and will slow the operation that triggers it.</db:para>
<db:warning>
<db:para>reserve() reserves memory but does not change the size of the list. Accessing data beyond the current end of the list is undefined behavior. If you need to access memory beyond the current end of the list, use <db:link xlink:href="qlist.xml#resize">resize</db:link>().</db:para>
</db:warning>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qlist.xml#squeeze">squeeze</db:link>()</db:member>
<db:member><db:link xlink:href="qlist.xml#capacity">capacity</db:link>()</db:member>
<db:member><db:link xlink:href="qlist.xml#resize">resize</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="shrink_to_fit">
<db:title>void QList::shrink_to_fit()</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>shrink_to_fit</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void shrink_to_fit()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This function is provided for STL compatibility. It is equivalent to <db:link xlink:href="qlist.xml#squeeze">squeeze</db:link>().</db:para>
</db:section>
<db:section xml:id="size">
<db:title>qsizetype QList::size() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>qsizetype</db:type>
<db:methodname>size</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">qsizetype size() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the number of items in the list.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qlist.xml#isEmpty">isEmpty</db:link>()</db:member>
<db:member><db:link xlink:href="qlist.xml#resize">resize</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="sliced">
<db:title>[since 6.0] QList&lt;T&gt; QList::sliced(qsizetype <db:emphasis>pos</db:emphasis>, qsizetype <db:emphasis>n</db:emphasis>) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QList&lt;T&gt;</db:type>
<db:methodname>sliced</db:methodname>
<db:methodparam>
<db:type>qsizetype</db:type>
<db:parameter>pos</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>qsizetype</db:type>
<db:parameter>n</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QList&lt;T&gt; sliced(qsizetype pos, qsizetype n) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns a sub-list that contains <db:code role="parameter">n</db:code> elements of this list, starting at position <db:code role="parameter">pos</db:code>.</db:para>
<db:note>
<db:para>The behavior is undefined when <db:code role="parameter">pos</db:code> &lt; 0, <db:code role="parameter">n</db:code> &lt; 0, or <db:code role="parameter">pos</db:code> + <db:code role="parameter">n</db:code> &gt; <db:link xlink:href="qlist.xml#size">size</db:link>().</db:para>
</db:note>
<db:para>This function was introduced in Qt 6.0.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qlist.xml#first">first</db:link>()</db:member>
<db:member><db:link xlink:href="qlist.xml#last">last</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="sliced-1">
<db:title>[since 6.0] QList&lt;T&gt; QList::sliced(qsizetype <db:emphasis>pos</db:emphasis>) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QList&lt;T&gt;</db:type>
<db:methodname>sliced</db:methodname>
<db:methodparam>
<db:type>qsizetype</db:type>
<db:parameter>pos</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">QList&lt;T&gt; sliced(qsizetype pos) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>Returns a sub-list that contains the elements of this list starting at position <db:code role="parameter">pos</db:code> and extending to its end.</db:para>
<db:note>
<db:para>The behavior is undefined when <db:code role="parameter">pos</db:code> &lt; 0 or <db:code role="parameter">pos</db:code> &gt; <db:link xlink:href="qlist.xml#size">size</db:link>().</db:para>
</db:note>
<db:para>This function was introduced in Qt 6.0.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qlist.xml#first">first</db:link>()</db:member>
<db:member><db:link xlink:href="qlist.xml#last">last</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="squeeze">
<db:title>void QList::squeeze()</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>squeeze</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void squeeze()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Releases any memory not required to store the items.</db:para>
<db:para>The sole purpose of this function is to provide a means of fine tuning <db:link xlink:href="qlist.xml">QList</db:link>'s memory usage. In general, you will rarely ever need to call this function.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qlist.xml#reserve">reserve</db:link>()</db:member>
<db:member><db:link xlink:href="qlist.xml#capacity">capacity</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="startsWith">
<db:title>bool QList::startsWith(QList::parameter_type <db:emphasis>value</db:emphasis>) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>bool</db:type>
<db:methodname>startsWith</db:methodname>
<db:methodparam>
<db:type>QList::parameter_type</db:type>
<db:parameter>value</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool startsWith(QList::parameter_type value) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns <db:code>true</db:code> if this list is not empty and its first item is equal to <db:code role="parameter">value</db:code>; otherwise returns <db:code>false</db:code>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qlist.xml#isEmpty">isEmpty</db:link>()</db:member>
<db:member><db:link xlink:href="qlist.xml#first">first</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="swap">
<db:title>void QList::swap(QList&lt;T&gt; &amp;<db:emphasis>other</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>swap</db:methodname>
<db:methodparam>
<db:type>QList&lt;T&gt; &amp;</db:type>
<db:parameter>other</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void swap(QList&lt;T&gt; &amp;other)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Swaps list <db:code role="parameter">other</db:code> with this list. This operation is very fast and never fails.</db:para>
</db:section>
<db:section xml:id="swapItemsAt">
<db:title>void QList::swapItemsAt(qsizetype <db:emphasis>i</db:emphasis>, qsizetype <db:emphasis>j</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>swapItemsAt</db:methodname>
<db:methodparam>
<db:type>qsizetype</db:type>
<db:parameter>i</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>qsizetype</db:type>
<db:parameter>j</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void swapItemsAt(qsizetype i, qsizetype j)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Exchange the item at index position <db:code role="parameter">i</db:code> with the item at index position <db:code role="parameter">j</db:code>. This function assumes that both <db:code role="parameter">i</db:code> and <db:code role="parameter">j</db:code> are at least 0 but less than <db:link xlink:href="qlist.xml#size">size</db:link>(). To avoid failure, test that both <db:code role="parameter">i</db:code> and <db:code role="parameter">j</db:code> are at least 0 and less than <db:link xlink:href="qlist.xml#size">size</db:link>().</db:para>
</db:section>
<db:section xml:id="takeAt">
<db:title>T QList::takeAt(qsizetype <db:emphasis>i</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>T</db:type>
<db:methodname>takeAt</db:methodname>
<db:methodparam>
<db:type>qsizetype</db:type>
<db:parameter>i</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">T takeAt(qsizetype i)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Removes the element at index position <db:code role="parameter">i</db:code> and returns it.</db:para>
<db:para>Equivalent to</db:para>
<db:programlisting language="cpp">T t = at(i);
remove(i);
return t;
</db:programlisting>
<db:note>
<db:para>When <db:link xlink:href="qlist.xml">QList</db:link> is not <db:link xlink:href="implicit-sharing.xml">implicitly shared</db:link>, this function only invalidates iterators at or after the specified position.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qlist.xml#takeFirst">takeFirst</db:link>()</db:member>
<db:member><db:link xlink:href="qlist.xml#takeLast">takeLast</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="takeFirst">
<db:title>QList::value_type QList::takeFirst()</db:title>
<db:methodsynopsis>
<db:type>QList::value_type</db:type>
<db:methodname>takeFirst</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QList::value_type takeFirst()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Removes the first item in the list and returns it. This function assumes the list is not empty. To avoid failure, call <db:link xlink:href="qlist.xml#isEmpty">isEmpty</db:link>() before calling this function.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qlist.xml#takeLast">takeLast</db:link>()</db:member>
<db:member><db:link xlink:href="qlist.xml#removeFirst">removeFirst</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="takeLast">
<db:title>QList::value_type QList::takeLast()</db:title>
<db:methodsynopsis>
<db:type>QList::value_type</db:type>
<db:methodname>takeLast</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QList::value_type takeLast()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Removes the last item in the list and returns it. This function assumes the list is not empty. To avoid failure, call <db:link xlink:href="qlist.xml#isEmpty">isEmpty</db:link>() before calling this function.</db:para>
<db:para>If you don't use the return value, <db:link xlink:href="qlist.xml#removeLast">removeLast</db:link>() is more efficient.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qlist.xml#takeFirst">takeFirst</db:link>()</db:member>
<db:member><db:link xlink:href="qlist.xml#removeLast">removeLast</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="value">
<db:title>T QList::value(qsizetype <db:emphasis>i</db:emphasis>) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>T</db:type>
<db:methodname>value</db:methodname>
<db:methodparam>
<db:type>qsizetype</db:type>
<db:parameter>i</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">T value(qsizetype i) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the value at index position <db:code role="parameter">i</db:code> in the list.</db:para>
<db:para>If the index <db:code role="parameter">i</db:code> is out of bounds, the function returns a <db:link xlink:href="containers.xml#default-constructed-value">default-constructed value</db:link>. If you are certain that <db:code role="parameter">i</db:code> is within bounds, you can use <db:link xlink:href="qlist.xml#at">at</db:link>() instead, which is slightly faster.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qlist.xml#at">at</db:link>()</db:member>
<db:member><db:link xlink:href="qlist.xml#operator-5b-5d">operator[]</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="value-1">
<db:title>T QList::value(qsizetype <db:emphasis>i</db:emphasis>, QList::parameter_type <db:emphasis>defaultValue</db:emphasis>) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>T</db:type>
<db:methodname>value</db:methodname>
<db:methodparam>
<db:type>qsizetype</db:type>
<db:parameter>i</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>QList::parameter_type</db:type>
<db:parameter>defaultValue</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">T value(qsizetype i, QList::parameter_type defaultValue) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>If the index <db:code role="parameter">i</db:code> is out of bounds, the function returns <db:code role="parameter">defaultValue</db:code>.</db:para>
</db:section>
<db:section xml:id="operator-not-eq">
<db:title>bool QList::operator!=(const QList&lt;T&gt; &amp;<db:emphasis>other</db:emphasis>) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>bool</db:type>
<db:methodname>operator!=</db:methodname>
<db:methodparam>
<db:type>const QList&lt;T&gt; &amp;</db:type>
<db:parameter>other</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool operator!=(const QList&lt;T&gt; &amp;other) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns <db:code>true</db:code> if <db:code role="parameter">other</db:code> is not equal to this list; otherwise returns <db:code>false</db:code>.</db:para>
<db:para>Two lists are considered equal if they contain the same values in the same order.</db:para>
<db:para>This function requires the value type to have an implementation of <db:code>operator==()</db:code>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qlist.xml#operator-eq-eq">operator==</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="operator-2b-eq">
<db:title>QList&lt;T&gt; &amp;QList::operator+=(const QList&lt;T&gt; &amp;<db:emphasis>other</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>QList&lt;T&gt; &amp;</db:type>
<db:methodname>operator+=</db:methodname>
<db:methodparam>
<db:type>const QList&lt;T&gt; &amp;</db:type>
<db:parameter>other</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QList&lt;T&gt; &amp; operator+=(const QList&lt;T&gt; &amp;other)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Appends the items of the <db:code role="parameter">other</db:code> list to this list and returns a reference to this list.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qlist.xml#operator-2b">operator+</db:link>()</db:member>
<db:member><db:link xlink:href="qlist.xml#append">append</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="operator-2b-eq-1">
<db:title>[since 6.0] QList&lt;T&gt; &amp;QList::operator+=(QList&lt;T&gt; &amp;&amp;<db:emphasis>other</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>QList&lt;T&gt; &amp;</db:type>
<db:methodname>operator+=</db:methodname>
<db:methodparam>
<db:type>QList&lt;T&gt; &amp;&amp;</db:type>
<db:parameter>other</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">QList&lt;T&gt; &amp; operator+=(QList&lt;T&gt; &amp;&amp;other)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>This function was introduced in Qt 6.0.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qlist.xml#operator-2b">operator+</db:link>()</db:member>
<db:member><db:link xlink:href="qlist.xml#append">append</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="operator-2b-eq-2">
<db:title>QList&lt;T&gt; &amp;QList::operator+=(QList::parameter_type <db:emphasis>value</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>QList&lt;T&gt; &amp;</db:type>
<db:methodname>operator+=</db:methodname>
<db:methodparam>
<db:type>QList::parameter_type</db:type>
<db:parameter>value</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">2</db:synopsisinfo>
<db:synopsisinfo role="signature">QList&lt;T&gt; &amp; operator+=(QList::parameter_type value)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>Appends <db:code role="parameter">value</db:code> to the list.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qlist.xml#append">append</db:link>()</db:member>
<db:member><db:link xlink:href="qlist.xml#operator-lt-lt">operator&lt;&lt;</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="operator-2b-eq-3">
<db:title>QList&lt;T&gt; &amp;QList::operator+=(QList::rvalue_ref <db:emphasis>value</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>QList&lt;T&gt; &amp;</db:type>
<db:methodname>operator+=</db:methodname>
<db:methodparam>
<db:type>QList::rvalue_ref</db:type>
<db:parameter>value</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">3</db:synopsisinfo>
<db:synopsisinfo role="signature">QList&lt;T&gt; &amp; operator+=(QList::rvalue_ref value)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qlist.xml#append">append</db:link>()</db:member>
<db:member><db:link xlink:href="qlist.xml#operator-lt-lt">operator&lt;&lt;</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="operator-lt">
<db:title>bool QList::operator&lt;(const QList&lt;T&gt; &amp;<db:emphasis>other</db:emphasis>) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>bool</db:type>
<db:methodname>operator&lt;</db:methodname>
<db:methodparam>
<db:type>const QList&lt;T&gt; &amp;</db:type>
<db:parameter>other</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool operator&lt;(const QList&lt;T&gt; &amp;other) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns <db:code>true</db:code> if this list is <db:link xlink:href="http://en.cppreference.com/w/cpp/algorithm/lexicographical_compare">lexically less than</db:link> <db:code role="parameter">other</db:code>; otherwise returns <db:code>false</db:code>.</db:para>
<db:para>This function requires the value type to have an implementation of <db:code>operator&lt;()</db:code>.</db:para>
</db:section>
<db:section xml:id="operator-lt-lt">
<db:title>QList&lt;T&gt; &amp;QList::operator&lt;&lt;(QList::parameter_type <db:emphasis>value</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>QList&lt;T&gt; &amp;</db:type>
<db:methodname>operator&lt;&lt;</db:methodname>
<db:methodparam>
<db:type>QList::parameter_type</db:type>
<db:parameter>value</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QList&lt;T&gt; &amp; operator&lt;&lt;(QList::parameter_type value)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Appends <db:code role="parameter">value</db:code> to the list and returns a reference to this list.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qlist.xml#append">append</db:link>()</db:member>
<db:member><db:link xlink:href="qlist.xml#operator-2b-eq">operator+=</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="operator-lt-lt-1">
<db:title>QList&lt;T&gt; &amp;QList::operator&lt;&lt;(const QList&lt;T&gt; &amp;<db:emphasis>other</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>QList&lt;T&gt; &amp;</db:type>
<db:methodname>operator&lt;&lt;</db:methodname>
<db:methodparam>
<db:type>const QList&lt;T&gt; &amp;</db:type>
<db:parameter>other</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">QList&lt;T&gt; &amp; operator&lt;&lt;(const QList&lt;T&gt; &amp;other)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Appends <db:code role="parameter">other</db:code> to the list and returns a reference to the list.</db:para>
</db:section>
<db:section xml:id="operator-lt-lt-2">
<db:title>[since 6.0] QList&lt;T&gt; &amp;QList::operator&lt;&lt;(QList&lt;T&gt; &amp;&amp;<db:emphasis>other</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>QList&lt;T&gt; &amp;</db:type>
<db:methodname>operator&lt;&lt;</db:methodname>
<db:methodparam>
<db:type>QList&lt;T&gt; &amp;&amp;</db:type>
<db:parameter>other</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">2</db:synopsisinfo>
<db:synopsisinfo role="signature">QList&lt;T&gt; &amp; operator&lt;&lt;(QList&lt;T&gt; &amp;&amp;other)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>This function was introduced in Qt 6.0.</db:para>
</db:section>
<db:section xml:id="operator-lt-lt-3">
<db:title>QList&lt;T&gt; &amp;QList::operator&lt;&lt;(QList::rvalue_ref <db:emphasis>value</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>QList&lt;T&gt; &amp;</db:type>
<db:methodname>operator&lt;&lt;</db:methodname>
<db:methodparam>
<db:type>QList::rvalue_ref</db:type>
<db:parameter>value</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">3</db:synopsisinfo>
<db:synopsisinfo role="signature">QList&lt;T&gt; &amp; operator&lt;&lt;(QList::rvalue_ref value)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qlist.xml#append">append</db:link>()</db:member>
<db:member><db:link xlink:href="qlist.xml#operator-2b-eq">operator+=</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="operator-lt-eq">
<db:title>bool QList::operator&lt;=(const QList&lt;T&gt; &amp;<db:emphasis>other</db:emphasis>) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>bool</db:type>
<db:methodname>operator&lt;=</db:methodname>
<db:methodparam>
<db:type>const QList&lt;T&gt; &amp;</db:type>
<db:parameter>other</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool operator&lt;=(const QList&lt;T&gt; &amp;other) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns <db:code>true</db:code> if this list is <db:link xlink:href="http://en.cppreference.com/w/cpp/algorithm/lexicographical_compare">lexically less than or equal to</db:link> <db:code role="parameter">other</db:code>; otherwise returns <db:code>false</db:code>.</db:para>
<db:para>This function requires the value type to have an implementation of <db:code>operator&lt;()</db:code>.</db:para>
</db:section>
<db:section xml:id="operator-eq">
<db:title>QList&lt;T&gt; &amp;QList::operator=(std::initializer_list&lt;T&gt; <db:emphasis>args</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>QList&lt;T&gt; &amp;</db:type>
<db:methodname>operator=</db:methodname>
<db:methodparam>
<db:type>std::initializer_list&lt;T&gt;</db:type>
<db:parameter>args</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QList&lt;T&gt; &amp; operator=(std::initializer_list&lt;T&gt; args)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Assigns the collection of values in <db:code role="parameter">args</db:code> to this <db:link xlink:href="qlist.xml">QList</db:link> instance.</db:para>
</db:section>
<db:section xml:id="operator-eq-1">
<db:title>[default] QList&lt;T&gt; &amp;QList::operator=(const QList&lt;T&gt; &amp;<db:emphasis>other</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>QList&lt;T&gt; &amp;</db:type>
<db:methodname>operator=</db:methodname>
<db:methodparam>
<db:type>const QList&lt;T&gt; &amp;</db:type>
<db:parameter>other</db:parameter>
</db:methodparam>
<db:modifier>default</db:modifier>
<db:synopsisinfo role="meta">copy-assign</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">QList&lt;T&gt; &amp; operator=(const QList&lt;T&gt; &amp;other) = default</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Assigns <db:code role="parameter">other</db:code> to this list and returns a reference to this list.</db:para>
</db:section>
<db:section xml:id="operator-eq-2">
<db:title>[default] QList&lt;T&gt; &amp;QList::operator=(QList&lt;T&gt; &amp;&amp;<db:emphasis>other</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>QList&lt;T&gt; &amp;</db:type>
<db:methodname>operator=</db:methodname>
<db:methodparam>
<db:type>QList&lt;T&gt; &amp;&amp;</db:type>
<db:parameter>other</db:parameter>
</db:methodparam>
<db:modifier>default</db:modifier>
<db:synopsisinfo role="meta">move-assign</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">2</db:synopsisinfo>
<db:synopsisinfo role="signature">QList&lt;T&gt; &amp; operator=(QList&lt;T&gt; &amp;&amp;other) = default</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Move-assigns <db:code role="parameter">other</db:code> to this <db:link xlink:href="qlist.xml">QList</db:link> instance.</db:para>
</db:section>
<db:section xml:id="operator-eq-eq">
<db:title>bool QList::operator==(const QList&lt;T&gt; &amp;<db:emphasis>other</db:emphasis>) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>bool</db:type>
<db:methodname>operator==</db:methodname>
<db:methodparam>
<db:type>const QList&lt;T&gt; &amp;</db:type>
<db:parameter>other</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool operator==(const QList&lt;T&gt; &amp;other) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns <db:code>true</db:code> if <db:code role="parameter">other</db:code> is equal to this list; otherwise returns <db:code>false</db:code>.</db:para>
<db:para>Two lists are considered equal if they contain the same values in the same order.</db:para>
<db:para>This function requires the value type to have an implementation of <db:code>operator==()</db:code>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qlist.xml#operator-not-eq">operator!=</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="operator-gt">
<db:title>bool QList::operator&gt;(const QList&lt;T&gt; &amp;<db:emphasis>other</db:emphasis>) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>bool</db:type>
<db:methodname>operator&gt;</db:methodname>
<db:methodparam>
<db:type>const QList&lt;T&gt; &amp;</db:type>
<db:parameter>other</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool operator&gt;(const QList&lt;T&gt; &amp;other) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns <db:code>true</db:code> if this list is <db:link xlink:href="http://en.cppreference.com/w/cpp/algorithm/lexicographical_compare">lexically greater than</db:link> <db:code role="parameter">other</db:code>; otherwise returns <db:code>false</db:code>.</db:para>
<db:para>This function requires the value type to have an implementation of <db:code>operator&lt;()</db:code>.</db:para>
</db:section>
<db:section xml:id="operator-gt-eq">
<db:title>bool QList::operator&gt;=(const QList&lt;T&gt; &amp;<db:emphasis>other</db:emphasis>) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>bool</db:type>
<db:methodname>operator&gt;=</db:methodname>
<db:methodparam>
<db:type>const QList&lt;T&gt; &amp;</db:type>
<db:parameter>other</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool operator&gt;=(const QList&lt;T&gt; &amp;other) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns <db:code>true</db:code> if this list is <db:link xlink:href="http://en.cppreference.com/w/cpp/algorithm/lexicographical_compare">lexically greater than or equal to</db:link> <db:code role="parameter">other</db:code>; otherwise returns <db:code>false</db:code>.</db:para>
<db:para>This function requires the value type to have an implementation of <db:code>operator&lt;()</db:code>.</db:para>
</db:section>
<db:section xml:id="operator-5b-5d">
<db:title>QList::reference QList::operator[](qsizetype <db:emphasis>i</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>QList::reference</db:type>
<db:methodname>operator[]</db:methodname>
<db:methodparam>
<db:type>qsizetype</db:type>
<db:parameter>i</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QList::reference operator[](qsizetype i)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the item at index position <db:code role="parameter">i</db:code> as a modifiable reference.</db:para>
<db:para><db:code role="parameter">i</db:code> must be a valid index position in the list (i.e., 0 &lt;= <db:code role="parameter">i</db:code> &lt; <db:link xlink:href="qlist.xml#size">size</db:link>()).</db:para>
<db:para>Note that using non-const operators can cause <db:link xlink:href="qlist.xml">QList</db:link> to do a deep copy.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qlist.xml#at">at</db:link>()</db:member>
<db:member><db:link xlink:href="qlist.xml#value">value</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="operator-5b-5d-1">
<db:title>QList::const_reference QList::operator[](qsizetype <db:emphasis>i</db:emphasis>) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QList::const_reference</db:type>
<db:methodname>operator[]</db:methodname>
<db:methodparam>
<db:type>qsizetype</db:type>
<db:parameter>i</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">QList::const_reference operator[](qsizetype i) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>Same as at(<db:code role="parameter">i</db:code>).</db:para>
</db:section>
</db:section>
<db:section xml:id="related-non-members">
<db:title>Related Non-Members</db:title>
<db:section xml:id="erase-2">
<db:title>[since 6.1] qsizetype erase(QList&lt;T&gt; &amp;<db:emphasis>list</db:emphasis>, const AT &amp;<db:emphasis>t</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>qsizetype</db:type>
<db:methodname>erase</db:methodname>
<db:methodparam>
<db:type>QList&lt;T&gt; &amp;</db:type>
<db:parameter>list</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const AT &amp;</db:type>
<db:parameter>t</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">2</db:synopsisinfo>
<db:synopsisinfo role="signature">qsizetype erase(QList&lt;T&gt; &amp;list, const AT &amp;t)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Removes all elements that compare equal to <db:code role="parameter">t</db:code> from the list <db:code role="parameter">list</db:code>. Returns the number of elements removed, if any.</db:para>
<db:note>
<db:para>Unlike <db:link xlink:href="qlist.xml#removeAll">QList::removeAll</db:link>, <db:code role="parameter">t</db:code> is not allowed to be a reference to an element inside <db:code role="parameter">list</db:code>. If you cannot be sure that this is not the case, take a copy of <db:code role="parameter">t</db:code> and call this function with the copy.</db:para>
</db:note>
<db:para>This function was introduced in Qt 6.1.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qlist.xml#removeAll">QList::removeAll</db:link>()</db:member>
<db:member><db:link xlink:href="qlist.xml#erase_if">erase_if</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="erase_if">
<db:title>[since 6.1] qsizetype erase_if(QList&lt;T&gt; &amp;<db:emphasis>list</db:emphasis>, Predicate <db:emphasis>pred</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>qsizetype</db:type>
<db:methodname>erase_if</db:methodname>
<db:methodparam>
<db:type>QList&lt;T&gt; &amp;</db:type>
<db:parameter>list</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>Predicate</db:type>
<db:parameter>pred</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">qsizetype erase_if(QList&lt;T&gt; &amp;list, Predicate pred)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Removes all elements for which the predicate <db:code role="parameter">pred</db:code> returns true from the list <db:code role="parameter">list</db:code>. Returns the number of elements removed, if any.</db:para>
<db:para>This function was introduced in Qt 6.1.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qlist.xml#erase">erase</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="qHash">
<db:title>size_t qHash(const QList&lt;T&gt; &amp;<db:emphasis>key</db:emphasis>, size_t <db:emphasis>seed</db:emphasis> = 0)</db:title>
<db:methodsynopsis>
<db:type>size_t</db:type>
<db:methodname>qHash</db:methodname>
<db:methodparam>
<db:type>const QList&lt;T&gt; &amp;</db:type>
<db:parameter>key</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>size_t</db:type>
<db:parameter>seed</db:parameter>
<db:initializer>0</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">size_t qHash(const QList&lt;T&gt; &amp;key, size_t seed)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the hash value for <db:code role="parameter">key</db:code>, using <db:code role="parameter">seed</db:code> to seed the calculation.</db:para>
<db:para>This function requires qHash() to be overloaded for the value type <db:code>T</db:code>.</db:para>
</db:section>
<db:section xml:id="operator-lt-lt-4">
<db:title>QDataStream &amp;operator&lt;&lt;(QDataStream &amp;<db:emphasis>out</db:emphasis>, const QList&lt;T&gt; &amp;<db:emphasis>list</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>QDataStream &amp;</db:type>
<db:methodname>operator&lt;&lt;</db:methodname>
<db:methodparam>
<db:type>QDataStream &amp;</db:type>
<db:parameter>out</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const QList&lt;T&gt; &amp;</db:type>
<db:parameter>list</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">4</db:synopsisinfo>
<db:synopsisinfo role="signature">QDataStream &amp; operator&lt;&lt;(QDataStream &amp;out, const QList&lt;T&gt; &amp;list)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Writes the list <db:code role="parameter">list</db:code> to stream <db:code role="parameter">out</db:code>.</db:para>
<db:para>This function requires the value type to implement <db:code>operator&lt;&lt;()</db:code>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="datastreamformat.xml">Format of the QDataStream operators</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="operator-gt-gt">
<db:title>QDataStream &amp;operator&gt;&gt;(QDataStream &amp;<db:emphasis>in</db:emphasis>, QList&lt;T&gt; &amp;<db:emphasis>list</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>QDataStream &amp;</db:type>
<db:methodname>operator&gt;&gt;</db:methodname>
<db:methodparam>
<db:type>QDataStream &amp;</db:type>
<db:parameter>in</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>QList&lt;T&gt; &amp;</db:type>
<db:parameter>list</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QDataStream &amp; operator&gt;&gt;(QDataStream &amp;in, QList&lt;T&gt; &amp;list)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Reads a list from stream <db:code role="parameter">in</db:code> into <db:code role="parameter">list</db:code>.</db:para>
<db:para>This function requires the value type to implement <db:code>operator&gt;&gt;()</db:code>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="datastreamformat.xml">Format of the QDataStream operators</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
</db:section>
<db:section xml:id="obsolete">
<db:title>Obsolete Members for QList</db:title>
<db:para><db:emphasis role="bold">The following members of class <db:link xlink:href="qlist.xml">QList</db:link> are deprecated.</db:emphasis> We strongly advise against using them in new code.</db:para>
<db:section xml:id="obsolete-member-function-documentation">
<db:title>Obsolete Member Function Documentation</db:title>
<db:section xml:id="toList">
<db:title>QList&lt;T&gt; QList::toList() const</db:title>
<db:bridgehead renderas="sect2" xml:id="toVector">QList&lt;T&gt; QList::toVector() const</db:bridgehead>
<db:para>This function is deprecated. We strongly advise against using it in new code.</db:para>
<db:para>A no-op in Qt 6. Provided for backwards compatibility with Qt 5, where <db:link xlink:href="qlist.xml">QList</db:link> and <db:link xlink:href="qvector.xml">QVector</db:link> where two different types.</db:para>
<db:para>Returns this list.</db:para>
</db:section>
<db:section xml:id="fromList">
<db:title>[static] QList&lt;T&gt; QList::fromList(const QList&lt;T&gt; &amp;<db:emphasis>list</db:emphasis>)</db:title>
<db:bridgehead renderas="sect2" xml:id="fromVector">[static] QList&lt;T&gt; QList::fromVector(const QList&lt;T&gt; &amp;<db:emphasis>list</db:emphasis>)</db:bridgehead>
<db:para>This function is deprecated. We strongly advise against using it in new code.</db:para>
<db:para>A no-op in Qt 6. Provided for backwards compatibility with Qt 5, where <db:link xlink:href="qlist.xml">QList</db:link> and <db:link xlink:href="qvector.xml">QVector</db:link> were two different types.</db:para>
<db:para>Returns this list.</db:para>
</db:section>
</db:section>
</db:section>
</db:article>
