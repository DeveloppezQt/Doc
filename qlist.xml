<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en_US">
<db:info>
<db:title>QList Class</db:title>
<db:subtitle>template &lt;typename T&gt; class QList</db:subtitle>
<db:productname>QtCore</db:productname>
<db:edition>Qt 5.3.2 Reference Documentation</db:edition>
<db:titleabbrev>Qt Core Reference Documentation</db:titleabbrev>
<db:abstract>
<db:para>The <db:link xlink:href="qlist.xml">QList</db:link> class is a template class that provides lists.</db:para>
<db:note>
<db:para>All functions in this class are reentrant.</db:para>
</db:note>
</db:abstract>
<db:pubdate>2025-06-29</db:pubdate>
<db:date>2025-06-29</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:variablelist>
<db:varlistentry>
<db:term>Header</db:term>
<db:listitem>
<db:para>QList</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>qmake</db:term>
<db:listitem>
<db:para>QT += core</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Inherited By</db:term>
<db:listitem>
<db:para><db:link xlink:href="qqueue.xml" xlink:role="class">QQueue</db:link></db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Group</db:term>
<db:listitem>
<db:para>QList is part of <db:simplelist><db:member>tools</db:member><db:member><db:link xlink:href="shared.xml">Implicitly Shared Classes</db:link></db:member></db:simplelist>
</db:para>
</db:listitem>
</db:varlistentry>
</db:variablelist>
<db:section xml:id="details">
<db:title>Detailed Description</db:title>
<db:para><db:link xlink:href="qlist.xml">QList</db:link>&lt;T&gt; is one of Qt's generic <db:link xlink:href="containers.xml">container classes</db:link>. It stores a list of values and provides fast index-based access as well as fast insertions and removals.</db:para>
<db:para><db:link xlink:href="qlist.xml">QList</db:link>&lt;T&gt;, <db:link xlink:href="qlinkedlist.xml">QLinkedList</db:link>&lt;T&gt;, and <db:link xlink:href="qvector.xml">QVector</db:link>&lt;T&gt; provide similar functionality. Here's an overview:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para>For most purposes, <db:link xlink:href="qlist.xml">QList</db:link> is the right class to use. Its index-based API is more convenient than <db:link xlink:href="qlinkedlist.xml">QLinkedList</db:link>'s iterator-based API, and it is usually faster than <db:link xlink:href="qvector.xml">QVector</db:link> because of the way it stores its items in memory. It also expands to less code in your executable.</db:para>
</db:listitem>
<db:listitem>
<db:para>If you need a real linked list, with guarantees of <db:link xlink:href="containers.xml">constant time</db:link> insertions in the middle of the list and iterators to items rather than indexes, use <db:link xlink:href="qlinkedlist.xml">QLinkedList</db:link>.</db:para>
</db:listitem>
<db:listitem>
<db:para>If you want the items to occupy adjacent memory positions, use <db:link xlink:href="qvector.xml">QVector</db:link>.</db:para>
</db:listitem>
</db:itemizedlist>
<db:para>Internally, <db:link xlink:href="qlist.xml">QList</db:link>&lt;T&gt; is represented as an array of pointers to items of type T. If T is itself a pointer type or a basic type that is no larger than a pointer, or if T is one of Qt's <db:link xlink:href="implicit-sharing.xml">shared classes</db:link>, then <db:link xlink:href="qlist.xml">QList</db:link>&lt;T&gt; stores the items directly in the pointer array. For lists under a thousand items, this array representation allows for very fast insertions in the middle, and it allows index-based access. Furthermore, operations like prepend() and append() are very fast, because <db:link xlink:href="qlist.xml">QList</db:link> preallocates memory at both ends of its internal array. (See <db:link xlink:href="containers.xml#algorithmic-complexity">Algorithmic Complexity</db:link> for details.) Note, however, that for unshared list items that are larger than a pointer, each append or insert of a new item requires allocating the new item on the heap, and this per item allocation might make <db:link xlink:href="qvector.xml">QVector</db:link> a better choice in cases that do lots of appending or inserting, since <db:link xlink:href="qvector.xml">QVector</db:link> allocates memory for its items in a single heap allocation.</db:para>
<db:para>Note that the internal array only ever gets bigger over the life of the list. It never shrinks. The internal array is deallocated by the destructor and by the assignment operator, when one list is assigned to another.</db:para>
<db:para>Here's an example of a <db:link xlink:href="qlist.xml">QList</db:link> that stores integers and a <db:link xlink:href="qlist.xml">QList</db:link> that stores <db:link xlink:href="qdate.xml">QDate</db:link> values:</db:para>
<db:programlisting language="cpp">QList&lt;int&gt; integerList;
QList&lt;QDate&gt; dateList;
</db:programlisting>
<db:para>Qt includes a <db:link xlink:href="qstringlist.xml">QStringList</db:link> class that inherits <db:link xlink:href="qlist.xml">QList</db:link>&lt;<db:link xlink:href="qstring.xml">QString</db:link>&gt; and adds a few convenience functions, such as <db:link xlink:href="qstringlist.xml#join">QStringList::join</db:link>() and QStringList::find(). (<db:link xlink:href="qstring.xml#split">QString::split</db:link>() creates QStringLists from strings.)</db:para>
<db:para><db:link xlink:href="qlist.xml">QList</db:link> stores a list of items. The default constructor creates an empty list. To insert items into the list, you can use operator&lt;&lt;():</db:para>
<db:programlisting language="cpp">QList&lt;QString&gt; list;
list &lt;&lt; &quot;one&quot; &lt;&lt; &quot;two&quot; &lt;&lt; &quot;three&quot;;
// list: [&quot;one&quot;, &quot;two&quot;, &quot;three&quot;]
</db:programlisting>
<db:para><db:link xlink:href="qlist.xml">QList</db:link> provides these basic functions to add, move, and remove items: insert(), replace(), removeAt(), move(), and swap(). In addition, it provides the following convenience functions: append(), prepend(), removeFirst(), and removeLast().</db:para>
<db:para><db:link xlink:href="qlist.xml">QList</db:link> uses 0-based indexes, just like C++ arrays. To access the item at a particular index position, you can use operator[](). On non-const lists, operator[]() returns a reference to the item and can be used on the left side of an assignment:</db:para>
<db:programlisting language="cpp">if (list[0] == &quot;Bob&quot;)
    list[0] = &quot;Robert&quot;;
</db:programlisting>
<db:para>Because <db:link xlink:href="qlist.xml">QList</db:link> is implemented as an array of pointers, this operation is very fast (<db:link xlink:href="containers.xml">constant time</db:link>). For read-only access, an alternative syntax is to use at():</db:para>
<db:programlisting language="cpp">for (int i = 0; i &lt; list.size(); ++i) {
    if (list.at(i) == &quot;Jane&quot;)
        cout &lt;&lt; &quot;Found Jane at position &quot; &lt;&lt; i &lt;&lt; endl;
}
</db:programlisting>
<db:para>at() can be faster than operator[](), because it never causes a <db:link xlink:href="implicit-sharing.xml">deep copy</db:link> to occur.</db:para>
<db:para>A common requirement is to remove an item from a list and do something with it. For this, <db:link xlink:href="qlist.xml">QList</db:link> provides takeAt(), takeFirst(), and takeLast(). Here's a loop that removes the items from a list one at a time and calls <db:code>delete</db:code> on them:</db:para>
<db:programlisting language="cpp">QList&lt;QWidget *&gt; list;
...
while (!list.isEmpty())
    delete list.takeFirst();
</db:programlisting>
<db:para>Inserting and removing items at either ends of the list is very fast (<db:link xlink:href="containers.xml">constant time</db:link> in most cases), because <db:link xlink:href="qlist.xml">QList</db:link> preallocates extra space on both sides of its internal buffer to allow for fast growth at both ends of the list.</db:para>
<db:para>If you want to find all occurrences of a particular value in a list, use indexOf() or lastIndexOf(). The former searches forward starting from a given index position, the latter searches backward. Both return the index of a matching item if they find it; otherwise, they return -1. For example:</db:para>
<db:programlisting language="cpp">int i = list.indexOf(&quot;Jane&quot;);
if (i != -1)
    cout &lt;&lt; &quot;First occurrence of Jane is at position &quot; &lt;&lt; i &lt;&lt; endl;
</db:programlisting>
<db:para>If you simply want to check whether a list contains a particular value, use contains(). If you want to find out how many times a particular value occurs in the list, use count(). If you want to replace all occurrences of a particular value with another, use replace().</db:para>
<db:para><db:link xlink:href="qlist.xml">QList</db:link>'s value type must be an <db:link xlink:href="containers.xml">assignable data type</db:link>. This covers most data types that are commonly used, but the compiler won't let you, for example, store a QWidget as a value; instead, store a QWidget *. A few functions have additional requirements; for example, indexOf() and lastIndexOf() expect the value type to support <db:code>operator==()</db:code>. These requirements are documented on a per-function basis.</db:para>
<db:para>Like the other container classes, <db:link xlink:href="qlist.xml">QList</db:link> provides <db:link xlink:href="containers.xml#java-style-iterators">Java-style iterators</db:link> (<db:link xlink:href="qlistiterator.xml">QListIterator</db:link> and <db:link xlink:href="qmutablelistiterator.xml">QMutableListIterator</db:link>) and <db:link xlink:href="containers.xml#stl-style-iterators">STL-style iterators</db:link> (<db:link xlink:href="qlist-const-iterator.xml">QList::const_iterator</db:link> and <db:link xlink:href="qlist-iterator.xml">QList::iterator</db:link>). In practice, these are rarely used, because you can use indexes into the <db:link xlink:href="qlist.xml">QList</db:link>. <db:link xlink:href="qlist.xml">QList</db:link> is implemented in such a way that direct index-based access is just as fast as using iterators.</db:para>
<db:para><db:link xlink:href="qlist.xml">QList</db:link> does <db:emphasis>not</db:emphasis> support inserting, prepending, appending or replacing with references to its own values. Doing so will cause your application to abort with an error message.</db:para>
<db:para>To make <db:link xlink:href="qlist.xml">QList</db:link> as efficient as possible, its member functions don't validate their input before using it. Except for isEmpty(), member functions always assume the list is <db:emphasis>not</db:emphasis> empty. Member functions that take index values as parameters always assume their index value parameters are in the valid range. This means <db:link xlink:href="qlist.xml">QList</db:link> member functions can fail. If you define QT_NO_DEBUG when you compile, failures will not be detected. If you <db:emphasis>don't</db:emphasis> define QT_NO_DEBUG, failures will be detected using <db:link xlink:href="qtglobal.xml#Q_ASSERT">Q_ASSERT</db:link>() or <db:link xlink:href="qtglobal.xml#Q_ASSERT_X">Q_ASSERT_X</db:link>() with an appropriate message.</db:para>
<db:para>To avoid failures when your list can be empty, call isEmpty() before calling other member functions. If you must pass an index value that might not be in the valid range, check that it is less than the value returned by size() but <db:emphasis>not</db:emphasis> less than 0.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qlistiterator.xml">QListIterator</db:link></db:member>
<db:member><db:link xlink:href="qmutablelistiterator.xml">QMutableListIterator</db:link></db:member>
<db:member><db:link xlink:href="qlinkedlist.xml">QLinkedList</db:link></db:member>
<db:member><db:link xlink:href="qvector.xml">QVector</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="member-type-documentation">
<db:title>Member Type Documentation</db:title>
<db:section xml:id="ConstIterator-typedef">
<db:title>QList::ConstIterator</db:title>
<db:para>Qt-style synonym for <db:link xlink:href="qlist-const-iterator.xml">QList::const_iterator</db:link>.</db:para>
</db:section>
<db:section xml:id="Iterator-typedef">
<db:title>QList::Iterator</db:title>
<db:para>Qt-style synonym for <db:link xlink:href="qlist-iterator.xml">QList::iterator</db:link>.</db:para>
</db:section>
<db:section xml:id="const_pointer-typedef">
<db:title>QList::const_pointer</db:title>
<db:para>Typedef for const T *. Provided for STL compatibility.</db:para>
</db:section>
<db:section xml:id="const_reference-typedef">
<db:title>QList::const_reference</db:title>
<db:para>Typedef for const T &amp;. Provided for STL compatibility.</db:para>
</db:section>
<db:section xml:id="difference_type-typedef">
<db:title>QList::difference_type</db:title>
<db:para>Typedef for ptrdiff_t. Provided for STL compatibility.</db:para>
</db:section>
<db:section xml:id="pointer-typedef">
<db:title>QList::pointer</db:title>
<db:para>Typedef for T *. Provided for STL compatibility.</db:para>
</db:section>
<db:section xml:id="reference-typedef">
<db:title>QList::reference</db:title>
<db:para>Typedef for T &amp;. Provided for STL compatibility.</db:para>
</db:section>
<db:section xml:id="size_type-typedef">
<db:title>QList::size_type</db:title>
<db:para>Typedef for int. Provided for STL compatibility.</db:para>
</db:section>
<db:section xml:id="value_type-typedef">
<db:title>QList::value_type</db:title>
<db:para>Typedef for T. Provided for STL compatibility.</db:para>
</db:section>
</db:section>
</db:article>
