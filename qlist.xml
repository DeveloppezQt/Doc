<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en">
<db:info>
<db:title>QList Class</db:title>
<db:subtitle>template &lt;typename T&gt; class QList</db:subtitle>
<db:productname>QtCore</db:productname>
<db:edition>Qt 5.8.0 Reference Documentation</db:edition>
<db:titleabbrev>Qt Core Reference Documentation</db:titleabbrev>
<db:abstract>
<db:para>The <db:link xlink:href="qlist.xml">QList</db:link> class is a template class that provides lists.</db:para>
<db:note>
<db:para>All functions in this class are <db:link xlink:href="threads-reentrancy.xml">reentrant</db:link>.</db:para>
</db:note>
</db:abstract>
<db:pubdate>2025-06-29</db:pubdate>
<db:date>2025-06-29</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:variablelist>
<db:varlistentry>
<db:term>Header</db:term>
<db:listitem>
<db:para>QList</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>qmake</db:term>
<db:listitem>
<db:para>QT += core</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Inherited By</db:term>
<db:listitem>
<db:para><db:link xlink:href="qbluetoothserviceinfo-alternative.xml" xlink:role="class">QBluetoothServiceInfo::Alternative</db:link>, <db:link xlink:href="qbluetoothserviceinfo-sequence.xml" xlink:role="class">QBluetoothServiceInfo::Sequence</db:link>, <db:link xlink:href="qbytearraylist.xml" xlink:role="class">QByteArrayList</db:link>, <db:link xlink:href="qitemselection.xml" xlink:role="class">QItemSelection</db:link>, <db:link xlink:href="qndefmessage.xml" xlink:role="class">QNdefMessage</db:link>, <db:link xlink:href="qqueue.xml" xlink:role="class">QQueue</db:link>, <db:link xlink:href="qsignalspy.xml" xlink:role="class">QSignalSpy</db:link>, <db:link xlink:href="qstringlist.xml" xlink:role="class">QStringList</db:link>, and <db:link xlink:href="qtesteventlist.xml" xlink:role="class">QTestEventList</db:link></db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Group</db:term>
<db:listitem>
<db:para>QList is part of <db:simplelist><db:member>tools</db:member><db:member><db:link xlink:href="shared.xml">Implicitly Shared Classes</db:link></db:member></db:simplelist>
</db:para>
</db:listitem>
</db:varlistentry>
</db:variablelist>
<db:section xml:id="details">
<db:title>Detailed Description</db:title>
<db:para><db:link xlink:href="qlist.xml">QList</db:link>&lt;T&gt; is one of Qt's generic <db:link xlink:href="containers.xml">container classes</db:link>. It stores items in a list that provides fast index-based access and index-based insertions and removals.</db:para>
<db:para><db:link xlink:href="qlist.xml">QList</db:link>&lt;T&gt;, <db:link xlink:href="qlinkedlist.xml">QLinkedList</db:link>&lt;T&gt;, and <db:link xlink:href="qvector.xml">QVector</db:link>&lt;T&gt; provide similar APIs and functionality. They are often interchangeable, but there are performance consequences. Here is an overview of use cases:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:link xlink:href="qvector.xml">QVector</db:link> should be your default first choice. <db:link xlink:href="qvector.xml">QVector</db:link>&lt;T&gt; will usually give better performance than <db:link xlink:href="qlist.xml">QList</db:link>&lt;T&gt;, because <db:link xlink:href="qvector.xml">QVector</db:link>&lt;T&gt; always stores its items sequentially in memory, where <db:link xlink:href="qlist.xml">QList</db:link>&lt;T&gt; will allocate its items on the heap unless <db:code>sizeof(T) &lt;= sizeof(void*)</db:code> and T has been declared to be either a <db:code>Q_MOVABLE_TYPE</db:code> or a <db:code>Q_PRIMITIVE_TYPE</db:code> using <db:link xlink:href="qtglobal.xml#Q_DECLARE_TYPEINFO">Q_DECLARE_TYPEINFO</db:link>. See the <db:link xlink:href="http://marcmutz.wordpress.com/effective-qt/containers/#containers-qlist">Pros and Cons of Using QList</db:link> for an explanation.</db:para>
</db:listitem>
<db:listitem>
<db:para>However, <db:link xlink:href="qlist.xml">QList</db:link> is used throughout the Qt APIs for passing parameters and for returning values. Use <db:link xlink:href="qlist.xml">QList</db:link> to interface with those APIs.</db:para>
</db:listitem>
<db:listitem>
<db:para>If you need a real linked list, which guarantees <db:link xlink:href="containers.xml#algorithmic-complexity">constant time</db:link> insertions mid-list and uses iterators to items rather than indexes, use <db:link xlink:href="qlinkedlist.xml">QLinkedList</db:link>.</db:para>
</db:listitem>
</db:itemizedlist>
<db:note>
<db:para><db:link xlink:href="qvector.xml">QVector</db:link> and <db:link xlink:href="qvarlengtharray.xml">QVarLengthArray</db:link> both guarantee C-compatible array layout. <db:link xlink:href="qlist.xml">QList</db:link> does not. This might be important if your application must interface with a C API.</db:para>
</db:note>
<db:note>
<db:para>Iterators into a <db:link xlink:href="qlinkedlist.xml">QLinkedList</db:link> and references into heap-allocating QLists remain valid as long as the referenced items remain in the container. This is not true for iterators and references into a <db:link xlink:href="qvector.xml">QVector</db:link> and non-heap-allocating QLists.</db:para>
</db:note>
<db:para>Internally, <db:link xlink:href="qlist.xml">QList</db:link>&lt;T&gt; is represented as an array of T if <db:code>sizeof(T) &lt;= sizeof(void*)</db:code> and T has been declared to be either a <db:code>Q_MOVABLE_TYPE</db:code> or a <db:code>Q_PRIMITIVE_TYPE</db:code> using <db:link xlink:href="qtglobal.xml#Q_DECLARE_TYPEINFO">Q_DECLARE_TYPEINFO</db:link>. Otherwise, <db:link xlink:href="qlist.xml">QList</db:link>&lt;T&gt; is represented as an array of T* and the items are allocated on the heap.</db:para>
<db:para>The array representation allows very fast insertions and index-based access. The prepend() and append() operations are also very fast because <db:link xlink:href="qlist.xml">QList</db:link> preallocates memory at both ends of its internal array. (See <db:link xlink:href="containers.xml#algorithmic-complexity">Algorithmic Complexity</db:link> for details.</db:para>
<db:para>Note, however, that when the conditions specified above are not met, each append or insert of a new item requires allocating the new item on the heap, and this per item allocation will make <db:link xlink:href="qvector.xml">QVector</db:link> a better choice for use cases that do a lot of appending or inserting, because <db:link xlink:href="qvector.xml">QVector</db:link> can allocate memory for many items in a single heap allocation.</db:para>
<db:para>Note that the internal array only ever gets bigger over the life of the list. It never shrinks. The internal array is deallocated by the destructor and by the assignment operator, when one list is assigned to another.</db:para>
<db:para>Here's an example of a <db:link xlink:href="qlist.xml">QList</db:link> that stores integers and a <db:link xlink:href="qlist.xml">QList</db:link> that stores <db:link xlink:href="qdate.xml">QDate</db:link> values:</db:para>
<db:programlisting language="cpp">QList&lt;int&gt; integerList;
QList&lt;QDate&gt; dateList;
</db:programlisting>
<db:para>Qt includes a <db:link xlink:href="qstringlist.xml">QStringList</db:link> class that inherits <db:link xlink:href="qlist.xml">QList</db:link>&lt;<db:link xlink:href="qstring.xml">QString</db:link>&gt; and adds a few convenience functions, such as <db:link xlink:href="qstringlist.xml#join">QStringList::join</db:link>() and <db:link xlink:href="qstringlist.xml#filter">QStringList::filter</db:link>(). <db:link xlink:href="qstring.xml#split">QString::split</db:link>() creates QStringLists from strings.</db:para>
<db:para><db:link xlink:href="qlist.xml">QList</db:link> stores a list of items. The default constructor creates an empty list. To insert items into the list, you can use operator&lt;&lt;():</db:para>
<db:programlisting language="cpp">QList&lt;QString&gt; list;
list &lt;&lt; &quot;one&quot; &lt;&lt; &quot;two&quot; &lt;&lt; &quot;three&quot;;
// list: [&quot;one&quot;, &quot;two&quot;, &quot;three&quot;]
</db:programlisting>
<db:para><db:link xlink:href="qlist.xml">QList</db:link> provides these basic functions to add, move, and remove items: insert(), replace(), removeAt(), move(), and swap(). In addition, it provides the following convenience functions: append(), prepend(), removeFirst(), and removeLast().</db:para>
<db:para><db:link xlink:href="qlist.xml">QList</db:link> uses 0-based indexes, just like C++ arrays. To access the item at a particular index position, you can use operator[](). On non-const lists, operator[]() returns a reference to the item and can be used on the left side of an assignment:</db:para>
<db:programlisting language="cpp">if (list[0] == &quot;Bob&quot;)
    list[0] = &quot;Robert&quot;;
</db:programlisting>
<db:para>Because <db:link xlink:href="qlist.xml">QList</db:link> is implemented as an array of pointers for types that are larger than a pointer or are not movable, this operation requires (<db:link xlink:href="containers.xml#algorithmic-complexity">constant time</db:link>). For read-only access, an alternative syntax is to use at():</db:para>
<db:programlisting language="cpp">for (int i = 0; i &lt; list.size(); ++i) {
    if (list.at(i) == &quot;Jane&quot;)
        cout &lt;&lt; &quot;Found Jane at position &quot; &lt;&lt; i &lt;&lt; endl;
}
</db:programlisting>
<db:para>at() can be faster than operator[](), because it never causes a <db:link xlink:href="implicit-sharing.xml#deep-copy">deep copy</db:link> to occur.</db:para>
<db:para>A common requirement is to remove an item from a list and do something with it. For this, <db:link xlink:href="qlist.xml">QList</db:link> provides takeAt(), takeFirst(), and takeLast(). Here's a loop that removes the items from a list one at a time and calls <db:code>delete</db:code> on them:</db:para>
<db:programlisting language="cpp">QList&lt;QWidget *&gt; list;
...
while (!list.isEmpty())
    delete list.takeFirst();
</db:programlisting>
<db:para>Inserting and removing items at either end of the list is very fast (<db:link xlink:href="containers.xml#algorithmic-complexity">constant time</db:link> in most cases), because <db:link xlink:href="qlist.xml">QList</db:link> preallocates extra space on both sides of its internal buffer to allow for fast growth at both ends of the list.</db:para>
<db:para>If you want to find all occurrences of a particular value in a list, use indexOf() or lastIndexOf(). The former searches forward starting from a given index position, the latter searches backward. Both return the index of a matching item if they find it; otherwise, they return -1. For example:</db:para>
<db:programlisting language="cpp">int i = list.indexOf(&quot;Jane&quot;);
if (i != -1)
    cout &lt;&lt; &quot;First occurrence of Jane is at position &quot; &lt;&lt; i &lt;&lt; endl;
</db:programlisting>
<db:para>If you simply want to check whether a list contains a particular value, use <db:link xlink:href="qml-geoshape.xml#contains">contains()</db:link>. If you want to find out how many times a particular value occurs in the list, use count(). If you want to replace all occurrences of a particular value with another, use replace().</db:para>
<db:para><db:link xlink:href="qlist.xml">QList</db:link>'s value type must be an <db:link xlink:href="containers.xml#assignable-data-type">assignable data type</db:link>. This covers most data types that are commonly used, but the compiler won't let you, for example, store a <db:link xlink:href="qwidget.xml">QWidget</db:link> as a value; instead, store a <db:link xlink:href="qwidget.xml">QWidget</db:link> *. A few functions have additional requirements; for example, indexOf() and lastIndexOf() expect the value type to support <db:code>operator==()</db:code>. These requirements are documented on a per-function basis.</db:para>
<db:para>Like the other container classes, <db:link xlink:href="qlist.xml">QList</db:link> provides <db:link xlink:href="containers.xml#java-style-iterators">Java-style iterators</db:link> (<db:link xlink:href="qlistiterator.xml">QListIterator</db:link> and <db:link xlink:href="qmutablelistiterator.xml">QMutableListIterator</db:link>) and <db:link xlink:href="containers.xml#stl-style-iterators">STL-style iterators</db:link> (<db:link xlink:href="qlist-const-iterator.xml">QList::const_iterator</db:link> and <db:link xlink:href="qlist-iterator.xml">QList::iterator</db:link>). In practice, these are rarely used, because you can use indexes into the <db:link xlink:href="qlist.xml">QList</db:link>. <db:link xlink:href="qlist.xml">QList</db:link> is implemented in such a way that direct index-based access is just as fast as using iterators.</db:para>
<db:para><db:link xlink:href="qlist.xml">QList</db:link> does <db:emphasis>not</db:emphasis> support inserting, prepending, appending or replacing with references to its own values. Doing so will cause your application to abort with an error message.</db:para>
<db:para>To make <db:link xlink:href="qlist.xml">QList</db:link> as efficient as possible, its member functions don't validate their input before using it. Except for <db:link xlink:href="qml-geoshape.xml#isempty">isEmpty()</db:link>, member functions always assume the list is <db:emphasis>not</db:emphasis> empty. Member functions that take index values as parameters always assume their index value parameters are in the valid range. This means <db:link xlink:href="qlist.xml">QList</db:link> member functions can fail. If you define QT_NO_DEBUG when you compile, failures will not be detected. If you <db:emphasis>don't</db:emphasis> define QT_NO_DEBUG, failures will be detected using <db:link xlink:href="qtglobal.xml#Q_ASSERT">Q_ASSERT</db:link>() or <db:link xlink:href="qtglobal.xml#Q_ASSERT_X">Q_ASSERT_X</db:link>() with an appropriate message.</db:para>
<db:para>To avoid failures when your list can be empty, call <db:link xlink:href="qml-geoshape.xml#isempty">isEmpty()</db:link> before calling other member functions. If you must pass an index value that might not be in the valid range, check that it is less than the value returned by size() but <db:emphasis>not</db:emphasis> less than 0.</db:para>
<db:section xml:id="more-members">
<db:title>More Members</db:title>
<db:para>If T is a <db:link xlink:href="qbytearray.xml">QByteArray</db:link>, this class has a couple more members that can be used. See the documentation for <db:link xlink:href="qbytearraylist.xml">QByteArrayList</db:link> for more information.</db:para>
<db:para>If T is <db:link xlink:href="qstring.xml">QString</db:link>, this class has the following additional members: <db:link xlink:href="qstringlist.xml#filter">filter</db:link>, <db:link xlink:href="qstringlist.xml#join">join</db:link>, <db:link xlink:href="qstringlist.xml#removeDuplicates">removeDuplicates</db:link>, <db:link xlink:href="qstringlist.xml#sort">sort</db:link>.</db:para>
</db:section>
<db:section xml:id="more-information-on-using-qt-containers">
<db:title>More Information on Using Qt Containers</db:title>
<db:para>For a detailed discussion comparing Qt containers with each other and with STL containers, see <db:link xlink:href="http://marcmutz.wordpress.com/effective-qt/containers/">Understand the Qt Containers</db:link>.</db:para>
</db:section>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qlistiterator.xml">QListIterator</db:link></db:member>
<db:member><db:link xlink:href="qmutablelistiterator.xml">QMutableListIterator</db:link></db:member>
<db:member><db:link xlink:href="qlinkedlist.xml">QLinkedList</db:link></db:member>
<db:member><db:link xlink:href="qvector.xml">QVector</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="member-type-documentation">
<db:title>Member Type Documentation</db:title>
<db:section xml:id="ConstIterator-typedef">
<db:title>QList::ConstIterator</db:title>
<db:para>Qt-style synonym for <db:link xlink:href="qlist-const-iterator.xml">QList::const_iterator</db:link>.</db:para>
</db:section>
<db:section xml:id="Iterator-typedef">
<db:title>QList::Iterator</db:title>
<db:para>Qt-style synonym for <db:link xlink:href="qlist-iterator.xml">QList::iterator</db:link>.</db:para>
</db:section>
<db:section xml:id="const_pointer-typedef">
<db:title>QList::const_pointer</db:title>
<db:para>Typedef for const T *. Provided for STL compatibility.</db:para>
</db:section>
<db:section xml:id="const_reference-typedef">
<db:title>QList::const_reference</db:title>
<db:para>Typedef for const T &amp;. Provided for STL compatibility.</db:para>
</db:section>
<db:section xml:id="const_reverse_iterator-typedef">
<db:title>[since 5.6] QList::const_reverse_iterator</db:title>
<db:para>The QList::const_reverse_iterator typedef provides an STL-style const reverse iterator for <db:link xlink:href="qlist.xml">QList</db:link>.</db:para>
<db:para>It is simply a typedef for <db:code>std::reverse_iterator&lt;const_iterator&gt;</db:code>.</db:para>
<db:warning>
<db:para>Iterators on implicitly shared containers do not work exactly like STL-iterators. You should avoid copying a container while iterators are active on that container. For more information, read <db:link xlink:href="containers.xml#implicit-sharing-iterator-problem">Implicit sharing iterator problem</db:link>.</db:para>
</db:warning>
<db:para>This typedef was introduced in Qt 5.6.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="">QList::rbegin()</db:link></db:member>
<db:member><db:link xlink:href="">QList::rend()</db:link></db:member>
<db:member><db:link xlink:href="qlist.xml#reverse_iterator-typedef">QList::reverse_iterator</db:link></db:member>
<db:member><db:link xlink:href="qlist-const-iterator.xml">QList::const_iterator</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="difference_type-typedef">
<db:title>QList::difference_type</db:title>
<db:para>Typedef for ptrdiff_t. Provided for STL compatibility.</db:para>
</db:section>
<db:section xml:id="pointer-typedef">
<db:title>QList::pointer</db:title>
<db:para>Typedef for T *. Provided for STL compatibility.</db:para>
</db:section>
<db:section xml:id="reference-typedef">
<db:title>QList::reference</db:title>
<db:para>Typedef for T &amp;. Provided for STL compatibility.</db:para>
</db:section>
<db:section xml:id="reverse_iterator-typedef">
<db:title>[since 5.6] QList::reverse_iterator</db:title>
<db:para>The QList::reverse_iterator typedef provides an STL-style non-const reverse iterator for <db:link xlink:href="qlist.xml">QList</db:link>.</db:para>
<db:para>It is simply a typedef for <db:code>std::reverse_iterator&lt;iterator&gt;</db:code>.</db:para>
<db:warning>
<db:para>Iterators on implicitly shared containers do not work exactly like STL-iterators. You should avoid copying a container while iterators are active on that container. For more information, read <db:link xlink:href="containers.xml#implicit-sharing-iterator-problem">Implicit sharing iterator problem</db:link>.</db:para>
</db:warning>
<db:para>This typedef was introduced in Qt 5.6.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="">QList::rbegin()</db:link></db:member>
<db:member><db:link xlink:href="">QList::rend()</db:link></db:member>
<db:member><db:link xlink:href="qlist.xml#const_reverse_iterator-typedef">QList::const_reverse_iterator</db:link></db:member>
<db:member><db:link xlink:href="qlist-iterator.xml">QList::iterator</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="size_type-typedef">
<db:title>QList::size_type</db:title>
<db:para>Typedef for int. Provided for STL compatibility.</db:para>
</db:section>
<db:section xml:id="value_type-typedef">
<db:title>QList::value_type</db:title>
<db:para>Typedef for T. Provided for STL compatibility.</db:para>
</db:section>
</db:section>
</db:article>
