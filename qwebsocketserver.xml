<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en">
<db:info>
<db:title>QWebSocketServer Class</db:title>
<db:productname>QtWebSockets</db:productname>
<db:edition>Qt 6.5.3 Reference Documentation</db:edition>
<db:titleabbrev>Qt WebSockets Reference Documentation</db:titleabbrev>
<db:abstract>
<db:para>Implements a WebSocket-based server.</db:para>
</db:abstract>
<db:pubdate>2024-02-14</db:pubdate>
<db:date>2024-02-14</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:variablelist>
<db:varlistentry>
<db:term>Header</db:term>
<db:listitem>
<db:para>QWebSocketServer</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>CMake</db:term>
<db:listitem>
<db:para>find_package(Qt6 REQUIRED COMPONENTS WebSockets)</db:para>
<db:para>target_link_libraries(mytarget PRIVATE Qt6::WebSockets)</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>qmake</db:term>
<db:listitem>
<db:para>QT += websockets</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Inherits</db:term>
<db:listitem>
<db:para><db:link xlink:href="qobject.xml" xlink:role="class">QObject</db:link></db:para>
</db:listitem>
</db:varlistentry>
</db:variablelist>
<db:section xml:id="details">
<db:title>Detailed Description</db:title>
<db:para>It is modeled after <db:link xlink:href="qtcpserver.xml">QTcpServer</db:link>, and behaves the same. So, if you know how to use <db:link xlink:href="qtcpserver.xml">QTcpServer</db:link>, you know how to use <db:link xlink:href="qwebsocketserver.xml">QWebSocketServer</db:link>. This class makes it possible to accept incoming WebSocket connections. You can specify the port or have <db:link xlink:href="qwebsocketserver.xml">QWebSocketServer</db:link> pick one automatically. You can listen on a specific address or on all the machine's addresses. Call <db:link xlink:href="qwebsocketserver.xml#listen">listen</db:link>() to have the server listen for incoming connections.</db:para>
<db:para>The <db:link xlink:href="qwebsocketserver.xml#newConnection">newConnection</db:link>() signal is then emitted each time a client connects to the server. Call <db:link xlink:href="qwebsocketserver.xml#nextPendingConnection">nextPendingConnection</db:link>() to accept the pending connection as a connected <db:link xlink:href="qwebsocket.xml">QWebSocket</db:link>. The function returns a pointer to a <db:link xlink:href="qwebsocket.xml">QWebSocket</db:link> in <db:link xlink:href="qabstractsocket.xml#SocketState-enum">QAbstractSocket::ConnectedState</db:link> that you can use for communicating with the client.</db:para>
<db:para>If an error occurs, <db:link xlink:href="qwebsocketserver.xml#serverError">serverError</db:link>() returns the type of error, and <db:link xlink:href="qwebsocketserver.xml#errorString">errorString</db:link>() can be called to get a human readable description of what happened.</db:para>
<db:para>When listening for connections, the address and port on which the server is listening are available as <db:link xlink:href="qwebsocketserver.xml#serverAddress">serverAddress</db:link>() and <db:link xlink:href="qwebsocketserver.xml#serverPort">serverPort</db:link>().</db:para>
<db:para>Calling <db:link xlink:href="qwebsocketserver.xml#close">close</db:link>() makes <db:link xlink:href="qwebsocketserver.xml">QWebSocketServer</db:link> stop listening for incoming connections.</db:para>
<db:para><db:link xlink:href="qwebsocketserver.xml">QWebSocketServer</db:link> currently does not support <db:link xlink:href="https://datatracker.ietf.org/doc/html/rfc6455#section-9">WebSocket Extensions</db:link>.</db:para>
<db:note>
<db:para>When working with self-signed certificates, <db:link xlink:href="https://bugzilla.mozilla.org/show_bug.cgi?id=594502">Firefox bug 594502</db:link> prevents <db:link xlink:href="https://www.mozilla.org/firefox">Firefox</db:link> to connect to a secure WebSocket server. To work around this problem, first browse to the secure WebSocket server using HTTPS. FireFox will indicate that the certificate is invalid. From here on, the certificate can be added to the exceptions. After this, the secure WebSockets connection should work.</db:para>
</db:note>
<db:para><db:link xlink:href="qwebsocketserver.xml">QWebSocketServer</db:link> only supports version 13 of the WebSocket protocol, as outlined in <db:link xlink:href="https://datatracker.ietf.org/doc/html/rfc6455">RFC 6455</db:link>.</db:para>
<db:para>There is a default connection handshake timeout of 10 seconds to avoid denial of service, which can be customized using <db:link xlink:href="qwebsocketserver.xml#setHandshakeTimeout">setHandshakeTimeout</db:link>().</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="echoserver.xml">WebSocket Server Example</db:link></db:member>
<db:member><db:link xlink:href="qwebsocket.xml">QWebSocket</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="member-type-documentation">
<db:title>Member Type Documentation</db:title>
<db:section xml:id="SslMode-enum">
<db:title>enum QWebSocketServer::SslMode</db:title>
<db:enumsynopsis>
<db:enumname>SslMode</db:enumname>
<db:enumitem>
<db:enumidentifier>SecureMode</db:enumidentifier>
<db:enumvalue>0</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>NonSecureMode</db:enumidentifier>
<db:enumvalue>1</db:enumvalue>
</db:enumitem>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:enumsynopsis>
<db:para>Indicates whether the server operates over wss (SecureMode) or ws (NonSecureMode)</db:para>
<db:informaltable>
<db:thead>
<db:tr>
<db:th>Constant</db:th>
<db:th>Value</db:th>
<db:th>Description</db:th>
</db:tr>
</db:thead>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qwebsocketserver.xml">QWebSocketServer</db:link></db:emphasis>::SecureMode</db:code></db:para>
</db:td>
<db:td><db:code>0</db:code></db:td>
<db:td>
<db:para>The server operates in secure mode (over wss)</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qwebsocketserver.xml">QWebSocketServer</db:link></db:emphasis>::NonSecureMode</db:code></db:para>
</db:td>
<db:td><db:code>1</db:code></db:td>
<db:td>
<db:para>The server operates in non-secure mode (over ws)</db:para>
</db:td>
</db:tr>
</db:informaltable>
</db:section>
</db:section>
<db:section xml:id="member-function-documentation">
<db:title>Member Function Documentation</db:title>
<db:section xml:id="QWebSocketServer-1">
<db:title>[explicit] QWebSocketServer::QWebSocketServer(const QString &amp;<db:emphasis>serverName</db:emphasis>, QWebSocketServer::SslMode <db:emphasis>secureMode</db:emphasis>, QObject *<db:emphasis>parent</db:emphasis> = nullptr)</db:title>
<db:constructorsynopsis>
<db:methodname>QWebSocketServer</db:methodname>
<db:methodparam>
<db:type>const QString &amp;</db:type>
<db:parameter>serverName</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>QWebSocketServer::SslMode</db:type>
<db:parameter>secureMode</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>QObject *</db:type>
<db:parameter>parent</db:parameter>
<db:initializer>nullptr</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">constructor</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">QWebSocketServer(const QString &amp;serverName, QWebSocketServer::SslMode secureMode, QObject *parent)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:constructorsynopsis>
<db:para>Constructs a new <db:link xlink:href="qwebsocketserver.xml">QWebSocketServer</db:link> with the given <db:code role="parameter">serverName</db:code>. The <db:code role="parameter">serverName</db:code> will be used in the HTTP handshake phase to identify the server. It can be empty, in which case no server name will be sent to the client. The <db:code role="parameter">secureMode</db:code> parameter indicates whether the server operates over wss (<db:link xlink:href="qwebsocketserver.xml#SslMode-enum">SecureMode</db:link>) or over ws (<db:link xlink:href="qwebsocketserver.xml#SslMode-enum">NonSecureMode</db:link>).</db:para>
<db:para><db:code role="parameter">parent</db:code> is passed to the <db:link xlink:href="qobject.xml">QObject</db:link> constructor.</db:para>
</db:section>
<db:section xml:id="dtor.QWebSocketServer">
<db:title>[override virtual] QWebSocketServer::~QWebSocketServer()</db:title>
<db:destructorsynopsis>
<db:modifier>virtual</db:modifier>
<db:methodname>~QWebSocketServer</db:methodname>
<db:void/>
<db:modifier>override</db:modifier>
<db:synopsisinfo role="meta">destructor</db:synopsisinfo>
<db:synopsisinfo role="signature">~QWebSocketServer() override</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:destructorsynopsis>
<db:para>Destroys the <db:link xlink:href="qwebsocketserver.xml">QWebSocketServer</db:link> object. If the server is listening for connections, the socket is automatically closed. Any client <db:link xlink:href="qwebsocket.xml">QWebSocket</db:link>s that are still queued are closed and deleted.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qwebsocketserver.xml#close">close</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="acceptError">
<db:title>void QWebSocketServer::acceptError(QAbstractSocket::SocketError <db:emphasis>socketError</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>acceptError</db:methodname>
<db:methodparam>
<db:type>QAbstractSocket::SocketError</db:type>
<db:parameter>socketError</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void acceptError(QAbstractSocket::SocketError socketError)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This signal is emitted when the acceptance of a new connection results in an error. The <db:code role="parameter">socketError</db:code> parameter describes the type of error that occurred.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qwebsocketserver.xml#pauseAccepting">pauseAccepting</db:link>()</db:member>
<db:member><db:link xlink:href="qwebsocketserver.xml#resumeAccepting">resumeAccepting</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="alertReceived">
<db:title>[since 6.2] void QWebSocketServer::alertReceived(QSsl::AlertLevel <db:emphasis>level</db:emphasis>, QSsl::AlertType <db:emphasis>type</db:emphasis>, const QString &amp;<db:emphasis>description</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>alertReceived</db:methodname>
<db:methodparam>
<db:type>QSsl::AlertLevel</db:type>
<db:parameter>level</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>QSsl::AlertType</db:type>
<db:parameter>type</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const QString &amp;</db:type>
<db:parameter>description</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void alertReceived(QSsl::AlertLevel level, QSsl::AlertType type, const QString &amp;description)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para><db:link xlink:href="qwebsocketserver.xml">QWebSocketServer</db:link> emits this signal if an alert message was received from a peer. <db:code role="parameter">level</db:code> tells if the alert was fatal or it was a warning. <db:code role="parameter">type</db:code> is the code explaining why the alert was sent. When a textual description of the alert message is available, it is supplied in <db:code role="parameter">description</db:code>.</db:para>
<db:note>
<db:para>The signal is mostly for informational and debugging purposes and does not require any handling in the application. If the alert was fatal, underlying backend will handle it and close the connection.</db:para>
</db:note>
<db:note>
<db:para>Not all backends support this functionality.</db:para>
</db:note>
<db:para>This function was introduced in Qt 6.2.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qwebsocketserver.xml#alertSent">alertSent</db:link>()</db:member>
<db:member><db:link xlink:href="qsslsocket.xml#AlertLevel-enum">QSsl::AlertLevel</db:link></db:member>
<db:member><db:link xlink:href="qsslsocket.xml#AlertType-enum">QSsl::AlertType</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="alertSent">
<db:title>[since 6.2] void QWebSocketServer::alertSent(QSsl::AlertLevel <db:emphasis>level</db:emphasis>, QSsl::AlertType <db:emphasis>type</db:emphasis>, const QString &amp;<db:emphasis>description</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>alertSent</db:methodname>
<db:methodparam>
<db:type>QSsl::AlertLevel</db:type>
<db:parameter>level</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>QSsl::AlertType</db:type>
<db:parameter>type</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const QString &amp;</db:type>
<db:parameter>description</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void alertSent(QSsl::AlertLevel level, QSsl::AlertType type, const QString &amp;description)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para><db:link xlink:href="qwebsocketserver.xml">QWebSocketServer</db:link> emits this signal if an alert message was sent to a peer. <db:code role="parameter">level</db:code> describes if it was a warning or a fatal error. <db:code role="parameter">type</db:code> gives the code of the alert message. When a textual description of the alert message is available, it is supplied in <db:code role="parameter">description</db:code>.</db:para>
<db:note>
<db:para>This signal is mostly informational and can be used for debugging purposes, normally it does not require any actions from the application.</db:para>
</db:note>
<db:note>
<db:para>Not all backends support this functionality.</db:para>
</db:note>
<db:para>This function was introduced in Qt 6.2.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qwebsocketserver.xml#alertReceived">alertReceived</db:link>()</db:member>
<db:member><db:link xlink:href="qsslsocket.xml#AlertLevel-enum">QSsl::AlertLevel</db:link></db:member>
<db:member><db:link xlink:href="qsslsocket.xml#AlertType-enum">QSsl::AlertType</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="close">
<db:title>void QWebSocketServer::close()</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>close</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void close()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Closes the server. The server will no longer listen for incoming connections.</db:para>
</db:section>
<db:section xml:id="closed">
<db:title>void QWebSocketServer::closed()</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>closed</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void closed()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This signal is emitted when the server closed its connection.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qwebsocketserver.xml#close">close</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="error">
<db:title>QWebSocketProtocol::CloseCode QWebSocketServer::error() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QWebSocketProtocol::CloseCode</db:type>
<db:methodname>error</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QWebSocketProtocol::CloseCode error() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns an error code for the last error that occurred. If no error occurred, <db:link xlink:href="qwebsocketprotocol.xml#CloseCode-enum">QWebSocketProtocol::CloseCodeNormal</db:link> is returned.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qwebsocketserver.xml#errorString">errorString</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="errorString">
<db:title>QString QWebSocketServer::errorString() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QString</db:type>
<db:methodname>errorString</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QString errorString() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns a human readable description of the last error that occurred. If no error occurred, an empty string is returned.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qwebsocketserver.xml#serverError">serverError</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="handleConnection">
<db:title>void QWebSocketServer::handleConnection(QTcpSocket *<db:emphasis>socket</db:emphasis>) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:void/>
<db:methodname>handleConnection</db:methodname>
<db:methodparam>
<db:type>QTcpSocket *</db:type>
<db:parameter>socket</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void handleConnection(QTcpSocket *socket) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Upgrades a tcp <db:code role="parameter">socket</db:code> to websocket.</db:para>
<db:para>The <db:link xlink:href="qwebsocketserver.xml">QWebSocketServer</db:link> object will take ownership of the socket object and delete it when appropriate.</db:para>
</db:section>
<db:section xml:id="handshakeInterruptedOnError">
<db:title>[since 6.2] void QWebSocketServer::handshakeInterruptedOnError(const QSslError &amp;<db:emphasis>error</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>handshakeInterruptedOnError</db:methodname>
<db:methodparam>
<db:type>const QSslError &amp;</db:type>
<db:parameter>error</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void handshakeInterruptedOnError(const QSslError &amp;error)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para><db:link xlink:href="qwebsocketserver.xml">QWebSocketServer</db:link> emits this signal if a certificate verification <db:code role="parameter">error</db:code> was found and if early error reporting was enabled in <db:link xlink:href="qsslconfiguration.xml">QSslConfiguration</db:link>.</db:para>
<db:para>This function was introduced in Qt 6.2.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qwebsocketserver.xml#sslErrors">sslErrors</db:link>()</db:member>
<db:member><db:link xlink:href="qsslconfiguration.xml#setHandshakeMustInterruptOnError">QSslConfiguration::setHandshakeMustInterruptOnError</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="handshakeTimeout">
<db:title>std::chrono::milliseconds QWebSocketServer::handshakeTimeout() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>std::chrono::milliseconds</db:type>
<db:methodname>handshakeTimeout</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">std::chrono::milliseconds handshakeTimeout() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the handshake timeout for new connections in milliseconds.</db:para>
<db:para>The default is 10 seconds. If a peer uses more time to complete the handshake their connection is closed.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qwebsocketserver.xml#setHandshakeTimeout">setHandshakeTimeout</db:link>()</db:member>
<db:member><db:link xlink:href="qwebsocketserver.xml#handshakeTimeoutMS">handshakeTimeoutMS</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="handshakeTimeoutMS">
<db:title>int QWebSocketServer::handshakeTimeoutMS() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>int</db:type>
<db:methodname>handshakeTimeoutMS</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">int handshakeTimeoutMS() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the handshake timeout for new connections in milliseconds.</db:para>
<db:para>The default is 10 seconds. If a peer uses more time to complete the handshake their connection is closed.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qwebsocketserver.xml#setHandshakeTimeout">setHandshakeTimeout</db:link>()</db:member>
<db:member><db:link xlink:href="qwebsocketserver.xml#handshakeTimeout">handshakeTimeout</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="hasPendingConnections">
<db:title>bool QWebSocketServer::hasPendingConnections() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>bool</db:type>
<db:methodname>hasPendingConnections</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool hasPendingConnections() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns true if the server has pending connections; otherwise returns false.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qwebsocketserver.xml#nextPendingConnection">nextPendingConnection</db:link>()</db:member>
<db:member><db:link xlink:href="qwebsocketserver.xml#setMaxPendingConnections">setMaxPendingConnections</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="isListening">
<db:title>bool QWebSocketServer::isListening() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>bool</db:type>
<db:methodname>isListening</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool isListening() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns true if the server is currently listening for incoming connections; otherwise returns false. If listening fails, <db:link xlink:href="qwebsocketserver.xml#error">error</db:link>() will return the reason.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qwebsocketserver.xml#listen">listen</db:link>()</db:member>
<db:member><db:link xlink:href="qwebsocketserver.xml#error">error</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="listen">
<db:title>bool QWebSocketServer::listen(const QHostAddress &amp;<db:emphasis>address</db:emphasis> = QHostAddress::Any, quint16 <db:emphasis>port</db:emphasis> = 0)</db:title>
<db:methodsynopsis>
<db:type>bool</db:type>
<db:methodname>listen</db:methodname>
<db:methodparam>
<db:type>const QHostAddress &amp;</db:type>
<db:parameter>address</db:parameter>
<db:initializer>QHostAddress::Any</db:initializer>
</db:methodparam>
<db:methodparam>
<db:type>quint16</db:type>
<db:parameter>port</db:parameter>
<db:initializer>0</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool listen(const QHostAddress &amp;address, quint16 port)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Tells the server to listen for incoming connections on address <db:code role="parameter">address</db:code> and port <db:code role="parameter">port</db:code>. If <db:code role="parameter">port</db:code> is 0, a port is chosen automatically. If <db:code role="parameter">address</db:code> is <db:link xlink:href="qhostaddress.xml#SpecialAddress-enum">QHostAddress::Any</db:link>, the server will listen on all network interfaces.</db:para>
<db:para>Returns true on success; otherwise returns false.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qwebsocketserver.xml#isListening">isListening</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="maxPendingConnections">
<db:title>int QWebSocketServer::maxPendingConnections() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>int</db:type>
<db:methodname>maxPendingConnections</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">int maxPendingConnections() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the maximum number of pending accepted connections. The default is 30.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qwebsocketserver.xml#setMaxPendingConnections">setMaxPendingConnections</db:link>()</db:member>
<db:member><db:link xlink:href="qwebsocketserver.xml#hasPendingConnections">hasPendingConnections</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="newConnection">
<db:title>void QWebSocketServer::newConnection()</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>newConnection</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void newConnection()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This signal is emitted every time a new connection is available.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qwebsocketserver.xml#hasPendingConnections">hasPendingConnections</db:link>()</db:member>
<db:member><db:link xlink:href="qwebsocketserver.xml#nextPendingConnection">nextPendingConnection</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="nextPendingConnection">
<db:title>[virtual] QWebSocket *QWebSocketServer::nextPendingConnection()</db:title>
<db:methodsynopsis>
<db:modifier>virtual</db:modifier>
<db:type>QWebSocket *</db:type>
<db:methodname>nextPendingConnection</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QWebSocket * nextPendingConnection()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the next pending connection as a connected <db:link xlink:href="qwebsocket.xml">QWebSocket</db:link> object. <db:link xlink:href="qwebsocketserver.xml">QWebSocketServer</db:link> does not take ownership of the returned <db:link xlink:href="qwebsocket.xml">QWebSocket</db:link> object. It is up to the caller to delete the object explicitly when it will no longer be used, otherwise a memory leak will occur. nullptr is returned if this function is called when there are no pending connections.</db:para>
<db:para>Note: The returned <db:link xlink:href="qwebsocket.xml">QWebSocket</db:link> object cannot be used from another thread.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qwebsocketserver.xml#hasPendingConnections">hasPendingConnections</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="originAuthenticationRequired">
<db:title>void QWebSocketServer::originAuthenticationRequired(QWebSocketCorsAuthenticator *<db:emphasis>authenticator</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>originAuthenticationRequired</db:methodname>
<db:methodparam>
<db:type>QWebSocketCorsAuthenticator *</db:type>
<db:parameter>authenticator</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void originAuthenticationRequired(QWebSocketCorsAuthenticator *authenticator)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This signal is emitted when a new connection is requested. The slot connected to this signal should indicate whether the origin (which can be determined by the origin() call) is allowed in the <db:code role="parameter">authenticator</db:code> object (by issuing <db:link xlink:href="qwebsocketcorsauthenticator.xml#setAllowed">setAllowed</db:link>()).</db:para>
<db:para>If no slot is connected to this signal, all origins will be accepted by default.</db:para>
<db:note>
<db:para>It is not possible to use a QueuedConnection to connect to this signal, as the connection will always succeed.</db:para>
</db:note>
</db:section>
<db:section xml:id="pauseAccepting">
<db:title>void QWebSocketServer::pauseAccepting()</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>pauseAccepting</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void pauseAccepting()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Pauses incoming new connections. Queued connections will remain in queue.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qwebsocketserver.xml#resumeAccepting">resumeAccepting</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="peerVerifyError">
<db:title>void QWebSocketServer::peerVerifyError(const QSslError &amp;<db:emphasis>error</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>peerVerifyError</db:methodname>
<db:methodparam>
<db:type>const QSslError &amp;</db:type>
<db:parameter>error</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void peerVerifyError(const QSslError &amp;error)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para><db:link xlink:href="qwebsocketserver.xml">QWebSocketServer</db:link> can emit this signal several times during the SSL handshake, before encryption has been established, to indicate that an error has occurred while establishing the identity of the peer. The <db:code role="parameter">error</db:code> is usually an indication that <db:link xlink:href="qwebsocketserver.xml">QWebSocketServer</db:link> is unable to securely identify the peer.</db:para>
<db:para>This signal provides you with an early indication when something is wrong. By connecting to this signal, you can manually choose to tear down the connection from inside the connected slot before the handshake has completed. If no action is taken, <db:link xlink:href="qwebsocketserver.xml">QWebSocketServer</db:link> will proceed to emitting <db:link xlink:href="qwebsocketserver.xml#sslErrors">QWebSocketServer::sslErrors</db:link>().</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qwebsocketserver.xml#sslErrors">sslErrors</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="preSharedKeyAuthenticationRequired">
<db:title>void QWebSocketServer::preSharedKeyAuthenticationRequired(QSslPreSharedKeyAuthenticator *<db:emphasis>authenticator</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>preSharedKeyAuthenticationRequired</db:methodname>
<db:methodparam>
<db:type>QSslPreSharedKeyAuthenticator *</db:type>
<db:parameter>authenticator</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void preSharedKeyAuthenticationRequired(QSslPreSharedKeyAuthenticator *authenticator)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para><db:link xlink:href="qwebsocketserver.xml">QWebSocketServer</db:link> emits this signal when it negotiates a PSK ciphersuite, and therefore a PSK authentication is then required.</db:para>
<db:para>When using PSK, the client must send to the server a valid identity and a valid pre shared key, in order for the SSL handshake to continue. Applications can provide this information in a slot connected to this signal, by filling in the passed <db:code role="parameter">authenticator</db:code> object according to their needs.</db:para>
<db:note>
<db:para>Ignoring this signal, or failing to provide the required credentials, will cause the handshake to fail, and therefore the connection to be aborted.</db:para>
</db:note>
<db:note>
<db:para>The <db:code role="parameter">authenticator</db:code> object is owned by the socket and must not be deleted by the application.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qsslpresharedkeyauthenticator.xml">QSslPreSharedKeyAuthenticator</db:link></db:member>
<db:member><db:link xlink:href="qsslsocket.xml#preSharedKeyAuthenticationRequired">QSslSocket::preSharedKeyAuthenticationRequired</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="proxy">
<db:title>QNetworkProxy QWebSocketServer::proxy() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QNetworkProxy</db:type>
<db:methodname>proxy</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QNetworkProxy proxy() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the network proxy for this server. By default <db:link xlink:href="qnetworkproxy.xml#ProxyType-enum">QNetworkProxy::DefaultProxy</db:link> is used.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qwebsocketserver.xml#setProxy">setProxy</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="resumeAccepting">
<db:title>void QWebSocketServer::resumeAccepting()</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>resumeAccepting</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void resumeAccepting()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Resumes accepting new connections.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qwebsocketserver.xml#pauseAccepting">pauseAccepting</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="secureMode">
<db:title>QWebSocketServer::SslMode QWebSocketServer::secureMode() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QWebSocketServer::SslMode</db:type>
<db:methodname>secureMode</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QWebSocketServer::SslMode secureMode() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the secure mode the server is running in.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qwebsocketserver.xml#QWebSocketServer-1">QWebSocketServer</db:link>()</db:member>
<db:member><db:link xlink:href="qwebsocketserver.xml#SslMode-enum">SslMode</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="serverAddress">
<db:title>QHostAddress QWebSocketServer::serverAddress() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QHostAddress</db:type>
<db:methodname>serverAddress</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QHostAddress serverAddress() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the server's address if the server is listening for connections; otherwise returns <db:link xlink:href="qhostaddress.xml#SpecialAddress-enum">QHostAddress::Null</db:link>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qwebsocketserver.xml#serverPort">serverPort</db:link>()</db:member>
<db:member><db:link xlink:href="qwebsocketserver.xml#listen">listen</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="serverError">
<db:title>void QWebSocketServer::serverError(QWebSocketProtocol::CloseCode <db:emphasis>closeCode</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>serverError</db:methodname>
<db:methodparam>
<db:type>QWebSocketProtocol::CloseCode</db:type>
<db:parameter>closeCode</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void serverError(QWebSocketProtocol::CloseCode closeCode)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This signal is emitted when an error occurs during the setup of a WebSocket connection. The <db:code role="parameter">closeCode</db:code> parameter describes the type of error that occurred</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qwebsocketserver.xml#errorString">errorString</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="serverName">
<db:title>QString QWebSocketServer::serverName() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QString</db:type>
<db:methodname>serverName</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QString serverName() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the server name that is used during the http handshake phase.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qwebsocketserver.xml#setServerName">setServerName</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="serverPort">
<db:title>quint16 QWebSocketServer::serverPort() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>quint16</db:type>
<db:methodname>serverPort</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">quint16 serverPort() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the server's port if the server is listening for connections; otherwise returns 0.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qwebsocketserver.xml#serverAddress">serverAddress</db:link>()</db:member>
<db:member><db:link xlink:href="qwebsocketserver.xml#listen">listen</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="serverUrl">
<db:title>QUrl QWebSocketServer::serverUrl() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QUrl</db:type>
<db:methodname>serverUrl</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QUrl serverUrl() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns a URL clients can use to connect to this server if the server is listening for connections. Otherwise an invalid URL is returned.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qwebsocketserver.xml#serverPort">serverPort</db:link>()</db:member>
<db:member><db:link xlink:href="qwebsocketserver.xml#serverAddress">serverAddress</db:link>()</db:member>
<db:member><db:link xlink:href="qwebsocketserver.xml#listen">listen</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setHandshakeTimeout">
<db:title>void QWebSocketServer::setHandshakeTimeout(std::chrono::milliseconds <db:emphasis>msec</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>setHandshakeTimeout</db:methodname>
<db:methodparam>
<db:type>std::chrono::milliseconds</db:type>
<db:parameter>msec</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void setHandshakeTimeout(std::chrono::milliseconds msec)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Sets the handshake timeout for new connections to <db:code role="parameter">msec</db:code> milliseconds.</db:para>
<db:para>By default this is set to 10 seconds. If a peer uses more time to complete the handshake, their connection is closed. You can pass a negative value (e.g. -1) to disable the timeout.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qwebsocketserver.xml#handshakeTimeout">handshakeTimeout</db:link>()</db:member>
<db:member><db:link xlink:href="qwebsocketserver.xml#handshakeTimeoutMS">handshakeTimeoutMS</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setHandshakeTimeout-1">
<db:title>void QWebSocketServer::setHandshakeTimeout(int <db:emphasis>msec</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>setHandshakeTimeout</db:methodname>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>msec</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">void setHandshakeTimeout(int msec)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
</db:section>
<db:section xml:id="setMaxPendingConnections">
<db:title>void QWebSocketServer::setMaxPendingConnections(int <db:emphasis>numConnections</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>setMaxPendingConnections</db:methodname>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>numConnections</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void setMaxPendingConnections(int numConnections)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Sets the maximum number of pending accepted connections to <db:code role="parameter">numConnections</db:code>. <db:link xlink:href="qml-qtwebsockets-websocketserver.xml">WebSocketServer</db:link> will accept no more than <db:code role="parameter">numConnections</db:code> incoming connections before <db:link xlink:href="qwebsocketserver.xml#nextPendingConnection">nextPendingConnection</db:link>() is called. By default, the limit is 30 pending connections.</db:para>
<db:para><db:link xlink:href="qwebsocketserver.xml">QWebSocketServer</db:link> will emit the <db:link xlink:href="qwebsocketserver.xml#error">error</db:link>() signal with the <db:link xlink:href="qwebsocketprotocol.xml#CloseCode-enum">QWebSocketProtocol::CloseCodeAbnormalDisconnection</db:link> close code when the maximum of connections has been reached. The WebSocket handshake will fail and the socket will be closed.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qwebsocketserver.xml#maxPendingConnections">maxPendingConnections</db:link>()</db:member>
<db:member><db:link xlink:href="qwebsocketserver.xml#hasPendingConnections">hasPendingConnections</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setProxy">
<db:title>void QWebSocketServer::setProxy(const QNetworkProxy &amp;<db:emphasis>networkProxy</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>setProxy</db:methodname>
<db:methodparam>
<db:type>const QNetworkProxy &amp;</db:type>
<db:parameter>networkProxy</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void setProxy(const QNetworkProxy &amp;networkProxy)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Sets the explicit network proxy for this server to <db:code role="parameter">networkProxy</db:code>.</db:para>
<db:para>To disable the use of a proxy, use the <db:link xlink:href="qnetworkproxy.xml#ProxyType-enum">QNetworkProxy::NoProxy</db:link> proxy type:</db:para>
<db:programlisting language="cpp">server-&amp;gt;setProxy(QNetworkProxy::NoProxy);
</db:programlisting>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qwebsocketserver.xml#proxy">proxy</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setServerName">
<db:title>void QWebSocketServer::setServerName(const QString &amp;<db:emphasis>serverName</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>setServerName</db:methodname>
<db:methodparam>
<db:type>const QString &amp;</db:type>
<db:parameter>serverName</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void setServerName(const QString &amp;serverName)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Sets the server name that will be used during the HTTP handshake phase to the given <db:code role="parameter">serverName</db:code>. The <db:code role="parameter">serverName</db:code> can be empty, in which case an empty server name will be sent to the client. Existing connected clients will not be notified of this change, only newly connecting clients will see this new name.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qwebsocketserver.xml#serverName">serverName</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setSocketDescriptor">
<db:title>bool QWebSocketServer::setSocketDescriptor(qintptr <db:emphasis>socketDescriptor</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>bool</db:type>
<db:methodname>setSocketDescriptor</db:methodname>
<db:methodparam>
<db:type>qintptr</db:type>
<db:parameter>socketDescriptor</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool setSocketDescriptor(qintptr socketDescriptor)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Sets the socket descriptor this server should use when listening for incoming connections to <db:code role="parameter">socketDescriptor</db:code>.</db:para>
<db:para>Returns true if the socket is set successfully; otherwise returns false. The socket is assumed to be in listening state.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qwebsocketserver.xml#socketDescriptor">socketDescriptor</db:link>()</db:member>
<db:member><db:link xlink:href="qwebsocketserver.xml#isListening">isListening</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setSslConfiguration">
<db:title>void QWebSocketServer::setSslConfiguration(const QSslConfiguration &amp;<db:emphasis>sslConfiguration</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>setSslConfiguration</db:methodname>
<db:methodparam>
<db:type>const QSslConfiguration &amp;</db:type>
<db:parameter>sslConfiguration</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void setSslConfiguration(const QSslConfiguration &amp;sslConfiguration)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Sets the SSL configuration for the <db:link xlink:href="qwebsocketserver.xml">QWebSocketServer</db:link> to <db:code role="parameter">sslConfiguration</db:code>. This method has no effect if <db:link xlink:href="qwebsocketserver.xml">QWebSocketServer</db:link> runs in non-secure mode (<db:link xlink:href="qwebsocketserver.xml#SslMode-enum">QWebSocketServer::NonSecureMode</db:link>).</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qwebsocketserver.xml#sslConfiguration">sslConfiguration</db:link>()</db:member>
<db:member><db:link xlink:href="qwebsocketserver.xml#SslMode-enum">SslMode</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setSupportedSubprotocols">
<db:title>[since 6.4] void QWebSocketServer::setSupportedSubprotocols(const QStringList &amp;<db:emphasis>protocols</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>setSupportedSubprotocols</db:methodname>
<db:methodparam>
<db:type>const QStringList &amp;</db:type>
<db:parameter>protocols</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void setSupportedSubprotocols(const QStringList &amp;protocols)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Sets the list of protocols supported by the server to <db:code role="parameter">protocols</db:code>.</db:para>
<db:para>This function was introduced in Qt 6.4.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qwebsocketserver.xml#supportedSubprotocols">supportedSubprotocols</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="socketDescriptor">
<db:title>qintptr QWebSocketServer::socketDescriptor() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>qintptr</db:type>
<db:methodname>socketDescriptor</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">qintptr socketDescriptor() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the native socket descriptor the server uses to listen for incoming instructions, or -1 if the server is not listening. If the server is using <db:link xlink:href="qnetworkproxy.xml">QNetworkProxy</db:link>, the returned descriptor may not be usable with native socket functions.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qwebsocketserver.xml#setSocketDescriptor">setSocketDescriptor</db:link>()</db:member>
<db:member><db:link xlink:href="qwebsocketserver.xml#isListening">isListening</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="sslConfiguration">
<db:title>QSslConfiguration QWebSocketServer::sslConfiguration() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QSslConfiguration</db:type>
<db:methodname>sslConfiguration</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QSslConfiguration sslConfiguration() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the SSL configuration used by the <db:link xlink:href="qwebsocketserver.xml">QWebSocketServer</db:link>. If the server is not running in secure mode (<db:link xlink:href="qwebsocketserver.xml#SslMode-enum">QWebSocketServer::SecureMode</db:link>), this method returns <db:link xlink:href="qsslconfiguration.xml#defaultConfiguration">QSslConfiguration::defaultConfiguration</db:link>().</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qwebsocketserver.xml#setSslConfiguration">setSslConfiguration</db:link>()</db:member>
<db:member><db:link xlink:href="qwebsocketserver.xml#SslMode-enum">SslMode</db:link></db:member>
<db:member><db:link xlink:href="qsslconfiguration.xml#defaultConfiguration">QSslConfiguration::defaultConfiguration</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="sslErrors">
<db:title>void QWebSocketServer::sslErrors(const QList&lt;QSslError&gt; &amp;<db:emphasis>errors</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>sslErrors</db:methodname>
<db:methodparam>
<db:type>const QList&lt;QSslError&gt; &amp;</db:type>
<db:parameter>errors</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void sslErrors(const QList&lt;QSslError&gt; &amp;errors)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para><db:link xlink:href="qwebsocketserver.xml">QWebSocketServer</db:link> emits this signal after the SSL handshake to indicate that one or more errors have occurred while establishing the identity of the peer. The errors are usually an indication that <db:link xlink:href="qwebsocketserver.xml">QWebSocketServer</db:link> is unable to securely identify the peer. Unless any action is taken, the connection will be dropped after this signal has been emitted.</db:para>
<db:para><db:code role="parameter">errors</db:code> contains one or more errors that prevent <db:link xlink:href="qsslsocket.xml">QSslSocket</db:link> from verifying the identity of the peer.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qwebsocketserver.xml#peerVerifyError">peerVerifyError</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="supportedSubprotocols">
<db:title>[since 6.4] QStringList QWebSocketServer::supportedSubprotocols() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QStringList</db:type>
<db:methodname>supportedSubprotocols</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QStringList supportedSubprotocols() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the list of protocols supported by the server.</db:para>
<db:para>This function was introduced in Qt 6.4.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qwebsocketserver.xml#setSupportedSubprotocols">setSupportedSubprotocols</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="supportedVersions">
<db:title>QList&lt;QWebSocketProtocol::Version&gt; QWebSocketServer::supportedVersions() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QList&lt;QWebSocketProtocol::Version&gt;</db:type>
<db:methodname>supportedVersions</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QList&lt;QWebSocketProtocol::Version&gt; supportedVersions() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns a list of WebSocket versions that this server is supporting.</db:para>
</db:section>
</db:section>
<db:section xml:id="obsolete">
<db:title>Obsolete Members for QWebSocketServer</db:title>
<db:para><db:emphasis role="bold">The following members of class <db:link xlink:href="qwebsocketserver.xml">QWebSocketServer</db:link> are deprecated.</db:emphasis> We strongly advise against using them in new code.</db:para>
<db:section xml:id="obsolete-member-function-documentation">
<db:title>Obsolete Member Function Documentation</db:title>
<db:section xml:id="nativeDescriptor">
<db:title>qintptr QWebSocketServer::nativeDescriptor() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>qintptr</db:type>
<db:methodname>nativeDescriptor</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">qintptr nativeDescriptor() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">deprecated</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This function is deprecated. We strongly advise against using it in new code.</db:para>
<db:para>Returns the native socket descriptor the server uses to listen for incoming instructions, or -1 if the server is not listening. If the server is using <db:link xlink:href="qnetworkproxy.xml">QNetworkProxy</db:link>, the returned descriptor may not be usable with native socket functions.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qwebsocketserver.xml#setNativeDescriptor">setNativeDescriptor</db:link>()</db:member>
<db:member><db:link xlink:href="qwebsocketserver.xml#socketDescriptor">socketDescriptor</db:link>()</db:member>
<db:member><db:link xlink:href="qwebsocketserver.xml#isListening">isListening</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setNativeDescriptor">
<db:title>bool QWebSocketServer::setNativeDescriptor(qintptr <db:emphasis>socketDescriptor</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>bool</db:type>
<db:methodname>setNativeDescriptor</db:methodname>
<db:methodparam>
<db:type>qintptr</db:type>
<db:parameter>socketDescriptor</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool setNativeDescriptor(qintptr socketDescriptor)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">deprecated</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This function is deprecated. We strongly advise against using it in new code.</db:para>
<db:para>Sets the socket descriptor this server should use when listening for incoming connections to <db:code role="parameter">socketDescriptor</db:code>.</db:para>
<db:para>Returns true if the socket is set successfully; otherwise returns false. The socket is assumed to be in listening state.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qwebsocketserver.xml#nativeDescriptor">nativeDescriptor</db:link>()</db:member>
<db:member><db:link xlink:href="qwebsocketserver.xml#setSocketDescriptor">setSocketDescriptor</db:link>()</db:member>
<db:member><db:link xlink:href="qwebsocketserver.xml#isListening">isListening</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
</db:section>
</db:section>
</db:article>
