<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en">
<db:info>
<db:title>&lt;QtAlgorithms&gt; - Generic Algorithms</db:title>
<db:productname>QtCore</db:productname>
<db:edition>Qt 5.12.12 Reference Documentation</db:edition>
<db:titleabbrev>Qt Core Reference Documentation</db:titleabbrev>
<db:abstract>
<db:para>The &lt;QtAlgorithms&gt; header includes the generic, template-based algorithms.</db:para>
</db:abstract>
<db:pubdate>2024-12-27</db:pubdate>
<db:date>2024-12-27</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:variablelist>
<db:varlistentry>
<db:term>Header</db:term>
<db:listitem>
<db:para>QtAlgorithms</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Group</db:term>
<db:listitem>
<db:para>&lt;QtAlgorithms&gt; is part of <db:simplelist><db:member>funclists</db:member></db:simplelist></db:para>
</db:listitem>
</db:varlistentry>
</db:variablelist>
<db:section xml:id="details">
<db:title>Detailed Description</db:title>
<db:para>Qt provides a number of global template functions in &lt;QtAlgorithms&gt; that work on containers and perform small tasks to make life easier, such as <db:link xlink:href="qtalgorithms.xml#qDeleteAll">qDeleteAll</db:link>(), which invokes operator delete on all items in a given container or in a given range. You can use these algorithms with any <db:link xlink:href="containers.xml">container class</db:link> that provides STL-style iterators, including Qt's <db:link xlink:href="qlist.xml">QList</db:link>, <db:link xlink:href="qlinkedlist.xml">QLinkedList</db:link>, <db:link xlink:href="qvector.xml">QVector</db:link>, <db:link xlink:href="qmap.xml">QMap</db:link>, and <db:link xlink:href="qhash.xml#qhash">QHash</db:link> classes.</db:para>
<db:para>Most algorithms take <db:link xlink:href="containers.xml#stl-style-iterators">STL-style iterators</db:link> as parameters. The algorithms are generic in the sense that they aren't bound to a specific iterator class; you can use them with any iterators that meet a certain set of requirements.</db:para>
<db:para>Different algorithms can have different requirements for the iterators they accept. For example, qFill() accepts two <db:link xlink:href="qtalgorithms.xml#forward-iterators">forward iterators</db:link>. The iterator types required are specified for each algorithm. If an iterator of the wrong type is passed (for example, if <db:link xlink:href="qlist.xml#ConstIterator-typedef">QList::ConstIterator</db:link> is passed as an <db:link xlink:href="qtalgorithms.xml#output-iterators">output iterator</db:link>), you will always get a compiler error, although not necessarily a very informative one.</db:para>
<db:para>Some algorithms have special requirements on the value type stored in the containers. For example, <db:link xlink:href="qtalgorithms.xml#qDeleteAll">qDeleteAll</db:link>() requires that the value type is a non-const pointer type (for example, <db:link xlink:href="qwidget.xml">QWidget</db:link> *). The value type requirements are specified for each algorithm, and the compiler will produce an error if a requirement isn't met.</db:para>
<db:para>The generic algorithms can be used on other container classes than those provided by Qt and STL. The syntax of STL-style iterators is modeled after C++ pointers, so it's possible to use plain arrays as containers and plain pointers as iterators. A common idiom is to use qBinaryFind() together with two static arrays: one that contains a list of keys, and another that contains a list of associated values. For example, the following code will look up an HTML entity (e.g., &amp;amp;) in the name_table array and return the corresponding Unicode value from the value_table if the entity is recognized:</db:para>
<db:programlisting language="cpp">QChar resolveEntity(const QString &amp;amp;entity)
{
    static const QLatin1String name_table[] = {
        &quot;AElig&quot;, &quot;Aacute&quot;, ..., &quot;zwnj&quot;
    };
    static const ushort value_table[] = {
        0x0061, 0x00c1, ..., 0x200c
    };
    int N = sizeof(name_table) / sizeof(name_table[0]);

    const QLatin1String *name = qBinaryFind(name_table, name_table + N,
                                            entity);
    int index = name - name_table;
    if (index == N)
        return QChar();

    return QChar(value_table[index]);
}
</db:programlisting>
<db:para>This kind of code is for advanced users only; for most applications, a <db:link xlink:href="qmap.xml">QMap</db:link>- or <db:link xlink:href="qhash.xml#qhash">QHash</db:link>-based approach would work just as well:</db:para>
<db:programlisting language="cpp">QChar resolveEntity(const QString &amp;amp;entity)
{
    static QMap&amp;lt;QString, int&amp;gt; entityMap;

    if (!entityMap) {
        entityMap.insert(&quot;AElig&quot;, 0x0061);
        entityMap.insert(&quot;Aacute&quot;, 0x00c1);
        ...
        entityMap.insert(&quot;zwnj&quot;, 0x200c);
    }
    return QChar(entityMap.value(entity));
}
</db:programlisting>
<db:section xml:id="types-of-iterators">
<db:title>Types of Iterators</db:title>
<db:para>The algorithms have certain requirements on the iterator types they accept, and these are specified individually for each function. The compiler will produce an error if a requirement isn't met.</db:para>
<db:section xml:id="input-iterators">
<db:title>Input Iterators</db:title>
<db:para>An <db:emphasis>input iterator</db:emphasis> is an iterator that can be used for reading data sequentially from a container. It must provide the following operators: == and != for comparing two iterators, unary * for retrieving the value stored in the item, and prefix ++ for advancing to the next item.</db:para>
<db:para>The Qt containers' iterator types (const and non-const) are all input iterators.</db:para>
</db:section>
<db:section xml:id="output-iterators">
<db:title>Output Iterators</db:title>
<db:para>An output iterator is an iterator that can be used for writing data sequentially to a container or to some output stream. It must provide the following operators: unary * for writing a value (i.e., *it = val) and prefix ++ for advancing to the next item.</db:para>
<db:para>The Qt containers' non-const iterator types are all output iterators.</db:para>
</db:section>
<db:section xml:id="forward-iterators">
<db:title>Forward Iterators</db:title>
<db:para>A <db:emphasis>forward iterator</db:emphasis> is an iterator that meets the requirements of both input iterators and output iterators.</db:para>
<db:para>The Qt containers' non-const iterator types are all forward iterators.</db:para>
</db:section>
<db:section xml:id="bidirectional-iterators">
<db:title>Bidirectional Iterators</db:title>
<db:para>A <db:emphasis>bidirectional iterator</db:emphasis> is an iterator that meets the requirements of forward iterators but that in addition supports prefix -- for iterating backward.</db:para>
<db:para>The Qt containers' non-const iterator types are all bidirectional iterators.</db:para>
</db:section>
<db:section xml:id="random-access-iterators">
<db:title>Random Access Iterators</db:title>
<db:para>The last category, <db:emphasis>random access iterators</db:emphasis>, is the most powerful type of iterator. It supports all the requirements of a bidirectional iterator, and supports the following operations:</db:para>
<db:informaltable style="generic">
<db:tr valign="top">
<db:td>
<db:para>i += n</db:para>
</db:td>
<db:td>
<db:para>advances iterator i by n positions</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>i -= n</db:para>
</db:td>
<db:td>
<db:para>moves iterator i back by n positions</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>i + n or n + i</db:para>
</db:td>
<db:td>
<db:para>returns the iterator for the item n positions ahead of iterator i</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>i - n</db:para>
</db:td>
<db:td>
<db:para>returns the iterator for the item n positions behind of iterator i</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>i - j</db:para>
</db:td>
<db:td>
<db:para>returns the number of items between iterators i and j</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>i[n]</db:para>
</db:td>
<db:td>
<db:para>same as *(i + n)</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>i &lt; j</db:para>
</db:td>
<db:td>
<db:para>returns true if iterator j comes after iterator i</db:para>
</db:td>
</db:tr>
</db:informaltable>
<db:para><db:link xlink:href="qlist.xml">QList</db:link> and <db:link xlink:href="qvector.xml">QVector</db:link>'s non-const iterator types are random access iterators.</db:para>
</db:section>
</db:section>
<db:section xml:id="qt-and-the-stl-algorithms">
<db:title>Qt and the STL Algorithms</db:title>
<db:para>Historically, Qt used to provide functions which were direct equivalents of many STL algorithmic functions. Starting with Qt 5.0, you are instead encouraged to use directly the implementations available in the STL; most of the Qt ones have been deprecated (although they are still available to keep the old code compiling).</db:para>
<db:section xml:id="porting-guidelines">
<db:title>Porting guidelines</db:title>
<db:para>Most of the times, an application using the deprecated Qt algorithmic functions can be easily ported to use the equivalent STL functions. You need to</db:para>
<db:orderedlist numeration="arabic">
<db:listitem>
<db:para>add the #include &lt;algorithm&gt; preprocessor directive;</db:para>
</db:listitem>
<db:listitem>
<db:para>replace the Qt functions with the STL counterparts, according to the table below.</db:para>
</db:listitem>
</db:orderedlist>
<db:informaltable style="generic">
<db:thead>
<db:tr>
<db:th>
<db:para>Qt function</db:para>
</db:th>
<db:th>
<db:para>STL function</db:para>
</db:th>
</db:tr>
</db:thead>
<db:tr valign="top">
<db:td>
<db:para>qBinaryFind</db:para>
</db:td>
<db:td>
<db:para>std::binary_search or std::lower_bound</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>qCopy</db:para>
</db:td>
<db:td>
<db:para>std::copy</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>qCopyBackward</db:para>
</db:td>
<db:td>
<db:para>std::copy_backward</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>qEqual</db:para>
</db:td>
<db:td>
<db:para>std::equal</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>qFill</db:para>
</db:td>
<db:td>
<db:para>std::fill</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>qFind</db:para>
</db:td>
<db:td>
<db:para>std::find</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>qCount</db:para>
</db:td>
<db:td>
<db:para>std::count</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>qSort</db:para>
</db:td>
<db:td>
<db:para>std::sort</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>qStableSort</db:para>
</db:td>
<db:td>
<db:para>std::stable_sort</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>qLowerBound</db:para>
</db:td>
<db:td>
<db:para>std::lower_bound</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>qUpperBound</db:para>
</db:td>
<db:td>
<db:para>std::upper_bound</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>qLess</db:para>
</db:td>
<db:td>
<db:para>std::less</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>qGreater</db:para>
</db:td>
<db:td>
<db:para>std::greater</db:para>
</db:td>
</db:tr>
</db:informaltable>
<db:para>The only cases in which the port may not be straightforward is if the old code relied on template specializations of the qLess() and/or the qSwap() functions, which were used internally by the implementations of the Qt algorithmic functions, but are instead ignored by the STL ones.</db:para>
<db:para>In case the old code relied on the specialization of the qLess() functor, then a workaround is explicitly passing an instance of the qLess() class to the STL function, for instance like this:</db:para>
<db:programlisting language="cpp">std::sort(container.begin(), container.end(), qLess&amp;lt;T&amp;gt;());
</db:programlisting>
<db:para>Instead, since it's not possible to pass a custom swapper functor to STL functions, the only workaround for a template specialization for qSwap() is providing the same specialization for std::swap().</db:para>
</db:section>
</db:section>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="containers.xml">container classes</db:link></db:member>
<db:member><db:link xlink:href="qtglobal.xml">&lt;QtGlobal&gt;</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="function-documentation">
<db:title>Function Documentation</db:title>
<db:section xml:id="qCountLeadingZeroBits">
<db:title>[since 5.6] uint qCountLeadingZeroBits(quint8 <db:emphasis>v</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>uint</db:type>
<db:methodname>qCountLeadingZeroBits</db:methodname>
<db:methodparam>
<db:type>quint8</db:type>
<db:parameter>v</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">uint qCountLeadingZeroBits(quint8 v)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the number of consecutive zero bits in <db:code role="parameter">v</db:code>, when searching from the MSB. For example, qCountLeadingZeroBits(quint8(1)) returns 7 and qCountLeadingZeroBits(quint8(8)) returns 4.</db:para>
<db:para>This function was introduced in Qt 5.6.</db:para>
</db:section>
<db:section xml:id="qCountLeadingZeroBits-1">
<db:title>[since 5.6] uint qCountLeadingZeroBits(quint16 <db:emphasis>v</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>uint</db:type>
<db:methodname>qCountLeadingZeroBits</db:methodname>
<db:methodparam>
<db:type>quint16</db:type>
<db:parameter>v</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">uint qCountLeadingZeroBits(quint16 v)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the number of consecutive zero bits in <db:code role="parameter">v</db:code>, when searching from the MSB. For example, <db:link xlink:href="qtalgorithms.xml#qCountLeadingZeroBits">qCountLeadingZeroBits</db:link>(quint16(1)) returns 15 and <db:link xlink:href="qtalgorithms.xml#qCountLeadingZeroBits">qCountLeadingZeroBits</db:link>(quint16(8)) returns 12.</db:para>
<db:para>This function was introduced in Qt 5.6.</db:para>
</db:section>
<db:section xml:id="qCountLeadingZeroBits-2">
<db:title>[since 5.6] uint qCountLeadingZeroBits(quint32 <db:emphasis>v</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>uint</db:type>
<db:methodname>qCountLeadingZeroBits</db:methodname>
<db:methodparam>
<db:type>quint32</db:type>
<db:parameter>v</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">2</db:synopsisinfo>
<db:synopsisinfo role="signature">uint qCountLeadingZeroBits(quint32 v)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the number of consecutive zero bits in <db:code role="parameter">v</db:code>, when searching from the MSB. For example, <db:link xlink:href="qtalgorithms.xml#qCountLeadingZeroBits">qCountLeadingZeroBits</db:link>(quint32(1)) returns 31 and <db:link xlink:href="qtalgorithms.xml#qCountLeadingZeroBits">qCountLeadingZeroBits</db:link>(quint32(8)) returns 28.</db:para>
<db:para>This function was introduced in Qt 5.6.</db:para>
</db:section>
<db:section xml:id="qCountLeadingZeroBits-3">
<db:title>[since 5.6] uint qCountLeadingZeroBits(quint64 <db:emphasis>v</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>uint</db:type>
<db:methodname>qCountLeadingZeroBits</db:methodname>
<db:methodparam>
<db:type>quint64</db:type>
<db:parameter>v</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">3</db:synopsisinfo>
<db:synopsisinfo role="signature">uint qCountLeadingZeroBits(quint64 v)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the number of consecutive zero bits in <db:code role="parameter">v</db:code>, when searching from the MSB. For example, <db:link xlink:href="qtalgorithms.xml#qCountLeadingZeroBits">qCountLeadingZeroBits</db:link>(quint64(1)) returns 63 and <db:link xlink:href="qtalgorithms.xml#qCountLeadingZeroBits">qCountLeadingZeroBits</db:link>(quint64(8)) returns 60.</db:para>
<db:para>This function was introduced in Qt 5.6.</db:para>
</db:section>
<db:section xml:id="qCountTrailingZeroBits">
<db:title>[since 5.6] uint qCountTrailingZeroBits(quint8 <db:emphasis>v</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>uint</db:type>
<db:methodname>qCountTrailingZeroBits</db:methodname>
<db:methodparam>
<db:type>quint8</db:type>
<db:parameter>v</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">uint qCountTrailingZeroBits(quint8 v)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the number of consecutive zero bits in <db:code role="parameter">v</db:code>, when searching from the LSB. For example, qCountTrailingZeroBits(1) returns 0 and qCountTrailingZeroBits(8) returns 3.</db:para>
<db:para>This function was introduced in Qt 5.6.</db:para>
</db:section>
<db:section xml:id="qCountTrailingZeroBits-1">
<db:title>[since 5.6] uint qCountTrailingZeroBits(quint16 <db:emphasis>v</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>uint</db:type>
<db:methodname>qCountTrailingZeroBits</db:methodname>
<db:methodparam>
<db:type>quint16</db:type>
<db:parameter>v</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">uint qCountTrailingZeroBits(quint16 v)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>This function was introduced in Qt 5.6.</db:para>
</db:section>
<db:section xml:id="qCountTrailingZeroBits-2">
<db:title>[since 5.6] uint qCountTrailingZeroBits(quint32 <db:emphasis>v</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>uint</db:type>
<db:methodname>qCountTrailingZeroBits</db:methodname>
<db:methodparam>
<db:type>quint32</db:type>
<db:parameter>v</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">2</db:synopsisinfo>
<db:synopsisinfo role="signature">uint qCountTrailingZeroBits(quint32 v)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>This function was introduced in Qt 5.6.</db:para>
</db:section>
<db:section xml:id="qCountTrailingZeroBits-3">
<db:title>[since 5.6] uint qCountTrailingZeroBits(quint64 <db:emphasis>v</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>uint</db:type>
<db:methodname>qCountTrailingZeroBits</db:methodname>
<db:methodparam>
<db:type>quint64</db:type>
<db:parameter>v</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">3</db:synopsisinfo>
<db:synopsisinfo role="signature">uint qCountTrailingZeroBits(quint64 v)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>This function was introduced in Qt 5.6.</db:para>
</db:section>
<db:section xml:id="qDeleteAll">
<db:title>void qDeleteAll(ForwardIterator <db:emphasis>begin</db:emphasis>, ForwardIterator <db:emphasis>end</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>qDeleteAll</db:methodname>
<db:methodparam>
<db:type>ForwardIterator</db:type>
<db:parameter>begin</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>ForwardIterator</db:type>
<db:parameter>end</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void qDeleteAll(ForwardIterator begin, ForwardIterator end)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Deletes all the items in the range [<db:code role="parameter">begin</db:code>, <db:code role="parameter">end</db:code>) using the C++ delete operator. The item type must be a pointer type (for example, QWidget *).</db:para>
<db:para>Example:</db:para>
<db:programlisting language="cpp">QList&amp;lt;Employee *&amp;gt; list;
list.append(new Employee(&quot;Blackpool&quot;, &quot;Stephen&quot;));
list.append(new Employee(&quot;Twist&quot;, &quot;Oliver&quot;));

qDeleteAll(list.begin(), list.end());
list.clear();
</db:programlisting>
<db:para>Notice that qDeleteAll() doesn't remove the items from the container; it merely calls delete on them. In the example above, we call clear() on the container to remove the items.</db:para>
<db:para>This function can also be used to delete items stored in associative containers, such as <db:link xlink:href="qmap.xml">QMap</db:link> and <db:link xlink:href="qhash.xml#qhash">QHash</db:link>. Only the objects stored in each container will be deleted by this function; objects used as keys will not be deleted.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtalgorithms.xml#forward-iterators">forward iterators</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="qDeleteAll-1">
<db:title>void qDeleteAll(const Container &amp;<db:emphasis>c</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>qDeleteAll</db:methodname>
<db:methodparam>
<db:type>const Container &amp;</db:type>
<db:parameter>c</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">void qDeleteAll(const Container &amp;c)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>This is the same as <db:link xlink:href="qtalgorithms.xml#qDeleteAll">qDeleteAll</db:link>(<db:code role="parameter">c</db:code>.begin(), <db:code role="parameter">c</db:code>.end()).</db:para>
</db:section>
<db:section xml:id="qPopulationCount">
<db:title>[since 5.2] uint qPopulationCount(quint8 <db:emphasis>v</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>uint</db:type>
<db:methodname>qPopulationCount</db:methodname>
<db:methodparam>
<db:type>quint8</db:type>
<db:parameter>v</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">uint qPopulationCount(quint8 v)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the number of bits set in <db:code role="parameter">v</db:code>. This number is also called the Hamming Weight of <db:code role="parameter">v</db:code>.</db:para>
<db:para>This function was introduced in Qt 5.2.</db:para>
</db:section>
<db:section xml:id="qPopulationCount-1">
<db:title>[since 5.2] uint qPopulationCount(quint16 <db:emphasis>v</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>uint</db:type>
<db:methodname>qPopulationCount</db:methodname>
<db:methodparam>
<db:type>quint16</db:type>
<db:parameter>v</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">uint qPopulationCount(quint16 v)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>This function was introduced in Qt 5.2.</db:para>
</db:section>
<db:section xml:id="qPopulationCount-2">
<db:title>[since 5.2] uint qPopulationCount(quint32 <db:emphasis>v</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>uint</db:type>
<db:methodname>qPopulationCount</db:methodname>
<db:methodparam>
<db:type>quint32</db:type>
<db:parameter>v</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">2</db:synopsisinfo>
<db:synopsisinfo role="signature">uint qPopulationCount(quint32 v)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>This function was introduced in Qt 5.2.</db:para>
</db:section>
<db:section xml:id="qPopulationCount-3">
<db:title>[since 5.2] uint qPopulationCount(quint64 <db:emphasis>v</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>uint</db:type>
<db:methodname>qPopulationCount</db:methodname>
<db:methodparam>
<db:type>quint64</db:type>
<db:parameter>v</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">3</db:synopsisinfo>
<db:synopsisinfo role="signature">uint qPopulationCount(quint64 v)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>This function was introduced in Qt 5.2.</db:para>
</db:section>
</db:section>
<db:section xml:id="obsolete">
<db:title>Obsolete Members for &lt;QtAlgorithms&gt;</db:title>
<db:para><db:emphasis role="bold">The following members of class <db:link xlink:href="qtalgorithms.xml">&lt;QtAlgorithms&gt;</db:link> are deprecated.</db:emphasis> We strongly advise against using them in new code.</db:para>
<db:section xml:id="obsolete-function-documentation">
<db:title>Obsolete Function Documentation</db:title>
<db:section xml:id="qBinaryFind">
<db:title>RandomAccessIterator qBinaryFind(RandomAccessIterator <db:emphasis>begin</db:emphasis>, RandomAccessIterator <db:emphasis>end</db:emphasis>, const T &amp;<db:emphasis>value</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>RandomAccessIterator</db:type>
<db:methodname>qBinaryFind</db:methodname>
<db:methodparam>
<db:type>RandomAccessIterator</db:type>
<db:parameter>begin</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>RandomAccessIterator</db:type>
<db:parameter>end</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const T &amp;</db:type>
<db:parameter>value</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">RandomAccessIterator qBinaryFind(RandomAccessIterator begin, RandomAccessIterator end, const T &amp;value)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">deprecated</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This function is deprecated. We strongly advise against using it in new code.</db:para>
<db:para>Use std::binary_search or std::lower_bound instead.</db:para>
<db:para>Performs a binary search of the range [<db:code role="parameter">begin</db:code>, <db:code role="parameter">end</db:code>) and returns the position of an occurrence of <db:code role="parameter">value</db:code>. If there are no occurrences of <db:code role="parameter">value</db:code>, returns <db:code role="parameter">end</db:code>.</db:para>
<db:para>The items in the range [<db:code role="parameter">begin</db:code>, <db:code role="parameter">end</db:code>) must be sorted in ascending order; see <db:link xlink:href="qtalgorithms.xml#qSort">qSort</db:link>().</db:para>
<db:para>If there are many occurrences of the same value, any one of them could be returned. Use <db:link xlink:href="qtalgorithms.xml#qLowerBound">qLowerBound</db:link>() or <db:link xlink:href="qtalgorithms.xml#qUpperBound">qUpperBound</db:link>() if you need finer control.</db:para>
<db:para>Example:</db:para>
<db:programlisting language="cpp">QVector&amp;lt;int&amp;gt; vect;
vect &amp;lt;&amp;lt; 3 &amp;lt;&amp;lt; 3 &amp;lt;&amp;lt; 6 &amp;lt;&amp;lt; 6 &amp;lt;&amp;lt; 6 &amp;lt;&amp;lt; 8;

QVector&amp;lt;int&amp;gt;::iterator i =
        qBinaryFind(vect.begin(), vect.end(), 6);
// i == vect.begin() + 2 (or 3 or 4)
</db:programlisting>
<db:para>This function requires the item type (in the example above, <db:link xlink:href="qstring.xml">QString</db:link>) to implement operator&lt;().</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtalgorithms.xml#qLowerBound">qLowerBound</db:link>()</db:member>
<db:member><db:link xlink:href="qtalgorithms.xml#qUpperBound">qUpperBound</db:link>()</db:member>
<db:member><db:link xlink:href="qtalgorithms.xml#random-access-iterators">random access iterators</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="qBinaryFind-1">
<db:title>RandomAccessIterator qBinaryFind(RandomAccessIterator <db:emphasis>begin</db:emphasis>, RandomAccessIterator <db:emphasis>end</db:emphasis>, const T &amp;<db:emphasis>value</db:emphasis>, LessThan <db:emphasis>lessThan</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>RandomAccessIterator</db:type>
<db:methodname>qBinaryFind</db:methodname>
<db:methodparam>
<db:type>RandomAccessIterator</db:type>
<db:parameter>begin</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>RandomAccessIterator</db:type>
<db:parameter>end</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const T &amp;</db:type>
<db:parameter>value</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>LessThan</db:type>
<db:parameter>lessThan</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">RandomAccessIterator qBinaryFind(RandomAccessIterator begin, RandomAccessIterator end, const T &amp;value, LessThan lessThan)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">deprecated</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This function is deprecated. We strongly advise against using it in new code.</db:para>
<db:para>This is an overloaded function.</db:para>
<db:para>Use std::binary_search or std::lower_bound instead.</db:para>
<db:para>Uses the <db:code role="parameter">lessThan</db:code> function instead of operator&lt;() to compare the items.</db:para>
<db:para>Note that the items in the range must be sorted according to the order specified by the <db:code role="parameter">lessThan</db:code> object.</db:para>
</db:section>
<db:section xml:id="qBinaryFind-2">
<db:title>typename Container::const_iterator qBinaryFind(const Container &amp;<db:emphasis>container</db:emphasis>, const T &amp;<db:emphasis>value</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>typename Container::const_iterator</db:type>
<db:methodname>qBinaryFind</db:methodname>
<db:methodparam>
<db:type>const Container &amp;</db:type>
<db:parameter>container</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const T &amp;</db:type>
<db:parameter>value</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">2</db:synopsisinfo>
<db:synopsisinfo role="signature">typename Container::const_iterator qBinaryFind(const Container &amp;container, const T &amp;value)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">deprecated</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This function is deprecated. We strongly advise against using it in new code.</db:para>
<db:para>This is an overloaded function.</db:para>
<db:para>Use std::binary_search or std::lower_bound instead.</db:para>
<db:para>This is the same as <db:link xlink:href="qtalgorithms.xml#qBinaryFind">qBinaryFind</db:link>(<db:code role="parameter">container</db:code>.begin(), <db:code role="parameter">container</db:code>.end(), <db:code role="parameter">value</db:code>);</db:para>
</db:section>
<db:section xml:id="qCopy">
<db:title>OutputIterator qCopy(InputIterator <db:emphasis>begin1</db:emphasis>, InputIterator <db:emphasis>end1</db:emphasis>, OutputIterator <db:emphasis>begin2</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>OutputIterator</db:type>
<db:methodname>qCopy</db:methodname>
<db:methodparam>
<db:type>InputIterator</db:type>
<db:parameter>begin1</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>InputIterator</db:type>
<db:parameter>end1</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>OutputIterator</db:type>
<db:parameter>begin2</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">OutputIterator qCopy(InputIterator begin1, InputIterator end1, OutputIterator begin2)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">deprecated</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This function is deprecated. We strongly advise against using it in new code.</db:para>
<db:para>Use std::copy instead.</db:para>
<db:para>Copies the items from range [<db:code role="parameter">begin1</db:code>, <db:code role="parameter">end1</db:code>) to range [<db:code role="parameter">begin2</db:code>, ...), in the order in which they appear.</db:para>
<db:para>The item at position <db:code role="parameter">begin1</db:code> is assigned to that at position <db:code role="parameter">begin2</db:code>; the item at position <db:code role="parameter">begin1</db:code> + 1 is assigned to that at position <db:code role="parameter">begin2</db:code> + 1; and so on.</db:para>
<db:para>Example:</db:para>
<db:programlisting language="cpp">QStringList list;
list &amp;lt;&amp;lt; &quot;one&quot; &amp;lt;&amp;lt; &quot;two&quot; &amp;lt;&amp;lt; &quot;three&quot;;

QVector&amp;lt;QString&amp;gt; vect1(3);
qCopy(list.begin(), list.end(), vect1.begin());
// vect: [ &quot;one&quot;, &quot;two&quot;, &quot;three&quot; ]

QVector&amp;lt;QString&amp;gt; vect2(8);
qCopy(list.begin(), list.end(), vect2.begin() + 2);
// vect: [ &quot;&quot;, &quot;&quot;, &quot;one&quot;, &quot;two&quot;, &quot;three&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot; ]
</db:programlisting>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtalgorithms.xml#qCopyBackward">qCopyBackward</db:link>()</db:member>
<db:member><db:link xlink:href="qtalgorithms.xml#input-iterators">input iterators</db:link></db:member>
<db:member><db:link xlink:href="qtalgorithms.xml#output-iterators">output iterators</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="qCopyBackward">
<db:title>BiIterator2 qCopyBackward(BiIterator1 <db:emphasis>begin1</db:emphasis>, BiIterator1 <db:emphasis>end1</db:emphasis>, BiIterator2 <db:emphasis>end2</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>BiIterator2</db:type>
<db:methodname>qCopyBackward</db:methodname>
<db:methodparam>
<db:type>BiIterator1</db:type>
<db:parameter>begin1</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>BiIterator1</db:type>
<db:parameter>end1</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>BiIterator2</db:type>
<db:parameter>end2</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">BiIterator2 qCopyBackward(BiIterator1 begin1, BiIterator1 end1, BiIterator2 end2)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">deprecated</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This function is deprecated. We strongly advise against using it in new code.</db:para>
<db:para>Use std::copy_backward instead.</db:para>
<db:para>Copies the items from range [<db:code role="parameter">begin1</db:code>, <db:code role="parameter">end1</db:code>) to range [..., <db:code role="parameter">end2</db:code>).</db:para>
<db:para>The item at position <db:code role="parameter">end1</db:code> - 1 is assigned to that at position <db:code role="parameter">end2</db:code> - 1; the item at position <db:code role="parameter">end1</db:code> - 2 is assigned to that at position <db:code role="parameter">end2</db:code> - 2; and so on.</db:para>
<db:para>Example:</db:para>
<db:programlisting language="cpp">QStringList list;
list &amp;lt;&amp;lt; &quot;one&quot; &amp;lt;&amp;lt; &quot;two&quot; &amp;lt;&amp;lt; &quot;three&quot;;

QVector&amp;lt;QString&amp;gt; vect(5);
qCopyBackward(list.begin(), list.end(), vect.end());
// vect: [ &quot;&quot;, &quot;&quot;, &quot;one&quot;, &quot;two&quot;, &quot;three&quot; ]
</db:programlisting>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtalgorithms.xml#qCopy">qCopy</db:link>()</db:member>
<db:member><db:link xlink:href="qtalgorithms.xml#bidirectional-iterators">bidirectional iterators</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="qCount">
<db:title>void qCount(InputIterator <db:emphasis>begin</db:emphasis>, InputIterator <db:emphasis>end</db:emphasis>, const T &amp;<db:emphasis>value</db:emphasis>, Size &amp;<db:emphasis>n</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>qCount</db:methodname>
<db:methodparam>
<db:type>InputIterator</db:type>
<db:parameter>begin</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>InputIterator</db:type>
<db:parameter>end</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const T &amp;</db:type>
<db:parameter>value</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>Size &amp;</db:type>
<db:parameter>n</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void qCount(InputIterator begin, InputIterator end, const T &amp;value, Size &amp;n)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">deprecated</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This function is deprecated. We strongly advise against using it in new code.</db:para>
<db:para>Use std::count instead.</db:para>
<db:para>Returns the number of occurrences of <db:code role="parameter">value</db:code> in the range [<db:code role="parameter">begin</db:code>, <db:code role="parameter">end</db:code>), which is returned in <db:code role="parameter">n</db:code>. <db:code role="parameter">n</db:code> is never initialized, the count is added to <db:code role="parameter">n</db:code>. It is the caller's responsibility to initialize <db:code role="parameter">n</db:code>.</db:para>
<db:para>Example:</db:para>
<db:programlisting language="cpp">QList&amp;lt;int&amp;gt; list;
list &amp;lt;&amp;lt; 3 &amp;lt;&amp;lt; 3 &amp;lt;&amp;lt; 6 &amp;lt;&amp;lt; 6 &amp;lt;&amp;lt; 6 &amp;lt;&amp;lt; 8;

int countOf6 = 0;
qCount(list.begin(), list.end(), 6, countOf6);
// countOf6 == 3

int countOf7 = 0;
qCount(list.begin(), list.end(), 7, countOf7);
// countOf7 == 0
</db:programlisting>
<db:para>This function requires the item type (in the example above, int) to implement operator==().</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtalgorithms.xml#input-iterators">input iterators</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="qCount-1">
<db:title>void qCount(const Container &amp;<db:emphasis>container</db:emphasis>, const T &amp;<db:emphasis>value</db:emphasis>, Size &amp;<db:emphasis>n</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>qCount</db:methodname>
<db:methodparam>
<db:type>const Container &amp;</db:type>
<db:parameter>container</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const T &amp;</db:type>
<db:parameter>value</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>Size &amp;</db:type>
<db:parameter>n</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">void qCount(const Container &amp;container, const T &amp;value, Size &amp;n)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">deprecated</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This function is deprecated. We strongly advise against using it in new code.</db:para>
<db:para>This is an overloaded function.</db:para>
<db:para>Use std::count instead.</db:para>
<db:para>Instead of operating on iterators, as in the other overload, this function operates on the specified <db:code role="parameter">container</db:code> to obtain the number of instances of <db:code role="parameter">value</db:code> in the variable passed as a reference in argument <db:code role="parameter">n</db:code>.</db:para>
</db:section>
<db:section xml:id="qEqual">
<db:title>bool qEqual(InputIterator1 <db:emphasis>begin1</db:emphasis>, InputIterator1 <db:emphasis>end1</db:emphasis>, InputIterator2 <db:emphasis>begin2</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>bool</db:type>
<db:methodname>qEqual</db:methodname>
<db:methodparam>
<db:type>InputIterator1</db:type>
<db:parameter>begin1</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>InputIterator1</db:type>
<db:parameter>end1</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>InputIterator2</db:type>
<db:parameter>begin2</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool qEqual(InputIterator1 begin1, InputIterator1 end1, InputIterator2 begin2)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">deprecated</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This function is deprecated. We strongly advise against using it in new code.</db:para>
<db:para>Use std::equal instead.</db:para>
<db:para>Compares the items in the range [<db:code role="parameter">begin1</db:code>, <db:code role="parameter">end1</db:code>) with the items in the range [<db:code role="parameter">begin2</db:code>, ...). Returns true if all the items compare equal; otherwise returns false.</db:para>
<db:para>Example:</db:para>
<db:programlisting language="cpp">QStringList list;
list &amp;lt;&amp;lt; &quot;one&quot; &amp;lt;&amp;lt; &quot;two&quot; &amp;lt;&amp;lt; &quot;three&quot;;

QVector&amp;lt;QString&amp;gt; vect(3);
vect[0] = &quot;one&quot;;
vect[1] = &quot;two&quot;;
vect[2] = &quot;three&quot;;

bool ret1 = qEqual(list.begin(), list.end(), vect.begin());
// ret1 == true

vect[2] = &quot;seven&quot;;
bool ret2 = qEqual(list.begin(), list.end(), vect.begin());
// ret2 == false
</db:programlisting>
<db:para>This function requires the item type (in the example above, <db:link xlink:href="qstring.xml">QString</db:link>) to implement operator==().</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtalgorithms.xml#input-iterators">input iterators</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="qFill">
<db:title>void qFill(ForwardIterator <db:emphasis>begin</db:emphasis>, ForwardIterator <db:emphasis>end</db:emphasis>, const T &amp;<db:emphasis>value</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>qFill</db:methodname>
<db:methodparam>
<db:type>ForwardIterator</db:type>
<db:parameter>begin</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>ForwardIterator</db:type>
<db:parameter>end</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const T &amp;</db:type>
<db:parameter>value</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void qFill(ForwardIterator begin, ForwardIterator end, const T &amp;value)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">deprecated</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This function is deprecated. We strongly advise against using it in new code.</db:para>
<db:para>Use std::fill instead.</db:para>
<db:para>Fills the range [<db:code role="parameter">begin</db:code>, <db:code role="parameter">end</db:code>) with <db:code role="parameter">value</db:code>.</db:para>
<db:para>Example:</db:para>
<db:programlisting language="cpp">QStringList list;
list &amp;lt;&amp;lt; &quot;one&quot; &amp;lt;&amp;lt; &quot;two&quot; &amp;lt;&amp;lt; &quot;three&quot;;

qFill(list.begin(), list.end(), &quot;eleven&quot;);
// list: [ &quot;eleven&quot;, &quot;eleven&quot;, &quot;eleven&quot; ]

qFill(list.begin() + 1, list.end(), &quot;six&quot;);
// list: [ &quot;eleven&quot;, &quot;six&quot;, &quot;six&quot; ]
</db:programlisting>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtalgorithms.xml#qCopy">qCopy</db:link>()</db:member>
<db:member><db:link xlink:href="qtalgorithms.xml#forward-iterators">forward iterators</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="qFill-1">
<db:title>void qFill(Container &amp;<db:emphasis>container</db:emphasis>, const T &amp;<db:emphasis>value</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>qFill</db:methodname>
<db:methodparam>
<db:type>Container &amp;</db:type>
<db:parameter>container</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const T &amp;</db:type>
<db:parameter>value</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">void qFill(Container &amp;container, const T &amp;value)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">deprecated</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This function is deprecated. We strongly advise against using it in new code.</db:para>
<db:para>This is an overloaded function.</db:para>
<db:para>Use std::fill instead.</db:para>
<db:para>This is the same as <db:link xlink:href="qtalgorithms.xml#qFill">qFill</db:link>(<db:code role="parameter">container</db:code>.begin(), <db:code role="parameter">container</db:code>.end(), <db:code role="parameter">value</db:code>);</db:para>
</db:section>
<db:section xml:id="qFind">
<db:title>InputIterator qFind(InputIterator <db:emphasis>begin</db:emphasis>, InputIterator <db:emphasis>end</db:emphasis>, const T &amp;<db:emphasis>value</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>InputIterator</db:type>
<db:methodname>qFind</db:methodname>
<db:methodparam>
<db:type>InputIterator</db:type>
<db:parameter>begin</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>InputIterator</db:type>
<db:parameter>end</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const T &amp;</db:type>
<db:parameter>value</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">InputIterator qFind(InputIterator begin, InputIterator end, const T &amp;value)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">deprecated</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This function is deprecated. We strongly advise against using it in new code.</db:para>
<db:para>Use std::find instead.</db:para>
<db:para>Returns an iterator to the first occurrence of <db:code role="parameter">value</db:code> in a container in the range [<db:code role="parameter">begin</db:code>, <db:code role="parameter">end</db:code>). Returns <db:code role="parameter">end</db:code> if <db:code role="parameter">value</db:code> isn't found.</db:para>
<db:para>Example:</db:para>
<db:programlisting language="cpp">QStringList list;
list &amp;lt;&amp;lt; &quot;one&quot; &amp;lt;&amp;lt; &quot;two&quot; &amp;lt;&amp;lt; &quot;three&quot;;

QStringList::iterator i1 = qFind(list.begin(), list.end(), &quot;two&quot;);
// i1 == list.begin() + 1

QStringList::iterator i2 = qFind(list.begin(), list.end(), &quot;seventy&quot;);
// i2 == list.end()
</db:programlisting>
<db:para>This function requires the item type (in the example above, <db:link xlink:href="qstring.xml">QString</db:link>) to implement operator==().</db:para>
<db:para>If the items in the range are in ascending order, you can get faster results by using <db:link xlink:href="qtalgorithms.xml#qLowerBound">qLowerBound</db:link>() or <db:link xlink:href="qtalgorithms.xml#qBinaryFind">qBinaryFind</db:link>() instead of qFind().</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtalgorithms.xml#qBinaryFind">qBinaryFind</db:link>()</db:member>
<db:member><db:link xlink:href="qtalgorithms.xml#input-iterators">input iterators</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="qFind-1">
<db:title>typename Container::const_iterator qFind(const Container &amp;<db:emphasis>container</db:emphasis>, const T &amp;<db:emphasis>value</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>typename Container::const_iterator</db:type>
<db:methodname>qFind</db:methodname>
<db:methodparam>
<db:type>const Container &amp;</db:type>
<db:parameter>container</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const T &amp;</db:type>
<db:parameter>value</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">typename Container::const_iterator qFind(const Container &amp;container, const T &amp;value)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">deprecated</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This function is deprecated. We strongly advise against using it in new code.</db:para>
<db:para>This is an overloaded function.</db:para>
<db:para>Use std::find instead.</db:para>
<db:para>This is the same as <db:link xlink:href="qtalgorithms.xml#qFind">qFind</db:link>(<db:code role="parameter">container</db:code>.constBegin(), <db:code role="parameter">container</db:code>.constEnd(), <db:code role="parameter">value</db:code>);</db:para>
</db:section>
<db:section xml:id="qGreater">
<db:title>LessThan qGreater()</db:title>
<db:methodsynopsis>
<db:type>LessThan</db:type>
<db:methodname>qGreater</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">LessThan qGreater()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">deprecated</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This function is deprecated. We strongly advise against using it in new code.</db:para>
<db:para>Use std::greater instead.</db:para>
<db:para>Returns a functional object, or functor, that can be passed to <db:link xlink:href="qtalgorithms.xml#qSort">qSort</db:link>() or <db:link xlink:href="qtalgorithms.xml#qStableSort">qStableSort</db:link>().</db:para>
<db:para>Example:</db:para>
<db:programlisting language="cpp">QList&amp;lt;int&amp;gt; list;
list &amp;lt;&amp;lt; 33 &amp;lt;&amp;lt; 12 &amp;lt;&amp;lt; 68 &amp;lt;&amp;lt; 6 &amp;lt;&amp;lt; 12;
qSort(list.begin(), list.end(), qGreater&amp;lt;int&amp;gt;());
// list: [ 68, 33, 12, 12, 6 ]
</db:programlisting>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtalgorithms.xml#qLess">qLess&lt;T&gt;</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="qLess">
<db:title>LessThan qLess()</db:title>
<db:methodsynopsis>
<db:type>LessThan</db:type>
<db:methodname>qLess</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">LessThan qLess()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">deprecated</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This function is deprecated. We strongly advise against using it in new code.</db:para>
<db:para>Use std::less instead.</db:para>
<db:para>Returns a functional object, or functor, that can be passed to <db:link xlink:href="qtalgorithms.xml#qSort">qSort</db:link>() or <db:link xlink:href="qtalgorithms.xml#qStableSort">qStableSort</db:link>().</db:para>
<db:para>Example:</db:para>
<db:programlisting language="cpp">QList&amp;lt;int&amp;gt; list;
list &amp;lt;&amp;lt; 33 &amp;lt;&amp;lt; 12 &amp;lt;&amp;lt; 68 &amp;lt;&amp;lt; 6 &amp;lt;&amp;lt; 12;
qSort(list.begin(), list.end(), qLess&amp;lt;int&amp;gt;());
// list: [ 6, 12, 12, 33, 68 ]
</db:programlisting>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtalgorithms.xml#qGreater">qGreater&lt;T&gt;</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="qLowerBound">
<db:title>RandomAccessIterator qLowerBound(RandomAccessIterator <db:emphasis>begin</db:emphasis>, RandomAccessIterator <db:emphasis>end</db:emphasis>, const T &amp;<db:emphasis>value</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>RandomAccessIterator</db:type>
<db:methodname>qLowerBound</db:methodname>
<db:methodparam>
<db:type>RandomAccessIterator</db:type>
<db:parameter>begin</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>RandomAccessIterator</db:type>
<db:parameter>end</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const T &amp;</db:type>
<db:parameter>value</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">RandomAccessIterator qLowerBound(RandomAccessIterator begin, RandomAccessIterator end, const T &amp;value)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">deprecated</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This function is deprecated. We strongly advise against using it in new code.</db:para>
<db:para>Use std::lower_bound instead.</db:para>
<db:para>Performs a binary search of the range [<db:code role="parameter">begin</db:code>, <db:code role="parameter">end</db:code>) and returns the position of the first occurrence of <db:code role="parameter">value</db:code>. If no such item is found, returns the position where it should be inserted.</db:para>
<db:para>The items in the range [<db:code role="parameter">begin</db:code>, <db:emphasis>end</db:emphasis>) must be sorted in ascending order; see <db:link xlink:href="qtalgorithms.xml#qSort">qSort</db:link>().</db:para>
<db:para>Example:</db:para>
<db:programlisting language="cpp">QList&amp;lt;int&amp;gt; list;
list &amp;lt;&amp;lt; 3 &amp;lt;&amp;lt; 3 &amp;lt;&amp;lt; 6 &amp;lt;&amp;lt; 6 &amp;lt;&amp;lt; 6 &amp;lt;&amp;lt; 8;

QList&amp;lt;int&amp;gt;::iterator i = qLowerBound(list.begin(), list.end(), 5);
list.insert(i, 5);
// list: [ 3, 3, 5, 6, 6, 6, 8 ]

i = qLowerBound(list.begin(), list.end(), 12);
list.insert(i, 12);
// list: [ 3, 3, 5, 6, 6, 6, 8, 12 ]
</db:programlisting>
<db:para>This function requires the item type (in the example above, int) to implement operator&lt;().</db:para>
<db:para>qLowerBound() can be used in conjunction with <db:link xlink:href="qtalgorithms.xml#qUpperBound">qUpperBound</db:link>() to iterate over all occurrences of the same value:</db:para>
<db:programlisting language="cpp">QVector&amp;lt;int&amp;gt; vect;
vect &amp;lt;&amp;lt; 3 &amp;lt;&amp;lt; 3 &amp;lt;&amp;lt; 6 &amp;lt;&amp;lt; 6 &amp;lt;&amp;lt; 6 &amp;lt;&amp;lt; 8;
QVector&amp;lt;int&amp;gt;::iterator begin6 =
        qLowerBound(vect.begin(), vect.end(), 6);
QVector&amp;lt;int&amp;gt;::iterator end6 =
        qUpperBound(begin6, vect.end(), 6);

QVector&amp;lt;int&amp;gt;::iterator i = begin6;
while (i != end6) {
    *i = 7;
    ++i;
}
// vect: [ 3, 3, 7, 7, 7, 8 ]
</db:programlisting>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtalgorithms.xml#qUpperBound">qUpperBound</db:link>()</db:member>
<db:member><db:link xlink:href="qtalgorithms.xml#qBinaryFind">qBinaryFind</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="qLowerBound-1">
<db:title>RandomAccessIterator qLowerBound(RandomAccessIterator <db:emphasis>begin</db:emphasis>, RandomAccessIterator <db:emphasis>end</db:emphasis>, const T &amp;<db:emphasis>value</db:emphasis>, LessThan <db:emphasis>lessThan</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>RandomAccessIterator</db:type>
<db:methodname>qLowerBound</db:methodname>
<db:methodparam>
<db:type>RandomAccessIterator</db:type>
<db:parameter>begin</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>RandomAccessIterator</db:type>
<db:parameter>end</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const T &amp;</db:type>
<db:parameter>value</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>LessThan</db:type>
<db:parameter>lessThan</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">RandomAccessIterator qLowerBound(RandomAccessIterator begin, RandomAccessIterator end, const T &amp;value, LessThan lessThan)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">deprecated</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This function is deprecated. We strongly advise against using it in new code.</db:para>
<db:para>This is an overloaded function.</db:para>
<db:para>Use std::lower_bound instead.</db:para>
<db:para>Uses the <db:code role="parameter">lessThan</db:code> function instead of operator&lt;() to compare the items.</db:para>
<db:para>Note that the items in the range must be sorted according to the order specified by the <db:code role="parameter">lessThan</db:code> object.</db:para>
</db:section>
<db:section xml:id="qLowerBound-2">
<db:title>typename Container::const_iterator qLowerBound(const Container &amp;<db:emphasis>container</db:emphasis>, const T &amp;<db:emphasis>value</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>typename Container::const_iterator</db:type>
<db:methodname>qLowerBound</db:methodname>
<db:methodparam>
<db:type>const Container &amp;</db:type>
<db:parameter>container</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const T &amp;</db:type>
<db:parameter>value</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">2</db:synopsisinfo>
<db:synopsisinfo role="signature">typename Container::const_iterator qLowerBound(const Container &amp;container, const T &amp;value)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">deprecated</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This function is deprecated. We strongly advise against using it in new code.</db:para>
<db:para>This is an overloaded function.</db:para>
<db:para>Use std::lower_bound instead.</db:para>
<db:para>For read-only iteration over containers, this function is broadly equivalent to <db:link xlink:href="qtalgorithms.xml#qLowerBound">qLowerBound</db:link>(<db:code role="parameter">container</db:code>.begin(), <db:code role="parameter">container</db:code>.end(), value). However, since it returns a const iterator, you cannot use it to modify the container; for example, to insert items.</db:para>
</db:section>
<db:section xml:id="qSort">
<db:title>void qSort(RandomAccessIterator <db:emphasis>begin</db:emphasis>, RandomAccessIterator <db:emphasis>end</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>qSort</db:methodname>
<db:methodparam>
<db:type>RandomAccessIterator</db:type>
<db:parameter>begin</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>RandomAccessIterator</db:type>
<db:parameter>end</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void qSort(RandomAccessIterator begin, RandomAccessIterator end)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">deprecated</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This function is deprecated. We strongly advise against using it in new code.</db:para>
<db:para>Use std::sort instead.</db:para>
<db:para>Sorts the items in range [<db:code role="parameter">begin</db:code>, <db:code role="parameter">end</db:code>) in ascending order using the quicksort algorithm.</db:para>
<db:para>Example:</db:para>
<db:programlisting language="cpp">QList&amp;lt;int&amp;gt; list;
list &amp;lt;&amp;lt; 33 &amp;lt;&amp;lt; 12 &amp;lt;&amp;lt; 68 &amp;lt;&amp;lt; 6 &amp;lt;&amp;lt; 12;
qSort(list.begin(), list.end());
// list: [ 6, 12, 12, 33, 68 ]
</db:programlisting>
<db:para>The sort algorithm is efficient on large data sets. It operates in <db:link xlink:href="containers.xml#linear-logarithmic-time">linear-logarithmic time</db:link>, O(<db:emphasis>n</db:emphasis> log <db:emphasis>n</db:emphasis>).</db:para>
<db:para>This function requires the item type (in the example above, int) to implement operator&lt;().</db:para>
<db:para>If neither of the two items is &quot;less than&quot; the other, the items are taken to be equal. It is then undefined which one of the two items will appear before the other after the sort.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtalgorithms.xml#qStableSort">qStableSort</db:link>()</db:member>
<db:member><db:link xlink:href="qtalgorithms.xml#random-access-iterators">random access iterators</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="qSort-1">
<db:title>void qSort(RandomAccessIterator <db:emphasis>begin</db:emphasis>, RandomAccessIterator <db:emphasis>end</db:emphasis>, LessThan <db:emphasis>lessThan</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>qSort</db:methodname>
<db:methodparam>
<db:type>RandomAccessIterator</db:type>
<db:parameter>begin</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>RandomAccessIterator</db:type>
<db:parameter>end</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>LessThan</db:type>
<db:parameter>lessThan</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">void qSort(RandomAccessIterator begin, RandomAccessIterator end, LessThan lessThan)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">deprecated</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This function is deprecated. We strongly advise against using it in new code.</db:para>
<db:para>This is an overloaded function.</db:para>
<db:para>Use std::sort instead.</db:para>
<db:para>Uses the <db:code role="parameter">lessThan</db:code> function instead of operator&lt;() to compare the items.</db:para>
<db:para>For example, here's how to sort the strings in a <db:link xlink:href="qstringlist.xml">QStringList</db:link> in case-insensitive alphabetical order:</db:para>
<db:programlisting language="cpp">bool caseInsensitiveLessThan(const QString &amp;amp;s1, const QString &amp;amp;s2)
{
    return s1.toLower() &amp;lt; s2.toLower();
}

int doSomething()
{
    QStringList list;
    list &amp;lt;&amp;lt; &quot;AlPha&quot; &amp;lt;&amp;lt; &quot;beTA&quot; &amp;lt;&amp;lt; &quot;gamma&quot; &amp;lt;&amp;lt; &quot;DELTA&quot;;
    qSort(list.begin(), list.end(), caseInsensitiveLessThan);
    // list: [ &quot;AlPha&quot;, &quot;beTA&quot;, &quot;DELTA&quot;, &quot;gamma&quot; ]
}
</db:programlisting>
<db:para>To sort values in reverse order, pass <db:link xlink:href="qtalgorithms.xml#qGreater">qGreater&lt;T&gt;</db:link>() as the <db:code role="parameter">lessThan</db:code> parameter. For example:</db:para>
<db:programlisting language="cpp">QList&amp;lt;int&amp;gt; list;
list &amp;lt;&amp;lt; 33 &amp;lt;&amp;lt; 12 &amp;lt;&amp;lt; 68 &amp;lt;&amp;lt; 6 &amp;lt;&amp;lt; 12;
qSort(list.begin(), list.end(), qGreater&amp;lt;int&amp;gt;());
// list: [ 68, 33, 12, 12, 6 ]
</db:programlisting>
<db:para>If neither of the two items is &quot;less than&quot; the other, the items are taken to be equal. It is then undefined which one of the two items will appear before the other after the sort.</db:para>
<db:para>An alternative to using <db:link xlink:href="qtalgorithms.xml#qSort">qSort</db:link>() is to put the items to sort in a <db:link xlink:href="qmap.xml">QMap</db:link>, using the sort key as the <db:link xlink:href="qmap.xml">QMap</db:link> key. This is often more convenient than defining a <db:code role="parameter">lessThan</db:code> function. For example, the following code shows how to sort a list of strings case insensitively using <db:link xlink:href="qmap.xml">QMap</db:link>:</db:para>
<db:programlisting language="cpp">QStringList list;
list &amp;lt;&amp;lt; &quot;AlPha&quot; &amp;lt;&amp;lt; &quot;beTA&quot; &amp;lt;&amp;lt; &quot;gamma&quot; &amp;lt;&amp;lt; &quot;DELTA&quot;;

QMap&amp;lt;QString, QString&amp;gt; map;
foreach (const QString &amp;amp;str, list)
    map.insert(str.toLower(), str);

list = map.values();
</db:programlisting>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qmap.xml">QMap</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="qSort-2">
<db:title>void qSort(Container &amp;<db:emphasis>container</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>qSort</db:methodname>
<db:methodparam>
<db:type>Container &amp;</db:type>
<db:parameter>container</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">2</db:synopsisinfo>
<db:synopsisinfo role="signature">void qSort(Container &amp;container)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">deprecated</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This function is deprecated. We strongly advise against using it in new code.</db:para>
<db:para>This is an overloaded function.</db:para>
<db:para>Use std::sort instead.</db:para>
<db:para>This is the same as <db:link xlink:href="qtalgorithms.xml#qSort">qSort</db:link>(<db:code role="parameter">container</db:code>.begin(), <db:code role="parameter">container</db:code>.end());</db:para>
</db:section>
<db:section xml:id="qStableSort">
<db:title>void qStableSort(RandomAccessIterator <db:emphasis>begin</db:emphasis>, RandomAccessIterator <db:emphasis>end</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>qStableSort</db:methodname>
<db:methodparam>
<db:type>RandomAccessIterator</db:type>
<db:parameter>begin</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>RandomAccessIterator</db:type>
<db:parameter>end</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void qStableSort(RandomAccessIterator begin, RandomAccessIterator end)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">deprecated</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This function is deprecated. We strongly advise against using it in new code.</db:para>
<db:para>Use std::stable_sort instead.</db:para>
<db:para>Sorts the items in range [<db:code role="parameter">begin</db:code>, <db:code role="parameter">end</db:code>) in ascending order using a stable sorting algorithm.</db:para>
<db:para>If neither of the two items is &quot;less than&quot; the other, the items are taken to be equal. The item that appeared before the other in the original container will still appear first after the sort. This property is often useful when sorting user-visible data.</db:para>
<db:para>Example:</db:para>
<db:programlisting language="cpp">QList&amp;lt;int&amp;gt; list;
list &amp;lt;&amp;lt; 33 &amp;lt;&amp;lt; 12 &amp;lt;&amp;lt; 68 &amp;lt;&amp;lt; 6 &amp;lt;&amp;lt; 12;
qStableSort(list.begin(), list.end());
// list: [ 6, 12, 12, 33, 68 ]
</db:programlisting>
<db:para>The sort algorithm is efficient on large data sets. It operates in <db:link xlink:href="containers.xml#linear-logarithmic-time">linear-logarithmic time</db:link>, O(<db:emphasis>n</db:emphasis> log <db:emphasis>n</db:emphasis>).</db:para>
<db:para>This function requires the item type (in the example above, int) to implement operator&lt;().</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtalgorithms.xml#qSort">qSort</db:link>()</db:member>
<db:member><db:link xlink:href="qtalgorithms.xml#random-access-iterators">random access iterators</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="qStableSort-1">
<db:title>void qStableSort(RandomAccessIterator <db:emphasis>begin</db:emphasis>, RandomAccessIterator <db:emphasis>end</db:emphasis>, LessThan <db:emphasis>lessThan</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>qStableSort</db:methodname>
<db:methodparam>
<db:type>RandomAccessIterator</db:type>
<db:parameter>begin</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>RandomAccessIterator</db:type>
<db:parameter>end</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>LessThan</db:type>
<db:parameter>lessThan</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">void qStableSort(RandomAccessIterator begin, RandomAccessIterator end, LessThan lessThan)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">deprecated</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This function is deprecated. We strongly advise against using it in new code.</db:para>
<db:para>This is an overloaded function.</db:para>
<db:para>Use std::stable_sort instead.</db:para>
<db:para>Uses the <db:code role="parameter">lessThan</db:code> function instead of operator&lt;() to compare the items.</db:para>
<db:para>For example, here's how to sort the strings in a <db:link xlink:href="qstringlist.xml">QStringList</db:link> in case-insensitive alphabetical order:</db:para>
<db:programlisting language="cpp">bool caseInsensitiveLessThan(const QString &amp;amp;s1, const QString &amp;amp;s2)
{
    return s1.toLower() &amp;lt; s2.toLower();
}

int doSomething()
{
    QStringList list;
    list &amp;lt;&amp;lt; &quot;AlPha&quot; &amp;lt;&amp;lt; &quot;beTA&quot; &amp;lt;&amp;lt; &quot;gamma&quot; &amp;lt;&amp;lt; &quot;DELTA&quot;;
    qStableSort(list.begin(), list.end(), caseInsensitiveLessThan);
    // list: [ &quot;AlPha&quot;, &quot;beTA&quot;, &quot;DELTA&quot;, &quot;gamma&quot; ]
}
</db:programlisting>
<db:para>Note that earlier versions of Qt allowed using a lessThan function that took its arguments by non-const reference. From 4.3 and on this is no longer possible, the arguments has to be passed by const reference or value.</db:para>
<db:para>To sort values in reverse order, pass <db:link xlink:href="qtalgorithms.xml#qGreater">qGreater&lt;T&gt;</db:link>() as the <db:code role="parameter">lessThan</db:code> parameter. For example:</db:para>
<db:programlisting language="cpp">QList&amp;lt;int&amp;gt; list;
list &amp;lt;&amp;lt; 33 &amp;lt;&amp;lt; 12 &amp;lt;&amp;lt; 68 &amp;lt;&amp;lt; 6 &amp;lt;&amp;lt; 12;
qStableSort(list.begin(), list.end(), qGreater&amp;lt;int&amp;gt;());
// list: [ 68, 33, 12, 12, 6 ]
</db:programlisting>
<db:para>If neither of the two items is &quot;less than&quot; the other, the items are taken to be equal. The item that appeared before the other in the original container will still appear first after the sort. This property is often useful when sorting user-visible data.</db:para>
</db:section>
<db:section xml:id="qStableSort-2">
<db:title>void qStableSort(Container &amp;<db:emphasis>container</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>qStableSort</db:methodname>
<db:methodparam>
<db:type>Container &amp;</db:type>
<db:parameter>container</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">2</db:synopsisinfo>
<db:synopsisinfo role="signature">void qStableSort(Container &amp;container)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">deprecated</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This function is deprecated. We strongly advise against using it in new code.</db:para>
<db:para>This is an overloaded function.</db:para>
<db:para>Use std::stable_sort instead.</db:para>
<db:para>This is the same as <db:link xlink:href="qtalgorithms.xml#qStableSort">qStableSort</db:link>(<db:code role="parameter">container</db:code>.begin(), <db:code role="parameter">container</db:code>.end());</db:para>
</db:section>
<db:section xml:id="qSwap">
<db:title>void qSwap(T &amp;<db:emphasis>var1</db:emphasis>, T &amp;<db:emphasis>var2</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>qSwap</db:methodname>
<db:methodparam>
<db:type>T &amp;</db:type>
<db:parameter>var1</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>T &amp;</db:type>
<db:parameter>var2</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void qSwap(T &amp;var1, T &amp;var2)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">deprecated</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This function is deprecated. We strongly advise against using it in new code.</db:para>
<db:para>Use std::swap instead.</db:para>
<db:para>Exchanges the values of variables <db:code role="parameter">var1</db:code> and <db:code role="parameter">var2</db:code>.</db:para>
<db:para>Example:</db:para>
<db:programlisting language="cpp">double pi = 3.14;
double e = 2.71;

qSwap(pi, e);
// pi == 2.71, e == 3.14
</db:programlisting>
</db:section>
<db:section xml:id="qUpperBound">
<db:title>RandomAccessIterator qUpperBound(RandomAccessIterator <db:emphasis>begin</db:emphasis>, RandomAccessIterator <db:emphasis>end</db:emphasis>, const T &amp;<db:emphasis>value</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>RandomAccessIterator</db:type>
<db:methodname>qUpperBound</db:methodname>
<db:methodparam>
<db:type>RandomAccessIterator</db:type>
<db:parameter>begin</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>RandomAccessIterator</db:type>
<db:parameter>end</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const T &amp;</db:type>
<db:parameter>value</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">RandomAccessIterator qUpperBound(RandomAccessIterator begin, RandomAccessIterator end, const T &amp;value)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">deprecated</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This function is deprecated. We strongly advise against using it in new code.</db:para>
<db:para>Use std::upper_bound instead.</db:para>
<db:para>Performs a binary search of the range [<db:code role="parameter">begin</db:code>, <db:code role="parameter">end</db:code>) and returns the position of the one-past-the-last occurrence of <db:code role="parameter">value</db:code>. If no such item is found, returns the position where the item should be inserted.</db:para>
<db:para>The items in the range [<db:code role="parameter">begin</db:code>, <db:emphasis>end</db:emphasis>) must be sorted in ascending order; see <db:link xlink:href="qtalgorithms.xml#qSort">qSort</db:link>().</db:para>
<db:para>Example:</db:para>
<db:programlisting language="cpp">QList&amp;lt;int&amp;gt; list;
list &amp;lt;&amp;lt; 3 &amp;lt;&amp;lt; 3 &amp;lt;&amp;lt; 6 &amp;lt;&amp;lt; 6 &amp;lt;&amp;lt; 6 &amp;lt;&amp;lt; 8;

QList&amp;lt;int&amp;gt;::iterator i = qUpperBound(list.begin(), list.end(), 5);
list.insert(i, 5);
// list: [ 3, 3, 5, 6, 6, 6, 8 ]

i = qUpperBound(list.begin(), list.end(), 12);
list.insert(i, 12);
// list: [ 3, 3, 5, 6, 6, 6, 8, 12 ]
</db:programlisting>
<db:para>This function requires the item type (in the example above, int) to implement operator&lt;().</db:para>
<db:para>qUpperBound() can be used in conjunction with <db:link xlink:href="qtalgorithms.xml#qLowerBound">qLowerBound</db:link>() to iterate over all occurrences of the same value:</db:para>
<db:programlisting language="cpp">QVector&amp;lt;int&amp;gt; vect;
vect &amp;lt;&amp;lt; 3 &amp;lt;&amp;lt; 3 &amp;lt;&amp;lt; 6 &amp;lt;&amp;lt; 6 &amp;lt;&amp;lt; 6 &amp;lt;&amp;lt; 8;
QVector&amp;lt;int&amp;gt;::iterator begin6 =
        qLowerBound(vect.begin(), vect.end(), 6);
QVector&amp;lt;int&amp;gt;::iterator end6 =
        qUpperBound(vect.begin(), vect.end(), 6);

QVector&amp;lt;int&amp;gt;::iterator i = begin6;
while (i != end6) {
    *i = 7;
    ++i;
}
// vect: [ 3, 3, 7, 7, 7, 8 ]
</db:programlisting>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtalgorithms.xml#qLowerBound">qLowerBound</db:link>()</db:member>
<db:member><db:link xlink:href="qtalgorithms.xml#qBinaryFind">qBinaryFind</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="qUpperBound-1">
<db:title>RandomAccessIterator qUpperBound(RandomAccessIterator <db:emphasis>begin</db:emphasis>, RandomAccessIterator <db:emphasis>end</db:emphasis>, const T &amp;<db:emphasis>value</db:emphasis>, LessThan <db:emphasis>lessThan</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>RandomAccessIterator</db:type>
<db:methodname>qUpperBound</db:methodname>
<db:methodparam>
<db:type>RandomAccessIterator</db:type>
<db:parameter>begin</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>RandomAccessIterator</db:type>
<db:parameter>end</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const T &amp;</db:type>
<db:parameter>value</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>LessThan</db:type>
<db:parameter>lessThan</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">RandomAccessIterator qUpperBound(RandomAccessIterator begin, RandomAccessIterator end, const T &amp;value, LessThan lessThan)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">deprecated</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This function is deprecated. We strongly advise against using it in new code.</db:para>
<db:para>This is an overloaded function.</db:para>
<db:para>Use std::upper_bound instead.</db:para>
<db:para>Uses the <db:code role="parameter">lessThan</db:code> function instead of operator&lt;() to compare the items.</db:para>
<db:para>Note that the items in the range must be sorted according to the order specified by the <db:code role="parameter">lessThan</db:code> object.</db:para>
</db:section>
<db:section xml:id="qUpperBound-2">
<db:title>typename Container::const_iterator qUpperBound(const Container &amp;<db:emphasis>container</db:emphasis>, const T &amp;<db:emphasis>value</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>typename Container::const_iterator</db:type>
<db:methodname>qUpperBound</db:methodname>
<db:methodparam>
<db:type>const Container &amp;</db:type>
<db:parameter>container</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const T &amp;</db:type>
<db:parameter>value</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">2</db:synopsisinfo>
<db:synopsisinfo role="signature">typename Container::const_iterator qUpperBound(const Container &amp;container, const T &amp;value)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">deprecated</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This function is deprecated. We strongly advise against using it in new code.</db:para>
<db:para>This is an overloaded function.</db:para>
<db:para>Use std::upper_bound instead.</db:para>
<db:para>This is the same as <db:link xlink:href="qtalgorithms.xml#qUpperBound">qUpperBound</db:link>(<db:code role="parameter">container</db:code>.begin(), <db:code role="parameter">container</db:code>.end(), <db:code role="parameter">value</db:code>);</db:para>
</db:section>
</db:section>
</db:section>
</db:article>
