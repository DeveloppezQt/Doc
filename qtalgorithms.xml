<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en_US">
<db:info>
<db:title>&lt;QtAlgorithms&gt; - Generic Algorithms</db:title>
<db:productname>QtCore</db:productname>
<db:edition>Qt 5.2.1 Reference Documentation</db:edition>
<db:titleabbrev>Qt Core Reference Documentation</db:titleabbrev>
<db:abstract>
<db:para>The &lt;QtAlgorithms&gt; header includes the generic, template-based algorithms.</db:para>
</db:abstract>
<db:pubdate>2025-06-29</db:pubdate>
<db:date>2025-06-29</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:variablelist>
<db:varlistentry>
<db:term>Header</db:term>
<db:listitem>
<db:para>QtAlgorithms</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Group</db:term>
<db:listitem>
<db:para>&lt;QtAlgorithms&gt; is part of <db:simplelist><db:member>funclists</db:member></db:simplelist>
</db:para>
</db:listitem>
</db:varlistentry>
</db:variablelist>
<db:section xml:id="details">
<db:title>Detailed Description</db:title>
<db:para>Qt provides a number of global template functions in &lt;QtAlgorithms&gt; that work on containers and perform small tasks to make life easier, such as qDeleteAll(), which invokes operator delete on all items in a given container or in a given range. You can use these algorithms with any <db:link xlink:href="containers.xml">container class</db:link> that provides STL-style iterators, including Qt's <db:link xlink:href="qlist.xml">QList</db:link>, <db:link xlink:href="qlinkedlist.xml">QLinkedList</db:link>, <db:link xlink:href="qvector.xml">QVector</db:link>, <db:link xlink:href="qmap.xml">QMap</db:link>, and <db:link xlink:href="qhash.xml#the-qhash-hashing-function">QHash</db:link> classes.</db:para>
<db:para>Most algorithms take <db:link xlink:href="containers.xml#stl-style-iterators">STL-style iterators</db:link> as parameters. The algorithms are generic in the sense that they aren't bound to a specific iterator class; you can use them with any iterators that meet a certain set of requirements.</db:para>
<db:para>Different algorithms can have different requirements for the iterators they accept. For example, qFill() accepts two <db:link xlink:href="qtalgorithms.xml#forward-iterators">forward iterators</db:link>. The iterator types required are specified for each algorithm. If an iterator of the wrong type is passed (for example, if <db:link xlink:href="qlist.xml#ConstIterator-typedef">QList::ConstIterator</db:link> is passed as an <db:link xlink:href="qtalgorithms.xml#output-iterators">output iterator</db:link>), you will always get a compiler error, although not necessarily a very informative one.</db:para>
<db:para>Some algorithms have special requirements on the value type stored in the containers. For example, qDeleteAll() requires that the value type is a non-const pointer type (for example, QWidget *). The value type requirements are specified for each algorithm, and the compiler will produce an error if a requirement isn't met.</db:para>
<db:para>The generic algorithms can be used on other container classes than those provided by Qt and STL. The syntax of STL-style iterators is modeled after C++ pointers, so it's possible to use plain arrays as containers and plain pointers as iterators. A common idiom is to use qBinaryFind() together with two static arrays: one that contains a list of keys, and another that contains a list of associated values. For example, the following code will look up an HTML entity (e.g., &amp;amp;) in the name_table array and return the corresponding Unicode value from the value_table if the entity is recognized:</db:para>
<db:programlisting language="cpp">QChar resolveEntity(const QString &amp;entity)
{
    static const QLatin1String name_table[] = {
        &quot;AElig&quot;, &quot;Aacute&quot;, ..., &quot;zwnj&quot;
    };
    static const ushort value_table[] = {
        0x0061, 0x00c1, ..., 0x200c
    };
    int N = sizeof(name_table) / sizeof(name_table[0]);

    const QLatin1String *name = qBinaryFind(name_table, name_table + N,
                                            entity);
    int index = name - name_table;
    if (index == N)
        return QChar();

    return QChar(value_table[index]);
}
</db:programlisting>
<db:para>This kind of code is for advanced users only; for most applications, a <db:link xlink:href="qmap.xml">QMap</db:link>- or <db:link xlink:href="qhash.xml#the-qhash-hashing-function">QHash</db:link>-based approach would work just as well:</db:para>
<db:programlisting language="cpp">QChar resolveEntity(const QString &amp;entity)
{
    static QMap&lt;QString, int&gt; entityMap;

    if (!entityMap) {
        entityMap.insert(&quot;AElig&quot;, 0x0061);
        entityMap.insert(&quot;Aacute&quot;, 0x00c1);
        ...
        entityMap.insert(&quot;zwnj&quot;, 0x200c);
    }
    return QChar(entityMap.value(entity));
}
</db:programlisting>
<db:section xml:id="types-of-iterators">
<db:title>Types of Iterators</db:title>
<db:para>The algorithms have certain requirements on the iterator types they accept, and these are specified individually for each function. The compiler will produce an error if a requirement isn't met.</db:para>
<db:section xml:id="input-iterators">
<db:title>Input Iterators</db:title>
<db:para>An <db:emphasis>input iterator</db:emphasis> is an iterator that can be used for reading data sequentially from a container. It must provide the following operators: == and != for comparing two iterators, unary * for retrieving the value stored in the item, and prefix ++ for advancing to the next item.</db:para>
<db:para>The Qt containers' iterator types (const and non-const) are all input iterators.</db:para>
</db:section>
<db:section xml:id="output-iterators">
<db:title>Output Iterators</db:title>
<db:para>An output iterator is an iterator that can be used for writing data sequentially to a container or to some output stream. It must provide the following operators: unary * for writing a value (i.e., *it = val) and prefix ++ for advancing to the next item.</db:para>
<db:para>The Qt containers' non-const iterator types are all output iterators.</db:para>
</db:section>
<db:section xml:id="forward-iterators">
<db:title>Forward Iterators</db:title>
<db:para>A <db:emphasis>forward iterator</db:emphasis> is an iterator that meets the requirements of both input iterators and output iterators.</db:para>
<db:para>The Qt containers' non-const iterator types are all forward iterators.</db:para>
</db:section>
<db:section xml:id="bidirectional-iterators">
<db:title>Bidirectional Iterators</db:title>
<db:para>A <db:emphasis>bidirectional iterator</db:emphasis> is an iterator that meets the requirements of forward iterators but that in addition supports prefix -- for iterating backward.</db:para>
<db:para>The Qt containers' non-const iterator types are all bidirectional iterators.</db:para>
</db:section>
<db:section xml:id="random-access-iterators">
<db:title>Random Access Iterators</db:title>
<db:para>The last category, <db:emphasis>random access iterators</db:emphasis>, is the most powerful type of iterator. It supports all the requirements of a bidirectional iterator, and supports the following operations:</db:para>
<db:informaltable style="generic">
<db:tr valign="top">
<db:td>
<db:para>i += n</db:para>
</db:td>
<db:td>
<db:para>advances iterator i by n positions</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>i -= n</db:para>
</db:td>
<db:td>
<db:para>moves iterator i back by n positions</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>i + n or n + i</db:para>
</db:td>
<db:td>
<db:para>returns the iterator for the item n positions ahead of iterator i</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>i - n</db:para>
</db:td>
<db:td>
<db:para>returns the iterator for the item n positions behind of iterator i</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>i - j</db:para>
</db:td>
<db:td>
<db:para>returns the number of items between iterators i and j</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>i[n]</db:para>
</db:td>
<db:td>
<db:para>same as *(i + n)</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>i &lt; j</db:para>
</db:td>
<db:td>
<db:para>returns true if iterator j comes after iterator i</db:para>
</db:td>
</db:tr>
</db:informaltable>
<db:para><db:link xlink:href="qlist.xml">QList</db:link> and <db:link xlink:href="qvector.xml">QVector</db:link>'s non-const iterator types are random access iterators.</db:para>
</db:section>
</db:section>
<db:section xml:id="qt-and-the-stl-algorithms">
<db:title>Qt and the STL algorithms</db:title>
<db:para>Historically, Qt used to provide functions which were direct equivalents of many STL algorithmic functions. Starting with Qt 5.0, you are instead encouraged to use directly the implementations available in the STL; most of the Qt ones have been deprecated (although they are still available to keep the old code compiling).</db:para>
<db:section xml:id="porting-guidelines">
<db:title>Porting guidelines</db:title>
<db:para>Most of the times, an application using the deprecated Qt algorithmic functions can be easily ported to use the equivalent STL functions. You need to</db:para>
<db:orderedlist numeration="arabic">
<db:listitem>
<db:para>add the #include &lt;algorithm&gt; preprocessor directive;</db:para>
</db:listitem>
<db:listitem>
<db:para>replace the Qt functions with the STL counterparts, according to the table below.</db:para>
</db:listitem>
</db:orderedlist>
<db:informaltable style="generic">
<db:thead>
<db:tr>
<db:th>
<db:para>Qt function</db:para>
</db:th>
<db:th>
<db:para>STL function</db:para>
</db:th>
</db:tr>
</db:thead>
<db:tr valign="top">
<db:td>
<db:para>qBinaryFind</db:para>
</db:td>
<db:td>
<db:para>std::binary_search or std::lower_bound</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>qCopy</db:para>
</db:td>
<db:td>
<db:para>std::copy</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>qCopyBackward</db:para>
</db:td>
<db:td>
<db:para>std::copy_backward</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>qEqual</db:para>
</db:td>
<db:td>
<db:para>std::equal</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>qFill</db:para>
</db:td>
<db:td>
<db:para>std::fill</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>qFind</db:para>
</db:td>
<db:td>
<db:para>std::find</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>qCount</db:para>
</db:td>
<db:td>
<db:para>std::count</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>qSort</db:para>
</db:td>
<db:td>
<db:para>std::sort</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>qStableSort</db:para>
</db:td>
<db:td>
<db:para>std::stable_sort</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>qLowerBound</db:para>
</db:td>
<db:td>
<db:para>std::lower_bound</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>qUpperBound</db:para>
</db:td>
<db:td>
<db:para>std::upper_bound</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>qLess</db:para>
</db:td>
<db:td>
<db:para>std::less</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>qGreater</db:para>
</db:td>
<db:td>
<db:para>std::greater</db:para>
</db:td>
</db:tr>
</db:informaltable>
<db:para>The only cases in which the port may not be straightforward is if the old code relied on template specializations of the qLess() and/or the qSwap() functions, which were used internally by the implementations of the Qt algorithmic functions, but are instead ignored by the STL ones.</db:para>
<db:para>In case the old code relied on the specialization of the qLess() functor, then a workaround is explicitly passing an instance of the qLess() class to the STL function, for instance like this:</db:para>
<db:programlisting language="cpp">std::sort(container.begin(), container.end(), qLess&lt;T&gt;());
</db:programlisting>
<db:para>Instead, since it's not possible to pass a custom swapper functor to STL functions, the only workaround for a template specialization for qSwap() is providing the same specialization for std::swap().</db:para>
</db:section>
</db:section>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="containers.xml">container classes</db:link></db:member>
<db:member><db:link xlink:href="qtglobal.xml">&lt;QtGlobal&gt;</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="function-documentation">
<db:title>Function Documentation</db:title>
<db:section xml:id="qPopulationCount">
<db:title>[since 5.2] uint qPopulationCount(quint8 <db:emphasis>v</db:emphasis>)</db:title>
<db:para>Returns the number of bits set in <db:code role="parameter">v</db:code>. This number is also called the Hamming Weight of <db:code role="parameter">v</db:code>.</db:para>
<db:para>This function was introduced in Qt 5.2.</db:para>
</db:section>
<db:section xml:id="qPopulationCount-1">
<db:title>[since 5.2] uint qPopulationCount(quint16 <db:emphasis>v</db:emphasis>)</db:title>
<db:para>This is an overloaded function.</db:para>
<db:para>This function was introduced in Qt 5.2.</db:para>
</db:section>
<db:section xml:id="qPopulationCount-2">
<db:title>[since 5.2] uint qPopulationCount(quint32 <db:emphasis>v</db:emphasis>)</db:title>
<db:para>This is an overloaded function.</db:para>
<db:para>This function was introduced in Qt 5.2.</db:para>
</db:section>
<db:section xml:id="qPopulationCount-3">
<db:title>[since 5.2] uint qPopulationCount(quint64 <db:emphasis>v</db:emphasis>)</db:title>
<db:para>This is an overloaded function.</db:para>
<db:para>This function was introduced in Qt 5.2.</db:para>
</db:section>
</db:section>
</db:article>
