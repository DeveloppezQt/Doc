<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en">
<db:info>
<db:title>&lt;QtAlgorithms&gt; - Generic Algorithms</db:title>
<db:productname>QtCore</db:productname>
<db:edition>Qt 5.13.2 Reference Documentation</db:edition>
<db:titleabbrev>Qt Core Reference Documentation</db:titleabbrev>
<db:abstract>
<db:para>The &lt;QtAlgorithms&gt; header includes the generic, template-based algorithms.</db:para>
</db:abstract>
<db:pubdate>2024-12-27</db:pubdate>
<db:date>2024-12-27</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:variablelist>
<db:varlistentry>
<db:term>Header</db:term>
<db:listitem>
<db:para>QtAlgorithms</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Group</db:term>
<db:listitem>
<db:para>&lt;QtAlgorithms&gt; is part of <db:simplelist><db:member>funclists</db:member></db:simplelist></db:para>
</db:listitem>
</db:varlistentry>
</db:variablelist>
<db:section xml:id="details">
<db:title>Detailed Description</db:title>
<db:para>Qt provides a number of global template functions in &lt;QtAlgorithms&gt; that work on containers and perform small tasks to make life easier, such as <db:link xlink:href="qtalgorithms.xml#qDeleteAll">qDeleteAll</db:link>(), which invokes operator delete on all items in a given container or in a given range. You can use these algorithms with any <db:link xlink:href="containers.xml">container class</db:link> that provides STL-style iterators, including Qt's <db:link xlink:href="qlist.xml">QList</db:link>, <db:link xlink:href="qlinkedlist.xml">QLinkedList</db:link>, <db:link xlink:href="qvector.xml">QVector</db:link>, <db:link xlink:href="qmap.xml">QMap</db:link>, and <db:link xlink:href="qhash.xml#qhash">QHash</db:link> classes.</db:para>
<db:para>Most algorithms take <db:link xlink:href="containers.xml#stl-style-iterators">STL-style iterators</db:link> as parameters. The algorithms are generic in the sense that they aren't bound to a specific iterator class; you can use them with any iterators that meet a certain set of requirements.</db:para>
<db:para>Different algorithms can have different requirements for the iterators they accept. For example, qFill() accepts two <db:link xlink:href="qtalgorithms.xml#forward-iterators">forward iterators</db:link>. The iterator types required are specified for each algorithm. If an iterator of the wrong type is passed (for example, if <db:link xlink:href="qlist.xml#ConstIterator-typedef">QList::ConstIterator</db:link> is passed as an <db:link xlink:href="qtalgorithms.xml#output-iterators">output iterator</db:link>), you will always get a compiler error, although not necessarily a very informative one.</db:para>
<db:para>Some algorithms have special requirements on the value type stored in the containers. For example, <db:link xlink:href="qtalgorithms.xml#qDeleteAll">qDeleteAll</db:link>() requires that the value type is a non-const pointer type (for example, QWidget *). The value type requirements are specified for each algorithm, and the compiler will produce an error if a requirement isn't met.</db:para>
<db:para>The generic algorithms can be used on other container classes than those provided by Qt and STL. The syntax of STL-style iterators is modeled after C++ pointers, so it's possible to use plain arrays as containers and plain pointers as iterators. A common idiom is to use qBinaryFind() together with two static arrays: one that contains a list of keys, and another that contains a list of associated values. For example, the following code will look up an HTML entity (e.g., &amp;amp;) in the name_table array and return the corresponding Unicode value from the value_table if the entity is recognized:</db:para>
<db:programlisting language="cpp">QChar resolveEntity(const QString &amp;amp;entity)
{
    static const QLatin1String name_table[] = {
        &quot;AElig&quot;, &quot;Aacute&quot;, ..., &quot;zwnj&quot;
    };
    static const ushort value_table[] = {
        0x0061, 0x00c1, ..., 0x200c
    };
    int N = sizeof(name_table) / sizeof(name_table[0]);

    const QLatin1String *name = qBinaryFind(name_table, name_table + N,
                                            entity);
    int index = name - name_table;
    if (index == N)
        return QChar();

    return QChar(value_table[index]);
}
</db:programlisting>
<db:para>This kind of code is for advanced users only; for most applications, a <db:link xlink:href="qmap.xml">QMap</db:link>- or <db:link xlink:href="qhash.xml#qhash">QHash</db:link>-based approach would work just as well:</db:para>
<db:programlisting language="cpp">QChar resolveEntity(const QString &amp;amp;entity)
{
    static QMap&amp;lt;QString, int&amp;gt; entityMap;

    if (!entityMap) {
        entityMap.insert(&quot;AElig&quot;, 0x0061);
        entityMap.insert(&quot;Aacute&quot;, 0x00c1);
        ...
        entityMap.insert(&quot;zwnj&quot;, 0x200c);
    }
    return QChar(entityMap.value(entity));
}
</db:programlisting>
<db:section xml:id="types-of-iterators">
<db:title>Types of Iterators</db:title>
<db:para>The algorithms have certain requirements on the iterator types they accept, and these are specified individually for each function. The compiler will produce an error if a requirement isn't met.</db:para>
<db:section xml:id="input-iterators">
<db:title>Input Iterators</db:title>
<db:para>An <db:emphasis>input iterator</db:emphasis> is an iterator that can be used for reading data sequentially from a container. It must provide the following operators: == and != for comparing two iterators, unary * for retrieving the value stored in the item, and prefix ++ for advancing to the next item.</db:para>
<db:para>The Qt containers' iterator types (const and non-const) are all input iterators.</db:para>
</db:section>
<db:section xml:id="output-iterators">
<db:title>Output Iterators</db:title>
<db:para>An output iterator is an iterator that can be used for writing data sequentially to a container or to some output stream. It must provide the following operators: unary * for writing a value (i.e., *it = val) and prefix ++ for advancing to the next item.</db:para>
<db:para>The Qt containers' non-const iterator types are all output iterators.</db:para>
</db:section>
<db:section xml:id="forward-iterators">
<db:title>Forward Iterators</db:title>
<db:para>A <db:emphasis>forward iterator</db:emphasis> is an iterator that meets the requirements of both input iterators and output iterators.</db:para>
<db:para>The Qt containers' non-const iterator types are all forward iterators.</db:para>
</db:section>
<db:section xml:id="bidirectional-iterators">
<db:title>Bidirectional Iterators</db:title>
<db:para>A <db:emphasis>bidirectional iterator</db:emphasis> is an iterator that meets the requirements of forward iterators but that in addition supports prefix -- for iterating backward.</db:para>
<db:para>The Qt containers' non-const iterator types are all bidirectional iterators.</db:para>
</db:section>
<db:section xml:id="random-access-iterators">
<db:title>Random Access Iterators</db:title>
<db:para>The last category, <db:emphasis>random access iterators</db:emphasis>, is the most powerful type of iterator. It supports all the requirements of a bidirectional iterator, and supports the following operations:</db:para>
<db:informaltable style="generic">
<db:tr valign="top">
<db:td>
<db:para>i += n</db:para>
</db:td>
<db:td>
<db:para>advances iterator i by n positions</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>i -= n</db:para>
</db:td>
<db:td>
<db:para>moves iterator i back by n positions</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>i + n or n + i</db:para>
</db:td>
<db:td>
<db:para>returns the iterator for the item n positions ahead of iterator i</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>i - n</db:para>
</db:td>
<db:td>
<db:para>returns the iterator for the item n positions behind of iterator i</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>i - j</db:para>
</db:td>
<db:td>
<db:para>returns the number of items between iterators i and j</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>i[n]</db:para>
</db:td>
<db:td>
<db:para>same as *(i + n)</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>i &lt; j</db:para>
</db:td>
<db:td>
<db:para>returns true if iterator j comes after iterator i</db:para>
</db:td>
</db:tr>
</db:informaltable>
<db:para><db:link xlink:href="qlist.xml">QList</db:link> and <db:link xlink:href="qvector.xml">QVector</db:link>'s non-const iterator types are random access iterators.</db:para>
</db:section>
</db:section>
<db:section xml:id="qt-and-the-stl-algorithms">
<db:title>Qt and the STL Algorithms</db:title>
<db:para>Historically, Qt used to provide functions which were direct equivalents of many STL algorithmic functions. Starting with Qt 5.0, you are instead encouraged to use directly the implementations available in the STL; most of the Qt ones have been deprecated (although they are still available to keep the old code compiling).</db:para>
<db:section xml:id="porting-guidelines">
<db:title>Porting guidelines</db:title>
<db:para>Most of the time, an application using the deprecated Qt algorithmic functions can be easily ported to use the equivalent STL functions. You need to:</db:para>
<db:orderedlist numeration="arabic">
<db:listitem>
<db:para>add the #include &lt;algorithm&gt; preprocessor directive;</db:para>
</db:listitem>
<db:listitem>
<db:para>replace the Qt functions with the STL counterparts, according to the table below.</db:para>
</db:listitem>
</db:orderedlist>
<db:informaltable style="generic">
<db:thead>
<db:tr>
<db:th>
<db:para>Qt function</db:para>
</db:th>
<db:th>
<db:para>STL function</db:para>
</db:th>
</db:tr>
</db:thead>
<db:tr valign="top">
<db:td>
<db:para>qBinaryFind</db:para>
</db:td>
<db:td>
<db:para>std::binary_search or std::lower_bound</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>qCopy</db:para>
</db:td>
<db:td>
<db:para>std::copy</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>qCopyBackward</db:para>
</db:td>
<db:td>
<db:para>std::copy_backward</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>qEqual</db:para>
</db:td>
<db:td>
<db:para>std::equal</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>qFill</db:para>
</db:td>
<db:td>
<db:para>std::fill</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>qFind</db:para>
</db:td>
<db:td>
<db:para>std::find</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>qCount</db:para>
</db:td>
<db:td>
<db:para>std::count</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>qSort</db:para>
</db:td>
<db:td>
<db:para>std::sort</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>qStableSort</db:para>
</db:td>
<db:td>
<db:para>std::stable_sort</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>qLowerBound</db:para>
</db:td>
<db:td>
<db:para>std::lower_bound</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>qUpperBound</db:para>
</db:td>
<db:td>
<db:para>std::upper_bound</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>qLess</db:para>
</db:td>
<db:td>
<db:para>std::less</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>qGreater</db:para>
</db:td>
<db:td>
<db:para>std::greater</db:para>
</db:td>
</db:tr>
</db:informaltable>
<db:para>The only cases in which the port may not be straightforward is if the old code relied on template specializations of the qLess() and/or the qSwap() functions, which were used internally by the implementations of the Qt algorithmic functions, but are instead ignored by the STL ones.</db:para>
<db:para>In case the old code relied on the specialization of the qLess() functor, then a workaround is explicitly passing an instance of the qLess() class to the STL function, for instance like this:</db:para>
<db:programlisting language="cpp">std::sort(container.begin(), container.end(), qLess&amp;lt;T&amp;gt;());
</db:programlisting>
<db:para>Instead, since it's not possible to pass a custom swapper functor to STL functions, the only workaround for a template specialization for qSwap() is providing the same specialization for std::swap().</db:para>
</db:section>
</db:section>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="containers.xml">container classes</db:link></db:member>
<db:member><db:link xlink:href="qtglobal.xml">&lt;QtGlobal&gt;</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="function-documentation">
<db:title>Function Documentation</db:title>
<db:section xml:id="qDeleteAll">
<db:title>void qDeleteAll(ForwardIterator <db:emphasis>begin</db:emphasis>, ForwardIterator <db:emphasis>end</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>qDeleteAll</db:methodname>
<db:methodparam>
<db:type>ForwardIterator</db:type>
<db:parameter>begin</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>ForwardIterator</db:type>
<db:parameter>end</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void qDeleteAll(ForwardIterator begin, ForwardIterator end)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Deletes all the items in the range [<db:code role="parameter">begin</db:code>, <db:code role="parameter">end</db:code>) using the C++ delete operator. The item type must be a pointer type (for example, QWidget *).</db:para>
<db:para>Example:</db:para>
<db:programlisting language="cpp">QList&amp;lt;Employee *&amp;gt; list;
list.append(new Employee(&quot;Blackpool&quot;, &quot;Stephen&quot;));
list.append(new Employee(&quot;Twist&quot;, &quot;Oliver&quot;));

qDeleteAll(list.begin(), list.end());
list.clear();
</db:programlisting>
<db:para>Notice that qDeleteAll() doesn't remove the items from the container; it merely calls delete on them. In the example above, we call clear() on the container to remove the items.</db:para>
<db:para>This function can also be used to delete items stored in associative containers, such as <db:link xlink:href="qmap.xml">QMap</db:link> and <db:link xlink:href="qhash.xml#qhash">QHash</db:link>. Only the objects stored in each container will be deleted by this function; objects used as keys will not be deleted.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtalgorithms.xml#forward-iterators">forward iterators</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="qDeleteAll-1">
<db:title>void qDeleteAll(const Container &amp;<db:emphasis>c</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>qDeleteAll</db:methodname>
<db:methodparam>
<db:type>const Container &amp;</db:type>
<db:parameter>c</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">void qDeleteAll(const Container &amp;c)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>This is the same as <db:link xlink:href="qtalgorithms.xml#qDeleteAll">qDeleteAll</db:link>(<db:code role="parameter">c</db:code>.begin(), <db:code role="parameter">c</db:code>.end()).</db:para>
</db:section>
</db:section>
<db:section xml:id="obsolete">
<db:title>Obsolete Members for &lt;QtAlgorithms&gt;</db:title>
<db:para><db:emphasis role="bold">The following members of class <db:link xlink:href="qtalgorithms.xml">&lt;QtAlgorithms&gt;</db:link> are deprecated.</db:emphasis> We strongly advise against using them in new code.</db:para>
<db:section xml:id="obsolete-function-documentation">
<db:title>Obsolete Function Documentation</db:title>
<db:section xml:id="qGreater">
<db:title>int qGreater()</db:title>
<db:methodsynopsis>
<db:type>int</db:type>
<db:methodname>qGreater</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">int qGreater()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">deprecated</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This function is deprecated. We strongly advise against using it in new code.</db:para>
<db:para>Use std::greater instead.</db:para>
<db:para>Returns a functional object, or functor, that can be passed to qSort() or qStableSort().</db:para>
<db:para>Example:</db:para>
<db:programlisting language="cpp">QList&amp;lt;int&amp;gt; list;
list &amp;lt;&amp;lt; 33 &amp;lt;&amp;lt; 12 &amp;lt;&amp;lt; 68 &amp;lt;&amp;lt; 6 &amp;lt;&amp;lt; 12;
qSort(list.begin(), list.end(), qGreater&amp;lt;int&amp;gt;());
// list: [ 68, 33, 12, 12, 6 ]
</db:programlisting>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtalgorithms.xml#qLess">qLess&lt;T&gt;</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="qLess">
<db:title>int qLess()</db:title>
<db:methodsynopsis>
<db:type>int</db:type>
<db:methodname>qLess</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">int qLess()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">deprecated</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This function is deprecated. We strongly advise against using it in new code.</db:para>
<db:para>Use std::less instead.</db:para>
<db:para>Returns a functional object, or functor, that can be passed to qSort() or qStableSort().</db:para>
<db:para>Example:</db:para>
<db:programlisting language="cpp">QList&amp;lt;int&amp;gt; list;
list &amp;lt;&amp;lt; 33 &amp;lt;&amp;lt; 12 &amp;lt;&amp;lt; 68 &amp;lt;&amp;lt; 6 &amp;lt;&amp;lt; 12;
qSort(list.begin(), list.end(), qLess&amp;lt;int&amp;gt;());
// list: [ 6, 12, 12, 33, 68 ]
</db:programlisting>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtalgorithms.xml#qGreater">qGreater&lt;T&gt;</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="qSwap">
<db:title>void qSwap(T &amp;<db:emphasis>var1</db:emphasis>, T &amp;<db:emphasis>var2</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>qSwap</db:methodname>
<db:methodparam>
<db:type>T &amp;</db:type>
<db:parameter>var1</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>T &amp;</db:type>
<db:parameter>var2</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void qSwap(T &amp;var1, T &amp;var2)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">deprecated</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This function is deprecated. We strongly advise against using it in new code.</db:para>
<db:para>Use std::swap instead.</db:para>
<db:para>Exchanges the values of variables <db:code role="parameter">var1</db:code> and <db:code role="parameter">var2</db:code>.</db:para>
<db:para>Example:</db:para>
<db:programlisting language="cpp">double pi = 3.14;
double e = 2.71;

qSwap(pi, e);
// pi == 2.71, e == 3.14
</db:programlisting>
</db:section>
</db:section>
</db:section>
</db:article>
