<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en">
<db:info>
<db:title>WebEngine Demo Browser Example</db:title>
<db:productname>QtWebEngine</db:productname>
<db:edition>Qt 5.8.0 Reference Documentation</db:edition>
<db:titleabbrev>Qt WebEngine Reference Documentation</db:titleabbrev>
<db:abstract>
<db:para>A demo browser based on Qt <db:link xlink:href="qml-qtwebengine-webengine.xml">WebEngine</db:link> Widgets.</db:para>
</db:abstract>
<db:pubdate>2025-06-29</db:pubdate>
<db:date>2025-06-29</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:programlisting language="cpp">/****************************************************************************
**
** Copyright (C) 2016 The Qt Company Ltd.
** Contact: https://www.qt.io/licensing/
**
** This file is part of the demonstration applications of the Qt Toolkit.
**
** $QT_BEGIN_LICENSE:BSD$
** Commercial License Usage
** Licensees holding valid commercial Qt licenses may use this file in
** accordance with the commercial license agreement provided with the
** Software or, alternatively, in accordance with the terms contained in
** a written agreement between you and The Qt Company. For licensing terms
** and conditions see https://www.qt.io/terms-conditions. For further
** information use the contact form at https://www.qt.io/contact-us.
**
** BSD License Usage
** Alternatively, you may use this file under the terms of the BSD license
** as follows:
**
** &quot;Redistribution and use in source and binary forms, with or without
** modification, are permitted provided that the following conditions are
** met:
**   * Redistributions of source code must retain the above copyright
**     notice, this list of conditions and the following disclaimer.
**   * Redistributions in binary form must reproduce the above copyright
**     notice, this list of conditions and the following disclaimer in
**     the documentation and/or other materials provided with the
**     distribution.
**   * Neither the name of The Qt Company Ltd nor the names of its
**     contributors may be used to endorse or promote products derived
**     from this software without specific prior written permission.
**
**
** THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
** &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
** LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
** A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
** OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
** SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
** LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
** DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
** THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
** (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
** OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.&quot;
**
** $QT_END_LICENSE$
**
****************************************************************************/

#include &quot;tabwidget.h&quot;

#include &quot;browserapplication.h&quot;
#include &quot;browsermainwindow.h&quot;
#include &quot;downloadmanager.h&quot;
#include &quot;fullscreennotification.h&quot;
#include &quot;history.h&quot;
#include &quot;savepagedialog.h&quot;
#include &quot;urllineedit.h&quot;
#include &quot;webview.h&quot;

#include &lt;QWebEngineDownloadItem&gt;
#include &lt;QWebEngineProfile&gt;
#include &lt;QWebEngineFullScreenRequest&gt;
#include &lt;QtCore/QMimeData&gt;
#include &lt;QtGui/QClipboard&gt;
#include &lt;QtWidgets/QCompleter&gt;
#include &lt;QtWidgets/QListView&gt;
#include &lt;QtWidgets/QMenu&gt;
#include &lt;QtWidgets/QMessageBox&gt;
#include &lt;QtGui/QDrag&gt;
#include &lt;QtGui/QMouseEvent&gt;
#include &lt;QtWidgets/QStackedWidget&gt;
#include &lt;QtWidgets/QStyle&gt;
#include &lt;QtWidgets/QToolButton&gt;

#include &lt;QtCore/QDebug&gt;

TabBar::TabBar(QWidget *parent)
    : QTabBar(parent)
{
    setContextMenuPolicy(Qt::CustomContextMenu);
    setAcceptDrops(true);
    connect(this, SIGNAL(customContextMenuRequested(QPoint)),
            this, SLOT(contextMenuRequested(QPoint)));

    QString ctrl = QLatin1String(&quot;Ctrl+%1&quot;);
    for (int i = 1; i &lt; 10; ++i) {
        QShortcut *shortCut = new QShortcut(ctrl.arg(i), this);
        m_tabShortcuts.append(shortCut);
        connect(shortCut, SIGNAL(activated()), this, SLOT(selectTabAction()));
    }
    setTabsClosable(true);
    connect(this, SIGNAL(tabCloseRequested(int)),
            this, SIGNAL(closeTab(int)));
    setSelectionBehaviorOnRemove(QTabBar::SelectPreviousTab);
    setMovable(true);
}

TabWidget::~TabWidget()
{
    delete m_fullScreenNotification;
    delete m_fullScreenView;
}

void TabBar::selectTabAction()
{
    if (QShortcut *shortCut = qobject_cast&lt;QShortcut*&gt;(sender())) {
        int index = m_tabShortcuts.indexOf(shortCut);
        setCurrentIndex(index);
    }
}

void TabBar::contextMenuRequested(const QPoint &amp;position)
{
    QMenu menu;
    menu.addAction(tr(&quot;New &amp;Tab&quot;), this, SIGNAL(newTab()), QKeySequence::AddTab);
    int index = tabAt(position);
    if (-1 != index) {
        QAction *action = menu.addAction(tr(&quot;Clone Tab&quot;),
                this, SLOT(cloneTab()));
        action-&gt;setData(index);

        menu.addSeparator();

        action = menu.addAction(tr(&quot;&amp;Close Tab&quot;),
                this, SLOT(closeTab()), QKeySequence::Close);
        action-&gt;setData(index);

        action = menu.addAction(tr(&quot;Close &amp;Other Tabs&quot;),
                this, SLOT(closeOtherTabs()));
        action-&gt;setData(index);

        menu.addSeparator();

        action = menu.addAction(tr(&quot;Reload Tab&quot;),
                this, SLOT(reloadTab()), QKeySequence::Refresh);
        action-&gt;setData(index);

        // Audio mute / unmute.
        action = menu.addAction(tr(&quot;Mute tab&quot;),
                this, SLOT(muteTab()));
        action-&gt;setData(index);

        action = menu.addAction(tr(&quot;Unmute tab&quot;),
                this, SLOT(unmuteTab()));
        action-&gt;setData(index);
    } else {
        menu.addSeparator();
    }
    menu.addAction(tr(&quot;Reload All Tabs&quot;), this, SIGNAL(reloadAllTabs()));
    menu.exec(QCursor::pos());
}

void TabBar::cloneTab()
{
    if (QAction *action = qobject_cast&lt;QAction*&gt;(sender())) {
        int index = action-&gt;data().toInt();
        emit cloneTab(index);
    }
}

void TabBar::closeTab()
{
    if (QAction *action = qobject_cast&lt;QAction*&gt;(sender())) {
        int index = action-&gt;data().toInt();
        emit closeTab(index);
    }
}

void TabBar::closeOtherTabs()
{
    if (QAction *action = qobject_cast&lt;QAction*&gt;(sender())) {
        int index = action-&gt;data().toInt();
        emit closeOtherTabs(index);
    }
}

void TabBar::mousePressEvent(QMouseEvent *event)
{
    if (event-&gt;button() == Qt::LeftButton)
        m_dragStartPos = event-&gt;pos();

    QTabBar::mousePressEvent(event);

    // Middle click on tab should close it.
    if (event-&gt;button() == Qt::MiddleButton) {
        const QPoint pos = event-&gt;pos();
        int index = tabAt(pos);
        if (index != -1) {
            emit closeTab(index);
        }
    }
}

void TabBar::mouseMoveEvent(QMouseEvent *event)
{
    if (event-&gt;buttons() == Qt::LeftButton) {
        int diffX = event-&gt;pos().x() - m_dragStartPos.x();
        int diffY = event-&gt;pos().y() - m_dragStartPos.y();
        if ((event-&gt;pos() - m_dragStartPos).manhattanLength() &gt; QApplication::startDragDistance()
            &amp;&amp; diffX &lt; 3 &amp;&amp; diffX &gt; -3
            &amp;&amp; diffY &lt; -10) {
            QDrag *drag = new QDrag(this);
            QMimeData *mimeData = new QMimeData;
            QList&lt;QUrl&gt; urls;
            int index = tabAt(event-&gt;pos());
            QUrl url = tabData(index).toUrl();
            urls.append(url);
            mimeData-&gt;setUrls(urls);
            mimeData-&gt;setText(tabText(index));
            mimeData-&gt;setData(QLatin1String(&quot;action&quot;), &quot;tab-reordering&quot;);
            drag-&gt;setMimeData(mimeData);
            drag-&gt;exec();
        }
    }
    QTabBar::mouseMoveEvent(event);
}

// When index is -1 index chooses the current tab
void TabWidget::reloadTab(int index)
{
    if (index &lt; 0)
        index = currentIndex();
    if (index &lt; 0 || index &gt;= count())
        return;

    QWidget *widget = this-&gt;widget(index);
    if (WebView *tab = qobject_cast&lt;WebView*&gt;(widget))
        tab-&gt;reload();
}

void TabBar::reloadTab()
{
    if (QAction *action = qobject_cast&lt;QAction*&gt;(sender())) {
        int index = action-&gt;data().toInt();
        emit reloadTab(index);
    }
}

void TabBar::muteTab()
{
    if (QAction *action = qobject_cast&lt;QAction*&gt;(sender())) {
        int index = action-&gt;data().toInt();
        emit muteTab(index, true);
    }
}

void TabBar::unmuteTab()
{
    if (QAction *action = qobject_cast&lt;QAction*&gt;(sender())) {
        int index = action-&gt;data().toInt();
        emit muteTab(index, false);
    }
}

TabWidget::TabWidget(QWidget *parent)
    : QTabWidget(parent)
    , m_recentlyClosedTabsAction(0)
    , m_newTabAction(0)
    , m_closeTabAction(0)
    , m_nextTabAction(0)
    , m_previousTabAction(0)
    , m_recentlyClosedTabsMenu(0)
    , m_lineEditCompleter(0)
    , m_lineEdits(0)
    , m_tabBar(new TabBar(this))
    , m_profile(QWebEngineProfile::defaultProfile())
    , m_fullScreenView(0)
    , m_fullScreenNotification(0)
{
    setElideMode(Qt::ElideRight);

    connect(m_tabBar, SIGNAL(newTab()), this, SLOT(newTab()));
    connect(m_tabBar, SIGNAL(closeTab(int)), this, SLOT(requestCloseTab(int)));
    connect(m_tabBar, SIGNAL(cloneTab(int)), this, SLOT(cloneTab(int)));
    connect(m_tabBar, SIGNAL(closeOtherTabs(int)), this, SLOT(closeOtherTabs(int)));
    connect(m_tabBar, SIGNAL(reloadTab(int)), this, SLOT(reloadTab(int)));
    connect(m_tabBar, SIGNAL(reloadAllTabs()), this, SLOT(reloadAllTabs()));
    connect(m_tabBar, SIGNAL(tabMoved(int,int)), this, SLOT(moveTab(int,int)));
    connect(m_tabBar, SIGNAL(tabBarDoubleClicked(int)), this, SLOT(handleTabBarDoubleClicked(int)));
    connect(m_tabBar, SIGNAL(muteTab(int,bool)), this, SLOT(setAudioMutedForTab(int,bool)));
    setTabBar(m_tabBar);
    setDocumentMode(true);

    // Actions
    m_newTabAction = new QAction(QIcon(QLatin1String(&quot;:addtab.png&quot;)), tr(&quot;New &amp;Tab&quot;), this);
    m_newTabAction-&gt;setShortcuts(QKeySequence::AddTab);
    m_newTabAction-&gt;setIconVisibleInMenu(false);
    connect(m_newTabAction, SIGNAL(triggered()), this, SLOT(newTab()));

    m_closeTabAction = new QAction(QIcon(QLatin1String(&quot;:closetab.png&quot;)), tr(&quot;&amp;Close Tab&quot;), this);
    m_closeTabAction-&gt;setShortcuts(QKeySequence::Close);
    m_closeTabAction-&gt;setIconVisibleInMenu(false);
    connect(m_closeTabAction, SIGNAL(triggered()), this, SLOT(requestCloseTab()));

    m_nextTabAction = new QAction(tr(&quot;Show Next Tab&quot;), this);
    QList&lt;QKeySequence&gt; shortcuts;
    shortcuts.append(QKeySequence(Qt::CTRL | Qt::Key_BraceRight));
    shortcuts.append(QKeySequence(Qt::CTRL | Qt::Key_PageDown));
    shortcuts.append(QKeySequence(Qt::CTRL | Qt::Key_BracketRight));
    shortcuts.append(QKeySequence(Qt::CTRL | Qt::Key_Less));
    m_nextTabAction-&gt;setShortcuts(shortcuts);
    connect(m_nextTabAction, SIGNAL(triggered()), this, SLOT(nextTab()));

    m_previousTabAction = new QAction(tr(&quot;Show Previous Tab&quot;), this);
    shortcuts.clear();
    shortcuts.append(QKeySequence(Qt::CTRL | Qt::Key_BraceLeft));
    shortcuts.append(QKeySequence(Qt::CTRL | Qt::Key_PageUp));
    shortcuts.append(QKeySequence(Qt::CTRL | Qt::Key_BracketLeft));
    shortcuts.append(QKeySequence(Qt::CTRL | Qt::Key_Greater));
    m_previousTabAction-&gt;setShortcuts(shortcuts);
    connect(m_previousTabAction, SIGNAL(triggered()), this, SLOT(previousTab()));

    m_recentlyClosedTabsMenu = new QMenu(this);
    connect(m_recentlyClosedTabsMenu, SIGNAL(aboutToShow()),
            this, SLOT(aboutToShowRecentTabsMenu()));
    connect(m_recentlyClosedTabsMenu, SIGNAL(triggered(QAction*)),
            this, SLOT(aboutToShowRecentTriggeredAction(QAction*)));
    m_recentlyClosedTabsAction = new QAction(tr(&quot;Recently Closed Tabs&quot;), this);
    m_recentlyClosedTabsAction-&gt;setMenu(m_recentlyClosedTabsMenu);
    m_recentlyClosedTabsAction-&gt;setEnabled(false);

    connect(this, SIGNAL(currentChanged(int)),
            this, SLOT(currentChanged(int)));

    m_lineEdits = new QStackedWidget(this);
}

void TabWidget::clear()
{
    // clear the recently closed tabs
    m_recentlyClosedTabs.clear();
    // clear the line edit history
    for (int i = 0; i &lt; m_lineEdits-&gt;count(); ++i) {
        QLineEdit *qLineEdit = lineEdit(i);
        qLineEdit-&gt;setText(qLineEdit-&gt;text());
    }
}

void TabWidget::moveTab(int fromIndex, int toIndex)
{
    QWidget *lineEdit = m_lineEdits-&gt;widget(fromIndex);
    m_lineEdits-&gt;removeWidget(lineEdit);
    m_lineEdits-&gt;insertWidget(toIndex, lineEdit);
}

void TabWidget::setAudioMutedForTab(int index, bool mute)
{
    if (index &lt; 0)
        index = currentIndex();
    if (index &lt; 0 || index &gt;= count())
        return;

    QWidget *widget = this-&gt;widget(index);
    if (WebView *tab = qobject_cast&lt;WebView*&gt;(widget))
        tab-&gt;page()-&gt;setAudioMuted(mute);
}

void TabWidget::addWebAction(QAction *action, QWebEnginePage::WebAction webAction)
{
    if (!action)
        return;
    m_actions.append(new WebActionMapper(action, webAction, this));
}

void TabWidget::currentChanged(int index)
{
    WebView *webView = this-&gt;webView(index);
    if (!webView)
        return;

    Q_ASSERT(m_lineEdits-&gt;count() == count());

    WebView *oldWebView = this-&gt;webView(m_lineEdits-&gt;currentIndex());
    if (oldWebView) {
#if defined(QWEBENGINEVIEW_STATUSBARMESSAGE)
        disconnect(oldWebView, SIGNAL(statusBarMessage(QString)),
                this, SIGNAL(showStatusBarMessage(QString)));
#endif
        disconnect(oldWebView-&gt;page(), SIGNAL(linkHovered(const QString&amp;)),
                this, SIGNAL(linkHovered(const QString&amp;)));
        disconnect(oldWebView, SIGNAL(loadProgress(int)),
                this, SIGNAL(loadProgress(int)));
        disconnect(oldWebView-&gt;page()-&gt;profile(), SIGNAL(downloadRequested(QWebEngineDownloadItem*)),
                this, SLOT(downloadRequested(QWebEngineDownloadItem*)));
        disconnect(oldWebView-&gt;page(), SIGNAL(fullScreenRequested(QWebEngineFullScreenRequest)),
                this, SLOT(fullScreenRequested(QWebEngineFullScreenRequest)));
    }

#if defined(QWEBENGINEVIEW_STATUSBARMESSAGE)
    connect(webView, SIGNAL(statusBarMessage(QString)),
            this, SIGNAL(showStatusBarMessage(QString)));
#endif
    connect(webView-&gt;page(), SIGNAL(linkHovered(const QString&amp;)),
            this, SIGNAL(linkHovered(const QString&amp;)));
    connect(webView, SIGNAL(loadProgress(int)),
            this, SIGNAL(loadProgress(int)));
    connect(webView-&gt;page()-&gt;profile(), SIGNAL(downloadRequested(QWebEngineDownloadItem*)),
            this, SLOT(downloadRequested(QWebEngineDownloadItem*)));
    connect(webView-&gt;page(), SIGNAL(fullScreenRequested(QWebEngineFullScreenRequest)),
            this, SLOT(fullScreenRequested(QWebEngineFullScreenRequest)));

    for (int i = 0; i &lt; m_actions.count(); ++i) {
        WebActionMapper *mapper = m_actions[i];
        mapper-&gt;updateCurrent(webView-&gt;page());
    }
    emit setCurrentTitle(webView-&gt;title());
    m_lineEdits-&gt;setCurrentIndex(index);
    emit loadProgress(webView-&gt;progress());
    emit showStatusBarMessage(webView-&gt;lastStatusBarText());
    if (webView-&gt;url().isEmpty())
        m_lineEdits-&gt;currentWidget()-&gt;setFocus();
    else
        webView-&gt;setFocus();
}

void TabWidget::fullScreenRequested(QWebEngineFullScreenRequest request)
{
    WebPage *webPage = qobject_cast&lt;WebPage*&gt;(sender());
    if (request.toggleOn()) {
        if (!m_fullScreenView) {
            m_fullScreenView = new QWebEngineView();
            m_fullScreenNotification = new FullScreenNotification(m_fullScreenView);

            QAction *exitFullScreenAction = new QAction(m_fullScreenView);
            exitFullScreenAction-&gt;setShortcut(Qt::Key_Escape);
            connect(exitFullScreenAction, &amp;QAction::triggered, [webPage] {
                webPage-&gt;triggerAction(QWebEnginePage::ExitFullScreen);
            });
            m_fullScreenView-&gt;addAction(exitFullScreenAction);
        }
        webPage-&gt;setView(m_fullScreenView);
        request.accept();
        m_fullScreenView-&gt;showFullScreen();
        m_fullScreenView-&gt;raise();
        m_fullScreenNotification-&gt;show();
    } else {
        if (!m_fullScreenView)
            return;
        WebView *oldWebView = this-&gt;webView(m_lineEdits-&gt;currentIndex());
        webPage-&gt;setView(oldWebView);
        request.accept();
        // Change the delete and window hide/show back to a simple m_fullScreenView-&gt;hide()
        // once QTBUG-46701 gets fixed.
        delete m_fullScreenView;
        m_fullScreenView = 0;
        window()-&gt;hide();
        window()-&gt;show();
    }
}

void TabWidget::handleTabBarDoubleClicked(int index)
{
    if (index != -1) return;
    newTab();
}

QAction *TabWidget::newTabAction() const
{
    return m_newTabAction;
}

QAction *TabWidget::closeTabAction() const
{
    return m_closeTabAction;
}

QAction *TabWidget::recentlyClosedTabsAction() const
{
    return m_recentlyClosedTabsAction;
}

QAction *TabWidget::nextTabAction() const
{
    return m_nextTabAction;
}

QAction *TabWidget::previousTabAction() const
{
    return m_previousTabAction;
}

QWidget *TabWidget::lineEditStack() const
{
    return m_lineEdits;
}

QLineEdit *TabWidget::currentLineEdit() const
{
    return lineEdit(m_lineEdits-&gt;currentIndex());
}

WebView *TabWidget::currentWebView() const
{
    return webView(currentIndex());
}

QLineEdit *TabWidget::lineEdit(int index) const
{
    UrlLineEdit *urlLineEdit = qobject_cast&lt;UrlLineEdit*&gt;(m_lineEdits-&gt;widget(index));
    if (urlLineEdit)
        return urlLineEdit-&gt;lineEdit();
    return 0;
}

WebView *TabWidget::webView(int index) const
{
    QWidget *widget = this-&gt;widget(index);
    if (WebView *webView = qobject_cast&lt;WebView*&gt;(widget)) {
        return webView;
    } else {
        // optimization to delay creating the first webview
        if (count() == 1) {
            TabWidget *that = const_cast&lt;TabWidget*&gt;(this);
            that-&gt;setUpdatesEnabled(false);
            that-&gt;newTab();
            that-&gt;closeTab(0);
            that-&gt;setUpdatesEnabled(true);
            return currentWebView();
        }
    }
    return 0;
}

int TabWidget::webViewIndex(WebView *webView) const
{
    int index = indexOf(webView);
    return index;
}

void TabWidget::setupPage(QWebEnginePage* page)
{
    connect(page, SIGNAL(windowCloseRequested()),
            this, SLOT(windowCloseRequested()));
    connect(page, SIGNAL(geometryChangeRequested(QRect)),
            this, SIGNAL(geometryChangeRequested(QRect)));
#if defined(QWEBENGINEPAGE_PRINTREQUESTED)
    connect(page, SIGNAL(printRequested(QWebEngineFrame*)),
            this, SIGNAL(printRequested(QWebEngineFrame*)));
#endif
#if defined(QWEBENGINEPAGE_MENUBARVISIBILITYCHANGEREQUESTED)
    connect(page, SIGNAL(menuBarVisibilityChangeRequested(bool)),
            this, SIGNAL(menuBarVisibilityChangeRequested(bool)));
#endif
#if defined(QWEBENGINEPAGE_STATUSBARVISIBILITYCHANGEREQUESTED)
    connect(page, SIGNAL(statusBarVisibilityChangeRequested(bool)),
            this, SIGNAL(statusBarVisibilityChangeRequested(bool)));
#endif
#if defined(QWEBENGINEPAGE_TOOLBARVISIBILITYCHANGEREQUESTED)
    connect(page, SIGNAL(toolBarVisibilityChangeRequested(bool)),
            this, SIGNAL(toolBarVisibilityChangeRequested(bool)));
#endif

    // webview actions
    for (int i = 0; i &lt; m_actions.count(); ++i) {
        WebActionMapper *mapper = m_actions[i];
        mapper-&gt;addChild(page-&gt;action(mapper-&gt;webAction()));
    }
}

WebView *TabWidget::newTab(bool makeCurrent)
{
    // line edit
    UrlLineEdit *urlLineEdit = new UrlLineEdit;
    QLineEdit *lineEdit = urlLineEdit-&gt;lineEdit();
    if (!m_lineEditCompleter &amp;&amp; count() &gt; 0) {
        HistoryCompletionModel *completionModel = new HistoryCompletionModel(this);
        completionModel-&gt;setSourceModel(BrowserApplication::historyManager()-&gt;historyFilterModel());
        m_lineEditCompleter = new QCompleter(completionModel, this);
        // Should this be in Qt by default?
        QAbstractItemView *popup = m_lineEditCompleter-&gt;popup();
        QListView *listView = qobject_cast&lt;QListView*&gt;(popup);
        if (listView)
            listView-&gt;setUniformItemSizes(true);
    }
    lineEdit-&gt;setCompleter(m_lineEditCompleter);
    connect(lineEdit, SIGNAL(returnPressed()), this, SLOT(lineEditReturnPressed()));
    m_lineEdits-&gt;addWidget(urlLineEdit);
    m_lineEdits-&gt;setSizePolicy(lineEdit-&gt;sizePolicy());

    // optimization to delay creating the more expensive WebView, history, etc
    if (count() == 0) {
        QWidget *emptyWidget = new QWidget;
        QPalette p = emptyWidget-&gt;palette();
        p.setColor(QPalette::Window, palette().color(QPalette::Base));
        emptyWidget-&gt;setPalette(p);
        emptyWidget-&gt;setAutoFillBackground(true);
        disconnect(this, SIGNAL(currentChanged(int)),
            this, SLOT(currentChanged(int)));
        addTab(emptyWidget, tr(&quot;(Untitled)&quot;));
        connect(this, SIGNAL(currentChanged(int)),
            this, SLOT(currentChanged(int)));
        return 0;
    }

    // webview
    WebView *webView = new WebView;
    webView-&gt;setPage(new WebPage(m_profile, webView));
    urlLineEdit-&gt;setWebView(webView);
    connect(webView, SIGNAL(loadStarted()),
            this, SLOT(webViewLoadStarted()));
    connect(webView, SIGNAL(iconChanged(QIcon)),
            this, SLOT(webViewIconChanged(QIcon)));
    connect(webView, SIGNAL(titleChanged(QString)),
            this, SLOT(webViewTitleChanged(QString)));
    connect(webView-&gt;page(), SIGNAL(audioMutedChanged(bool)),
            this, SLOT(webPageMutedOrAudibleChanged()));
    connect(webView-&gt;page(), SIGNAL(recentlyAudibleChanged(bool)),
            this, SLOT(webPageMutedOrAudibleChanged()));
    connect(webView, SIGNAL(urlChanged(QUrl)),
            this, SLOT(webViewUrlChanged(QUrl)));

    addTab(webView, tr(&quot;(Untitled)&quot;));
    if (makeCurrent)
        setCurrentWidget(webView);

    setupPage(webView-&gt;page());

    if (count() == 1)
        currentChanged(currentIndex());
    emit tabsChanged();
    return webView;
}

void TabWidget::reloadAllTabs()
{
    for (int i = 0; i &lt; count(); ++i) {
        QWidget *tabWidget = widget(i);
        if (WebView *tab = qobject_cast&lt;WebView*&gt;(tabWidget)) {
            tab-&gt;reload();
        }
    }
}

void TabWidget::lineEditReturnPressed()
{
    if (QLineEdit *lineEdit = qobject_cast&lt;QLineEdit*&gt;(sender())) {
        emit loadPage(lineEdit-&gt;text());
        if (m_lineEdits-&gt;currentWidget() == lineEdit)
            currentWebView()-&gt;setFocus();
    }
}

void TabWidget::windowCloseRequested()
{
    WebPage *webPage = qobject_cast&lt;WebPage*&gt;(sender());
    WebView *webView = qobject_cast&lt;WebView*&gt;(webPage-&gt;view());
    int index = webViewIndex(webView);
    if (index &gt;= 0)
        closeTab(index);
}

void TabWidget::closeOtherTabs(int index)
{
    if (-1 == index)
        return;
    for (int i = count() - 1; i &gt; index; --i)
        closeTab(i);
    for (int i = index - 1; i &gt;= 0; --i)
        closeTab(i);
}

// When index is -1 index chooses the current tab
void TabWidget::cloneTab(int index)
{
    if (index &lt; 0)
        index = currentIndex();
    if (index &lt; 0 || index &gt;= count())
        return;
    WebView *tab = newTab(false);
    tab-&gt;setUrl(webView(index)-&gt;url());
}

// When index is -1 index chooses the current tab
void TabWidget::requestCloseTab(int index)
{
    if (index &lt; 0)
        index = currentIndex();
    if (index &lt; 0 || index &gt;= count())
        return;
    WebView *tab = webView(index);
    if (!tab)
        return;
    tab-&gt;page()-&gt;triggerAction(QWebEnginePage::RequestClose);
}

void TabWidget::closeTab(int index)
{
    if (index &lt; 0 || index &gt;= count())
        return;

    bool hasFocus = false;
    if (WebView *tab = webView(index)) {
        hasFocus = tab-&gt;hasFocus();

        if (m_profile == QWebEngineProfile::defaultProfile()) {
            m_recentlyClosedTabsAction-&gt;setEnabled(true);
            m_recentlyClosedTabs.prepend(tab-&gt;url());
            if (m_recentlyClosedTabs.size() &gt;= TabWidget::m_recentlyClosedTabsSize)
                m_recentlyClosedTabs.removeLast();
        }
    }
    QWidget *lineEdit = m_lineEdits-&gt;widget(index);
    m_lineEdits-&gt;removeWidget(lineEdit);
    lineEdit-&gt;deleteLater();
    QWidget *webView = widget(index);
    removeTab(index);
    webView-&gt;deleteLater();
    emit tabsChanged();
    if (hasFocus &amp;&amp; count() &gt; 0)
        currentWebView()-&gt;setFocus();
    if (count() == 0)
        emit lastTabClosed();
}

void TabWidget::setProfile(QWebEngineProfile *profile)
{
    m_profile = profile;
    for (int i = 0; i &lt; count(); ++i) {
        QWidget *tabWidget = widget(i);
        if (WebView *tab = qobject_cast&lt;WebView*&gt;(tabWidget)) {
            WebPage* webPage = new WebPage(m_profile, tab);
            setupPage(webPage);
            webPage-&gt;load(tab-&gt;page()-&gt;url());
            tab-&gt;setPage(webPage);
        }
    }
}

void TabWidget::webViewLoadStarted()
{
    WebView *webView = qobject_cast&lt;WebView*&gt;(sender());
    int index = webViewIndex(webView);
    if (-1 != index) {
        QIcon icon(QLatin1String(&quot;:loading.gif&quot;));
        setTabIcon(index, icon);
    }
}

void TabWidget::webViewIconChanged(const QIcon &amp;icon)
{
    WebView *webView = qobject_cast&lt;WebView*&gt;(sender());
    int index = webViewIndex(webView);
    if (-1 != index)
        setTabIcon(index, icon);
}

void TabWidget::webViewTitleChanged(const QString &amp;title)
{
    WebView *webView = qobject_cast&lt;WebView*&gt;(sender());
    int index = webViewIndex(webView);
    if (-1 != index) {
        setTabText(index, title);
    }
    if (currentIndex() == index)
        emit setCurrentTitle(title);
    BrowserApplication::historyManager()-&gt;updateHistoryItem(webView-&gt;url(), title);
}

void TabWidget::webPageMutedOrAudibleChanged() {
    QWebEnginePage* webPage = qobject_cast&lt;QWebEnginePage*&gt;(sender());
    WebView *webView = qobject_cast&lt;WebView*&gt;(webPage-&gt;view());

    int index = webViewIndex(webView);
    if (-1 != index) {
        QString title = webView-&gt;title();

        bool muted = webPage-&gt;isAudioMuted();
        bool audible = webPage-&gt;recentlyAudible();
        if (muted) title += tr(&quot; (muted)&quot;);
        else if (audible) title += tr(&quot; (audible)&quot;);

        setTabText(index, title);
    }
}

void TabWidget::webViewUrlChanged(const QUrl &amp;url)
{
    WebView *webView = qobject_cast&lt;WebView*&gt;(sender());
    int index = webViewIndex(webView);
    if (-1 != index) {
        m_tabBar-&gt;setTabData(index, url);
        HistoryManager *manager = BrowserApplication::historyManager();
        if (url.isValid())
            manager-&gt;addHistoryEntry(url.toString());
    }
    emit tabsChanged();
}

void TabWidget::aboutToShowRecentTabsMenu()
{
    m_recentlyClosedTabsMenu-&gt;clear();
    for (int i = 0; i &lt; m_recentlyClosedTabs.count(); ++i) {
        QAction *action = new QAction(m_recentlyClosedTabsMenu);
        action-&gt;setData(m_recentlyClosedTabs.at(i));
        QIcon icon = BrowserApplication::instance()-&gt;icon(m_recentlyClosedTabs.at(i));
        action-&gt;setIcon(icon);
        action-&gt;setText(m_recentlyClosedTabs.at(i).toString());
        m_recentlyClosedTabsMenu-&gt;addAction(action);
    }
}

void TabWidget::aboutToShowRecentTriggeredAction(QAction *action)
{
    QUrl url = action-&gt;data().toUrl();
    loadUrlInCurrentTab(url);
}

void TabWidget::mouseDoubleClickEvent(QMouseEvent *event)
{
    if (!childAt(event-&gt;pos())
            // Remove the line below when QTabWidget does not have a one pixel frame
            &amp;&amp; event-&gt;pos().y() &lt; (tabBar()-&gt;y() + tabBar()-&gt;height())) {
        newTab();
        return;
    }
    QTabWidget::mouseDoubleClickEvent(event);
}

void TabWidget::contextMenuEvent(QContextMenuEvent *event)
{
    if (!childAt(event-&gt;pos())) {
        m_tabBar-&gt;contextMenuRequested(event-&gt;pos());
        return;
    }
    QTabWidget::contextMenuEvent(event);
}

void TabWidget::mouseReleaseEvent(QMouseEvent *event)
{
    if (event-&gt;button() == Qt::MidButton &amp;&amp; !childAt(event-&gt;pos())
            // Remove the line below when QTabWidget does not have a one pixel frame
            &amp;&amp; event-&gt;pos().y() &lt; (tabBar()-&gt;y() + tabBar()-&gt;height())) {
        QUrl url(QApplication::clipboard()-&gt;text(QClipboard::Selection));
        if (!url.isEmpty() &amp;&amp; url.isValid() &amp;&amp; !url.scheme().isEmpty()) {
            WebView *webView = newTab();
            webView-&gt;setUrl(url);
        }
    }
}

void TabWidget::loadUrlInCurrentTab(const QUrl &amp;url)
{
    WebView *webView = currentWebView();
    if (webView) {
        webView-&gt;loadUrl(url);
        webView-&gt;setFocus();
    }
}

void TabWidget::nextTab()
{
    int next = currentIndex() + 1;
    if (next == count())
        next = 0;
    setCurrentIndex(next);
}

void TabWidget::previousTab()
{
    int next = currentIndex() - 1;
    if (next &lt; 0)
        next = count() - 1;
    setCurrentIndex(next);
}

static const qint32 TabWidgetMagic = 0xaa;

QByteArray TabWidget::saveState() const
{
    int version = 1;
    QByteArray data;
    QDataStream stream(&amp;data, QIODevice::WriteOnly);

    stream &lt;&lt; qint32(TabWidgetMagic);
    stream &lt;&lt; qint32(version);

    QStringList tabs;
    for (int i = 0; i &lt; count(); ++i) {
        if (WebView *tab = qobject_cast&lt;WebView*&gt;(widget(i))) {
            tabs.append(tab-&gt;url().toString());
        } else {
            tabs.append(QString::null);
        }
    }
    stream &lt;&lt; tabs;
    stream &lt;&lt; currentIndex();
    return data;
}

bool TabWidget::restoreState(const QByteArray &amp;state)
{
    int version = 1;
    QByteArray sd = state;
    QDataStream stream(&amp;sd, QIODevice::ReadOnly);
    if (stream.atEnd())
        return false;

    qint32 marker;
    qint32 v;
    stream &gt;&gt; marker;
    stream &gt;&gt; v;
    if (marker != TabWidgetMagic || v != version)
        return false;

    QStringList openTabs;
    stream &gt;&gt; openTabs;

    for (int i = 0; i &lt; openTabs.count(); ++i) {
        if (i != 0)
            newTab();
        loadPage(openTabs.at(i));
    }

    int currentTab;
    stream &gt;&gt; currentTab;
    setCurrentIndex(currentTab);

    return true;
}

void TabWidget::downloadRequested(QWebEngineDownloadItem *download)
{
    if (download-&gt;savePageFormat() != QWebEngineDownloadItem::UnknownSaveFormat) {
        SavePageDialog dlg(this, download-&gt;savePageFormat(), download-&gt;path());
        if (dlg.exec() != SavePageDialog::Accepted)
            return;
        download-&gt;setSavePageFormat(dlg.pageFormat());
        download-&gt;setPath(dlg.filePath());
    }

    BrowserApplication::downloadManager()-&gt;download(download);
    download-&gt;accept();
}

WebActionMapper::WebActionMapper(QAction *root, QWebEnginePage::WebAction webAction, QObject *parent)
    : QObject(parent)
    , m_currentParent(0)
    , m_root(root)
    , m_webAction(webAction)
{
    if (!m_root)
        return;
    connect(m_root, SIGNAL(triggered()), this, SLOT(rootTriggered()));
    connect(root, SIGNAL(destroyed(QObject*)), this, SLOT(rootDestroyed()));
    root-&gt;setEnabled(false);
}

void WebActionMapper::rootDestroyed()
{
    m_root = 0;
}

void WebActionMapper::currentDestroyed()
{
    updateCurrent(0);
}

void WebActionMapper::addChild(QAction *action)
{
    if (!action)
        return;
    connect(action, SIGNAL(changed()), this, SLOT(childChanged()));
}

QWebEnginePage::WebAction WebActionMapper::webAction() const
{
    return m_webAction;
}

void WebActionMapper::rootTriggered()
{
    if (m_currentParent) {
        QAction *gotoAction = m_currentParent-&gt;action(m_webAction);
        gotoAction-&gt;trigger();
    }
}

void WebActionMapper::childChanged()
{
    if (QAction *source = qobject_cast&lt;QAction*&gt;(sender())) {
        if (m_root
            &amp;&amp; m_currentParent
            &amp;&amp; source-&gt;parent() == m_currentParent) {
            m_root-&gt;setChecked(source-&gt;isChecked());
            m_root-&gt;setEnabled(source-&gt;isEnabled());
        }
    }
}

void WebActionMapper::updateCurrent(QWebEnginePage *currentParent)
{
    if (m_currentParent)
        disconnect(m_currentParent, SIGNAL(destroyed(QObject*)),
                   this, SLOT(currentDestroyed()));

    m_currentParent = currentParent;
    if (!m_root)
        return;
    if (!m_currentParent) {
        m_root-&gt;setEnabled(false);
        m_root-&gt;setChecked(false);
        return;
    }
    QAction *source = m_currentParent-&gt;action(m_webAction);
    m_root-&gt;setChecked(source-&gt;isChecked());
    m_root-&gt;setEnabled(source-&gt;isEnabled());
    connect(m_currentParent, SIGNAL(destroyed(QObject*)),
            this, SLOT(currentDestroyed()));
}

</db:programlisting>
</db:article>
