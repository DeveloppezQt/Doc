<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en">
<db:info>
<db:title>QChronoTimer Class</db:title>
<db:productname>QtCore</db:productname>
<db:edition>Qt 6.9.1 Reference Documentation</db:edition>
<db:titleabbrev>Qt Core Reference Documentation</db:titleabbrev>
<db:abstract>
<db:para>The <db:link xlink:href="qchronotimer.xml">QChronoTimer</db:link> class provides repetitive and single-shot timers.</db:para>
<db:para>This class was introduced in Qt 6.8.</db:para>
</db:abstract>
<db:pubdate>2025-06-29</db:pubdate>
<db:date>2025-06-29</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:variablelist>
<db:varlistentry>
<db:term>Header</db:term>
<db:listitem>
<db:para>QChronoTimer</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Since</db:term>
<db:listitem>
<db:para>Qt 6.8</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>CMake</db:term>
<db:listitem>
<db:para>find_package(Qt6 REQUIRED COMPONENTS Core)</db:para>
<db:para>target_link_libraries(mytarget PRIVATE Qt6::Core)</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>qmake</db:term>
<db:listitem>
<db:para>QT += core</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Inherits</db:term>
<db:listitem>
<db:para><db:link xlink:href="qobject.xml" xlink:role="class">QObject</db:link></db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Group</db:term>
<db:listitem>
<db:para>QChronoTimer is part of <db:simplelist><db:member><db:link xlink:href="events.xml">Event Classes</db:link></db:member></db:simplelist>
</db:para>
</db:listitem>
</db:varlistentry>
</db:variablelist>
<db:section xml:id="details">
<db:title>Detailed Description</db:title>
<db:para>The <db:link xlink:href="qchronotimer.xml">QChronoTimer</db:link> class provides a high-level programming interface for timers. To use it, create a <db:link xlink:href="qchronotimer.xml">QChronoTimer</db:link>, either passing the interval to the constructor, or setting it after construction using <db:link xlink:href="qchronotimer.xml#interval-prop">setInterval</db:link>(), connect its <db:link xlink:href="qchronotimer.xml#timeout">timeout</db:link>() signal to the appropriate slots, and call <db:link xlink:href="qchronotimer.xml#start">start</db:link>(). From then on, it will emit the <db:link xlink:href="qchronotimer.xml#timeout">timeout</db:link>() signal at constant intervals. For example:</db:para>
<db:programlisting language="cpp">        QChronoTimer *timer = new QChronoTimer(1s, this);
        connect(timer, &amp;QChronoTimer::timeout, this, &amp;MyWidget::processOneThing);
        timer-&gt;start();
        QChronoTimer *timer = new QChronoTimer(this);
        connect(timer, &amp;QChronoTimer::timeout, this, &amp;MyWidget::processOneThing);
        timer-&gt;setInterval(1s);
        timer-&gt;start();
</db:programlisting>
<db:para>You can set a timer to time out only once by calling <db:link xlink:href="qchronotimer.xml#singleShot-prop">setSingleShot</db:link>(true).</db:para>
<db:note>
<db:para><db:link xlink:href="qchronotimer.xml">QChronoTimer</db:link> has no singleShot() static methods, as the ones on <db:link xlink:href="qtimer.xml">QTimer</db:link> already work with chrono types and nanoseconds resolution.</db:para>
</db:note>
<db:para>In multithreaded applications, you can use <db:link xlink:href="qchronotimer.xml">QChronoTimer</db:link> in any thread that has an event loop. To start an event loop from a non-GUI thread, use <db:link xlink:href="qthread.xml#exec">QThread::exec</db:link>(). Qt uses the timer's <db:link xlink:href="qobject.xml#thread">thread affinity</db:link> to determine which thread will emit the <db:link xlink:href="qchronotimer.xml#timeout">timeout</db:link>() signal. Because of this, you must start and stop the timer in its thread; it is not possible to start a timer from another thread.</db:para>
<db:para>As a special case, a <db:link xlink:href="qchronotimer.xml">QChronoTimer</db:link> with a timeout of 0ns will time out as soon as possible, though the ordering between zero timers and other sources of events is unspecified. Zero timers can be used to do some work while still providing a responsive user interface:</db:para>
<db:programlisting language="cpp">        // The default interval is 0ns
        QChronoTimer *timer = new QChronoTimer(this);
        connect(timer, &amp;QChronoTimer::timeout, this, &amp;MyWidget::processOneThing);
        timer-&gt;start();
</db:programlisting>
<db:para>From then on, processOneThing() will be called repeatedly. It should be written in such a way that it always returns quickly (for example, after processing one data item) so that Qt can deliver events to the user interface and stop the timer as soon as it has done all its work. This is the traditional way of implementing heavy work in GUI applications, but as multithreading is becoming available on more platforms, a modern alternative is doing the heavy work in a thread other than the GUI (main) thread. Qt has the <db:link xlink:href="qthread.xml">QThread</db:link> class, which can be used to achieve that.</db:para>
<db:section xml:id="accuracy-and-timer-resolution">
<db:title>Accuracy and Timer Resolution</db:title>
<db:para>The accuracy of timers depends on the underlying operating system and hardware. Most platforms support requesting nano-second precision for timers (for example, libc's nanosleep), though the accuracy of the timer will not equal this resolution in many real-world situations.</db:para>
<db:para>You can set the <db:link xlink:href="qt.xml#TimerType-enum">timer type</db:link> to tell <db:link xlink:href="qchronotimer.xml">QChronoTimer</db:link> which precision to request from the system.</db:para>
<db:para>For <db:link xlink:href="qt.xml#TimerType-enum">Qt::PreciseTimer</db:link>, <db:link xlink:href="qchronotimer.xml">QChronoTimer</db:link> will try to keep the precision at 1ns. Precise timers will never time out earlier than expected.</db:para>
<db:para>For <db:link xlink:href="qt.xml#TimerType-enum">Qt::CoarseTimer</db:link> and <db:link xlink:href="qt.xml#TimerType-enum">Qt::VeryCoarseTimer</db:link> types, <db:link xlink:href="qchronotimer.xml">QChronoTimer</db:link> may wake up earlier than expected, within the margins for those types:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para>5% of the interval for <db:link xlink:href="qt.xml#TimerType-enum">Qt::CoarseTimer</db:link></db:para>
</db:listitem>
<db:listitem>
<db:para>500ms for <db:link xlink:href="qt.xml#TimerType-enum">Qt::VeryCoarseTimer</db:link></db:para>
</db:listitem>
</db:itemizedlist>
<db:para>All timer types may time out later than expected if the system is busy or unable to provide the requested accuracy. In such a case of timeout overrun, Qt will emit <db:link xlink:href="qchronotimer.xml#timeout">timeout</db:link>() only once, even if multiple timeouts have expired, and then will resume the original interval.</db:para>
</db:section>
<db:section xml:id="alternatives-to-qchronotimer">
<db:title>Alternatives to QChronoTimer</db:title>
<db:para><db:link xlink:href="qchronotimer.xml">QChronoTimer</db:link> provides nanosecond resolution and a ±292 years range (less chances of integer overflow if the interval is longer than std::numeric_limits&lt;int&gt;::max()). If you only need millisecond resolution and ±24 days range, you can continue to use the classical <db:link xlink:href="qtimer.xml">QTimer</db:link> class</db:para>
<db:para>Another alternative is reimplementing the <db:link xlink:href="qobject.xml#timerEvent">QObject::timerEvent</db:link>() method in your class (which must be a sub-class of <db:link xlink:href="qobject.xml">QObject</db:link>), and using one of the following approaches:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para>Using <db:link xlink:href="qbasictimer.xml">QBasicTimer</db:link>, a lightweight value-class wrapping a timer ID. You can start the timer with <db:link xlink:href="qbasictimer.xml#start">QBasicTimer::start</db:link>() and stop it with <db:link xlink:href="qbasictimer.xml#stop">QBasicTimer::stop</db:link>(). You can handle the event in your reimplemneted <db:link xlink:href="qchronotimer.xml#timerEvent">timerEvent</db:link>().</db:para>
</db:listitem>
<db:listitem>
<db:para>A more low-level method is manipulating the timer IDs directly. To start the timer call <db:link xlink:href="qobject.xml#startTimer">QObject::startTimer</db:link>(), storing the returned ID. To stop the timer call <db:link xlink:href="qobject.xml#killTimer">QObject::killTimer</db:link>(). You can handle the event in your reimplemented <db:link xlink:href="qchronotimer.xml#timerEvent">timerEvent</db:link>(). This approach is typically more cumbersome than using <db:link xlink:href="qbasictimer.xml">QBasicTimer</db:link>.</db:para>
</db:listitem>
</db:itemizedlist>
<db:para>A disadvantage of using <db:link xlink:href="qchronotimer.xml#timerEvent">timerEvent</db:link>() is that some high-level features, such as single-shot timers and signals, aren't supported.</db:para>
<db:para>Some operating systems limit the number of timers that may be used; Qt does its best to work around these limitations.</db:para>
</db:section>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qbasictimer.xml">QBasicTimer</db:link></db:member>
<db:member><db:link xlink:href="qtimerevent.xml">QTimerEvent</db:link></db:member>
<db:member><db:link xlink:href="qobject.xml#timerEvent">QObject::timerEvent</db:link>()</db:member>
<db:member><db:link xlink:href="timers.xml">Timers</db:link></db:member>
<db:member><db:link xlink:href="">Analog Clock</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="property-documentation">
<db:title>Property Documentation</db:title>
<db:section xml:id="active-prop">
<db:title>[bindable read-only] active : bool</db:title>
<db:para>This property supports <db:link xlink:href="qproperty.xml">QProperty</db:link> bindings.</db:para>
<db:para>This boolean property is true if the timer is running; otherwise false.</db:para>
</db:section>
<db:section xml:id="interval-prop">
<db:title>[bindable] interval : std::chrono::nanoseconds</db:title>
<db:para>This property supports <db:link xlink:href="qproperty.xml">QProperty</db:link> bindings.</db:para>
<db:para>This property holds the timeout interval</db:para>
<db:para>The default value for this property is 0ns.</db:para>
<db:para>A <db:link xlink:href="qchronotimer.xml">QChronoTimer</db:link> with a timeout of 0ns will time out as soon as all the events in the window system's event queue have been processed.</db:para>
<db:para>Setting the interval of a running timer will change the interval, <db:link xlink:href="qchronotimer.xml#stop">stop</db:link>() and then <db:link xlink:href="qchronotimer.xml#start">start</db:link>() the timer, and acquire a new <db:link xlink:href="qchronotimer.xml#id">id</db:link>(). If the timer is not running, only the interval is changed.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qchronotimer.xml#singleShot-prop">singleShot</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="remainingTime-prop">
<db:title>[read-only] remainingTime : const std::chrono::nanoseconds</db:title>
<db:para>This property holds the remaining time</db:para>
<db:para>Returns the remaining duration until the timeout.</db:para>
<db:para>If the timer is inactive, the returned duration will be negative.</db:para>
<db:para>If the timer is overdue, the returned duration will be 0ns.</db:para>
<db:para>
<db:emphasis role="bold">Access functions:
</db:emphasis>
</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:type>std::chrono::nanoseconds</db:type> <db:emphasis role="bold">remainingTime</db:emphasis>() const</db:para>
</db:listitem>
</db:itemizedlist>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qchronotimer.xml#interval-prop">interval</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="singleShot-prop">
<db:title>[bindable] singleShot : bool</db:title>
<db:para>This property supports <db:link xlink:href="qproperty.xml">QProperty</db:link> bindings.</db:para>
<db:para>This property holds whether the timer is a single-shot timer</db:para>
<db:para>A single-shot timer fires only once, non-single-shot timers fire every <db:link xlink:href="qchronotimer.xml#interval-prop">interval</db:link>.</db:para>
<db:para>The default value for this property is false.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qchronotimer.xml#interval-prop">interval</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="timerType-prop">
<db:title>[bindable] timerType : Qt::TimerType</db:title>
<db:para>This property supports <db:link xlink:href="qproperty.xml">QProperty</db:link> bindings.</db:para>
<db:para>Controls the accuracy of the timer</db:para>
<db:para>The default value for this property is Qt::CoarseTimer.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qt.xml#TimerType-enum">Qt::TimerType</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
</db:section>
<db:section xml:id="member-function-documentation">
<db:title>Member Function Documentation</db:title>
<db:section xml:id="QChronoTimer">
<db:title>[explicit] QChronoTimer::QChronoTimer(QObject *<db:emphasis>parent</db:emphasis> = nullptr)</db:title>
<db:para>Constructs a timer with the given <db:code role="parameter">parent</db:code>, using the default interval, 0ns.</db:para>
</db:section>
<db:section xml:id="QChronoTimer-1">
<db:title>[explicit] QChronoTimer::QChronoTimer(std::chrono::nanoseconds <db:emphasis>nsec</db:emphasis>, QObject *<db:emphasis>parent</db:emphasis> = nullptr)</db:title>
<db:para>Constructs a timer with the given <db:code role="parameter">parent</db:code>, using an interval of <db:code role="parameter">nsec</db:code>.</db:para>
</db:section>
<db:section xml:id="dtor.QChronoTimer">
<db:title>[override virtual noexcept] QChronoTimer::~QChronoTimer()</db:title>
<db:para>Destroys the timer.</db:para>
</db:section>
<db:section xml:id="callOnTimeout">
<db:title>QMetaObject::Connection QChronoTimer::callOnTimeout(const QObject *<db:emphasis>context</db:emphasis>, Functor &amp;&amp;<db:emphasis>slot</db:emphasis>, Qt::ConnectionType <db:emphasis>connectionType</db:emphasis> = Qt::AutoConnection)</db:title>
<db:para>This function overloads callOnTimeout().</db:para>
<db:para>Creates a connection from the <db:link xlink:href="qchronotimer.xml#timeout">timeout</db:link>() signal to <db:code role="parameter">slot</db:code> to be placed in a specific event loop of <db:code role="parameter">context</db:code>, with connection type <db:code role="parameter">connectionType</db:code>, and returns a handle to the connection.</db:para>
<db:para>This method is provided as a convenience. It's equivalent to calling:</db:para>
<db:programlisting language="cpp">QObject::connect(timer, &amp;QChronoTimer::timeout, context, slot, connectionType);
</db:programlisting>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qobject.xml#connect">QObject::connect</db:link>()</db:member>
<db:member><db:link xlink:href="qchronotimer.xml#timeout">timeout</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="id">
<db:title>Qt::TimerId QChronoTimer::id() const</db:title>
<db:para>Returns a <db:link xlink:href="qobject.xml#TimerId-enum">Qt::TimerId</db:link> representing the timer ID if the timer is running; otherwise returns Qt::TimerId::Invalid.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qobject.xml#TimerId-enum">Qt::TimerId</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="isActive">
<db:title>bool QChronoTimer::isActive() const</db:title>
<db:para>Returns true if the timer is running; otherwise returns false.</db:para>
<db:note>
<db:para>Getter function for property <db:link xlink:href="qchronotimer.xml#active-prop">active</db:link>. </db:para>
</db:note>
</db:section>
<db:section xml:id="start">
<db:title>void QChronoTimer::start()</db:title>
<db:para>This function overloads start().</db:para>
<db:para>Starts or restarts the timer with the timeout specified in <db:link xlink:href="qchronotimer.xml#interval-prop">interval</db:link>.</db:para>
<db:para>If the timer is already running, it will be <db:link xlink:href="qchronotimer.xml#stop">stopped</db:link> and restarted. This will also change its <db:link xlink:href="qchronotimer.xml#id">id</db:link>().</db:para>
<db:para>If <db:link xlink:href="qchronotimer.xml#singleShot-prop">singleShot</db:link> is true, the timer will be activated only once.</db:para>
</db:section>
<db:section xml:id="stop">
<db:title>void QChronoTimer::stop()</db:title>
<db:para>Stops the timer.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qchronotimer.xml#start">start</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="timeout">
<db:title>void QChronoTimer::timeout()</db:title>
<db:para>This signal is emitted when the timer times out.</db:para>
<db:note>
<db:para>This is a private signal. It can be used in signal connections but cannot be emitted by the user.</db:para></db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qchronotimer.xml#interval-prop">interval</db:link></db:member>
<db:member><db:link xlink:href="qchronotimer.xml#start">start</db:link>()</db:member>
<db:member><db:link xlink:href="qchronotimer.xml#stop">stop</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="timerEvent">
<db:title>[override virtual protected] void QChronoTimer::timerEvent(QTimerEvent *<db:emphasis>e</db:emphasis>)</db:title>
<db:para>Reimplements: <db:link xlink:href="qobject.xml#timerEvent" role="function">QObject::timerEvent(QTimerEvent *event)</db:link>.</db:para>
</db:section>
</db:section>
</db:article>
