<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en">
<db:info>
<db:title>QThread Class</db:title>
<db:productname>QtCore</db:productname>
<db:edition>Qt 5.8.0 Reference Documentation</db:edition>
<db:titleabbrev>Qt Core Reference Documentation</db:titleabbrev>
<db:abstract>
<db:para>The <db:link xlink:href="qthread.xml">QThread</db:link> class provides a platform-independent way to manage threads.</db:para>
</db:abstract>
<db:pubdate>2025-06-29</db:pubdate>
<db:date>2025-06-29</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:variablelist>
<db:varlistentry>
<db:term>Header</db:term>
<db:listitem>
<db:para>QThread</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>qmake</db:term>
<db:listitem>
<db:para>QT += core</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Inherits</db:term>
<db:listitem>
<db:para><db:link xlink:href="qobject.xml" xlink:role="class">QObject</db:link></db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Inherited By</db:term>
<db:listitem>
<db:para/>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Group</db:term>
<db:listitem>
<db:para>QThread is part of <db:simplelist><db:member>thread</db:member></db:simplelist>
</db:para>
</db:listitem>
</db:varlistentry>
</db:variablelist>
<db:section xml:id="details">
<db:title>Detailed Description</db:title>
<db:para>A <db:link xlink:href="qthread.xml">QThread</db:link> object manages one thread of control within the program. QThreads begin executing in <db:link xlink:href="qthread.xml#run">run</db:link>(). By default, <db:link xlink:href="qthread.xml#run">run</db:link>() starts the event loop by calling <db:link xlink:href="qthread.xml#exec">exec</db:link>() and runs a Qt event loop inside the thread.</db:para>
<db:para>You can use worker objects by moving them to the thread using <db:link xlink:href="qobject.xml#moveToThread">QObject::moveToThread</db:link>().</db:para>
<db:programlisting language="cpp">class Worker : public QObject
{
    Q_OBJECT

public slots:
    void doWork(const QString &amp;parameter) {
        QString result;
        /* ... here is the expensive or blocking operation ... */
        emit resultReady(result);
    }

signals:
    void resultReady(const QString &amp;result);
};

class Controller : public QObject
{
    Q_OBJECT
    QThread workerThread;
public:
    Controller() {
        Worker *worker = new Worker;
        worker-&gt;moveToThread(&amp;workerThread);
        connect(&amp;workerThread, &amp;QThread::finished, worker, &amp;QObject::deleteLater);
        connect(this, &amp;Controller::operate, worker, &amp;Worker::doWork);
        connect(worker, &amp;Worker::resultReady, this, &amp;Controller::handleResults);
        workerThread.start();
    }
    ~Controller() {
        workerThread.quit();
        workerThread.wait();
    }
public slots:
    void handleResults(const QString &amp;);
signals:
    void operate(const QString &amp;);
};
</db:programlisting>
<db:para>The code inside the Worker's slot would then execute in a separate thread. However, you are free to connect the Worker's slots to any signal, from any object, in any thread. It is safe to connect signals and slots across different threads, thanks to a mechanism called <db:link xlink:href="qt.xml#ConnectionType-enum">queued connections</db:link>.</db:para>
<db:para>Another way to make code run in a separate thread, is to subclass <db:link xlink:href="qthread.xml">QThread</db:link> and reimplement <db:link xlink:href="qthread.xml#run">run</db:link>(). For example:</db:para>
<db:programlisting language="cpp">class WorkerThread : public QThread
{
    Q_OBJECT
    void run() Q_DECL_OVERRIDE {
        QString result;
        /* ... here is the expensive or blocking operation ... */
        emit resultReady(result);
    }
signals:
    void resultReady(const QString &amp;s);
};

void MyObject::startWorkInAThread()
{
    WorkerThread *workerThread = new WorkerThread(this);
    connect(workerThread, &amp;WorkerThread::resultReady, this, &amp;MyObject::handleResults);
    connect(workerThread, &amp;WorkerThread::finished, workerThread, &amp;QObject::deleteLater);
    workerThread-&gt;start();
}
</db:programlisting>
<db:para>In that example, the thread will exit after the run function has returned. There will not be any event loop running in the thread unless you call <db:link xlink:href="qthread.xml#exec">exec</db:link>().</db:para>
<db:para>It is important to remember that a <db:link xlink:href="qthread.xml">QThread</db:link> instance <db:link xlink:href="qobject.xml#thread-affinity">lives in</db:link> the old thread that instantiated it, not in the new thread that calls <db:link xlink:href="qthread.xml#run">run</db:link>(). This means that all of <db:link xlink:href="qthread.xml">QThread</db:link>'s queued slots will execute in the old thread. Thus, a developer who wishes to invoke slots in the new thread must use the worker-object approach; new slots should not be implemented directly into a subclassed <db:link xlink:href="qthread.xml">QThread</db:link>.</db:para>
<db:para>When subclassing <db:link xlink:href="qthread.xml">QThread</db:link>, keep in mind that the constructor executes in the old thread while <db:link xlink:href="qthread.xml#run">run</db:link>() executes in the new thread. If a member variable is accessed from both functions, then the variable is accessed from two different threads. Check that it is safe to do so.</db:para>
<db:note>
<db:para>Care must be taken when interacting with objects across different threads. See <db:link xlink:href="threads-synchronizing.xml">Synchronizing Threads</db:link> for details.</db:para>
</db:note>
<db:section xml:id="managing-threads">
<db:title>Managing Threads</db:title>
<db:para><db:link xlink:href="qthread.xml">QThread</db:link> will notifiy you via a signal when the thread is <db:link xlink:href="qthread.xml#started">started</db:link>() and <db:link xlink:href="qthread.xml#finished">finished</db:link>(), or you can use <db:link xlink:href="qthread.xml#isFinished">isFinished</db:link>() and <db:link xlink:href="qthread.xml#isRunning">isRunning</db:link>() to query the state of the thread.</db:para>
<db:para>You can stop the thread by calling <db:link xlink:href="qthread.xml#exit">exit</db:link>() or <db:link xlink:href="qthread.xml#quit">quit</db:link>(). In extreme cases, you may want to forcibly <db:link xlink:href="qthread.xml#terminate">terminate</db:link>() an executing thread. However, doing so is dangerous and discouraged. Please read the documentation for <db:link xlink:href="qthread.xml#terminate">terminate</db:link>() and <db:link xlink:href="qthread.xml#setTerminationEnabled">setTerminationEnabled</db:link>() for detailed information.</db:para>
<db:para>From Qt 4.8 onwards, it is possible to deallocate objects that live in a thread that has just ended, by connecting the <db:link xlink:href="qthread.xml#finished">finished</db:link>() signal to <db:link xlink:href="qobject.xml#deleteLater">QObject::deleteLater</db:link>().</db:para>
<db:para>Use <db:link xlink:href="qthread.xml#wait">wait</db:link>() to block the calling thread, until the other thread has finished execution (or until a specified time has passed).</db:para>
<db:para><db:link xlink:href="qthread.xml">QThread</db:link> also provides static, platform independent sleep functions: <db:link xlink:href="qthread.xml#sleep">sleep</db:link>(), <db:link xlink:href="qthread.xml#msleep">msleep</db:link>(), and <db:link xlink:href="qthread.xml#usleep">usleep</db:link>() allow full second, millisecond, and microsecond resolution respectively. These functions were made public in Qt 5.0.</db:para>
<db:note>
<db:para><db:link xlink:href="qthread.xml#wait">wait</db:link>() and the <db:link xlink:href="qthread.xml#sleep">sleep</db:link>() functions should be unnecessary in general, since Qt is an event-driven framework. Instead of <db:link xlink:href="qthread.xml#wait">wait</db:link>(), consider listening for the <db:link xlink:href="qthread.xml#finished">finished</db:link>() signal. Instead of the <db:link xlink:href="qthread.xml#sleep">sleep</db:link>() functions, consider using <db:link xlink:href="qtimer.xml">QTimer</db:link>.</db:para>
</db:note>
<db:para>The static functions <db:link xlink:href="qthread.xml#currentThreadId">currentThreadId</db:link>() and <db:link xlink:href="qthread.xml#currentThread">currentThread</db:link>() return identifiers for the currently executing thread. The former returns a platform specific ID for the thread; the latter returns a <db:link xlink:href="qthread.xml">QThread</db:link> pointer.</db:para>
<db:para>To choose the name that your thread will be given (as identified by the command ps -L on Linux, for example), you can call <db:link xlink:href="qobject.xml#objectName-prop">setObjectName</db:link>() before starting the thread. If you don't call <db:link xlink:href="qobject.xml#objectName-prop">setObjectName</db:link>(), the name given to your thread will be the class name of the runtime type of your thread object (for example, &quot;RenderThread&quot; in the case of the <db:link xlink:href="qtcore-threads-mandelbrot-example.xml">Mandelbrot Example</db:link>, as that is the name of the <db:link xlink:href="qthread.xml">QThread</db:link> subclass). Note that this is currently not available with release builds on Windows.</db:para>
</db:section>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="threads.xml">Thread Support in Qt</db:link></db:member>
<db:member><db:link xlink:href="qthreadstorage.xml">QThreadStorage</db:link></db:member>
<db:member><db:link xlink:href="threads-synchronizing.xml">Synchronizing Threads</db:link></db:member>
<db:member><db:link xlink:href="qtcore-threads-mandelbrot-example.xml">Mandelbrot Example</db:link></db:member>
<db:member><db:link xlink:href="qtcore-threads-semaphores-example.xml">Semaphores Example</db:link></db:member>
<db:member><db:link xlink:href="qtcore-threads-waitconditions-example.xml">Wait Conditions Example</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="member-type-documentation">
<db:title>Member Type Documentation</db:title>
<db:section xml:id="Priority-enum">
<db:title>enum QThread::Priority</db:title>
<db:para>This enum type indicates how the operating system should schedule newly created threads.</db:para>
<db:informaltable>
<db:thead>
<db:tr>
<db:th>Constant</db:th>
<db:th>Value</db:th>
<db:th>Description</db:th>
</db:tr>
</db:thead>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qthread.xml">QThread</db:link></db:emphasis>::IdlePriority</db:code></db:para>
</db:td>
<db:td><db:code>0</db:code></db:td>
<db:td>
<db:para>scheduled only when no other threads are running.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qthread.xml">QThread</db:link></db:emphasis>::LowestPriority</db:code></db:para>
</db:td>
<db:td><db:code>1</db:code></db:td>
<db:td>
<db:para>scheduled less often than LowPriority.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qthread.xml">QThread</db:link></db:emphasis>::LowPriority</db:code></db:para>
</db:td>
<db:td><db:code>2</db:code></db:td>
<db:td>
<db:para>scheduled less often than NormalPriority.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qthread.xml">QThread</db:link></db:emphasis>::NormalPriority</db:code></db:para>
</db:td>
<db:td><db:code>3</db:code></db:td>
<db:td>
<db:para>the default priority of the operating system.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qthread.xml">QThread</db:link></db:emphasis>::HighPriority</db:code></db:para>
</db:td>
<db:td><db:code>4</db:code></db:td>
<db:td>
<db:para>scheduled more often than NormalPriority.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qthread.xml">QThread</db:link></db:emphasis>::HighestPriority</db:code></db:para>
</db:td>
<db:td><db:code>5</db:code></db:td>
<db:td>
<db:para>scheduled more often than HighPriority.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qthread.xml">QThread</db:link></db:emphasis>::TimeCriticalPriority</db:code></db:para>
</db:td>
<db:td><db:code>6</db:code></db:td>
<db:td>
<db:para>scheduled as often as possible.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qthread.xml">QThread</db:link></db:emphasis>::InheritPriority</db:code></db:para>
</db:td>
<db:td><db:code>7</db:code></db:td>
<db:td>
<db:para>use the same priority as the creating thread. This is the default.</db:para>
</db:td>
</db:tr>
</db:informaltable>
</db:section>
</db:section>
<db:section xml:id="member-function-documentation">
<db:title>Member Function Documentation</db:title>
<db:section xml:id="QThread">
<db:title>[explicit] QThread::QThread(QObject *<db:emphasis>parent</db:emphasis> = Q_NULLPTR)</db:title>
<db:para>Constructs a new <db:link xlink:href="qthread.xml">QThread</db:link> to manage a new thread. The <db:code role="parameter">parent</db:code> takes ownership of the <db:link xlink:href="qthread.xml">QThread</db:link>. The thread does not begin executing until <db:link xlink:href="qthread.xml#start">start</db:link>() is called.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qthread.xml#start">start</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="dtor.QThread">
<db:title>[virtual noexcept] QThread::~QThread()</db:title>
<db:para>Destroys the <db:link xlink:href="qthread.xml">QThread</db:link>.</db:para>
<db:para>Note that deleting a <db:link xlink:href="qthread.xml">QThread</db:link> object will not stop the execution of the thread it manages. Deleting a running <db:link xlink:href="qthread.xml">QThread</db:link> (i.e. <db:link xlink:href="qthread.xml#isFinished">isFinished</db:link>() returns false) will result in a program crash. Wait for the <db:link xlink:href="qthread.xml#finished">finished</db:link>() signal before deleting the <db:link xlink:href="qthread.xml">QThread</db:link>.</db:para>
</db:section>
<db:section xml:id="currentThread">
<db:title>[static] QThread *QThread::currentThread()</db:title>
<db:para>Returns a pointer to a <db:link xlink:href="qthread.xml">QThread</db:link> which manages the currently executing thread.</db:para>
</db:section>
<db:section xml:id="currentThreadId">
<db:title>[static noexcept] Qt::HANDLE QThread::currentThreadId()</db:title>
<db:para>Returns the thread handle of the currently executing thread.</db:para>
<db:warning>
<db:para>The handle returned by this function is used for internal purposes and should not be used in any application code.</db:para>
</db:warning>
<db:warning>
<db:para>On Windows, the returned value is a pseudo-handle for the current thread. It can't be used for numerical comparison. i.e., this function returns the DWORD (Windows-Thread ID) returned by the Win32 function getCurrentThreadId(), not the HANDLE (Windows-Thread HANDLE) returned by the Win32 function getCurrentThread().</db:para>
</db:warning>
</db:section>
<db:section xml:id="event">
<db:title>[override virtual] bool QThread::event(QEvent *<db:emphasis>event</db:emphasis>)</db:title>
<db:para>Reimplements: <db:link xlink:href="qobject.xml#event" role="function">QObject::event(QEvent *e)</db:link>.</db:para>
</db:section>
<db:section xml:id="eventDispatcher">
<db:title>[since 5.0] QAbstractEventDispatcher *QThread::eventDispatcher() const</db:title>
<db:para>Returns a pointer to the event dispatcher object for the thread. If no event dispatcher exists for the thread, this function returns 0.</db:para>
<db:para>This function was introduced in Qt 5.0.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qthread.xml#setEventDispatcher">setEventDispatcher</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="exec">
<db:title>[protected] int QThread::exec()</db:title>
<db:para>Enters the event loop and waits until <db:link xlink:href="qthread.xml#exit">exit</db:link>() is called, returning the value that was passed to <db:link xlink:href="qthread.xml#exit">exit</db:link>(). The value returned is 0 if <db:link xlink:href="qthread.xml#exit">exit</db:link>() is called via <db:link xlink:href="qthread.xml#quit">quit</db:link>().</db:para>
<db:para>This function is meant to be called from within <db:link xlink:href="qthread.xml#run">run</db:link>(). It is necessary to call this function to start event handling.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qthread.xml#quit">quit</db:link>()</db:member>
<db:member><db:link xlink:href="qthread.xml#exit">exit</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="exit">
<db:title>void QThread::exit(int <db:emphasis>returnCode</db:emphasis> = 0)</db:title>
<db:para>Tells the thread's event loop to exit with a return code.</db:para>
<db:para>After calling this function, the thread leaves the event loop and returns from the call to <db:link xlink:href="qeventloop.xml#exec">QEventLoop::exec</db:link>(). The <db:link xlink:href="qeventloop.xml#exec">QEventLoop::exec</db:link>() function returns <db:code role="parameter">returnCode</db:code>.</db:para>
<db:para>By convention, a <db:code role="parameter">returnCode</db:code> of 0 means success, any non-zero value indicates an error.</db:para>
<db:para>Note that unlike the C library function of the same name, this function <db:emphasis>does</db:emphasis> return to the caller – it is event processing that stops.</db:para>
<db:para>No QEventLoops will be started anymore in this thread until <db:link xlink:href="qthread.xml#exec">QThread::exec</db:link>() has been called again. If the eventloop in <db:link xlink:href="qthread.xml#exec">QThread::exec</db:link>() is not running then the next call to <db:link xlink:href="qthread.xml#exec">QThread::exec</db:link>() will also return immediately.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qthread.xml#quit">quit</db:link>()</db:member>
<db:member><db:link xlink:href="qeventloop.xml">QEventLoop</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="finished">
<db:title>void QThread::finished()</db:title>
<db:para>This signal is emitted from the associated thread right before it finishes executing.</db:para>
<db:para>When this signal is emitted, the event loop has already stopped running. No more events will be processed in the thread, except for deferred deletion events. This signal can be connected to <db:link xlink:href="qobject.xml#deleteLater">QObject::deleteLater</db:link>(), to free objects in that thread.</db:para>
<db:note>
<db:para>If the associated thread was terminated using <db:link xlink:href="qthread.xml#terminate">terminate</db:link>(), it is undefined from which thread this signal is emitted.</db:para>
</db:note>
<db:note>
<db:para>This is a private signal. It can be used in signal connections but cannot be emitted by the user.</db:para></db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qthread.xml#started">started</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="idealThreadCount">
<db:title>[static noexcept] int QThread::idealThreadCount()</db:title>
<db:para>Returns the ideal number of threads that can be run on the system. This is done querying the number of processor cores, both real and logical, in the system. This function returns -1 if the number of processor cores could not be detected.</db:para>
</db:section>
<db:section xml:id="isFinished">
<db:title>bool QThread::isFinished() const</db:title>
<db:para>Returns true if the thread is finished; otherwise returns false.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qthread.xml#isRunning">isRunning</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="isInterruptionRequested">
<db:title>[since 5.2] bool QThread::isInterruptionRequested() const</db:title>
<db:para>Return true if the task running on this thread should be stopped. An interruption can be requested by <db:link xlink:href="qthread.xml#requestInterruption">requestInterruption</db:link>().</db:para>
<db:para>This function can be used to make long running tasks cleanly interruptible. Never checking or acting on the value returned by this function is safe, however it is advisable do so regularly in long running functions. Take care not to call it too often, to keep the overhead low.</db:para>
<db:programlisting language="cpp">void long_task() {
     forever {
        if ( QThread::currentThread()-&gt;isInterruptionRequested() ) {
            return;
        }
    }
}
</db:programlisting>
<db:para>This function was introduced in Qt 5.2.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qthread.xml#currentThread">currentThread</db:link>()</db:member>
<db:member><db:link xlink:href="qthread.xml#requestInterruption">requestInterruption</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="isRunning">
<db:title>bool QThread::isRunning() const</db:title>
<db:para>Returns true if the thread is running; otherwise returns false.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qthread.xml#isFinished">isFinished</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="loopLevel">
<db:title>[since 5.5] int QThread::loopLevel() const</db:title>
<db:para>Returns the current event loop level for the thread.</db:para>
<db:note>
<db:para>This can only be called within the thread itself, i.e. when it is the current thread.</db:para>
</db:note>
<db:para>This function was introduced in Qt 5.5.</db:para>
</db:section>
<db:section xml:id="msleep">
<db:title>[static] void QThread::msleep(unsigned long <db:emphasis>msecs</db:emphasis>)</db:title>
<db:para>Forces the current thread to sleep for <db:code role="parameter">msecs</db:code> milliseconds.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qthread.xml#sleep">sleep</db:link>()</db:member>
<db:member><db:link xlink:href="qthread.xml#usleep">usleep</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="priority">
<db:title>[since 4.1] QThread::Priority QThread::priority() const</db:title>
<db:para>Returns the priority for a running thread. If the thread is not running, this function returns InheritPriority.</db:para>
<db:para>This function was introduced in Qt 4.1.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qthread.xml#Priority-enum">Priority</db:link></db:member>
<db:member><db:link xlink:href="qthread.xml#setPriority">setPriority</db:link>()</db:member>
<db:member><db:link xlink:href="qthread.xml#start">start</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="quit">
<db:title>void QThread::quit()</db:title>
<db:para>Tells the thread's event loop to exit with return code 0 (success). Equivalent to calling <db:link xlink:href="qthread.xml#exit">QThread::exit</db:link>(0).</db:para>
<db:para>This function does nothing if the thread does not have an event loop.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qthread.xml#exit">exit</db:link>()</db:member>
<db:member><db:link xlink:href="qeventloop.xml">QEventLoop</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="requestInterruption">
<db:title>[since 5.2] void QThread::requestInterruption()</db:title>
<db:para>Request the interruption of the thread. That request is advisory and it is up to code running on the thread to decide if and how it should act upon such request. This function does not stop any event loop running on the thread and does not terminate it in any way.</db:para>
<db:para>This function was introduced in Qt 5.2.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qthread.xml#isInterruptionRequested">isInterruptionRequested</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="run">
<db:title>[virtual protected] void QThread::run()</db:title>
<db:para>The starting point for the thread. After calling <db:link xlink:href="qthread.xml#start">start</db:link>(), the newly created thread calls this function. The default implementation simply calls <db:link xlink:href="qthread.xml#exec">exec</db:link>().</db:para>
<db:para>You can reimplement this function to facilitate advanced thread management. Returning from this method will end the execution of the thread.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qthread.xml#start">start</db:link>()</db:member>
<db:member><db:link xlink:href="qthread.xml#wait">wait</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setEventDispatcher">
<db:title>[since 5.0] void QThread::setEventDispatcher(QAbstractEventDispatcher *<db:emphasis>eventDispatcher</db:emphasis>)</db:title>
<db:para>Sets the event dispatcher for the thread to <db:code role="parameter">eventDispatcher</db:code>. This is only possible as long as there is no event dispatcher installed for the thread yet. That is, before the thread has been started with <db:link xlink:href="qthread.xml#start">start</db:link>() or, in case of the main thread, before <db:link xlink:href="qcoreapplication.xml">QCoreApplication</db:link> has been instantiated. This method takes ownership of the object.</db:para>
<db:para>This function was introduced in Qt 5.0.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qthread.xml#eventDispatcher">eventDispatcher</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setPriority">
<db:title>[since 4.1] void QThread::setPriority(QThread::Priority <db:emphasis>priority</db:emphasis>)</db:title>
<db:para>This function sets the <db:code role="parameter">priority</db:code> for a running thread. If the thread is not running, this function does nothing and returns immediately. Use <db:link xlink:href="qthread.xml#start">start</db:link>() to start a thread with a specific priority.</db:para>
<db:para>The <db:code role="parameter">priority</db:code> argument can be any value in the QThread::Priority enum except for InheritPriorty.</db:para>
<db:para>The effect of the <db:code role="parameter">priority</db:code> parameter is dependent on the operating system's scheduling policy. In particular, the <db:code role="parameter">priority</db:code> will be ignored on systems that do not support thread priorities (such as on Linux, see http://linux.die.net/man/2/sched_setscheduler for more details).</db:para>
<db:para>This function was introduced in Qt 4.1.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qthread.xml#Priority-enum">Priority</db:link></db:member>
<db:member><db:link xlink:href="qthread.xml#priority">priority</db:link>()</db:member>
<db:member><db:link xlink:href="qthread.xml#start">start</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setStackSize">
<db:title>void QThread::setStackSize(uint <db:emphasis>stackSize</db:emphasis>)</db:title>
<db:para>Sets the maximum stack size for the thread to <db:code role="parameter">stackSize</db:code>. If <db:code role="parameter">stackSize</db:code> is greater than zero, the maximum stack size is set to <db:code role="parameter">stackSize</db:code> bytes, otherwise the maximum stack size is automatically determined by the operating system.</db:para>
<db:warning>
<db:para>Most operating systems place minimum and maximum limits on thread stack sizes. The thread will fail to start if the stack size is outside these limits.</db:para>
</db:warning>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qthread.xml#stackSize">stackSize</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setTerminationEnabled">
<db:title>[static protected] void QThread::setTerminationEnabled(bool <db:emphasis>enabled</db:emphasis> = true)</db:title>
<db:para>Enables or disables termination of the current thread based on the <db:code role="parameter">enabled</db:code> parameter. The thread must have been started by <db:link xlink:href="qthread.xml">QThread</db:link>.</db:para>
<db:para>When <db:code role="parameter">enabled</db:code> is false, termination is disabled. Future calls to <db:link xlink:href="qthread.xml#terminate">QThread::terminate</db:link>() will return immediately without effect. Instead, the termination is deferred until termination is enabled.</db:para>
<db:para>When <db:code role="parameter">enabled</db:code> is true, termination is enabled. Future calls to <db:link xlink:href="qthread.xml#terminate">QThread::terminate</db:link>() will terminate the thread normally. If termination has been deferred (i.e. <db:link xlink:href="qthread.xml#terminate">QThread::terminate</db:link>() was called with termination disabled), this function will terminate the calling thread <db:emphasis>immediately</db:emphasis>. Note that this function will not return in this case.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qthread.xml#terminate">terminate</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="sleep">
<db:title>[static] void QThread::sleep(unsigned long <db:emphasis>secs</db:emphasis>)</db:title>
<db:para>Forces the current thread to sleep for <db:code role="parameter">secs</db:code> seconds.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qthread.xml#msleep">msleep</db:link>()</db:member>
<db:member><db:link xlink:href="qthread.xml#usleep">usleep</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="stackSize">
<db:title>uint QThread::stackSize() const</db:title>
<db:para>Returns the maximum stack size for the thread (if set with <db:link xlink:href="qthread.xml#setStackSize">setStackSize</db:link>()); otherwise returns zero.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qthread.xml#setStackSize">setStackSize</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="start">
<db:title>void QThread::start(QThread::Priority <db:emphasis>priority</db:emphasis> = InheritPriority)</db:title>
<db:para>Begins execution of the thread by calling <db:link xlink:href="qthread.xml#run">run</db:link>(). The operating system will schedule the thread according to the <db:code role="parameter">priority</db:code> parameter. If the thread is already running, this function does nothing.</db:para>
<db:para>The effect of the <db:code role="parameter">priority</db:code> parameter is dependent on the operating system's scheduling policy. In particular, the <db:code role="parameter">priority</db:code> will be ignored on systems that do not support thread priorities (such as on Linux, see the <db:link xlink:href="http://linux.die.net/man/2/sched_setscheduler">sched_setscheduler</db:link> documentation for more details).</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qthread.xml#run">run</db:link>()</db:member>
<db:member><db:link xlink:href="qthread.xml#terminate">terminate</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="started">
<db:title>void QThread::started()</db:title>
<db:para>This signal is emitted from the associated thread when it starts executing, before the <db:link xlink:href="qthread.xml#run">run</db:link>() function is called.</db:para>
<db:note>
<db:para>This is a private signal. It can be used in signal connections but cannot be emitted by the user.</db:para></db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qthread.xml#finished">finished</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="terminate">
<db:title>void QThread::terminate()</db:title>
<db:para>Terminates the execution of the thread. The thread may or may not be terminated immediately, depending on the operating system's scheduling policies. Use <db:link xlink:href="qthread.xml#wait">QThread::wait</db:link>() after terminate(), to be sure.</db:para>
<db:para>When the thread is terminated, all threads waiting for the thread to finish will be woken up.</db:para>
<db:warning>
<db:para>This function is dangerous and its use is discouraged. The thread can be terminated at any point in its code path. Threads can be terminated while modifying data. There is no chance for the thread to clean up after itself, unlock any held mutexes, etc. In short, use this function only if absolutely necessary.</db:para>
</db:warning>
<db:para>Termination can be explicitly enabled or disabled by calling <db:link xlink:href="qthread.xml#setTerminationEnabled">QThread::setTerminationEnabled</db:link>(). Calling this function while termination is disabled results in the termination being deferred, until termination is re-enabled. See the documentation of <db:link xlink:href="qthread.xml#setTerminationEnabled">QThread::setTerminationEnabled</db:link>() for more information.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qthread.xml#setTerminationEnabled">setTerminationEnabled</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="usleep">
<db:title>[static] void QThread::usleep(unsigned long <db:emphasis>usecs</db:emphasis>)</db:title>
<db:para>Forces the current thread to sleep for <db:code role="parameter">usecs</db:code> microseconds.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qthread.xml#sleep">sleep</db:link>()</db:member>
<db:member><db:link xlink:href="qthread.xml#msleep">msleep</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="wait">
<db:title>bool QThread::wait(unsigned long <db:emphasis>time</db:emphasis> = ULONG_MAX)</db:title>
<db:para>Blocks the thread until either of these conditions is met:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para>The thread associated with this <db:link xlink:href="qthread.xml">QThread</db:link> object has finished execution (i.e. when it returns from <db:link xlink:href="qthread.xml#run">run</db:link>()). This function will return true if the thread has finished. It also returns true if the thread has not been started yet.</db:para>
</db:listitem>
<db:listitem>
<db:para><db:code role="parameter">time</db:code> milliseconds has elapsed. If <db:code role="parameter">time</db:code> is ULONG_MAX (the default), then the wait will never timeout (the thread must return from <db:link xlink:href="qthread.xml#run">run</db:link>()). This function will return false if the wait timed out.</db:para>
</db:listitem>
</db:itemizedlist>
<db:para>This provides similar functionality to the POSIX pthread_join() function.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qthread.xml#sleep">sleep</db:link>()</db:member>
<db:member><db:link xlink:href="qthread.xml#terminate">terminate</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="yieldCurrentThread">
<db:title>[static] void QThread::yieldCurrentThread()</db:title>
<db:para>Yields execution of the current thread to another runnable thread, if any. Note that the operating system decides to which thread to switch.</db:para>
</db:section>
</db:section>
</db:article>
