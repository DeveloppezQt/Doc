<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en">
<db:info>
<db:title>Qt Quick Scene Graph</db:title>
<db:productname>QtQuick</db:productname>
<db:edition>Qt 6.8.3 Reference Documentation</db:edition>
<db:titleabbrev>Qt Quick Reference Documentation</db:titleabbrev>
<db:abstract>
<db:para>Qt Quick Reference Documentation.</db:para></db:abstract>
<db:pubdate>2025-06-29</db:pubdate>
<db:date>2025-06-29</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:section xml:id="the-scene-graph-in-qt-quick">
<db:title>The Scene Graph in Qt Quick</db:title>
<db:para>Qt Quick 2 makes use of a dedicated scene graph that is then traversed and rendered via a graphics API such as OpenGL ES, OpenGL, Vulkan, Metal, or Direct 3D. Using a scene graph for graphics rather than the traditional imperative painting systems (<db:link xlink:href="qpainter.xml">QPainter</db:link> and similar), means the scene to be rendered can be retained between frames and the complete set of primitives to render is known before rendering starts. This opens up for a number of optimizations, such as batch rendering to minimize state changes and discarding obscured primitives.</db:para>
<db:para>For example, say a user-interface contains a list of ten items where each item has a background color, an icon and a text. Using the traditional drawing techniques, this would result in 30 draw calls and a similar amount of state changes. A scene graph, on the other hand, could reorganize the primitives to render such that all backgrounds are drawn in one call, then all icons, then all the text, reducing the total amount of draw calls to only 3. Batching and state change reduction like this can greatly improve performance on some hardware.</db:para>
<db:para>The scene graph is closely tied to Qt Quick 2.0 and can not be used stand-alone. The scene graph is managed and rendered by the <db:link xlink:href="qquickwindow.xml">QQuickWindow</db:link> class and custom Item types can add their graphical primitives into the scene graph through a call to <db:link xlink:href="qquickitem.xml#updatePaintNode">QQuickItem::updatePaintNode</db:link>().</db:para>
<db:para>The scene graph is a graphical representation of the Item scene, an independent structure that contains enough information to render all the items. Once it has been set up, it can be manipulated and rendered independently of the state of the items. On many platforms, the scene graph will even be rendered on a dedicated render thread while the GUI thread is preparing the next frame's state.</db:para>
<db:note>
<db:para>Much of the information listed on this page is specific to the built-in, default behavior of the Qt Quick Scene graph. When using an alternative scene graph adaptation, such as, the <db:code>software</db:code> adaptation, not all concepts may apply. For more information about the different scene graph adaptations see <db:link xlink:href="qtquick-visualcanvas-adaptations.xml">Scene Graph Adaptations</db:link>.</db:para>
</db:note>
</db:section>
<db:section xml:id="qt-quick-scene-graph-structure">
<db:title>Qt Quick Scene Graph Structure</db:title>
<db:para>The scene graph is composed of a number of predefined node types, each serving a dedicated purpose. Although we refer to it as a scene graph, a more precise definition is node tree. The tree is built from <db:link xlink:href="qquickitem.xml">QQuickItem</db:link> types in the QML scene and internally the scene is then processed by a renderer which draws the scene. The nodes themselves do <db:emphasis role="bold">not</db:emphasis> contain any active drawing code nor virtual <db:code>paint()</db:code> function.</db:para>
<db:para>Even though the node tree is mostly built internally by the existing Qt Quick QML types, it is possible for users to also add complete subtrees with their own content, including subtrees that represent 3D models.</db:para>
<db:section xml:id="nodes">
<db:title>Nodes</db:title>
<db:para>The most important node for users is the <db:link xlink:href="qsggeometrynode.xml">QSGGeometryNode</db:link>. It is used to define custom graphics by defining its geometry and material. The geometry is defined using <db:link xlink:href="qsggeometry.xml">QSGGeometry</db:link> and describes the shape or mesh of the graphical primitive. It can be a line, a rectangle, a polygon, many disconnected rectangles, or complex 3D mesh. The material defines how the pixels in this shape are filled.</db:para>
<db:para>A node can have any number of children and geometry nodes will be rendered so they appear in child-order with parents behind their children.</db:para>
<db:note>
<db:para>This does not say anything about the actual rendering order in the renderer. Only the visual output is guaranteed.</db:para>
</db:note>
<db:para>The available nodes are: <db:variablelist role="qtquick-scenegraph-nodes">
<db:varlistentry>
<db:term><db:link xlink:href="qsgclipnode.xml" xlink:role="class">QSGClipNode</db:link></db:term>
<db:listitem>
<db:para>The QSGClipNode class implements the clipping functionality in the scene graph.</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term><db:link xlink:href="qsggeometrynode.xml" xlink:role="class">QSGGeometryNode</db:link></db:term>
<db:listitem>
<db:para>The QSGGeometryNode class is used for all rendered content in the scene graph.</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term><db:link xlink:href="qsgnode.xml" xlink:role="class">QSGNode</db:link></db:term>
<db:listitem>
<db:para>The QSGNode class is the base class for all nodes in the scene graph.</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term><db:link xlink:href="qsgopacitynode.xml" xlink:role="class">QSGOpacityNode</db:link></db:term>
<db:listitem>
<db:para>The QSGOpacityNode class is used to change opacity of nodes.</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term><db:link xlink:href="qsgtransformnode.xml" xlink:role="class">QSGTransformNode</db:link></db:term>
<db:listitem>
<db:para>The QSGTransformNode class implements transformations in the scene graph.</db:para>
</db:listitem>
</db:varlistentry>
</db:variablelist>
</db:para>
<db:para>Custom nodes are added to the scene graph by subclassing <db:link xlink:href="qquickitem.xml#updatePaintNode">QQuickItem::updatePaintNode</db:link>() and setting the <db:link xlink:href="qquickitem.xml#Flag-enum">QQuickItem::ItemHasContents</db:link> flag.</db:para>
<db:warning>
<db:para>It is crucial that native graphics (OpenGL, Vulkan, Metal, etc.) operations and interaction with the scene graph happens exclusively on the render thread, primarily during the updatePaintNode() call. The rule of thumb is to only use classes with the &quot;QSG&quot; prefix inside the <db:link xlink:href="qquickitem.xml#updatePaintNode">QQuickItem::updatePaintNode</db:link>() function.</db:para>
</db:warning>
<db:para>For more details, see the <db:link xlink:href="qtquick-scenegraph-customgeometry-example.xml">Scene Graph - Custom Geometry</db:link>.</db:para>
<db:section xml:id="preprocessing">
<db:title>Preprocessing</db:title>
<db:para>Nodes have a virtual <db:link xlink:href="qsgnode.xml#preprocess">QSGNode::preprocess</db:link>() function, which will be called before the scene graph is rendered. Node subclasses can set the flag <db:link xlink:href="qsgnode.xml#Flag-enum">QSGNode::UsePreprocess</db:link> and override the <db:link xlink:href="qsgnode.xml#preprocess">QSGNode::preprocess</db:link>() function to do final preparation of their node. For example, dividing a bezier curve into the correct level of detail for the current scale factor or updating a section of a texture.</db:para>
</db:section>
<db:section xml:id="node-ownership">
<db:title>Node Ownership</db:title>
<db:para>Ownership of the nodes is either done explicitly by the creator or by the scene graph by setting the flag <db:link xlink:href="qsgnode.xml#Flag-enum">QSGNode::OwnedByParent</db:link>. Assigning ownership to the scene graph is often preferable as it simplifies cleanup when the scene graph lives outside the GUI thread.</db:para>
</db:section>
</db:section>
<db:section xml:id="materials">
<db:title>Materials</db:title>
<db:para>The material describes how the interior of a geometry in a <db:link xlink:href="qsggeometrynode.xml">QSGGeometryNode</db:link> is filled. It encapsulates graphics shaders for the vertex and fragment stages of the graphics pipeline and provides ample flexibility in what can be achieved, though most of the Qt Quick items themselves only use very basic materials, such as solid color and texture fills.</db:para>
<db:para>For users who just want to apply custom shading to a QML Item type, it is possible to do this directly in QML using the <db:link xlink:href="qml-qtquick-shadereffect.xml">ShaderEffect</db:link> type.</db:para>
<db:para>Below is a complete list of material classes: <db:variablelist role="qtquick-scenegraph-materials">
<db:varlistentry>
<db:term><db:link xlink:href="qsgflatcolormaterial.xml" xlink:role="class">QSGFlatColorMaterial</db:link></db:term>
<db:listitem>
<db:para>The QSGFlatColorMaterial class provides a convenient way of rendering solid colored geometry in the scene graph.</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term><db:link xlink:href="qsgmaterial.xml" xlink:role="class">QSGMaterial</db:link></db:term>
<db:listitem>
<db:para>The QSGMaterial class encapsulates rendering state for a shader program.</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term><db:link xlink:href="qsgmaterialshader.xml" xlink:role="class">QSGMaterialShader</db:link></db:term>
<db:listitem>
<db:para>The QSGMaterialShader class represents a graphics API independent shader program.</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term><db:link xlink:href="qsgmaterialtype.xml" xlink:role="class">QSGMaterialType</db:link></db:term>
<db:listitem>
<db:para>The QSGMaterialType class is used as a unique type token in combination with QSGMaterial.</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term><db:link xlink:href="qsgopaquetexturematerial.xml" xlink:role="class">QSGOpaqueTextureMaterial</db:link></db:term>
<db:listitem>
<db:para>The QSGOpaqueTextureMaterial class provides a convenient way of rendering textured geometry in the scene graph.</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term><db:link xlink:href="qsgtexturematerial.xml" xlink:role="class">QSGTextureMaterial</db:link></db:term>
<db:listitem>
<db:para>The QSGTextureMaterial class provides a convenient way of rendering textured geometry in the scene graph.</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term><db:link xlink:href="qsgvertexcolormaterial.xml" xlink:role="class">QSGVertexColorMaterial</db:link></db:term>
<db:listitem>
<db:para>The QSGVertexColorMaterial class provides a convenient way of rendering per-vertex colored geometry in the scene graph.</db:para>
</db:listitem>
</db:varlistentry>
</db:variablelist>
</db:para>
</db:section>
<db:section xml:id="convenience-nodes">
<db:title>Convenience Nodes</db:title>
<db:para>The scene graph API is low-level and focuses on performance rather than convenience. Writing custom geometries and materials from scratch, even the most basic ones, requires a non-trivial amount of code. For this reason, the API includes a few convenience classes to make the most common custom nodes readily available.</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:link xlink:href="qsgsimplerectnode.xml">QSGSimpleRectNode</db:link> - a <db:link xlink:href="qsggeometrynode.xml">QSGGeometryNode</db:link> subclass which defines a rectangular geometry with a solid color material.</db:para>
</db:listitem>
<db:listitem>
<db:para><db:link xlink:href="qsgsimpletexturenode.xml">QSGSimpleTextureNode</db:link> - a <db:link xlink:href="qsggeometrynode.xml">QSGGeometryNode</db:link> subclass which defines a rectangular geometry with a texture material.</db:para>
</db:listitem>
</db:itemizedlist>
</db:section>
</db:section>
<db:section xml:id="scene-graph-and-rendering">
<db:title>Scene Graph and Rendering</db:title>
<db:para>The rendering of the scene graph happens internally in the <db:link xlink:href="qquickwindow.xml">QQuickWindow</db:link> class, and there is no public API to access it. There are, however, a few places in the rendering pipeline where the user can attach application code. This can be used to add custom scene graph content or to insert arbitrary rendering commands by directly calling the graphics API (OpenGL, Vulkan, Metal, etc.) that is in use by the scene graph. The integration points are defined by the render loop.</db:para>
<db:para>For detailed description of how the scene graph renderer works, see <db:link xlink:href="qtquick-visualcanvas-scenegraph-renderer.xml">Qt Quick Scene Graph Default Renderer</db:link>.</db:para>
<db:para>There are two render loop variants available: <db:code>basic</db:code>, and <db:code>threaded</db:code>. <db:code>basic</db:code> is single-threaded, while <db:code>threaded</db:code> performs scene graph rendering on a dedicated thread. Qt attempts to choose a suitable loop based on the platform and possibly the graphics drivers in use. When this is not satisfactory, or for testing purposes, the environment variable <db:code>QSG_RENDER_LOOP</db:code> can be used to force the usage of a given loop. To verify which render loop is in use, enable the <db:code>qt.scenegraph.general</db:code> <db:link xlink:href="qloggingcategory.xml">logging category</db:link>.</db:para>
<db:section xml:id="threaded-render-loop-threaded">
<db:title>Threaded Render Loop ('threaded')</db:title>
<db:anchor xml:id="threaded-render-loop"/>
<db:para>On many configurations, the scene graph rendering will happen on a dedicated render thread. This is done to increase parallelism of multi-core processors and make better use of stall times such as waiting for a blocking swap buffer call. This offers significant performance improvements, but imposes certain restrictions on where and when interaction with the scene graph can happen.</db:para>
<db:para>The following is a simple outline of how a frame gets rendered with the threaded render loop and OpenGL. The steps are the same with other graphics APIs as well, apart from the OpenGL context specifics.</db:para>
<db:mediaobject>
<db:imageobject>
<db:imagedata fileref="images/sg-renderloop-threaded.png"/>
</db:imageobject>
</db:mediaobject>
<db:orderedlist numeration="arabic">
<db:listitem>
<db:para>A change occurs in the QML scene, causing <db:code>QQuickItem::update()</db:code> to be called. This can be the result of for instance an animation or user input. An event is posted to the render thread to initiate a new frame.</db:para>
</db:listitem>
<db:listitem>
<db:para>The render thread prepares to draw a new frame and initiates a block on the GUI thread.</db:para>
</db:listitem>
<db:listitem>
<db:para>While the render thread is preparing the new frame, the GUI thread calls <db:link xlink:href="qquickitem.xml#updatePolish">QQuickItem::updatePolish</db:link>() to do final touch-up of items before they are rendered.</db:para>
</db:listitem>
<db:listitem>
<db:para>GUI thread is blocked.</db:para>
</db:listitem>
<db:listitem>
<db:para>The <db:link xlink:href="qquickwindow.xml#beforeSynchronizing">QQuickWindow::beforeSynchronizing</db:link>() signal is emitted. Applications can make direct connections (using <db:link xlink:href="qt.xml#ConnectionType-enum">Qt::DirectConnection</db:link>) to this signal to do any preparation required before calls to <db:link xlink:href="qquickitem.xml#updatePaintNode">QQuickItem::updatePaintNode</db:link>().</db:para>
</db:listitem>
<db:listitem>
<db:para>Synchronization of the QML state into the scene graph. This is done by calling the <db:link xlink:href="qquickitem.xml#updatePaintNode">QQuickItem::updatePaintNode</db:link>() function on all items that have changed since the previous frame. This is the only time the QML items and the nodes in the scene graph interact.</db:para>
</db:listitem>
<db:listitem>
<db:para>GUI thread block is released.</db:para>
</db:listitem>
<db:listitem>
<db:para>The scene graph is rendered:</db:para>
<db:orderedlist numeration="arabic">
<db:listitem>
<db:para>The <db:link xlink:href="qquickwindow.xml#beforeRendering">QQuickWindow::beforeRendering</db:link>() signal is emitted. Applications can make direct connections (using <db:link xlink:href="qt.xml#ConnectionType-enum">Qt::DirectConnection</db:link>) to this signal to use custom graphics API calls which will then stack visually beneath the QML scene.</db:para>
</db:listitem>
<db:listitem>
<db:para>Items that have specified <db:link xlink:href="qsgnode.xml#Flag-enum">QSGNode::UsePreprocess</db:link>, will have their <db:link xlink:href="qsgnode.xml#preprocess">QSGNode::preprocess</db:link>() function invoked.</db:para>
</db:listitem>
<db:listitem>
<db:para>The renderer processes the nodes.</db:para>
</db:listitem>
<db:listitem>
<db:para>The renderer generates states and records draw calls for the graphics API in use.</db:para>
</db:listitem>
<db:listitem>
<db:para>The <db:link xlink:href="qquickwindow.xml#afterRendering">QQuickWindow::afterRendering</db:link>() signal is emitted. Applications can make direct connections (using <db:link xlink:href="qt.xml#ConnectionType-enum">Qt::DirectConnection</db:link>) to this signal to issue custom graphics API calls which will then stack visually over the QML scene.</db:para>
</db:listitem>
<db:listitem>
<db:para>The frame is now ready. The buffers are swapped (OpenGL), or a present command is recorded and the command buffers are submitted to a graphics queue (Vulkan, Metal). <db:link xlink:href="qquickwindow.xml#frameSwapped">QQuickWindow::frameSwapped</db:link>() is emitted.</db:para>
</db:listitem>
</db:orderedlist>
</db:listitem>
<db:listitem>
<db:para>While the render thread is rendering, the GUI is free to advance animations, process events, etc.</db:para>
</db:listitem>
</db:orderedlist>
<db:para>The threaded renderer is currently used by default on Windows with Direct3D 11 and with OpenGL when using opengl32.dll, Linux excluding Mesa llvmpipe, macOS with Metal, mobile platforms, and Embedded Linux with EGLFS, and with Vulkan regardless of the platform. All this may change in future releases. It is always possible to force use of the threaded renderer by setting <db:code>QSG_RENDER_LOOP=threaded</db:code> in the environment.</db:para>
</db:section>
<db:section xml:id="non-threaded-render-loop-basic">
<db:title>Non-threaded Render Loop ('basic')</db:title>
<db:para>The non-threaded render loop is currently used by default on Windows with OpenGL when not using the system's standard opengl32.dll, macOS with OpenGL, WebAssembly, and Linux with some drivers. For the latter this is mostly a precautionary measure, as not all combinations of OpenGL drivers and windowing systems have been tested.</db:para>
<db:para>On macOS and OpenGL, the threaded render loop is not supported when building with XCode 10 (10.14 SDK) or later, since this opts in to layer-backed views on macOS 10.14. You can build with Xcode 9 (10.13 SDK) to opt out of layer-backing, in which case the threaded render loop is available and used by default. There is no such restriction with Metal.</db:para>
<db:para>The threaded render loop is not supported on WebAssembly, since the web platform has limited support for using WebGL on other threads than the main thread, and limited support for blocking the main thread.</db:para>
<db:para>Even when using the non-threaded render loop, you should write your code as if you are using the threaded renderer, as failing to do so will make the code non-portable.</db:para>
<db:para>The following is a simplified illustration of the frame rendering sequence in the non-threaded renderer.</db:para>
<db:mediaobject>
<db:imageobject>
<db:imagedata fileref="images/sg-renderloop-singlethreaded.png"/>
</db:imageobject>
</db:mediaobject>
</db:section>
<db:section xml:id="driving-animations">
<db:title>Driving Animations</db:title>
<db:section xml:id="what-does-advance-animations-refer-to-in-the-above-diagrams">
<db:title>What does <db:code>Advance Animations</db:code> refer to in the above diagrams?</db:title>
<db:para>By default, a Qt Quick animation (such, as a <db:link xlink:href="qml-qtquick-numberanimation.xml">NumberAnimation</db:link>) is driven by the default animation driver. This relies on basic system timers, such as <db:link xlink:href="qobject.xml#startTimer">QObject::startTimer</db:link>(). The timer typically runs with an interval of 16 milliseconds. While this will never be fully accurate and also depends on the accuracy of timers in the underlying platform, it has the benefit of being independent of the rendering. It provides uniform results regardless of the display refresh rate and if synchronization to the display's vertical sync is active or not. This is how animations work with the <db:code>basic</db:code> render loop.</db:para>
<db:para>In order to provide more accurate results with less stutter on-screen, independent of the render loop design (be it single threaded or multiple threads) a render loop may decide to install its own custom animation driver, and take the operation of <db:code>advancing</db:code> it into its own hands, without relying on timers.</db:para>
<db:para>This is what the <db:code>threaded</db:code> render loop implements. In fact, it installs not one, but two animation drivers: one on the gui thread (to drive regular animations, such as <db:link xlink:href="qml-qtquick-numberanimation.xml">NumberAnimation</db:link>), and one on the render thread (to drive render thread animations, i.e. the <db:link xlink:href="qml-qtquick-animator.xml">Animator</db:link> types, such as <db:link xlink:href="qml-qtquick-opacityanimator.xml">OpacityAnimator</db:link> or <db:link xlink:href="qml-qtquick-xanimator.xml">XAnimator</db:link>). Both of these are advanced during the preparation of a frame, i.e. animations are now synchronized with rendering. This makes sense due to presentation being throttled to the display's vertical sync by the underlying graphics stack.</db:para>
<db:para>Therefore, in the diagram for the <db:code>threaded</db:code> render loop above, there is an explicit <db:code>Advance animations</db:code> step on both threads. For the render thread, this is trivial: as the thread is being throttled to vsync, advancing animations (for <db:link xlink:href="qml-qtquick-animator.xml">Animator</db:link> types) in each frame as if 16.67 milliseconds had elapsed gives more accurate results than relying on a system timer. (when throttled to the vsync timing, which is <db:code>1000/60</db:code> milliseconds with a 60 Hz refresh rate, it is fair to assume that it has been approximately that long since the same operation was done for the previous frame)</db:para>
<db:para>The same approach works for animations on the gui (main) thread too: due to the essential synchronization of data between the gui and render threads, the gui thread is effectively throttled to the same rate as the render thread, while still having the benefit of having less work to do, leaving more headroom for the application logic since much of the rendering preparations are now offloaded to the render thread.</db:para>
<db:para>While the above examples used 60 frames per second, Qt Quick is prepared for other refresh rates as well: the rate is queried from the <db:link xlink:href="qscreen.xml">QScreen</db:link> and the platform. For example, with a 144 Hz screen the interval is 6.94 ms. At the same time this is exactly what can cause trouble if vsync-based throttling is not functioning as expected, because if what the render loop thinks is happening is not matching reality, incorrect animation pacing will occur.</db:para>
<db:note>
<db:para>Starting from Qt 6.5, the threaded render loop offers the possibility of opting in to another animation driver, based solely on the elapsed time (<db:link xlink:href="qelapsedtimer.xml">QElapsedTimer</db:link>). To enable this, set the <db:code>QSG_USE_SIMPLE_ANIMATION_DRIVER</db:code> environment variable to a non-zero value. This has the benefits of not needing any of the infrastructure for falling back to a <db:link xlink:href="qtimer.xml">QTimer</db:link> when there are multiple windows, not needing heuristics trying determine if vsync-based throttling is missing or broken, being compatible with any kind of temporal drifts in vsync throttling, and not being tied to the primary screen's refresh rate, thus potentially working better in multi-screen setups. It also drives render thread animations (the <db:link xlink:href="qml-qtquick-animator.xml">Animator</db:link> types) correctly even if vsync-based throttling is broken or disabled. On the other hand, animations may be perceived as less smooth with this approach. With compatibility in mind, it is offered as an opt-in feature at the moment.</db:para>
</db:note>
<db:para>In summary, the <db:code>threaded</db:code> render loop is expected to provide smoother animations with less stutter as long as the following conditions are met:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para>There is exactly one window (as in <db:link xlink:href="qquickwindow.xml">QQuickWindow</db:link>) on-screen.</db:para>
</db:listitem>
<db:listitem>
<db:para>VSync-based throttling works as expected with the underyling graphics and display stack.</db:para>
</db:listitem>
</db:itemizedlist>
</db:section>
<db:section xml:id="what-if-there-is-no-or-more-than-one-window-visible">
<db:title>What if there is no or more than one window visible?</db:title>
<db:para>When there is no renderable window, for example because our <db:link xlink:href="qquickwindow.xml">QQuickWindow</db:link> is minimized (Windows) or fully obscured (macOS), we cannot present frames, thus cannot rely on the thread &quot;working&quot; in lockstep with the screen refresh rate. In this case, the <db:code>threaded</db:code> render loop automatically switches over to a system timer based approach to drive animations, i.e. temporarily switching over to the mechanism the <db:code>basic</db:code> loop would use.</db:para>
<db:para>The same is true when there are more than one <db:link xlink:href="qquickwindow.xml">QQuickWindow</db:link> instances on-screen. The model presented above for advancing animations on the gui thread, enabled by its synchronization with the render thread, is not satisfactory anymore, as there are now multiple sync points with multiple render threads. (one per window.) Here falling back to the system timer based approach becomes necessary as well, because how long and often the gui thread will block is now dependent on a number of factors, including the content in the windows (are they animating? how often are they updating?) and the graphics stack behavior (how exactly does it handle two or more threads presenting with wait-for-vsync?). As we cannot guarantee being throttled to the presentation rate of the window (which window would that be, to begin with?) in a stable, cross-platform manner, advancing animations cannot be based on the rendering.</db:para>
<db:para>This switch of animation handling mechanisms is transparent to the applications.</db:para>
</db:section>
<db:section xml:id="what-if-vsync-based-throttling-is-dysfunctional-globally-disabled-or-the-application-disabled-it-itself">
<db:title>What if vsync-based throttling is dysfunctional, globally disabled, or the application disabled it itself?</db:title>
<db:para>The <db:code>threaded</db:code> render loop relies on the graphics API implementation and/or the windowing system for throttling, for example, by requesting a swap interval of 1 in case of OpenGL (GLX, EGL, WGL), calling Present() with an interval of 1 for Direct 3D, or using the presentation mode <db:code>FIFO</db:code> with Vulkan.</db:para>
<db:para>Some graphics drivers allow users to override this setting and turn it off, ignoring Qt's request. An example of this would be a system wide control panel of the graphics driver that allows overriding the application's settings with regards to vsync. It can also happen that a graphics stack is unable to provide proper vsync-based throttling, which can be the case in some virtual machines (mainly due to using a software rasterization based implementation of OpenGL or Vulkan).</db:para>
<db:para>Without blocking in the swap/present operation (or some other graphics operation), such a render loop would advance animations too fast. This would be no issue with the <db:code>basic</db:code> render loop, because that always relies on system timers. With <db:code>threaded</db:code>, the behavior can vary based on the Qt version:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para>If a system is known to be unable to provide vsync-based throttling, the only option before Qt 6.4 was to use the <db:code>basic</db:code> render loop, by manually setting <db:code>QSG_RENDER_LOOP=basic</db:code> in the environment before running the application.</db:para>
</db:listitem>
<db:listitem>
<db:para>Starting with Qt 6.4, setting either the <db:code>QSG_NO_VSYNC</db:code> environment variable to a non-zero value, or the window's <db:link xlink:href="qsurfaceformat.xml#swapInterval">QSurfaceFormat::swapInterval</db:link>() to <db:code>0</db:code> can both alleviate the problem as well: by explicitly requesting disabling vsync-based blocking, regardless of the request having any effect in practice, the <db:code>threaded</db:code> render loop can by extension recognize that relying on vsync to drive animations is futile, and it will fall back to using system timers, just as it would for more than one window.</db:para>
</db:listitem>
<db:listitem>
<db:para>Even better, starting from Qt 6.4 the scenegraph also attempts to recognize using some simple heuristics that the frames are being presented &quot;too fast&quot;, and automatically switch over to system timers if seen necessary. This means that in most cases there will be no need to do anything and applications will run animations as expected even when the default render loop is the <db:code>threaded</db:code> one. While this is transparent to applications, for troubleshooting and development purposes it is useful to know that this is logged with a <db:code>&quot;Window 0x7ffc8489c3d0 is determined to have broken vsync throttling ...&quot;</db:code> message printed when <db:code>QSG_INFO</db:code> or <db:code>qt.scenegraph.general</db:code> is enabled. This method has the downside of activating only after a small set of frames, given that it first needs to collect data to evaluate, meaning that when opening a <db:link xlink:href="qquickwindow.xml">QQuickWindow</db:link> the application may still show overly fast animations for a short period of time. Additionally, it may not capture all possible vsync-broken situations.</db:para>
</db:listitem>
</db:itemizedlist>
<db:para>Remember however, that by design none of this helps render thread animations (the <db:link xlink:href="qml-qtquick-animator.xml">Animator</db:link> types). In the absence of vsync-based blocking, <db:link xlink:href="qml-qtquick-animator.xml">animators</db:link> will advance incorrectly by default, faster than expected, even when the workarounds are activated for regular <db:link xlink:href="qml-qtquick-animation.xml">animations</db:link>. If this becomes an issue, consider using the alternative animation driver by setting <db:code>QSG_USE_SIMPLE_ANIMATION_DRIVER</db:code>.</db:para>
<db:note>
<db:para>Be aware that the rendering loop logic and event processing on the GUI (main) thread is not necessarily unthrottled even if waiting for vsync is disabled: both render loops schedule updates for windows via <db:link xlink:href="qwindow.xml#requestUpdate">QWindow::requestUpdate</db:link>(). This is backed by a 5 ms GUI thread timer on most platforms, in order to give time for event processing. On some platforms, e.g. macOS, it is using platform-specific APIs (such as, CVDisplayLink) to get notified about the appropriate time to prepare a new frame, likely tied to the display's vsync in some form. This can be relevant in benchmarking and similar situations. For applications and tools attempting to perform low-level benchmarking it may be beneficial to set the <db:code>QT_QPA_UPDATE_IDLE_TIME</db:code> environment variable to <db:code>0</db:code> in order to potentially reduce idle time on the GUI thread. For normal application usage the defaults should, in most cases, be sufficient.</db:para>
</db:note>
<db:note>
<db:para>When in doubt, enable the <db:code>qt.scenegraph.general</db:code> and <db:code>qt.scenegraph.time.renderloop</db:code> logging categories for troubleshooting, as these may reveal some clues as to why rendering and animations are not running at the expected pace.</db:para>
</db:note>
</db:section>
</db:section>
<db:section xml:id="custom-control-over-rendering-with-qquickrendercontrol">
<db:title>Custom control over rendering with QQuickRenderControl</db:title>
<db:para>When using <db:link xlink:href="qquickrendercontrol.xml">QQuickRenderControl</db:link>, the responsibility for driving the rendering loop is transferred to the application. In this case no built-in render loop is used. Instead, it is up to the application to invoke the polish, synchronize and rendering steps at the appropriate time. It is possible to implement either a threaded or non-threaded behavior similar to the ones shown above.</db:para>
<db:para>Additionally, applications may wish to implement and install their own QAnimationDriver in combination with <db:link xlink:href="qquickrendercontrol.xml">QQuickRenderControl</db:link>. This gives full control over driving Qt Quick animations, which can be particularly important for content that is not shown on screen, bearing no relation to the presentation rate simply because there is no presenting of the frame happening. This is optional, by default animations will advance based on the system timer.</db:para>
</db:section>
<db:section xml:id="extending-the-scene-graph-with-qrhi-based-and-native-3d-rendering">
<db:title>Extending the Scene Graph with QRhi-based and native 3D rendering</db:title>
<db:para>The scene graph offers three methods for integrating application-provided graphics commands:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para>Issuing either <db:link xlink:href="qrhi.xml">QRhi</db:link>-based or OpenGL, Vulkan, Metal, Direct3D commands directly before or after the scene graph's own rendering. This in effect prepends or appends a set of draw calls into the main render pass. No additional render target is used.</db:para>
</db:listitem>
<db:listitem>
<db:para>Rendering to a texture and creating a textured node in the scene graph. This involves an additional render pass and render target.</db:para>
</db:listitem>
<db:listitem>
<db:para>Issuing draw calls inline with the scene graph's own rendering by instantiating a <db:link xlink:href="qsgrendernode.xml">QSGRenderNode</db:link> subclass in the scene graph. This is similar to the first approach but the custom draw calls are effectively injected into the scene graph's command stream.</db:para>
</db:listitem>
</db:itemizedlist>
<db:section xml:id="underlay-overlay-mode">
<db:title>Underlay/overlay mode</db:title>
<db:para>By connecting to the <db:link xlink:href="qquickwindow.xml#beforeRendering">QQuickWindow::beforeRendering</db:link>() and <db:link xlink:href="qquickwindow.xml#afterRendering">QQuickWindow::afterRendering</db:link>() signals, applications can make <db:link xlink:href="qrhi.xml">QRhi</db:link> or native 3D API calls directly into the same context as the scene graph is rendering to. With APIs like Vulkan or Metal, applications can query native objects, such as, the scene graph's command buffer, via <db:link xlink:href="qsgrendererinterface.xml">QSGRendererInterface</db:link>, and record commands to it as they see fit. As the signal names indicate, the user can then render content either under a Qt Quick scene or over it. The benefit of integrating in this manner is that no extra render targets are needed to perform the rendering, and a possibly expensive texturing step is eliminated. The downside is that the custom rendering can only be issued either at the beginning or at the end of Qt Quick's own rendering. Using <db:link xlink:href="qsgrendernode.xml">QSGRenderNode</db:link> instead of the <db:link xlink:href="qquickwindow.xml">QQuickWindow</db:link> signals can lift that restriction somewhat, but in either case care must be taken when it comes to 3D content and depth buffer usage since relying on depth testing and rendering with depth write enabled can easily create situations where the custom content and the Qt Quick content's depth buffer usage conflict with each other.</db:para>
<db:para>From Qt 6.6 the <db:link xlink:href="qrhi.xml">QRhi</db:link> APIs are considered semi-public, i.e. offered to the applications and documented, albeit with a limited compatibility guarantee. This allows creating portable, cross-platform 2D/3D rendering code by using the same graphics and shader abstractions the scene graph itself uses.</db:para>
<db:para>The <db:link xlink:href="qtquick-scenegraph-rhiunderqml-example.xml">Scene Graph - RHI Under QML</db:link> example gives an example on how to implement the underlay/overlay approach using <db:link xlink:href="qrhi.xml">QRhi</db:link>.</db:para>
<db:para>The <db:link xlink:href="qtquick-scenegraph-openglunderqml-example.xml">Scene Graph - OpenGL Under QML</db:link> example gives an example on how to use these signals using OpenGL.</db:para>
<db:para>The <db:link xlink:href="qtquick-scenegraph-d3d11underqml-example.xml">Scene Graph - Direct3D 11 Under QML</db:link> example gives an example on how to use these signals using Direct3D.</db:para>
<db:para>The <db:link xlink:href="qtquick-scenegraph-metalunderqml-example.xml">Scene Graph - Metal Under QML</db:link> example gives an example on how to use these signals using Metal.</db:para>
<db:para>The <db:link xlink:href="qtquick-scenegraph-vulkanunderqml-example.xml">Scene Graph - Vulkan Under QML</db:link> example gives an example on how to use these signals using Vulkan.</db:para>
<db:para>Starting with Qt 6.0, direct usage of the underlying graphics API must be enclosed by a call to <db:link xlink:href="qquickwindow.xml#beginExternalCommands">QQuickWindow::beginExternalCommands</db:link>() and <db:link xlink:href="qquickwindow.xml#endExternalCommands">QQuickWindow::endExternalCommands</db:link>(). This concept may be familiar from <db:link xlink:href="qpainter.xml#beginNativePainting">QPainter::beginNativePainting</db:link>(), and serves a similar purpose: it allows the Qt Quick Scene Graph to recognize that any cached state and assumptions about the state within the currently recorded render pass, if there is one, are now invalid, because the application code may have altered it by working directly with the underlying graphics API. This is not applicable and necessary when using <db:link xlink:href="qrhi.xml">QRhi</db:link>.</db:para>
<db:para>When mixing custom OpenGL rendering with the scene graph, it is important the application does not leave the OpenGL context in a state with buffers bound, attributes enabled, special values in the z-buffer or stencil-buffer or similar. Doing so can result in unpredictable behavior.</db:para>
<db:para>The custom rendering code must be thread aware in the sense that it should not assume being executed on the GUI (main) thread of the application. When connecting to the <db:link xlink:href="qquickwindow.xml">QQuickWindow</db:link> signals, the application should use <db:link xlink:href="qt.xml#ConnectionType-enum">Qt::DirectConnection</db:link> and understand that the connected slots are invoked on the scene graph's dedicated render thread, if there is one.</db:para>
</db:section>
<db:section xml:id="the-texture-based-approach">
<db:title>The texture-based approach</db:title>
<db:para>The texture-based alternative is the most flexible approach when the application needs to have a &quot;flattened&quot;, 2D image of some custom 3D rendering within the Qt Quick scene. This also allows using a dedicated depth/stencil buffer that is independent of the buffers used by the main render pass.</db:para>
<db:para>When using OpenGL, the legacy convenience class <db:link xlink:href="qquickframebufferobject.xml">QQuickFramebufferObject</db:link> can be used to achieve this. <db:link xlink:href="qrhi.xml">QRhi</db:link>-based custom renderers and graphics APIs other than OpenGL can also follow this approach, even though <db:link xlink:href="qquickframebufferobject.xml">QQuickFramebufferObject</db:link> does not currently support them. Creating and rendering to a texture directly with the underlying API, followed by wrapping and using this resource in a Qt Quick scene in a custom <db:link xlink:href="qquickitem.xml">QQuickItem</db:link>, is demonstrated in the following examples:</db:para>
<db:para><db:link xlink:href="qtquick-scenegraph-rhitextureitem-example.xml">Scene Graph - RHI Texture Item</db:link> example.</db:para>
<db:para><db:link xlink:href="qtquick-scenegraph-vulkantextureimport-example.xml">Scene Graph - Vulkan Texture Import</db:link> example.</db:para>
<db:para><db:link xlink:href="qtquick-scenegraph-metaltextureimport-example.xml">Scene Graph - Metal Texture Import</db:link> example.</db:para>
</db:section>
<db:section xml:id="the-inline-approach">
<db:title>The inline approach</db:title>
<db:para>Using <db:link xlink:href="qsgrendernode.xml">QSGRenderNode</db:link> the custom draw calls are injected not at the beginning or the end of the recording of the scene graph's render pass, but rather during the scene graph's rendering process. This is achieved by creating a custom <db:link xlink:href="qquickitem.xml">QQuickItem</db:link> based by an instance of <db:link xlink:href="qsgrendernode.xml">QSGRenderNode</db:link>, a scene graph node that exists specifically to allow issuing graphics commands either via <db:link xlink:href="qrhi.xml">QRhi</db:link> or a native 3D API such as OpenGL, Vulkan, Metal, or Direct 3D.</db:para>
<db:para>The <db:link xlink:href="qtquick-scenegraph-customrendernode-example.xml">Scene Graph - Custom QSGRenderNode</db:link> example gives a demonstration of this approach.</db:para>
</db:section>
</db:section>
<db:section xml:id="custom-items-using-qpainter">
<db:title>Custom Items using QPainter</db:title>
<db:para>The <db:link xlink:href="qquickitem.xml">QQuickItem</db:link> provides a subclass, <db:link xlink:href="qquickpainteditem.xml">QQuickPaintedItem</db:link>, which allows the users to render content using <db:link xlink:href="qpainter.xml">QPainter</db:link>.</db:para>
<db:warning>
<db:para>Using <db:link xlink:href="qquickpainteditem.xml">QQuickPaintedItem</db:link> uses an indirect 2D surface to render its content, either using software rasterization or using an OpenGL framebuffer object (FBO), so the rendering is a two-step operation. First rasterize the surface, then draw the surface. Using scene graph API directly is always significantly faster.</db:para>
</db:warning>
</db:section>
</db:section>
<db:section xml:id="logging-support">
<db:title>Logging Support</db:title>
<db:para>The scene graph has support for a number of logging categories. These can be useful in tracking down both performance issues and bugs in addition to being helpful to Qt contributors.</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:code>qt.scenegraph.time.texture</db:code> - logs the time spent doing texture uploads</db:para>
</db:listitem>
<db:listitem>
<db:para><db:code>qt.scenegraph.time.compilation</db:code> - logs the time spent doing shader compilation</db:para>
</db:listitem>
<db:listitem>
<db:para><db:code>qt.scenegraph.time.renderer</db:code> - logs the time spent in the various steps of the renderer</db:para>
</db:listitem>
<db:listitem>
<db:para><db:code>qt.scenegraph.time.renderloop</db:code> - logs the time spent in the various steps of the render loop. With the <db:code>threaded</db:code> render loop this gives an insight into the time elapsed between the various frame preparation steps both on the GUI and the render thread. It can therefore also be a useful troubleshooting tool, for example, to confirm how vsync-based throttling and other low-level Qt enablers, such as <db:link xlink:href="qwindow.xml#requestUpdate">QWindow::requestUpdate</db:link>(), affect the rendering and presentation pipeline.</db:para>
</db:listitem>
<db:listitem>
<db:para><db:code>qt.scenegraph.time.glyph</db:code> - logs the time spent preparing distance field glyphs</db:para>
</db:listitem>
<db:listitem>
<db:para><db:code>qt.scenegraph.general</db:code> - logs general information about various parts of the scene graph and the graphics stack</db:para>
</db:listitem>
<db:listitem>
<db:para><db:code>qt.scenegraph.renderloop</db:code> - creates a detailed log of the various stages involved in rendering. This log mode is primarily useful for developers working on Qt.</db:para>
</db:listitem>
</db:itemizedlist>
<db:para>The legacy <db:code>QSG_INFO</db:code> environment variable is also available. Setting it to a non-zero value enables the <db:code>qt.scenegraph.general</db:code> category.</db:para>
<db:note>
<db:para>When encountering graphics problems, or when in doubt which render loop or graphics API is in use, always start the application with at least <db:code>qt.scenegraph.general</db:code> and <db:code>qt.rhi.*</db:code> enabled, or <db:code>QSG_INFO=1</db:code> set. This will then print some essential information onto the debug output during initialization.</db:para>
</db:note>
</db:section>
<db:section xml:id="scene-graph-backend">
<db:title>Scene Graph Backend</db:title>
<db:para>In addition to the public API, the scene graph has an adaptation layer which opens up the implementation to do hardware specific adaptations. This is an undocumented, internal and private plugin API, which lets hardware adaptation teams make the most of their hardware. It includes:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para>Custom textures; specifically the implementation of <db:link xlink:href="qquickwindow.xml#createTextureFromImage">QQuickWindow::createTextureFromImage</db:link> and the internal representation of the texture used by <db:link xlink:href="qml-qtquick-image.xml">Image</db:link> and <db:link xlink:href="qml-qtquick-borderimage.xml">BorderImage</db:link> types.</db:para>
</db:listitem>
<db:listitem>
<db:para>Custom renderer; the adaptation layer lets the plugin decide how the scene graph is traversed and rendered, making it possible to optimize the rendering algorithm for a specific hardware or to make use of extensions which improve performance.</db:para>
</db:listitem>
<db:listitem>
<db:para>Custom scene graph implementation of many of the default QML types, including its text and font rendering.</db:para>
</db:listitem>
<db:listitem>
<db:para>Custom animation driver; allows the animation system to hook into the low-level display vertical refresh to get smooth rendering.</db:para>
</db:listitem>
<db:listitem>
<db:para>Custom render loop; allows better control over how QML deals with multiple windows.</db:para>
</db:listitem>
</db:itemizedlist>
</db:section>
</db:article>
