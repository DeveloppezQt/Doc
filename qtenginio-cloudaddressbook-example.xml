<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en">
<db:info>
<db:title>Enginio C++ Examples - Cloud Address Book</db:title>
<db:productname>QtEnginio</db:productname>
<db:edition>Qt 5.6.3 Reference Documentation</db:edition>
<db:titleabbrev>Client library for Enginio</db:titleabbrev>
<db:abstract>
<db:para>The Cloud Address Book demonstrates how to use sorting, filtering, and the full text search functionality.</db:para>
</db:abstract>
<db:pubdate>2025-06-29</db:pubdate>
<db:date>2025-06-29</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:para>This example explains how to use the full text search feature of Enginio, and how to sort and filter data showed from the <db:link xlink:href="enginiomodel.xml">EnginioModel</db:link>. A simple addressbook-like application will be created to illustrate this. This example doesn't cover security or multi-user management. For such topics, please refer to the Social Todo example.</db:para>
<db:mediaobject>
<db:imageobject>
<db:imagedata fileref="images/cloudaddressbook-example.png"/>
</db:imageobject>
</db:mediaobject>
<db:section xml:id="preconditions">
<db:title>Preconditions</db:title>
<db:para>To start the example, a <db:emphasis>backend id</db:emphasis> and a <db:emphasis>backend secret</db:emphasis> have to be provided for an existing and configured Enginio backend. The backend can be created using the dashboard, where the Cloud Address Book preconfigured backend can be chosen.</db:para>
</db:section>
<db:section xml:id="backend-description">
<db:title>Backend Description</db:title>
<db:para>We recommend to use preconfigured backend, because it contains already all data and structures that are needed to run these examples, but it is not difficult to create the backend from scratch too. The backend should contain one custom object type <db:code>objects.addressbook</db:code> having properties:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para>firstName</db:para>
</db:listitem>
<db:listitem>
<db:para>lastName</db:para>
</db:listitem>
<db:listitem>
<db:para>email</db:para>
</db:listitem>
<db:listitem>
<db:para>phone</db:para>
</db:listitem>
<db:listitem>
<db:para>address</db:para>
</db:listitem>
</db:itemizedlist>
<db:para>All properties are of <db:code>string</db:code> type and have to be indexed, because only indexed properties will be searched by the full text search.</db:para>
</db:section>
<db:section xml:id="application-design">
<db:title>Application Design</db:title>
<db:para>The application's ui mainly consists of a table showing all addresses and a text filed where a query can be typed. A user should be able to sort addresses or highlight an address containing a specified phrase.</db:para>
</db:section>
<db:section xml:id="implementation">
<db:title>Implementation</db:title>
<db:para>From a developer point of view the application consists of a few simple components:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:link xlink:href="qml-enginio-enginioclient.xml">EnginioClient</db:link> which encapsulates all information needed to keep the connection to the backend</db:para>
</db:listitem>
<db:listitem>
<db:para><db:link xlink:href="enginiomodel.xml">EnginioModel</db:link> which queries all addresses</db:para>
</db:listitem>
<db:listitem>
<db:para><db:link xlink:href="qsortfilterproxymodel.xml">QSortFilterProxyModel</db:link> which sorts the data</db:para>
</db:listitem>
<db:listitem>
<db:para><db:link xlink:href="qtableview.xml">QTableView</db:link> which shows the data</db:para>
</db:listitem>
</db:itemizedlist>
<db:para>First we need to establish a connection to the Enginio service. We need to specify the <db:emphasis>backend id</db:emphasis> as well as <db:emphasis>backend secret</db:emphasis>.</db:para>
<db:programlisting language="cpp">client = new EnginioClient(this);
client-&gt;setBackendId(EnginioBackendId);
</db:programlisting>
<db:para>The second step is to create <db:link xlink:href="enginiomodel.xml">EnginioModel</db:link> which queries all data from the backend. The query is quite simple, it specifies an object type of which all objects need to be returned.</db:para>
<db:programlisting language="cpp">model = new AddressBookModel(this);
model-&gt;setClient(client);

QJsonObject query;
query[&quot;objectType&quot;] = QString::fromUtf8(&quot;objects.addressbook&quot;);
model-&gt;setQuery(query);
</db:programlisting>
<db:para><db:link xlink:href="enginiomodel.xml">EnginioModel</db:link> can sort or filter data only initially, which means that, for example, a newly added item will not be placed correctly. To solve the problem <db:link xlink:href="qsortfilterproxymodel.xml">QSortFilterProxyModel</db:link> has to be used.</db:para>
<db:programlisting language="cpp">sortFilterProxyModel = new QSortFilterProxyModel(this);
sortFilterProxyModel-&gt;setSourceModel(model);
tableView-&gt;setSortingEnabled(true);
tableView-&gt;setModel(sortFilterProxyModel);
</db:programlisting>
<db:para>Now is a time to look deeper into EngnioModel. <db:link xlink:href="enginiomodel.xml">EnginioModel</db:link> should define data roles.</db:para>
<db:programlisting language="cpp">enum Roles {
    FirstNameRole = Enginio::CustomPropertyRole,
    LastNameRole,
    EmailRole,
    PhoneRole,
    AddressRole
};
QHash&lt;int, QByteArray&gt; AddressBookModel::roleNames() const
{
    QHash&lt;int, QByteArray&gt; roles = EnginioModel::roleNames();
    roles.insert(FirstNameRole, &quot;firstName&quot;);
    roles.insert(LastNameRole, &quot;lastName&quot;);
    roles.insert(EmailRole, &quot;email&quot;);
    roles.insert(PhoneRole, &quot;phone&quot;);
    roles.insert(AddressRole, &quot;address&quot;);
    return roles;
}
</db:programlisting>
<db:para>and as always the <db:link xlink:href="qabstractitemmodel.xml#data">data</db:link>() and <db:link xlink:href="enginiomodel.xml#setData">setData</db:link>() functions have to be overridden to provide <db:link xlink:href="qt.xml#ItemDataRole-enum">Qt::DisplayRole</db:link> in such a way as to nicely cooperate with <db:link xlink:href="qtableview.xml">QTableView</db:link>.</db:para>
<db:programlisting language="cpp">QVariant AddressBookModel::data(const QModelIndex &amp;index, int role) const
{
    if (role == Qt::DisplayRole) {
        // we assume here that column order is constant and it is the same as in AddressBookModel::Roles
        return EnginioModel::data(index, FirstNameRole + index.column()).value&lt;QJsonValue&gt;().toString();
    }
    if (role == Qt::FontRole) {
        // this role is used to mark items found in the full text search.
        QFont font;
        QString id = EnginioModel::data(index, Enginio::IdRole).value&lt;QString&gt;();
        font.setBold(_markedItems.contains(id));
        return font;
    }

    return EnginioModel::data(index, role);
}

bool AddressBookModel::setData(const QModelIndex &amp;index, const QVariant &amp;value, int role)
{
    bool result = role == Qt::EditRole
            ? EnginioModel::setData(this-&gt;index(index.row()), value, FirstNameRole + index.column())
            : EnginioModel::setData(this-&gt;index(index.row()), value, role);

    // if the data was edited, the marked items set may not be valid anymore
    // so we need to clear it.
    if (result)
        _markedItems.clear();
    return result;
}
</db:programlisting>
<db:para><db:link xlink:href="qtableview.xml">QTableView</db:link> requires the specification of columns headers, so that they can be shown in the user interface:</db:para>
<db:programlisting language="cpp">int AddressBookModel::columnCount(const QModelIndex &amp;parent) const
{
    return parent.isValid() ? 0 : 5;
}

QVariant AddressBookModel::headerData(int section, Qt::Orientation orientation, int role) const
{
    if (orientation == Qt::Horizontal &amp;&amp; role == Qt::DisplayRole) {
        switch (section) {
        case 0: return QStringLiteral(&quot;First name&quot;);
        case 1: return QStringLiteral(&quot;Last name&quot;);
        case 2: return QStringLiteral(&quot;Email&quot;);
        case 3: return QStringLiteral(&quot;Phone number&quot;);
        case 4: return QStringLiteral(&quot;Address&quot;);
        }
        return QVariant();
    }
    return EnginioModel::headerData(section, orientation, role);
}
</db:programlisting>
<db:para>Integration of the full text search is the last step in this tutorial. The goal is to highlight items that contain a given phrase. The highlighting is done by <db:link xlink:href="qabstractitemmodel.xml#data">data</db:link>(), which returns a bold font for <db:link xlink:href="qt.xml#ItemDataRole-enum">Qt::FontRole</db:link> if an item is matching the search query. For reasons of simplicity, this example assumes that the matching items count is not big and can be kept in a <db:link xlink:href="qset.xml">QSet</db:link>, which would be recreated on each search.</db:para>
<db:para>To do a full text search, a JSON query needs to be constructed:</db:para>
<db:programlisting language="cpp">// construct JSON object:
//    {
//        &quot;objectTypes&quot;: [&quot;objects.addressbook&quot;],
//        &quot;search&quot;: { &quot;phrase&quot;: &quot;*PHRASE*&quot;,
//            &quot;properties&quot;: [&quot;firstName&quot;, &quot;lastName&quot;, &quot;email&quot;, &quot;phone&quot;, &quot;address&quot;]
//        }
//    }

QJsonObject query;
{
    QJsonArray objectTypes;
    objectTypes.append(QString::fromUtf8(&quot;objects.addressbook&quot;));

    QJsonArray properties;
    properties.append(QString::fromUtf8(&quot;firstName&quot;));
    properties.append(QString::fromUtf8(&quot;lastName&quot;));
    properties.append(QString::fromUtf8(&quot;email&quot;));
    properties.append(QString::fromUtf8(&quot;phone&quot;));
    properties.append(QString::fromUtf8(&quot;address&quot;));

    QJsonObject searchQuery;
    searchQuery.insert(&quot;phrase&quot;, &quot;*&quot; + search + &quot;*&quot;);
    searchQuery.insert(&quot;properties&quot;, properties);

    query.insert(&quot;objectTypes&quot;, objectTypes);
    query.insert(&quot;search&quot;, searchQuery);
}
</db:programlisting>
<db:para>The query contains <db:code>objectTypes</db:code> property (note the 's' at the end) which is an array of all object types which have to be searched. In this case, it is only one type: <db:code>objects.addressbook</db:code>. Next the <db:code>search</db:code> property has to be specified. It is an object that is required to have a <db:code>phrase</db:code> property, containing the phrase to search for. phrase that has to be found. Please use the wildcard <db:code>*</db:code> in the search criteria, otherwise only full words will be found. To avoid substrings, for example in an <db:code>object id</db:code>, which is not visible for a user, the search is limited to a selected array of <db:code>properties</db:code>. When the search query is constructed, it is enough to call <db:link xlink:href="qml-enginio-enginioclient.xml#fullTextSearch-method">fullTextSearch</db:link>():</db:para>
<db:programlisting language="cpp">_searchReply =  client()-&gt;fullTextSearch(query);
QObject::connect(_searchReply, &amp;EnginioReply::finished, this, &amp;AddressBookModel::searchResultsArrived);
QObject::connect(_searchReply, &amp;EnginioReply::finished, _searchReply, &amp;EnginioReply::deleteLater);
</db:programlisting>
<db:para>The result will be delivered to the <db:code>searchResultsArrived</db:code> slot. All objects ids found will be gathered in a <db:code>markedItems</db:code> set.</db:para>
<db:programlisting language="cpp">void AddressBookModel::searchResultsArrived()
{
    // clear old marks.
    _markedItems.clear();

    // update marked ids.
    QJsonArray results = _searchReply-&gt;data()[&quot;results&quot;].toArray();
    foreach (const QJsonValue &amp;value, results) {
        QJsonObject person = value.toObject();
        _markedItems.insert(person[&quot;id&quot;].toString());
    }

    QVector&lt;int&gt; roles;
    roles.append(Qt::FontRole);
    // We do not keep id -&gt; row mapping, therefore it is easier to emit
    // data change signal for all items, even if it is not optimal from
    // the performance point of view.
    emit dataChanged(index(0), index(rowCount() - 1, columnCount() - 1) , roles);

    _searchReply = 0;
    emit searchFinished();
}
</db:programlisting>
</db:section>
<db:section>
<db:title>List of Files</db:title>
<db:para>Files:</db:para>
<db:section>
<db:title>List of Files</db:title>
<db:itemizedlist>
<db:listitem>
<db:para><db:link xlink:href="cloudaddressbook/addressbookmodel.cpp">cloudaddressbook/addressbookmodel.cpp</db:link></db:para></db:listitem>
<db:listitem>
<db:para><db:link xlink:href="cloudaddressbook/addressbookmodel.h">cloudaddressbook/addressbookmodel.h</db:link></db:para></db:listitem>
<db:listitem>
<db:para><db:link xlink:href="cloudaddressbook/cloudaddressbook.pro">cloudaddressbook/cloudaddressbook.pro</db:link></db:para></db:listitem>
<db:listitem>
<db:para><db:link xlink:href="cloudaddressbook/main.cpp">cloudaddressbook/main.cpp</db:link></db:para></db:listitem>
<db:listitem>
<db:para><db:link xlink:href="cloudaddressbook/mainwindow.cpp">cloudaddressbook/mainwindow.cpp</db:link></db:para></db:listitem>
<db:listitem>
<db:para><db:link xlink:href="cloudaddressbook/mainwindow.h">cloudaddressbook/mainwindow.h</db:link></db:para></db:listitem>
<db:listitem>
<db:para><db:link xlink:href="cloudaddressbook/mainwindow.ui">cloudaddressbook/mainwindow.ui</db:link></db:para></db:listitem>
</db:itemizedlist>
</db:section>
</db:section></db:article>
