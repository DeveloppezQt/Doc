<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en">
<db:info>
<db:title>QContiguousCache Class</db:title>
<db:subtitle>template &lt;typename T&gt; class QContiguousCache</db:subtitle>
<db:productname>QtCore</db:productname>
<db:edition>Qt 6.9.1 Reference Documentation</db:edition>
<db:titleabbrev>Qt Core Reference Documentation</db:titleabbrev>
<db:abstract>
<db:para>The <db:link xlink:href="qcontiguouscache.xml">QContiguousCache</db:link> class is a template class that provides a contiguous cache.</db:para>
<db:note>
<db:para>All functions in this class are reentrant.</db:para>
</db:note>
</db:abstract>
<db:pubdate>2025-06-29</db:pubdate>
<db:date>2025-06-29</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:variablelist>
<db:varlistentry>
<db:term>Header</db:term>
<db:listitem>
<db:para>QContiguousCache</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>CMake</db:term>
<db:listitem>
<db:para>find_package(Qt6 REQUIRED COMPONENTS Core)</db:para>
<db:para>target_link_libraries(mytarget PRIVATE Qt6::Core)</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>qmake</db:term>
<db:listitem>
<db:para>QT += core</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Group</db:term>
<db:listitem>
<db:para>QContiguousCache is part of <db:simplelist><db:member>tools</db:member><db:member><db:link xlink:href="shared.xml">Implicitly Shared Classes</db:link></db:member></db:simplelist>
</db:para>
</db:listitem>
</db:varlistentry>
</db:variablelist>
<db:section xml:id="details">
<db:title>Detailed Description</db:title>
<db:para>The <db:link xlink:href="qcontiguouscache.xml">QContiguousCache</db:link> class provides an efficient way of caching items for display in a user interface view. Unlike <db:link xlink:href="qcache.xml">QCache</db:link>, it adds a restriction that elements within the cache are contiguous. This has the advantage of matching how user interface views most commonly request data, as a set of rows localized around the current scrolled position. This restriction allows the cache to consume less memory and processor cycles than <db:link xlink:href="qcache.xml">QCache</db:link>.</db:para>
<db:para><db:link xlink:href="qcontiguouscache.xml">QContiguousCache</db:link> operates on a fixed capacity, set with <db:link xlink:href="qcontiguouscache.xml#setCapacity">setCapacity</db:link>() or passed as a parameter to the constructor. This capacity is the upper bound on memory usage by the cache itself, not including the memory allocated by the elements themselves. Note that a cache with a capacity of zero (the default) means no items will be stored: the <db:link xlink:href="qcontiguouscache.xml#insert">insert</db:link>(), <db:link xlink:href="qcontiguouscache.xml#append">append</db:link>() and <db:link xlink:href="qcontiguouscache.xml#prepend">prepend</db:link>() operations will effectively be no-ops. Therefore, it's important to set the capacity to a reasonable value before adding items to the cache.</db:para>
<db:para>The simplest way of using a contiguous cache is to use the <db:link xlink:href="qcontiguouscache.xml#append">append</db:link>() and <db:link xlink:href="qcontiguouscache.xml#prepend">prepend</db:link>().</db:para>
<db:programlisting language="cpp">MyRecord record(int row) const
{
    Q_ASSERT(row &gt;= 0 &amp;&amp; row &lt; count());

    while (row &gt; cache.lastIndex())
        cache.append(slowFetchRecord(cache.lastIndex()+1));
    while (row &lt; cache.firstIndex())
        cache.prepend(slowFetchRecord(cache.firstIndex()-1));

    return cache.at(row);
}
</db:programlisting>
<db:para>If the cache is full then the item at the opposite end of the cache from where the new item is appended or prepended will be removed.</db:para>
<db:para>This usage can be further optimized by using the <db:link xlink:href="qcontiguouscache.xml#insert">insert</db:link>() function in the case where the requested row is a long way from the currently cached items. If there is a gap between where the new item is inserted and the currently cached items then the existing cached items are first removed to retain the contiguous nature of the cache. Hence it is important to take some care then when using <db:link xlink:href="qcontiguouscache.xml#insert">insert</db:link>() in order to avoid unwanted clearing of the cache.</db:para>
<db:para>The range of valid indexes for the <db:link xlink:href="qcontiguouscache.xml">QContiguousCache</db:link> class are from 0 to INT_MAX. Calling <db:link xlink:href="qcontiguouscache.xml#prepend">prepend</db:link>() such that the first index would become less than 0 or <db:link xlink:href="qcontiguouscache.xml#append">append</db:link>() such that the last index would become greater than INT_MAX can result in the indexes of the cache being invalid. When the cache indexes are invalid it is important to call <db:link xlink:href="qcontiguouscache.xml#normalizeIndexes">normalizeIndexes</db:link>() before calling any of <db:link xlink:href="qcontiguouscache.xml#containsIndex">containsIndex</db:link>(), <db:link xlink:href="qcontiguouscache.xml#firstIndex">firstIndex</db:link>(), <db:link xlink:href="qcontiguouscache.xml#lastIndex">lastIndex</db:link>(), <db:link xlink:href="qcontiguouscache.xml#at">at</db:link>() or <db:link xlink:href="qcontiguouscache.xml#operator-5b-5d">operator[]</db:link>(). Calling these functions when the cache has invalid indexes will result in undefined behavior. The indexes can be checked by using <db:link xlink:href="qcontiguouscache.xml#areIndexesValid">areIndexesValid</db:link>()</db:para>
<db:para>In most cases the indexes will not exceed 0 to INT_MAX, and <db:link xlink:href="qcontiguouscache.xml#normalizeIndexes">normalizeIndexes</db:link>() will not need to be used.</db:para>
<db:para>See the <db:link xlink:href="qtcore-tools-contiguouscache-example.xml">Contiguous Cache</db:link> example.</db:para>
</db:section>
<db:section xml:id="member-function-documentation">
<db:title>Member Function Documentation</db:title>
<db:section xml:id="QContiguousCache-1">
<db:title>[explicit] QContiguousCache::QContiguousCache(qsizetype <db:emphasis>capacity</db:emphasis> = 0)</db:title>
<db:para>Constructs a cache with the given <db:code role="parameter">capacity</db:code>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qcontiguouscache.xml#setCapacity">setCapacity</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="QContiguousCache">
<db:title>QContiguousCache::QContiguousCache(const QContiguousCache&lt;T&gt; &amp;<db:emphasis>other</db:emphasis>)</db:title>
<db:para>Constructs a copy of <db:code role="parameter">other</db:code>.</db:para>
<db:para>This operation takes <db:link xlink:href="containers.xml#constant-time">constant time</db:link>, because <db:link xlink:href="qcontiguouscache.xml">QContiguousCache</db:link> is <db:link xlink:href="implicit-sharing.xml">implicitly shared</db:link>. This makes returning a <db:link xlink:href="qcontiguouscache.xml">QContiguousCache</db:link> from a function very fast. If a shared instance is modified, it will be copied (copy-on-write), and that takes <db:link xlink:href="containers.xml#linear-time">linear time</db:link>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qcontiguouscache.xml#operator-eq">operator=</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="dtor.QContiguousCache">
<db:title>QContiguousCache::~QContiguousCache()</db:title>
<db:para>Destroys the cache.</db:para>
</db:section>
<db:section xml:id="append">
<db:title>void QContiguousCache::append(const T &amp;<db:emphasis>value</db:emphasis>)</db:title>
<db:para>Inserts <db:code role="parameter">value</db:code> at the end of the cache. If the cache is already full the item at the start of the cache will be removed.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qcontiguouscache.xml#prepend">prepend</db:link>()</db:member>
<db:member><db:link xlink:href="qcontiguouscache.xml#insert">insert</db:link>()</db:member>
<db:member><db:link xlink:href="qcontiguouscache.xml#isFull">isFull</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="areIndexesValid">
<db:title>bool QContiguousCache::areIndexesValid() const</db:title>
<db:para>Returns whether the indexes for items stored in the cache are valid. Indexes can become invalid if items are appended after the index position INT_MAX or prepended before the index position 0. This is only expected to occur in very long lived circular buffer style usage of the contiguous cache. Indexes can be made valid again by calling <db:link xlink:href="qcontiguouscache.xml#normalizeIndexes">normalizeIndexes</db:link>().</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qcontiguouscache.xml#normalizeIndexes">normalizeIndexes</db:link>()</db:member>
<db:member><db:link xlink:href="qcontiguouscache.xml#append">append</db:link>()</db:member>
<db:member><db:link xlink:href="qcontiguouscache.xml#prepend">prepend</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="at">
<db:title>const T &amp;QContiguousCache::at(qsizetype <db:emphasis>i</db:emphasis>) const</db:title>
<db:para>Returns the item at index position <db:code role="parameter">i</db:code> in the cache. <db:code role="parameter">i</db:code> must be a valid index position in the cache (i.e, <db:link xlink:href="qcontiguouscache.xml#firstIndex">firstIndex</db:link>() &lt;= <db:code role="parameter">i</db:code> &lt;= <db:link xlink:href="qcontiguouscache.xml#lastIndex">lastIndex</db:link>()).</db:para>
<db:para>The indexes in the cache refer to the number of positions the item is from the first item appended into the cache. That is to say a cache with a capacity of 100, that has had 150 items appended will have a valid index range of 50 to 149. This allows inserting and retrieving items into the cache based on a theoretical infinite list</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qcontiguouscache.xml#firstIndex">firstIndex</db:link>()</db:member>
<db:member><db:link xlink:href="qcontiguouscache.xml#lastIndex">lastIndex</db:link>()</db:member>
<db:member><db:link xlink:href="qcontiguouscache.xml#insert">insert</db:link>()</db:member>
<db:member><db:link xlink:href="qcontiguouscache.xml#operator-5b-5d">operator[]</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="available">
<db:title>qsizetype QContiguousCache::available() const</db:title>
<db:para>Returns the number of items that can be added to the cache before it becomes full.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qcontiguouscache.xml#size">size</db:link>()</db:member>
<db:member><db:link xlink:href="qcontiguouscache.xml#capacity">capacity</db:link>()</db:member>
<db:member><db:link xlink:href="qcontiguouscache.xml#isFull">isFull</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="capacity">
<db:title>qsizetype QContiguousCache::capacity() const</db:title>
<db:para>Returns the number of items the cache can store before it is full. When a cache contains a number of items equal to its capacity, adding new items will cause items farthest from the added item to be removed.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qcontiguouscache.xml#setCapacity">setCapacity</db:link>()</db:member>
<db:member><db:link xlink:href="qcontiguouscache.xml#size">size</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="clear">
<db:title>void QContiguousCache::clear()</db:title>
<db:para>Removes all items from the cache. The capacity is unchanged.</db:para>
</db:section>
<db:section xml:id="containsIndex">
<db:title>bool QContiguousCache::containsIndex(qsizetype <db:emphasis>i</db:emphasis>) const</db:title>
<db:para>Returns true if the cache's index range includes the given index <db:code role="parameter">i</db:code>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qcontiguouscache.xml#firstIndex">firstIndex</db:link>()</db:member>
<db:member><db:link xlink:href="qcontiguouscache.xml#lastIndex">lastIndex</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="count">
<db:title>qsizetype QContiguousCache::count() const</db:title>
<db:para>Same as <db:link xlink:href="qcontiguouscache.xml#size">size</db:link>().</db:para>
</db:section>
<db:section xml:id="first">
<db:title>T &amp;QContiguousCache::first()</db:title>
<db:para>Returns a reference to the first item in the cache. This function assumes that the cache isn't empty.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qcontiguouscache.xml#last">last</db:link>()</db:member>
<db:member><db:link xlink:href="qcontiguouscache.xml#isEmpty">isEmpty</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="first-1">
<db:title>const T &amp;QContiguousCache::first() const</db:title>
<db:para>This is an overloaded function.</db:para>
</db:section>
<db:section xml:id="firstIndex">
<db:title>qsizetype QContiguousCache::firstIndex() const</db:title>
<db:para>Returns the first valid index in the cache. The index will be invalid if the cache is empty.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qcontiguouscache.xml#capacity">capacity</db:link>()</db:member>
<db:member><db:link xlink:href="qcontiguouscache.xml#size">size</db:link>()</db:member>
<db:member><db:link xlink:href="qcontiguouscache.xml#lastIndex">lastIndex</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="insert">
<db:title>void QContiguousCache::insert(qsizetype <db:emphasis>i</db:emphasis>, const T &amp;<db:emphasis>value</db:emphasis>)</db:title>
<db:para>Inserts the <db:code role="parameter">value</db:code> at the index position <db:code role="parameter">i</db:code>. If the cache already contains an item at <db:code role="parameter">i</db:code> then that value is replaced. If <db:code role="parameter">i</db:code> is either one more than <db:link xlink:href="qcontiguouscache.xml#lastIndex">lastIndex</db:link>() or one less than <db:link xlink:href="qcontiguouscache.xml#firstIndex">firstIndex</db:link>() it is the equivalent to an <db:link xlink:href="qcontiguouscache.xml#append">append</db:link>() or a <db:link xlink:href="qcontiguouscache.xml#prepend">prepend</db:link>().</db:para>
<db:para>If the given index <db:code role="parameter">i</db:code> is not within the current range of the cache nor adjacent to the bounds of the cache's index range, the cache is first cleared before inserting the item. At this point the cache will have a size of 1. It is worthwhile taking effort to insert items in an order that starts adjacent to the current index range for the cache.</db:para>
<db:para>The range of valid indexes for the <db:link xlink:href="qcontiguouscache.xml">QContiguousCache</db:link> class are from 0 to INT_MAX. Inserting outside of this range has undefined behavior.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qcontiguouscache.xml#prepend">prepend</db:link>()</db:member>
<db:member><db:link xlink:href="qcontiguouscache.xml#append">append</db:link>()</db:member>
<db:member><db:link xlink:href="qcontiguouscache.xml#isFull">isFull</db:link>()</db:member>
<db:member><db:link xlink:href="qcontiguouscache.xml#firstIndex">firstIndex</db:link>()</db:member>
<db:member><db:link xlink:href="qcontiguouscache.xml#lastIndex">lastIndex</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="isEmpty">
<db:title>bool QContiguousCache::isEmpty() const</db:title>
<db:para>Returns true if no items are stored within the cache.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qcontiguouscache.xml#size">size</db:link>()</db:member>
<db:member><db:link xlink:href="qcontiguouscache.xml#capacity">capacity</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="isFull">
<db:title>bool QContiguousCache::isFull() const</db:title>
<db:para>Returns true if the number of items stored within the cache is equal to the capacity of the cache.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qcontiguouscache.xml#size">size</db:link>()</db:member>
<db:member><db:link xlink:href="qcontiguouscache.xml#capacity">capacity</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="last">
<db:title>T &amp;QContiguousCache::last()</db:title>
<db:para>Returns a reference to the last item in the cache. This function assumes that the cache isn't empty.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qcontiguouscache.xml#first">first</db:link>()</db:member>
<db:member><db:link xlink:href="qcontiguouscache.xml#isEmpty">isEmpty</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="last-1">
<db:title>const T &amp;QContiguousCache::last() const</db:title>
<db:para>This is an overloaded function.</db:para>
</db:section>
<db:section xml:id="lastIndex">
<db:title>qsizetype QContiguousCache::lastIndex() const</db:title>
<db:para>Returns the last valid index in the cache. The index will be invalid if the cache is empty.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qcontiguouscache.xml#capacity">capacity</db:link>()</db:member>
<db:member><db:link xlink:href="qcontiguouscache.xml#size">size</db:link>()</db:member>
<db:member><db:link xlink:href="qcontiguouscache.xml#firstIndex">firstIndex</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="normalizeIndexes">
<db:title>void QContiguousCache::normalizeIndexes()</db:title>
<db:para>Moves the first index and last index of the cache such that they point to valid indexes. The function does not modify the contents of the cache or the ordering of elements within the cache.</db:para>
<db:para>It is provided so that index overflows can be corrected when using the cache as a circular buffer.</db:para>
<db:programlisting language="cpp">QContiguousCache&lt;int&gt; cache(10);
cache.insert(INT_MAX, 1); // cache contains one value and has valid indexes, INT_MAX to INT_MAX
cache.append(2); // cache contains two values but does not have valid indexes.
cache.normalizeIndexes(); // cache has two values, 1 and 2.  New first index will be in the range of 0 to capacity().
</db:programlisting>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qcontiguouscache.xml#areIndexesValid">areIndexesValid</db:link>()</db:member>
<db:member><db:link xlink:href="qcontiguouscache.xml#append">append</db:link>()</db:member>
<db:member><db:link xlink:href="qcontiguouscache.xml#prepend">prepend</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="prepend">
<db:title>void QContiguousCache::prepend(const T &amp;<db:emphasis>value</db:emphasis>)</db:title>
<db:para>Inserts <db:code role="parameter">value</db:code> at the start of the cache. If the cache is already full the item at the end of the cache will be removed.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qcontiguouscache.xml#append">append</db:link>()</db:member>
<db:member><db:link xlink:href="qcontiguouscache.xml#insert">insert</db:link>()</db:member>
<db:member><db:link xlink:href="qcontiguouscache.xml#isFull">isFull</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="removeFirst">
<db:title>void QContiguousCache::removeFirst()</db:title>
<db:para>Removes the first item from the cache. This function assumes that the cache isn't empty.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qcontiguouscache.xml#removeLast">removeLast</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="removeLast">
<db:title>void QContiguousCache::removeLast()</db:title>
<db:para>Removes the last item from the cache. This function assumes that the cache isn't empty.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qcontiguouscache.xml#removeFirst">removeFirst</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setCapacity">
<db:title>void QContiguousCache::setCapacity(qsizetype <db:emphasis>size</db:emphasis>)</db:title>
<db:para>Sets the capacity of the cache to the given <db:code role="parameter">size</db:code>. A cache can hold a number of items equal to its capacity. When inserting, appending or prepending items to the cache, if the cache is already full then the item farthest from the added item will be removed.</db:para>
<db:para>If the given <db:code role="parameter">size</db:code> is smaller than the current count of items in the cache then only the last <db:code role="parameter">size</db:code> items from the cache will remain.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qcontiguouscache.xml#capacity">capacity</db:link>()</db:member>
<db:member><db:link xlink:href="qcontiguouscache.xml#isFull">isFull</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="size">
<db:title>qsizetype QContiguousCache::size() const</db:title>
<db:para>Returns the number of items contained within the cache.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qcontiguouscache.xml#capacity">capacity</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="swap">
<db:title>[noexcept] void QContiguousCache::swap(QContiguousCache&lt;T&gt; &amp;<db:emphasis>other</db:emphasis>)</db:title>
<db:para>Swaps this cache with <db:code role="parameter">other</db:code>. This operation is very fast and never fails.</db:para>
</db:section>
<db:section xml:id="takeFirst">
<db:title>T QContiguousCache::takeFirst()</db:title>
<db:para>Removes the first item in the cache and returns it. This function assumes that the cache isn't empty.</db:para>
<db:para>If you don't use the return value, <db:link xlink:href="qcontiguouscache.xml#removeFirst">removeFirst</db:link>() is more efficient.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qcontiguouscache.xml#takeLast">takeLast</db:link>()</db:member>
<db:member><db:link xlink:href="qcontiguouscache.xml#removeFirst">removeFirst</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="takeLast">
<db:title>T QContiguousCache::takeLast()</db:title>
<db:para>Removes the last item in the cache and returns it. This function assumes that the cache isn't empty.</db:para>
<db:para>If you don't use the return value, <db:link xlink:href="qcontiguouscache.xml#removeLast">removeLast</db:link>() is more efficient.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qcontiguouscache.xml#takeFirst">takeFirst</db:link>()</db:member>
<db:member><db:link xlink:href="qcontiguouscache.xml#removeLast">removeLast</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="operator-not-eq">
<db:title>bool QContiguousCache::operator!=(const QContiguousCache&lt;T&gt; &amp;<db:emphasis>other</db:emphasis>) const</db:title>
<db:para>Returns true if <db:code role="parameter">other</db:code> is not equal to this cache; otherwise returns false.</db:para>
<db:para>Two caches are considered equal if they contain the same values at the same indexes. This function requires the value type to implement the operator==().</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qcontiguouscache.xml#operator-eq-eq">operator==</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="operator-eq">
<db:title>[noexcept] QContiguousCache&lt;T&gt; &amp;QContiguousCache::operator=(QContiguousCache&lt;T&gt; &amp;&amp;<db:emphasis>other</db:emphasis>)</db:title>
<db:para>Move-assigns <db:code role="parameter">other</db:code> to this <db:link xlink:href="qcontiguouscache.xml">QContiguousCache</db:link> instance.</db:para>
</db:section>
<db:section xml:id="operator-eq-1">
<db:title>QContiguousCache&lt;T&gt; &amp;QContiguousCache::operator=(const QContiguousCache&lt;T&gt; &amp;<db:emphasis>other</db:emphasis>)</db:title>
<db:para>Assigns <db:code role="parameter">other</db:code> to this cache and returns a reference to this cache.</db:para>
</db:section>
<db:section xml:id="operator-eq-eq">
<db:title>bool QContiguousCache::operator==(const QContiguousCache&lt;T&gt; &amp;<db:emphasis>other</db:emphasis>) const</db:title>
<db:para>Returns true if <db:code role="parameter">other</db:code> is equal to this cache; otherwise returns false.</db:para>
<db:para>Two caches are considered equal if they contain the same values at the same indexes. This function requires the value type to implement the operator==().</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qcontiguouscache.xml#operator-not-eq">operator!=</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="operator-5b-5d">
<db:title>T &amp;QContiguousCache::operator[](qsizetype <db:emphasis>i</db:emphasis>)</db:title>
<db:para>Returns the item at index position <db:code role="parameter">i</db:code> as a modifiable reference. If the cache does not contain an item at the given index position <db:code role="parameter">i</db:code> then it will first insert an empty item at that position.</db:para>
<db:para>In most cases it is better to use either <db:link xlink:href="qcontiguouscache.xml#at">at</db:link>() or <db:link xlink:href="qcontiguouscache.xml#insert">insert</db:link>().</db:para>
<db:note>
<db:para>This non-const overload of operator[] requires <db:link xlink:href="qcontiguouscache.xml">QContiguousCache</db:link> to make a deep copy. Use <db:link xlink:href="qcontiguouscache.xml#at">at</db:link>() for read-only access to a non-const <db:link xlink:href="qcontiguouscache.xml">QContiguousCache</db:link>.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qcontiguouscache.xml#insert">insert</db:link>()</db:member>
<db:member><db:link xlink:href="qcontiguouscache.xml#at">at</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="operator-5b-5d-1">
<db:title>const T &amp;QContiguousCache::operator[](qsizetype <db:emphasis>i</db:emphasis>) const</db:title>
<db:para>This is an overloaded function.</db:para>
<db:para>Same as at(<db:code role="parameter">i</db:code>).</db:para>
</db:section>
</db:section>
</db:article>
