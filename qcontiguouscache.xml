<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en">
<db:info>
<db:title>QContiguousCache Class</db:title>
<db:subtitle>template &lt;typename T&gt; class QContiguousCache</db:subtitle>
<db:productname>QtCore</db:productname>
<db:edition>Qt 5.5.1 Reference Documentation</db:edition>
<db:titleabbrev>Qt Core Reference Documentation</db:titleabbrev>
<db:abstract>
<db:para>The <db:link xlink:href="qcontiguouscache.xml">QContiguousCache</db:link> class is a template class that provides a contiguous cache.</db:para>
<db:para>This class was introduced in Qt 4.6.</db:para>
<db:note>
<db:para>All functions in this class are reentrant.</db:para>
</db:note>
</db:abstract>
<db:pubdate>2025-06-29</db:pubdate>
<db:date>2025-06-29</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:variablelist>
<db:varlistentry>
<db:term>Header</db:term>
<db:listitem>
<db:para>QContiguousCache</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Since</db:term>
<db:listitem>
<db:para>Qt 4.6</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>qmake</db:term>
<db:listitem>
<db:para>QT += core</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Group</db:term>
<db:listitem>
<db:para>QContiguousCache is part of <db:simplelist><db:member>tools</db:member><db:member><db:link xlink:href="shared.xml">Implicitly Shared Classes</db:link></db:member></db:simplelist>
</db:para>
</db:listitem>
</db:varlistentry>
</db:variablelist>
<db:section xml:id="details">
<db:title>Detailed Description</db:title>
<db:para>The <db:link xlink:href="qcontiguouscache.xml">QContiguousCache</db:link> class provides an efficient way of caching items for display in a user interface view. Unlike <db:link xlink:href="qcache.xml">QCache</db:link>, it adds a restriction that elements within the cache are contiguous. This has the advantage of matching how user interface views most commonly request data, as a set of rows localized around the current scrolled position. This restriction allows the cache to consume less memory and processor cycles than <db:link xlink:href="qcache.xml">QCache</db:link>.</db:para>
<db:para><db:link xlink:href="qcontiguouscache.xml">QContiguousCache</db:link> operates on a fixed capacity, set with setCapacity() or passed as a parameter to the constructor. This capacity is the upper bound on memory usage by the cache itself, not including the memory allocated by the elements themselves. Note that a cache with a capacity of zero (the default) means no items will be stored: the insert(), append() and prepend() operations will effectively be no-ops. Therefore, it's important to set the capacity to a reasonable value before adding items to the cache.</db:para>
<db:para>The simplest way of using a contiguous cache is to use the append() and prepend().</db:para>
<db:programlisting language="cpp">MyRecord record(int row) const
{
    Q_ASSERT(row &gt;= 0 &amp;&amp; row &lt; count());

    while(row &gt; cache.lastIndex())
        cache.append(slowFetchRecord(cache.lastIndex()+1));
    while(row &lt; cache.firstIndex())
        cache.prepend(slowFetchRecord(cache.firstIndex()-1));

    return cache.at(row);
}
</db:programlisting>
<db:para>If the cache is full then the item at the opposite end of the cache from where the new item is appended or prepended will be removed.</db:para>
<db:para>This usage can be further optimized by using the insert() function in the case where the requested row is a long way from the currently cached items. If there is a gap between where the new item is inserted and the currently cached items then the existing cached items are first removed to retain the contiguous nature of the cache. Hence it is important to take some care then when using insert() in order to avoid unwanted clearing of the cache.</db:para>
<db:para>The range of valid indexes for the <db:link xlink:href="qcontiguouscache.xml">QContiguousCache</db:link> class are from 0 to INT_MAX. Calling prepend() such that the first index would become less than 0 or append() such that the last index would become greater than INT_MAX can result in the indexes of the cache being invalid. When the cache indexes are invalid it is important to call normalizeIndexes() before calling any of containsIndex(), firstIndex(), lastIndex(), at() or <db:link xlink:href="">operator[]()</db:link>. Calling these functions when the cache has invalid indexes will result in undefined behavior. The indexes can be checked by using areIndexesValid()</db:para>
<db:para>In most cases the indexes will not exceed 0 to INT_MAX, and normalizeIndexes() will not need to be used.</db:para>
<db:para>See the <db:link xlink:href="qtcore-tools-contiguouscache-example.xml">Contiguous Cache</db:link> example.</db:para>
</db:section>
</db:article>
