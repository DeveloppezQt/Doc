<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en">
<db:info>
<db:title>Interaction Example</db:title>
<db:productname>QtCanvas3D</db:productname>
<db:edition>Qt 5.5.1 Reference Documentation</db:edition>
<db:titleabbrev>QtCanvas3D Reference Documentation</db:titleabbrev>
<db:abstract>
<db:para>Interact with an object in canvas using Qt Quick Controls.</db:para>
<db:para>This documentation was introduced in QtCanvas3D 1.0.</db:para>
</db:abstract>
<db:pubdate>2025-06-29</db:pubdate>
<db:date>2025-06-29</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:programlisting language="cpp">/****************************************************************************
**
** Copyright (C) 2015 The Qt Company Ltd.
** Contact: http://www.qt.io/licensing/
**
** This file is part of the QtCanvas3D module of the Qt Toolkit.
**
** $QT_BEGIN_LICENSE:LGPL3$
** Commercial License Usage
** Licensees holding valid commercial Qt licenses may use this file in
** accordance with the commercial license agreement provided with the
** Software or, alternatively, in accordance with the terms contained in
** a written agreement between you and The Qt Company. For licensing terms
** and conditions see http://www.qt.io/terms-conditions. For further
** information use the contact form at http://www.qt.io/contact-us.
**
** GNU Lesser General Public License Usage
** Alternatively, this file may be used under the terms of the GNU Lesser
** General Public License version 3 as published by the Free Software
** Foundation and appearing in the file LICENSE.LGPLv3 included in the
** packaging of this file. Please review the following information to
** ensure the GNU Lesser General Public License version 3 requirements
** will be met: https://www.gnu.org/licenses/lgpl.html.
**
** GNU General Public License Usage
** Alternatively, this file may be used under the terms of the GNU
** General Public License version 2.0 or later as published by the Free
** Software Foundation and appearing in the file LICENSE.GPL included in
** the packaging of this file. Please review the following information to
** ensure the GNU General Public License version 2.0 requirements will be
** met: http://www.gnu.org/licenses/gpl-2.0.html.
**
** $QT_END_LICENSE$
**
****************************************************************************/

Qt.include(&quot;gl-matrix.js&quot;)
Qt.include(&quot;ThreeJSLoader.js&quot;)

var gl;

var texturedShaderProgram = 0;
var vertexShader = 0;
var fragmentShader = 0;

var vertexPositionAttribute;
var textureCoordAttribute;
var vertexNormalAttribute;

var pMatrixUniform;
var mvMatrixUniform;
var nMatrixUniform;
var textureSamplerUniform;

var barrelTexture = 0;

var mvMatrix = mat4.create();
var pMatrix  = mat4.create();
var nMatrix  = mat4.create();
var startTime;

var canvas3d;
var isLogEnabled = false;

function log(message) {
    if (isLogEnabled)
        console.log(message)
}

function Model() {
    this.verticesVBO = 0;
    this.normalsVBO  = 0;
    this.texCoordVBO = 0;
    this.indexVBO    = 0;
    this.count       = 0;
}

var theModel = new Model();

function initializeGL(canvas) {
    canvas3d = canvas
    log(&quot;*******************************************************************************************&quot;)
    log(&quot;initializeGL ENTER...&quot;)
    try {
        startTime = Date.now();

        // Get the OpenGL context jsonObj that represents the API we call
        log(&quot;Getting Context&quot;);
        gl = canvas.getContext(&quot;canvas3d&quot;, {depth:true, antialias:true});
        log(&quot;Context received &quot;+gl);

        var contextConfig = gl.getContextAttributes();
        log(&quot;Depth: &quot;+contextConfig.alpha);
        log(&quot;Stencil: &quot;+contextConfig.stencil);
        log(&quot;Antialiasing: &quot;+contextConfig.antialias);
        log(&quot;Premultiplied alpha: &quot;+contextConfig.premultipliedAlpha);
        log(&quot;Preserve drawingbuffer: &quot;+contextConfig.preserveDrawingBuffer);
        log(&quot;Prefer Low Power To High Performance: &quot;+contextConfig.preferLowPowerToHighPerformance);
        log(&quot;Fail If Major Performance Caveat: &quot;+contextConfig.failIfMajorPerformanceCaveat);

        // Setup the OpenGL state
        gl.enable(gl.DEPTH_TEST);
        gl.enable(gl.CULL_FACE);

        gl.frontFace(gl.CCW);
        gl.cullFace(gl.BACK);

        gl.disable(gl.BLEND);

        gl.clearColor(0.98, 0.98, 0.98, 1.0);
        gl.clearDepth(1.0);

        // Set viewport
        gl.viewport(0, 0,
                    canvas.width * canvas.devicePixelRatio,
                    canvas.height * canvas.devicePixelRatio);

        // Initialize the shader program
        initShaders();

        // Initialize buffers
        theModel.verticesVBO = gl.createBuffer();
        theModel.verticesVBO.name = &quot;BarrelModel.verticesVBO&quot;;
        theModel.normalsVBO = gl.createBuffer();
        theModel.normalsVBO.name = &quot;BarrelModel.normalsVBO&quot;;
        theModel.texCoordVBO = gl.createBuffer();
        theModel.texCoordVBO.name = &quot;BarrelModel.texCoordVBO&quot;;
        theModel.indexVBO = gl.createBuffer();
        theModel.indexVBO.name = &quot;BarrelModel.indexVBO&quot;;

        // Load the barrel texture
        gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
        // Load the Qt logo as texture
        var barrelImage = TextureImageFactory.newTexImage();
        barrelImage.imageLoaded.connect(function() {
            barrelTexture = gl.createTexture();
            barrelTexture.name = &quot;barrelTexture&quot;
            gl.bindTexture(gl.TEXTURE_2D, barrelTexture);
            gl.texImage2D(gl.TEXTURE_2D,    // target
                          0,                // level
                          gl.RGBA,          // internalformat
                          gl.RGBA,          // format
                          gl.UNSIGNED_BYTE, // type
                          barrelImage);     // pixels

            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_NEAREST);
            gl.generateMipmap(gl.TEXTURE_2D);
        });
        barrelImage.imageLoadingFailed.connect(function() {
            console.log(&quot;Texture load FAILED, &quot;+barrelImage.errorString);
        });
        // Aliasing doesn't work correctly with QtQuick compiler for some reason,
        // so use full names for barrel.jpg and barrel.json
        barrelImage.src = &quot;qrc:/qml/interaction/barrel.jpg&quot;;

        // Load the model
        log(&quot;    Create XMLHttpRequest&quot;)
        var request = new XMLHttpRequest();
        log(&quot;    XMLHttpRequest.open&quot;)
        request.open(&quot;GET&quot;, &quot;qrc:/qml/interaction/barrel.json&quot;);
        log(&quot;    XMLHttpRequest.onreadystatechange&quot;)
        request.onreadystatechange = function () {
            if (request.readyState === XMLHttpRequest.DONE) {
                handleLoadedModel(JSON.parse(request.responseText));
            }
        }
        log(&quot;    XMLHttpRequest.send&quot;)
        request.send();

        log(&quot;...initializeGL EXIT&quot;);
    } catch(e) {
        console.log(&quot;...initializeGL FAILURE!&quot;);
        console.log(&quot;&quot;+e);
        console.log(&quot;&quot;+e.message);
    }
    log(&quot;*******************************************************************************************&quot;);
}

function resizeGL(canvas)
{
    var pixelRatio = canvas.devicePixelRatio;
    canvas.pixelSize = Qt.size(canvas.width * pixelRatio,
                               canvas.height * pixelRatio);
    if (gl)
        gl.viewport(0, 0,
                    canvas.width * canvas.devicePixelRatio,
                    canvas.height * canvas.devicePixelRatio);
}

function paintGL(canvas) {
    // draw
    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

    // draw only when we have the mesh and texture
    if (theModel.count &lt;= 0 || barrelTexture == 0) return;

    gl.useProgram(texturedShaderProgram);

    // Calculate the perspective projection
    mat4.perspective(pMatrix, degToRad(45), canvas.width / canvas.height, 0.1, 10000.0);
    gl.uniformMatrix4fv(pMatrixUniform, false, pMatrix);

    // Bind the correct buffers
    gl.bindBuffer(gl.ARRAY_BUFFER, theModel.verticesVBO);
    gl.enableVertexAttribArray(vertexPositionAttribute);
    gl.vertexAttribPointer(vertexPositionAttribute, 3, gl.FLOAT, false, 0, 0);

    gl.bindBuffer(gl.ARRAY_BUFFER, theModel.normalsVBO);
    gl.enableVertexAttribArray(vertexNormalAttribute);
    gl.vertexAttribPointer(vertexNormalAttribute, 3, gl.FLOAT, false, 0, 0);

    gl.bindBuffer(gl.ARRAY_BUFFER, theModel.texCoordVBO);
    gl.enableVertexAttribArray(textureCoordAttribute);
    gl.vertexAttribPointer(textureCoordAttribute, 2, gl.FLOAT, false, 0, 0);

    gl.activeTexture(gl.TEXTURE0);
    gl.bindTexture(gl.TEXTURE_2D, barrelTexture);
    gl.uniform1i(textureSamplerUniform, 0);

    // Calculate and apply the modelview matrix
    mvMatrix = mat4.identity(mvMatrix);
    mvMatrix = mat4.translate(mvMatrix, mvMatrix, [0, -40, -700]);
    mvMatrix = mat4.rotate(mvMatrix, mvMatrix, degToRad(canvas.xRotSlider), [1, 0, 0]);
    mvMatrix = mat4.rotate(mvMatrix, mvMatrix, degToRad(canvas.yRotSlider), [0, 1, 0]);
    mvMatrix = mat4.rotate(mvMatrix, mvMatrix, degToRad(canvas.zRotSlider), [0, 0, 1]);
    gl.uniformMatrix4fv(mvMatrixUniform, false, mvMatrix);

    // Calculate normal matrix
    nMatrix = mat4.invert(nMatrix, mvMatrix);
    nMatrix = mat4.transpose(nMatrix, nMatrix);
    gl.uniformMatrix4fv(nMatrixUniform, false, nMatrix);

    // Draw the barrel
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, theModel.indexVBO);
    gl.drawElements(gl.TRIANGLES, theModel.count, gl.UNSIGNED_SHORT, 0);

    // Calculate and apply the modelview matrix
    mvMatrix = mat4.identity(mvMatrix);
    mvMatrix = mat4.translate(mvMatrix, mvMatrix, [-250, -50, -700]);
    mvMatrix = mat4.rotate(mvMatrix, mvMatrix, degToRad(canvas.xRotSlider), [0, 1, 0]);
    gl.uniformMatrix4fv(mvMatrixUniform, false, mvMatrix);

    // Calculate normal matrix
    nMatrix = mat4.invert(nMatrix, mvMatrix);
    nMatrix = mat4.transpose(nMatrix, nMatrix);
    gl.uniformMatrix4fv(nMatrixUniform, false, nMatrix);

    // Draw the barrel
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, theModel.indexVBO);
    gl.drawElements(gl.POINTS, theModel.count, gl.UNSIGNED_SHORT, 0);

    // Calculate and apply the modelview matrix
    mvMatrix = mat4.identity(mvMatrix);
    mvMatrix = mat4.translate(mvMatrix, mvMatrix, [250, -50, -700]);
    mvMatrix = mat4.rotate(mvMatrix, mvMatrix, degToRad(canvas.zRotSlider), [0, 1, 0]);
    gl.uniformMatrix4fv(mvMatrixUniform, false, mvMatrix);

    // Calculate normal matrix
    nMatrix = mat4.invert(nMatrix, mvMatrix);
    nMatrix = mat4.transpose(nMatrix, nMatrix);
    gl.uniformMatrix4fv(nMatrixUniform, false, nMatrix);

    // Draw the barrel
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, theModel.indexVBO);
    gl.drawElements(gl.LINES, theModel.count, gl.UNSIGNED_SHORT, 0);
}

function handleLoadedModel(jsonObj) {
    log(&quot;*******************************************************************************************&quot;);
    log(&quot;handleLoadedModel ENTER...&quot;)
    var modelData = parseJSON3DModel(jsonObj, &quot;&quot;);

    log(&quot;    &quot;+theModel.verticesVBO);
    gl.bindBuffer(gl.ARRAY_BUFFER, theModel.verticesVBO);
    gl.bufferData(gl.ARRAY_BUFFER,
                  new Float32Array(modelData.vertices),
                  gl.STATIC_DRAW);

    log(&quot;    &quot;+theModel.normalsVBO);
    gl.bindBuffer(gl.ARRAY_BUFFER, theModel.normalsVBO);
    gl.bufferData(gl.ARRAY_BUFFER,
                  new Float32Array(modelData.normals),
                  gl.STATIC_DRAW);

    log(&quot;    &quot;+theModel.texCoordVBO);
    gl.bindBuffer(gl.ARRAY_BUFFER, theModel.texCoordVBO);
    gl.bufferData(gl.ARRAY_BUFFER,
                  new Float32Array(modelData.texCoords[0]),
                  gl.STATIC_DRAW);

    log(&quot;    &quot;+theModel.indexVBO);
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, theModel.indexVBO);
    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER,
                  new Uint16Array(modelData.indices),
                  gl.STATIC_DRAW);

    theModel.count = modelData.indices.length;
    log(&quot;...handleLoadedModel EXIT&quot;);
    log(&quot;*******************************************************************************************&quot;);
}

function degToRad(degrees) {
    return degrees * Math.PI / 180;
}

function initShaders()
{
    log(&quot;    initShaders ENTER...&quot;)

    vertexShader = getShader(gl,
                             &quot;attribute highp vec3 aVertexNormal;       \
                              attribute highp vec3 aVertexPosition;     \
                              attribute highp vec2 aTextureCoord;       \
                                                                        \
                              uniform highp mat4 uNormalMatrix;         \
                              uniform mat4 uMVMatrix;                   \
                              uniform mat4 uPMatrix;                    \
                                                                        \
                              varying highp vec2 vTextureCoord;         \
                              varying highp vec3 vLighting;             \
                                                                        \
                              void main(void) {                         \
                                 gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); \
                                 vTextureCoord = aTextureCoord;                                   \
                                 highp vec3 ambientLight = vec3(0.5, 0.5, 0.5);                   \
                                 highp vec3 directionalLightColor = vec3(0.75, 0.75, 0.75);       \
                                 highp vec3 directionalVector = vec3(0.85, 0.8, 0.75);            \
                                 highp vec4 transformedNormal = uNormalMatrix * vec4(aVertexNormal, 1.0); \
                                                                                                          \
                                 highp float directional = max(dot(transformedNormal.xyz, directionalVector), 0.0); \
                                 vLighting = ambientLight + (directionalLightColor * directional);                  \
                                 gl_PointSize = 1.0; \
                             }&quot;, gl.VERTEX_SHADER);

    fragmentShader = getShader(gl,
                               &quot;varying highp vec2 vTextureCoord;             \
                                varying highp vec3 vLighting;                 \
                                                                              \
                                uniform sampler2D uSampler;                   \
                                                                              \
                                void main(void) {                             \
                                    mediump vec4 texelColor = texture2D(uSampler, vec2(vTextureCoord.s, vTextureCoord.t));  \
                                    gl_FragColor = vec4(texelColor.rgb * vLighting, 1.0);                                   \
                                }&quot;, gl.FRAGMENT_SHADER);

    texturedShaderProgram = gl.createProgram();
    texturedShaderProgram.name = &quot;TexturedShaderProgram&quot;;
    gl.attachShader(texturedShaderProgram, vertexShader);
    gl.attachShader(texturedShaderProgram, fragmentShader);
    gl.linkProgram(texturedShaderProgram);

    if (!gl.getProgramParameter(texturedShaderProgram, gl.LINK_STATUS)) {
        console.log(&quot;Could not initialize shaders&quot;);
        console.log(gl.getProgramInfoLog(texturedShaderProgram));
    }

    gl.useProgram(texturedShaderProgram);

    // look up where the vertex data needs to go.
    vertexPositionAttribute = gl.getAttribLocation(texturedShaderProgram, &quot;aVertexPosition&quot;);
    vertexPositionAttribute.name = &quot;aVertexPosition_AttribLocation&quot;;
    gl.enableVertexAttribArray(vertexPositionAttribute);
    vertexNormalAttribute = gl.getAttribLocation(texturedShaderProgram, &quot;aVertexNormal&quot;);
    vertexPositionAttribute.name = &quot;aVertexNormal_AttribLocation&quot;;
    gl.enableVertexAttribArray(vertexNormalAttribute);
    textureCoordAttribute = gl.getAttribLocation(texturedShaderProgram, &quot;aTextureCoord&quot;);
    vertexPositionAttribute.name = &quot;aTextureCoord_AttribLocation&quot;;
    gl.enableVertexAttribArray(textureCoordAttribute);

    pMatrixUniform  = gl.getUniformLocation(texturedShaderProgram, &quot;uPMatrix&quot;);
    pMatrixUniform.name = &quot;uPMatrix_UniformLocation&quot;;
    mvMatrixUniform = gl.getUniformLocation(texturedShaderProgram, &quot;uMVMatrix&quot;);
    mvMatrixUniform.name = &quot;uMVMatrix_UniformLocation&quot;;
    textureSamplerUniform = gl.getUniformLocation(texturedShaderProgram, &quot;uSampler&quot;)
    textureSamplerUniform.name = &quot;uSampler_UniformLocation&quot;;
    nMatrixUniform = gl.getUniformLocation(texturedShaderProgram, &quot;uNormalMatrix&quot;);
    nMatrixUniform.name = &quot;uNormalMatrix_UniformLocation&quot;;
    log(&quot;    ... initShaders EXIT&quot;);
}

function getShader(gl, str, type) {
    var shader = gl.createShader(type);
    gl.shaderSource(shader, str);
    gl.compileShader(shader);

    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
        console.log(&quot;JS:Shader compile failed&quot;);
        console.log(gl.getShaderInfoLog(shader));
        return null;
    }

    return shader;
}

</db:programlisting>
</db:article>
