<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en">
<db:info>
<db:title>QAbstractSocket Class</db:title>
<db:productname>QtNetwork</db:productname>
<db:edition>Qt 6.1.3 Reference Documentation</db:edition>
<db:titleabbrev>Qt Network Reference Documentation</db:titleabbrev>
<db:abstract>
<db:para>The <db:link xlink:href="qabstractsocket.xml">QAbstractSocket</db:link> class provides the base functionality common to all socket types.</db:para>
<db:note>
<db:para>All functions in this class are <db:link xlink:href="threads-reentrancy.xml">reentrant</db:link>.</db:para>
</db:note>
</db:abstract>
<db:pubdate>2024-12-27</db:pubdate>
<db:date>2024-12-27</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:variablelist>
<db:varlistentry>
<db:term>Header</db:term>
<db:listitem>
<db:para>QAbstractSocket</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>CMake</db:term>
<db:listitem>
<db:para>find_package(Qt6 REQUIRED COMPONENTS Network)</db:para>
<db:para>target_link_libraries(mytarget PRIVATE Qt6::Network)</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>qmake</db:term>
<db:listitem>
<db:para>QT += network</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Inherits</db:term>
<db:listitem>
<db:para><db:link xlink:href="qiodevice.xml" xlink:role="class">QIODevice</db:link></db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Inherited By</db:term>
<db:listitem>
<db:para><db:link xlink:href="qtcpsocket.xml" xlink:role="class">QTcpSocket</db:link> and <db:link xlink:href="qudpsocket.xml" xlink:role="class">QUdpSocket</db:link></db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Group</db:term>
<db:listitem>
<db:para>QAbstractSocket is part of <db:simplelist><db:member><db:link xlink:href="network.xml">Network Programming API</db:link></db:member></db:simplelist></db:para>
</db:listitem>
</db:varlistentry>
</db:variablelist>
<db:section xml:id="details">
<db:title>Detailed Description</db:title>
<db:para><db:link xlink:href="qabstractsocket.xml">QAbstractSocket</db:link> is the base class for <db:link xlink:href="qtcpsocket.xml">QTcpSocket</db:link> and <db:link xlink:href="qudpsocket.xml">QUdpSocket</db:link> and contains all common functionality of these two classes. If you need a socket, you have two options:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para>Instantiate <db:link xlink:href="qtcpsocket.xml">QTcpSocket</db:link> or <db:link xlink:href="qudpsocket.xml">QUdpSocket</db:link>.</db:para>
</db:listitem>
<db:listitem>
<db:para>Create a native socket descriptor, instantiate <db:link xlink:href="qabstractsocket.xml">QAbstractSocket</db:link>, and call <db:link xlink:href="qabstractsocket.xml#setSocketDescriptor">setSocketDescriptor</db:link>() to wrap the native socket.</db:para>
</db:listitem>
</db:itemizedlist>
<db:para>TCP (Transmission Control Protocol) is a reliable, stream-oriented, connection-oriented transport protocol. UDP (User Datagram Protocol) is an unreliable, datagram-oriented, connectionless protocol. In practice, this means that TCP is better suited for continuous transmission of data, whereas the more lightweight UDP can be used when reliability isn't important.</db:para>
<db:para><db:link xlink:href="qabstractsocket.xml">QAbstractSocket</db:link>'s API unifies most of the differences between the two protocols. For example, although UDP is connectionless, <db:link xlink:href="qabstractsocket.xml#connectToHost">connectToHost</db:link>() establishes a virtual connection for UDP sockets, enabling you to use <db:link xlink:href="qabstractsocket.xml">QAbstractSocket</db:link> in more or less the same way regardless of the underlying protocol. Internally, <db:link xlink:href="qabstractsocket.xml">QAbstractSocket</db:link> remembers the address and port passed to <db:link xlink:href="qabstractsocket.xml#connectToHost">connectToHost</db:link>(), and functions like <db:link xlink:href="qiodevice.xml#read">read</db:link>() and <db:link xlink:href="qiodevice.xml#write">write</db:link>() use these values.</db:para>
<db:para>At any time, <db:link xlink:href="qabstractsocket.xml">QAbstractSocket</db:link> has a state (returned by <db:link xlink:href="qabstractsocket.xml#state">state</db:link>()). The initial state is <db:link xlink:href="qabstractsocket.xml#SocketState-enum">UnconnectedState</db:link>. After calling <db:link xlink:href="qabstractsocket.xml#connectToHost">connectToHost</db:link>(), the socket first enters <db:link xlink:href="qabstractsocket.xml#SocketState-enum">HostLookupState</db:link>. If the host is found, <db:link xlink:href="qabstractsocket.xml">QAbstractSocket</db:link> enters <db:link xlink:href="qabstractsocket.xml#SocketState-enum">ConnectingState</db:link> and emits the <db:link xlink:href="qabstractsocket.xml#hostFound">hostFound</db:link>() signal. When the connection has been established, it enters <db:link xlink:href="qabstractsocket.xml#SocketState-enum">ConnectedState</db:link> and emits <db:link xlink:href="qabstractsocket.xml#connected">connected</db:link>(). If an error occurs at any stage, <db:link xlink:href="qabstractsocket.xml#errorOccurred">errorOccurred</db:link>() is emitted. Whenever the state changes, <db:link xlink:href="qabstractsocket.xml#stateChanged">stateChanged</db:link>() is emitted. For convenience, <db:link xlink:href="qabstractsocket.xml#isValid">isValid</db:link>() returns <db:code>true</db:code> if the socket is ready for reading and writing, but note that the socket's state must be <db:link xlink:href="qabstractsocket.xml#SocketState-enum">ConnectedState</db:link> before reading and writing can occur.</db:para>
<db:para>Read or write data by calling <db:link xlink:href="qiodevice.xml#read">read</db:link>() or <db:link xlink:href="qiodevice.xml#write">write</db:link>(), or use the convenience functions <db:link xlink:href="qiodevice.xml#readLine">readLine</db:link>() and <db:link xlink:href="qiodevice.xml#readAll">readAll</db:link>(). <db:link xlink:href="qabstractsocket.xml">QAbstractSocket</db:link> also inherits <db:link xlink:href="qiodevice.xml#getChar">getChar</db:link>(), <db:link xlink:href="qiodevice.xml#putChar">putChar</db:link>(), and <db:link xlink:href="qiodevice.xml#ungetChar">ungetChar</db:link>() from <db:link xlink:href="qiodevice.xml">QIODevice</db:link>, which work on single bytes. The <db:link xlink:href="qiodevice.xml#bytesWritten">bytesWritten</db:link>() signal is emitted when data has been written to the socket. Note that Qt does not limit the write buffer size. You can monitor its size by listening to this signal.</db:para>
<db:para>The <db:link xlink:href="qiodevice.xml#readyRead">readyRead</db:link>() signal is emitted every time a new chunk of data has arrived. <db:link xlink:href="qabstractsocket.xml#bytesAvailable">bytesAvailable</db:link>() then returns the number of bytes that are available for reading. Typically, you would connect the <db:link xlink:href="qiodevice.xml#readyRead">readyRead</db:link>() signal to a slot and read all available data there. If you don't read all the data at once, the remaining data will still be available later, and any new incoming data will be appended to <db:link xlink:href="qabstractsocket.xml">QAbstractSocket</db:link>'s internal read buffer. To limit the size of the read buffer, call <db:link xlink:href="qabstractsocket.xml#setReadBufferSize">setReadBufferSize</db:link>().</db:para>
<db:para>To close the socket, call <db:link xlink:href="qabstractsocket.xml#disconnectFromHost">disconnectFromHost</db:link>(). <db:link xlink:href="qabstractsocket.xml">QAbstractSocket</db:link> enters <db:link xlink:href="qabstractsocket.xml#SocketState-enum">QAbstractSocket::ClosingState</db:link>. After all pending data has been written to the socket, <db:link xlink:href="qabstractsocket.xml">QAbstractSocket</db:link> actually closes the socket, enters <db:link xlink:href="qabstractsocket.xml#SocketState-enum">QAbstractSocket::UnconnectedState</db:link>, and emits <db:link xlink:href="qabstractsocket.xml#disconnected">disconnected</db:link>(). If you want to abort a connection immediately, discarding all pending data, call <db:link xlink:href="qabstractsocket.xml#abort">abort</db:link>() instead. If the remote host closes the connection, <db:link xlink:href="qabstractsocket.xml">QAbstractSocket</db:link> will emit <db:link xlink:href="qabstractsocket.xml#errorOccurred">errorOccurred</db:link>(<db:link xlink:href="qabstractsocket.xml#SocketError-enum">QAbstractSocket::RemoteHostClosedError</db:link>), during which the socket state will still be <db:link xlink:href="qabstractsocket.xml#SocketState-enum">ConnectedState</db:link>, and then the <db:link xlink:href="qabstractsocket.xml#disconnected">disconnected</db:link>() signal will be emitted.</db:para>
<db:para>The port and address of the connected peer is fetched by calling <db:link xlink:href="qabstractsocket.xml#peerPort">peerPort</db:link>() and <db:link xlink:href="qabstractsocket.xml#peerAddress">peerAddress</db:link>(). <db:link xlink:href="qabstractsocket.xml#peerName">peerName</db:link>() returns the host name of the peer, as passed to <db:link xlink:href="qabstractsocket.xml#connectToHost">connectToHost</db:link>(). <db:link xlink:href="qabstractsocket.xml#localPort">localPort</db:link>() and <db:link xlink:href="qabstractsocket.xml#localAddress">localAddress</db:link>() return the port and address of the local socket.</db:para>
<db:para><db:link xlink:href="qabstractsocket.xml">QAbstractSocket</db:link> provides a set of functions that suspend the calling thread until certain signals are emitted. These functions can be used to implement blocking sockets:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:link xlink:href="qabstractsocket.xml#waitForConnected">waitForConnected</db:link>() blocks until a connection has been established.</db:para>
</db:listitem>
<db:listitem>
<db:para><db:link xlink:href="qabstractsocket.xml#waitForReadyRead">waitForReadyRead</db:link>() blocks until new data is available for reading.</db:para>
</db:listitem>
<db:listitem>
<db:para><db:link xlink:href="qabstractsocket.xml#waitForBytesWritten">waitForBytesWritten</db:link>() blocks until one payload of data has been written to the socket.</db:para>
</db:listitem>
<db:listitem>
<db:para><db:link xlink:href="qabstractsocket.xml#waitForDisconnected">waitForDisconnected</db:link>() blocks until the connection has closed.</db:para>
</db:listitem>
</db:itemizedlist>
<db:para>We show an example:</db:para>
<db:programlisting language="cpp">    int numRead = 0, numReadTotal = 0;
    char buffer[50];

    forever {
        numRead  = socket.read(buffer, 50);

        // do whatever with array

        numReadTotal += numRead;
        if (numRead == 0 &amp;amp;&amp;amp; !socket.waitForReadyRead())
            break;
    }
</db:programlisting>
<db:para>If <db:link xlink:href="qiodevice.xml#waitForReadyRead">waitForReadyRead</db:link>() returns <db:code>false</db:code>, the connection has been closed or an error has occurred.</db:para>
<db:para>Programming with a blocking socket is radically different from programming with a non-blocking socket. A blocking socket doesn't require an event loop and typically leads to simpler code. However, in a GUI application, blocking sockets should only be used in non-GUI threads, to avoid freezing the user interface. See the <db:link xlink:href="qtnetwork-fortuneclient-example.xml">fortuneclient</db:link> and <db:link xlink:href="qtnetwork-blockingfortuneclient-example.xml">blockingfortuneclient</db:link> examples for an overview of both approaches.</db:para>
<db:note>
<db:para>We discourage the use of the blocking functions together with signals. One of the two possibilities should be used.</db:para>
</db:note>
<db:para><db:link xlink:href="qabstractsocket.xml">QAbstractSocket</db:link> can be used with <db:link xlink:href="qtextstream.xml">QTextStream</db:link> and <db:link xlink:href="qdatastream.xml">QDataStream</db:link>'s stream operators (operator&lt;&lt;() and operator&gt;&gt;()). There is one issue to be aware of, though: You must make sure that enough data is available before attempting to read it using operator&gt;&gt;().</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qnetworkaccessmanager.xml">QNetworkAccessManager</db:link></db:member>
<db:member><db:link xlink:href="qtcpserver.xml">QTcpServer</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="member-type-documentation">
<db:title>Member Type Documentation</db:title>
<db:section xml:id="BindFlag-enum">
<db:title>[since 5.0] enum QAbstractSocket::BindFlag</db:title>
<db:bridgehead renderas="sect2">flags QAbstractSocket::BindMode</db:bridgehead>
<db:enumsynopsis>
<db:enumname>BindFlag</db:enumname>
<db:enumitem>
<db:enumidentifier>DefaultForPlatform</db:enumidentifier>
<db:enumvalue>0x0</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>ShareAddress</db:enumidentifier>
<db:enumvalue>0x1</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>DontShareAddress</db:enumidentifier>
<db:enumvalue>0x2</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>ReuseAddressHint</db:enumidentifier>
<db:enumvalue>0x4</db:enumvalue>
</db:enumitem>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:enumsynopsis>
<db:typedefsynopsis>
<db:typedefname>QAbstractSocket::BindMode</db:typedefname>
</db:typedefsynopsis>
<db:para>This enum describes the different flags you can pass to modify the behavior of <db:link xlink:href="qabstractsocket.xml#bind">QAbstractSocket::bind</db:link>().</db:para>
<db:informaltable>
<db:thead>
<db:tr>
<db:th>Constant</db:th>
<db:th>Value</db:th>
<db:th>Description</db:th>
</db:tr>
</db:thead>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qabstractsocket.xml">QAbstractSocket</db:link></db:emphasis>::ShareAddress</db:code></db:para>
</db:td>
<db:td><db:code>0x1</db:code></db:td>
<db:td>
<db:para>Allow other services to bind to the same address and port. This is useful when multiple processes share the load of a single service by listening to the same address and port (e.g., a web server with several pre-forked listeners can greatly improve response time). However, because any service is allowed to rebind, this option is subject to certain security considerations. Note that by combining this option with ReuseAddressHint, you will also allow your service to rebind an existing shared address. On Unix, this is equivalent to the SO_REUSEADDR socket option. On Windows, this is the default behavior, so this option is ignored.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qabstractsocket.xml">QAbstractSocket</db:link></db:emphasis>::DontShareAddress</db:code></db:para>
</db:td>
<db:td><db:code>0x2</db:code></db:td>
<db:td>
<db:para>Bind the address and port exclusively, so that no other services are allowed to rebind. By passing this option to <db:link xlink:href="qabstractsocket.xml#bind">QAbstractSocket::bind</db:link>(), you are guaranteed that on successs, your service is the only one that listens to the address and port. No services are allowed to rebind, even if they pass ReuseAddressHint. This option provides more security than ShareAddress, but on certain operating systems, it requires you to run the server with administrator privileges. On Unix and macOS, not sharing is the default behavior for binding an address and port, so this option is ignored. On Windows, this option uses the SO_EXCLUSIVEADDRUSE socket option.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qabstractsocket.xml">QAbstractSocket</db:link></db:emphasis>::ReuseAddressHint</db:code></db:para>
</db:td>
<db:td><db:code>0x4</db:code></db:td>
<db:td>
<db:para>Provides a hint to <db:link xlink:href="qabstractsocket.xml">QAbstractSocket</db:link> that it should try to rebind the service even if the address and port are already bound by another socket. On Windows and Unix, this is equivalent to the SO_REUSEADDR socket option.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qabstractsocket.xml">QAbstractSocket</db:link></db:emphasis>::DefaultForPlatform</db:code></db:para>
</db:td>
<db:td><db:code>0x0</db:code></db:td>
<db:td>
<db:para>The default option for the current platform. On Unix and macOS, this is equivalent to (DontShareAddress + ReuseAddressHint), and on Windows, it is equivalent to ShareAddress.</db:para>
</db:td>
</db:tr>
</db:informaltable>
<db:para>This enum was introduced or modified in Qt 5.0.</db:para>
<db:para>The <db:code>BindMode</db:code> type is a typedef for <db:code><db:link xlink:href="qflags.xml">QFlags</db:link>&lt;BindFlag&gt;. </db:code>It stores an OR combination of <db:code>BindFlag</db:code> values.</db:para>
</db:section>
<db:section xml:id="NetworkLayerProtocol-enum">
<db:title>enum QAbstractSocket::NetworkLayerProtocol</db:title>
<db:enumsynopsis>
<db:enumname>NetworkLayerProtocol</db:enumname>
<db:enumitem>
<db:enumidentifier>IPv4Protocol</db:enumidentifier>
<db:enumvalue>0</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>IPv6Protocol</db:enumidentifier>
<db:enumvalue>1</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>AnyIPProtocol</db:enumidentifier>
<db:enumvalue>2</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>UnknownNetworkLayerProtocol</db:enumidentifier>
<db:enumvalue>-1</db:enumvalue>
</db:enumitem>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:enumsynopsis>
<db:para>This enum describes the network layer protocol values used in Qt.</db:para>
<db:informaltable>
<db:thead>
<db:tr>
<db:th>Constant</db:th>
<db:th>Value</db:th>
<db:th>Description</db:th>
</db:tr>
</db:thead>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qabstractsocket.xml">QAbstractSocket</db:link></db:emphasis>::IPv4Protocol</db:code></db:para>
</db:td>
<db:td><db:code>0</db:code></db:td>
<db:td>
<db:para>IPv4</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qabstractsocket.xml">QAbstractSocket</db:link></db:emphasis>::IPv6Protocol</db:code></db:para>
</db:td>
<db:td><db:code>1</db:code></db:td>
<db:td>
<db:para>IPv6</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qabstractsocket.xml">QAbstractSocket</db:link></db:emphasis>::AnyIPProtocol</db:code></db:para>
</db:td>
<db:td><db:code>2</db:code></db:td>
<db:td>
<db:para>Either IPv4 or IPv6</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qabstractsocket.xml">QAbstractSocket</db:link></db:emphasis>::UnknownNetworkLayerProtocol</db:code></db:para>
</db:td>
<db:td><db:code>-1</db:code></db:td>
<db:td>
<db:para>Other than IPv4 and IPv6</db:para>
</db:td>
</db:tr>
</db:informaltable>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qhostaddress.xml#protocol">QHostAddress::protocol</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="PauseMode-enum">
<db:title>[since 5.0] enum QAbstractSocket::PauseMode</db:title>
<db:bridgehead renderas="sect2">flags QAbstractSocket::PauseModes</db:bridgehead>
<db:enumsynopsis>
<db:enumname>PauseMode</db:enumname>
<db:enumitem>
<db:enumidentifier>PauseNever</db:enumidentifier>
<db:enumvalue>0x0</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>PauseOnSslErrors</db:enumidentifier>
<db:enumvalue>0x1</db:enumvalue>
</db:enumitem>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:enumsynopsis>
<db:typedefsynopsis>
<db:typedefname>QAbstractSocket::PauseModes</db:typedefname>
</db:typedefsynopsis>
<db:para>This enum describes the behavior of when the socket should hold back with continuing data transfer. The only notification currently supported is <db:link xlink:href="qsslsocket.xml#sslErrors">QSslSocket::sslErrors</db:link>().</db:para>
<db:informaltable>
<db:thead>
<db:tr>
<db:th>Constant</db:th>
<db:th>Value</db:th>
<db:th>Description</db:th>
</db:tr>
</db:thead>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qabstractsocket.xml">QAbstractSocket</db:link></db:emphasis>::PauseNever</db:code></db:para>
</db:td>
<db:td><db:code>0x0</db:code></db:td>
<db:td>
<db:para>Do not pause data transfer on the socket. This is the default and matches the behavior of Qt 4.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qabstractsocket.xml">QAbstractSocket</db:link></db:emphasis>::PauseOnSslErrors</db:code></db:para>
</db:td>
<db:td><db:code>0x1</db:code></db:td>
<db:td>
<db:para>Pause data transfer on the socket upon receiving an SSL error notification. I.E. <db:link xlink:href="qsslsocket.xml#sslErrors">QSslSocket::sslErrors</db:link>().</db:para>
</db:td>
</db:tr>
</db:informaltable>
<db:para>This enum was introduced or modified in Qt 5.0.</db:para>
<db:para>The <db:code>PauseModes</db:code> type is a typedef for <db:code><db:link xlink:href="qflags.xml">QFlags</db:link>&lt;PauseMode&gt;. </db:code>It stores an OR combination of <db:code>PauseMode</db:code> values.</db:para>
</db:section>
<db:section xml:id="SocketError-enum">
<db:title>enum QAbstractSocket::SocketError</db:title>
<db:enumsynopsis>
<db:enumname>SocketError</db:enumname>
<db:enumitem>
<db:enumidentifier>ConnectionRefusedError</db:enumidentifier>
<db:enumvalue>0</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>RemoteHostClosedError</db:enumidentifier>
<db:enumvalue>1</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>HostNotFoundError</db:enumidentifier>
<db:enumvalue>2</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>SocketAccessError</db:enumidentifier>
<db:enumvalue>3</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>SocketResourceError</db:enumidentifier>
<db:enumvalue>4</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>SocketTimeoutError</db:enumidentifier>
<db:enumvalue>5</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>DatagramTooLargeError</db:enumidentifier>
<db:enumvalue>6</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>NetworkError</db:enumidentifier>
<db:enumvalue>7</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>AddressInUseError</db:enumidentifier>
<db:enumvalue>8</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>SocketAddressNotAvailableError</db:enumidentifier>
<db:enumvalue>9</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>UnsupportedSocketOperationError</db:enumidentifier>
<db:enumvalue>10</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>UnfinishedSocketOperationError</db:enumidentifier>
<db:enumvalue>11</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>ProxyAuthenticationRequiredError</db:enumidentifier>
<db:enumvalue>12</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>SslHandshakeFailedError</db:enumidentifier>
<db:enumvalue>13</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>ProxyConnectionRefusedError</db:enumidentifier>
<db:enumvalue>14</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>ProxyConnectionClosedError</db:enumidentifier>
<db:enumvalue>15</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>ProxyConnectionTimeoutError</db:enumidentifier>
<db:enumvalue>16</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>ProxyNotFoundError</db:enumidentifier>
<db:enumvalue>17</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>ProxyProtocolError</db:enumidentifier>
<db:enumvalue>18</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>OperationError</db:enumidentifier>
<db:enumvalue>19</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>SslInternalError</db:enumidentifier>
<db:enumvalue>20</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>SslInvalidUserDataError</db:enumidentifier>
<db:enumvalue>21</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>TemporaryError</db:enumidentifier>
<db:enumvalue>22</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>UnknownSocketError</db:enumidentifier>
<db:enumvalue>-1</db:enumvalue>
</db:enumitem>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:enumsynopsis>
<db:para>This enum describes the socket errors that can occur.</db:para>
<db:informaltable>
<db:thead>
<db:tr>
<db:th>Constant</db:th>
<db:th>Value</db:th>
<db:th>Description</db:th>
</db:tr>
</db:thead>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qabstractsocket.xml">QAbstractSocket</db:link></db:emphasis>::ConnectionRefusedError</db:code></db:para>
</db:td>
<db:td><db:code>0</db:code></db:td>
<db:td>
<db:para>The connection was refused by the peer (or timed out).</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qabstractsocket.xml">QAbstractSocket</db:link></db:emphasis>::RemoteHostClosedError</db:code></db:para>
</db:td>
<db:td><db:code>1</db:code></db:td>
<db:td>
<db:para>The remote host closed the connection. Note that the client socket (i.e., this socket) will be closed after the remote close notification has been sent.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qabstractsocket.xml">QAbstractSocket</db:link></db:emphasis>::HostNotFoundError</db:code></db:para>
</db:td>
<db:td><db:code>2</db:code></db:td>
<db:td>
<db:para>The host address was not found.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qabstractsocket.xml">QAbstractSocket</db:link></db:emphasis>::SocketAccessError</db:code></db:para>
</db:td>
<db:td><db:code>3</db:code></db:td>
<db:td>
<db:para>The socket operation failed because the application lacked the required privileges.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qabstractsocket.xml">QAbstractSocket</db:link></db:emphasis>::SocketResourceError</db:code></db:para>
</db:td>
<db:td><db:code>4</db:code></db:td>
<db:td>
<db:para>The local system ran out of resources (e.g., too many sockets).</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qabstractsocket.xml">QAbstractSocket</db:link></db:emphasis>::SocketTimeoutError</db:code></db:para>
</db:td>
<db:td><db:code>5</db:code></db:td>
<db:td>
<db:para>The socket operation timed out.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qabstractsocket.xml">QAbstractSocket</db:link></db:emphasis>::DatagramTooLargeError</db:code></db:para>
</db:td>
<db:td><db:code>6</db:code></db:td>
<db:td>
<db:para>The datagram was larger than the operating system's limit (which can be as low as 8192 bytes).</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qabstractsocket.xml">QAbstractSocket</db:link></db:emphasis>::NetworkError</db:code></db:para>
</db:td>
<db:td><db:code>7</db:code></db:td>
<db:td>
<db:para>An error occurred with the network (e.g., the network cable was accidentally plugged out).</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qabstractsocket.xml">QAbstractSocket</db:link></db:emphasis>::AddressInUseError</db:code></db:para>
</db:td>
<db:td><db:code>8</db:code></db:td>
<db:td>
<db:para>The address specified to <db:link xlink:href="qabstractsocket.xml#bind">QAbstractSocket::bind</db:link>() is already in use and was set to be exclusive.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qabstractsocket.xml">QAbstractSocket</db:link></db:emphasis>::SocketAddressNotAvailableError</db:code></db:para>
</db:td>
<db:td><db:code>9</db:code></db:td>
<db:td>
<db:para>The address specified to <db:link xlink:href="qabstractsocket.xml#bind">QAbstractSocket::bind</db:link>() does not belong to the host.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qabstractsocket.xml">QAbstractSocket</db:link></db:emphasis>::UnsupportedSocketOperationError</db:code></db:para>
</db:td>
<db:td><db:code>10</db:code></db:td>
<db:td>
<db:para>The requested socket operation is not supported by the local operating system (e.g., lack of IPv6 support).</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qabstractsocket.xml">QAbstractSocket</db:link></db:emphasis>::ProxyAuthenticationRequiredError</db:code></db:para>
</db:td>
<db:td><db:code>12</db:code></db:td>
<db:td>
<db:para>The socket is using a proxy, and the proxy requires authentication.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qabstractsocket.xml">QAbstractSocket</db:link></db:emphasis>::SslHandshakeFailedError</db:code></db:para>
</db:td>
<db:td><db:code>13</db:code></db:td>
<db:td>
<db:para>The SSL/TLS handshake failed, so the connection was closed (only used in <db:link xlink:href="qsslsocket.xml">QSslSocket</db:link>)</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qabstractsocket.xml">QAbstractSocket</db:link></db:emphasis>::UnfinishedSocketOperationError</db:code></db:para>
</db:td>
<db:td><db:code>11</db:code></db:td>
<db:td>
<db:para>Used by QAbstractSocketEngine only, The last operation attempted has not finished yet (still in progress in the background).</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qabstractsocket.xml">QAbstractSocket</db:link></db:emphasis>::ProxyConnectionRefusedError</db:code></db:para>
</db:td>
<db:td><db:code>14</db:code></db:td>
<db:td>
<db:para>Could not contact the proxy server because the connection to that server was denied</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qabstractsocket.xml">QAbstractSocket</db:link></db:emphasis>::ProxyConnectionClosedError</db:code></db:para>
</db:td>
<db:td><db:code>15</db:code></db:td>
<db:td>
<db:para>The connection to the proxy server was closed unexpectedly (before the connection to the final peer was established)</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qabstractsocket.xml">QAbstractSocket</db:link></db:emphasis>::ProxyConnectionTimeoutError</db:code></db:para>
</db:td>
<db:td><db:code>16</db:code></db:td>
<db:td>
<db:para>The connection to the proxy server timed out or the proxy server stopped responding in the authentication phase.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qabstractsocket.xml">QAbstractSocket</db:link></db:emphasis>::ProxyNotFoundError</db:code></db:para>
</db:td>
<db:td><db:code>17</db:code></db:td>
<db:td>
<db:para>The proxy address set with <db:link xlink:href="qabstractsocket.xml#setProxy">setProxy</db:link>() (or the application proxy) was not found.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qabstractsocket.xml">QAbstractSocket</db:link></db:emphasis>::ProxyProtocolError</db:code></db:para>
</db:td>
<db:td><db:code>18</db:code></db:td>
<db:td>
<db:para>The connection negotiation with the proxy server failed, because the response from the proxy server could not be understood.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qabstractsocket.xml">QAbstractSocket</db:link></db:emphasis>::OperationError</db:code></db:para>
</db:td>
<db:td><db:code>19</db:code></db:td>
<db:td>
<db:para>An operation was attempted while the socket was in a state that did not permit it.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qabstractsocket.xml">QAbstractSocket</db:link></db:emphasis>::SslInternalError</db:code></db:para>
</db:td>
<db:td><db:code>20</db:code></db:td>
<db:td>
<db:para>The SSL library being used reported an internal error. This is probably the result of a bad installation or misconfiguration of the library.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qabstractsocket.xml">QAbstractSocket</db:link></db:emphasis>::SslInvalidUserDataError</db:code></db:para>
</db:td>
<db:td><db:code>21</db:code></db:td>
<db:td>
<db:para>Invalid data (certificate, key, cypher, etc.) was provided and its use resulted in an error in the SSL library.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qabstractsocket.xml">QAbstractSocket</db:link></db:emphasis>::TemporaryError</db:code></db:para>
</db:td>
<db:td><db:code>22</db:code></db:td>
<db:td>
<db:para>A temporary error occurred (e.g., operation would block and socket is non-blocking).</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qabstractsocket.xml">QAbstractSocket</db:link></db:emphasis>::UnknownSocketError</db:code></db:para>
</db:td>
<db:td><db:code>-1</db:code></db:td>
<db:td>
<db:para>An unidentified error occurred.</db:para>
</db:td>
</db:tr>
</db:informaltable>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qabstractsocket.xml#error">QAbstractSocket::error</db:link>()</db:member>
<db:member><db:link xlink:href="qabstractsocket.xml#errorOccurred">QAbstractSocket::errorOccurred</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="SocketOption-enum">
<db:title>enum QAbstractSocket::SocketOption</db:title>
<db:enumsynopsis>
<db:enumname>SocketOption</db:enumname>
<db:enumitem>
<db:enumidentifier>LowDelayOption</db:enumidentifier>
<db:enumvalue>0</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>KeepAliveOption</db:enumidentifier>
<db:enumvalue>1</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>MulticastTtlOption</db:enumidentifier>
<db:enumvalue>2</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>MulticastLoopbackOption</db:enumidentifier>
<db:enumvalue>3</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>TypeOfServiceOption</db:enumidentifier>
<db:enumvalue>4</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>SendBufferSizeSocketOption</db:enumidentifier>
<db:enumvalue>5</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>ReceiveBufferSizeSocketOption</db:enumidentifier>
<db:enumvalue>6</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>PathMtuSocketOption</db:enumidentifier>
<db:enumvalue>7</db:enumvalue>
</db:enumitem>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:enumsynopsis>
<db:para>This enum represents the options that can be set on a socket. If desired, they can be set after having received the <db:link xlink:href="qabstractsocket.xml#connected">connected</db:link>() signal from the socket or after having received a new socket from a <db:link xlink:href="qtcpserver.xml">QTcpServer</db:link>.</db:para>
<db:informaltable>
<db:thead>
<db:tr>
<db:th>Constant</db:th>
<db:th>Value</db:th>
<db:th>Description</db:th>
</db:tr>
</db:thead>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qabstractsocket.xml">QAbstractSocket</db:link></db:emphasis>::LowDelayOption</db:code></db:para>
</db:td>
<db:td><db:code>0</db:code></db:td>
<db:td>
<db:para>Try to optimize the socket for low latency. For a <db:link xlink:href="qtcpsocket.xml">QTcpSocket</db:link> this would set the TCP_NODELAY option and disable Nagle's algorithm. Set this to 1 to enable.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qabstractsocket.xml">QAbstractSocket</db:link></db:emphasis>::KeepAliveOption</db:code></db:para>
</db:td>
<db:td><db:code>1</db:code></db:td>
<db:td>
<db:para>Set this to 1 to enable the SO_KEEPALIVE socket option</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qabstractsocket.xml">QAbstractSocket</db:link></db:emphasis>::MulticastTtlOption</db:code></db:para>
</db:td>
<db:td><db:code>2</db:code></db:td>
<db:td>
<db:para>Set this to an integer value to set IP_MULTICAST_TTL (TTL for multicast datagrams) socket option.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qabstractsocket.xml">QAbstractSocket</db:link></db:emphasis>::MulticastLoopbackOption</db:code></db:para>
</db:td>
<db:td><db:code>3</db:code></db:td>
<db:td>
<db:para>Set this to 1 to enable the IP_MULTICAST_LOOP (multicast loopback) socket option.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qabstractsocket.xml">QAbstractSocket</db:link></db:emphasis>::TypeOfServiceOption</db:code></db:para>
</db:td>
<db:td><db:code>4</db:code></db:td>
<db:td>
<db:para>This option is not supported on Windows. This maps to the IP_TOS socket option. For possible values, see table below.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qabstractsocket.xml">QAbstractSocket</db:link></db:emphasis>::SendBufferSizeSocketOption</db:code></db:para>
</db:td>
<db:td><db:code>5</db:code></db:td>
<db:td>
<db:para>Sets the socket send buffer size in bytes at the OS level. This maps to the SO_SNDBUF socket option. This option does not affect the <db:link xlink:href="qiodevice.xml">QIODevice</db:link> or <db:link xlink:href="qabstractsocket.xml">QAbstractSocket</db:link> buffers. This enum value has been introduced in Qt 5.3.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qabstractsocket.xml">QAbstractSocket</db:link></db:emphasis>::ReceiveBufferSizeSocketOption</db:code></db:para>
</db:td>
<db:td><db:code>6</db:code></db:td>
<db:td>
<db:para>Sets the socket receive buffer size in bytes at the OS level. This maps to the SO_RCVBUF socket option. This option does not affect the <db:link xlink:href="qiodevice.xml">QIODevice</db:link> or <db:link xlink:href="qabstractsocket.xml">QAbstractSocket</db:link> buffers (see <db:link xlink:href="qabstractsocket.xml#setReadBufferSize">setReadBufferSize</db:link>()). This enum value has been introduced in Qt 5.3.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qabstractsocket.xml">QAbstractSocket</db:link></db:emphasis>::PathMtuSocketOption</db:code></db:para>
</db:td>
<db:td><db:code>7</db:code></db:td>
<db:td>
<db:para>Retrieves the Path Maximum Transmission Unit (PMTU) value currently known by the IP stack, if any. Some IP stacks also allow setting the MTU for transmission. This enum value was introduced in Qt 5.11.</db:para>
</db:td>
</db:tr>
</db:informaltable>
<db:para>Possible values for <db:emphasis>TypeOfServiceOption</db:emphasis> are:</db:para>
<db:informaltable style="generic">
<db:thead>
<db:tr>
<db:th>
<db:para>Value</db:para>
</db:th>
<db:th>
<db:para>Description</db:para>
</db:th>
</db:tr>
</db:thead>
<db:tr valign="top">
<db:td>
<db:para>224</db:para>
</db:td>
<db:td>
<db:para>Network control</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>192</db:para>
</db:td>
<db:td>
<db:para>Internetwork control</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>160</db:para>
</db:td>
<db:td>
<db:para>CRITIC/ECP</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>128</db:para>
</db:td>
<db:td>
<db:para>Flash override</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>96</db:para>
</db:td>
<db:td>
<db:para>Flash</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>64</db:para>
</db:td>
<db:td>
<db:para>Immediate</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>32</db:para>
</db:td>
<db:td>
<db:para>Priority</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>0</db:para>
</db:td>
<db:td>
<db:para>Routine</db:para>
</db:td>
</db:tr>
</db:informaltable>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qabstractsocket.xml#setSocketOption">QAbstractSocket::setSocketOption</db:link>()</db:member>
<db:member><db:link xlink:href="qabstractsocket.xml#socketOption">QAbstractSocket::socketOption</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="SocketState-enum">
<db:title>enum QAbstractSocket::SocketState</db:title>
<db:enumsynopsis>
<db:enumname>SocketState</db:enumname>
<db:enumitem>
<db:enumidentifier>UnconnectedState</db:enumidentifier>
<db:enumvalue>0</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>HostLookupState</db:enumidentifier>
<db:enumvalue>1</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>ConnectingState</db:enumidentifier>
<db:enumvalue>2</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>ConnectedState</db:enumidentifier>
<db:enumvalue>3</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>BoundState</db:enumidentifier>
<db:enumvalue>4</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>ListeningState</db:enumidentifier>
<db:enumvalue>5</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>ClosingState</db:enumidentifier>
<db:enumvalue>6</db:enumvalue>
</db:enumitem>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:enumsynopsis>
<db:para>This enum describes the different states in which a socket can be.</db:para>
<db:informaltable>
<db:thead>
<db:tr>
<db:th>Constant</db:th>
<db:th>Value</db:th>
<db:th>Description</db:th>
</db:tr>
</db:thead>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qabstractsocket.xml">QAbstractSocket</db:link></db:emphasis>::UnconnectedState</db:code></db:para>
</db:td>
<db:td><db:code>0</db:code></db:td>
<db:td>
<db:para>The socket is not connected.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qabstractsocket.xml">QAbstractSocket</db:link></db:emphasis>::HostLookupState</db:code></db:para>
</db:td>
<db:td><db:code>1</db:code></db:td>
<db:td>
<db:para>The socket is performing a host name lookup.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qabstractsocket.xml">QAbstractSocket</db:link></db:emphasis>::ConnectingState</db:code></db:para>
</db:td>
<db:td><db:code>2</db:code></db:td>
<db:td>
<db:para>The socket has started establishing a connection.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qabstractsocket.xml">QAbstractSocket</db:link></db:emphasis>::ConnectedState</db:code></db:para>
</db:td>
<db:td><db:code>3</db:code></db:td>
<db:td>
<db:para>A connection is established.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qabstractsocket.xml">QAbstractSocket</db:link></db:emphasis>::BoundState</db:code></db:para>
</db:td>
<db:td><db:code>4</db:code></db:td>
<db:td>
<db:para>The socket is bound to an address and port.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qabstractsocket.xml">QAbstractSocket</db:link></db:emphasis>::ClosingState</db:code></db:para>
</db:td>
<db:td><db:code>6</db:code></db:td>
<db:td>
<db:para>The socket is about to close (data may still be waiting to be written).</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qabstractsocket.xml">QAbstractSocket</db:link></db:emphasis>::ListeningState</db:code></db:para>
</db:td>
<db:td><db:code>5</db:code></db:td>
<db:td>
<db:para>For internal use only.</db:para>
</db:td>
</db:tr>
</db:informaltable>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qabstractsocket.xml#state">QAbstractSocket::state</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="SocketType-enum">
<db:title>enum QAbstractSocket::SocketType</db:title>
<db:enumsynopsis>
<db:enumname>SocketType</db:enumname>
<db:enumitem>
<db:enumidentifier>TcpSocket</db:enumidentifier>
<db:enumvalue>0</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>UdpSocket</db:enumidentifier>
<db:enumvalue>1</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>SctpSocket</db:enumidentifier>
<db:enumvalue>2</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>UnknownSocketType</db:enumidentifier>
<db:enumvalue>-1</db:enumvalue>
</db:enumitem>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:enumsynopsis>
<db:para>This enum describes the transport layer protocol.</db:para>
<db:informaltable>
<db:thead>
<db:tr>
<db:th>Constant</db:th>
<db:th>Value</db:th>
<db:th>Description</db:th>
</db:tr>
</db:thead>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qabstractsocket.xml">QAbstractSocket</db:link></db:emphasis>::TcpSocket</db:code></db:para>
</db:td>
<db:td><db:code>0</db:code></db:td>
<db:td>
<db:para>TCP</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qabstractsocket.xml">QAbstractSocket</db:link></db:emphasis>::UdpSocket</db:code></db:para>
</db:td>
<db:td><db:code>1</db:code></db:td>
<db:td>
<db:para>UDP</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qabstractsocket.xml">QAbstractSocket</db:link></db:emphasis>::SctpSocket</db:code></db:para>
</db:td>
<db:td><db:code>2</db:code></db:td>
<db:td>
<db:para>SCTP</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qabstractsocket.xml">QAbstractSocket</db:link></db:emphasis>::UnknownSocketType</db:code></db:para>
</db:td>
<db:td><db:code>-1</db:code></db:td>
<db:td>
<db:para>Other than TCP, UDP and SCTP</db:para>
</db:td>
</db:tr>
</db:informaltable>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qabstractsocket.xml#socketType">QAbstractSocket::socketType</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
</db:section>
<db:section xml:id="member-function-documentation">
<db:title>Member Function Documentation</db:title>
<db:section xml:id="QAbstractSocket">
<db:title>QAbstractSocket::QAbstractSocket(QAbstractSocket::SocketType <db:emphasis>socketType</db:emphasis>, QObject *<db:emphasis>parent</db:emphasis>)</db:title>
<db:constructorsynopsis>
<db:methodname>QAbstractSocket</db:methodname>
<db:methodparam>
<db:type>QAbstractSocket::SocketType</db:type>
<db:parameter>socketType</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>QObject *</db:type>
<db:parameter>parent</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">constructor</db:synopsisinfo>
<db:synopsisinfo role="signature">QAbstractSocket(QAbstractSocket::SocketType socketType, QObject *parent)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:constructorsynopsis>
<db:para>Creates a new abstract socket of type <db:code role="parameter">socketType</db:code>. The <db:code role="parameter">parent</db:code> argument is passed to <db:link xlink:href="qobject.xml">QObject</db:link>'s constructor.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qabstractsocket.xml#socketType">socketType</db:link>()</db:member>
<db:member><db:link xlink:href="qtcpsocket.xml">QTcpSocket</db:link></db:member>
<db:member><db:link xlink:href="qudpsocket.xml">QUdpSocket</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="dtor.QAbstractSocket">
<db:title>[virtual] QAbstractSocket::~QAbstractSocket()</db:title>
<db:destructorsynopsis>
<db:modifier>virtual</db:modifier>
<db:methodname>~QAbstractSocket</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">destructor</db:synopsisinfo>
<db:synopsisinfo role="signature">~QAbstractSocket()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:destructorsynopsis>
<db:para>Destroys the socket.</db:para>
</db:section>
<db:section xml:id="abort">
<db:title>void QAbstractSocket::abort()</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>abort</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void abort()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Aborts the current connection and resets the socket. Unlike <db:link xlink:href="qabstractsocket.xml#disconnectFromHost">disconnectFromHost</db:link>(), this function immediately closes the socket, discarding any pending data in the write buffer.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qabstractsocket.xml#disconnectFromHost">disconnectFromHost</db:link>()</db:member>
<db:member><db:link xlink:href="qabstractsocket.xml#close">close</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="bind">
<db:title>[virtual, since 5.0] bool QAbstractSocket::bind(const QHostAddress &amp;<db:emphasis>address</db:emphasis>, quint16 <db:emphasis>port</db:emphasis> = 0, QAbstractSocket::BindMode <db:emphasis>mode</db:emphasis> = DefaultForPlatform)</db:title>
<db:methodsynopsis>
<db:modifier>virtual</db:modifier>
<db:type>bool</db:type>
<db:methodname>bind</db:methodname>
<db:methodparam>
<db:type>const QHostAddress &amp;</db:type>
<db:parameter>address</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>quint16</db:type>
<db:parameter>port</db:parameter>
<db:initializer>0</db:initializer>
</db:methodparam>
<db:methodparam>
<db:type>QAbstractSocket::BindMode</db:type>
<db:parameter>mode</db:parameter>
<db:initializer>DefaultForPlatform</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool bind(const QHostAddress &amp;address, quint16 port, QAbstractSocket::BindMode mode)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Binds to <db:code role="parameter">address</db:code> on port <db:code role="parameter">port</db:code>, using the <db:link xlink:href="qabstractsocket.xml#BindFlag-enum">BindMode</db:link> <db:code role="parameter">mode</db:code>.</db:para>
<db:para>For UDP sockets, after binding, the signal <db:link xlink:href="qiodevice.xml#readyRead">QUdpSocket::readyRead</db:link>() is emitted whenever a UDP datagram arrives on the specified address and port. Thus, this function is useful to write UDP servers.</db:para>
<db:para>For TCP sockets, this function may be used to specify which interface to use for an outgoing connection, which is useful in case of multiple network interfaces.</db:para>
<db:para>By default, the socket is bound using the <db:link xlink:href="qabstractsocket.xml#BindFlag-enum">DefaultForPlatform</db:link> <db:link xlink:href="qabstractsocket.xml#BindFlag-enum">BindMode</db:link>. If a port is not specified, a random port is chosen.</db:para>
<db:para>On success, the function returns <db:code>true</db:code> and the socket enters <db:link xlink:href="qabstractsocket.xml#SocketState-enum">BoundState</db:link>; otherwise it returns <db:code>false</db:code>.</db:para>
<db:para>This function was introduced in Qt 5.0.</db:para>
</db:section>
<db:section xml:id="bind-1">
<db:title>[since 5.0] bool QAbstractSocket::bind(quint16 <db:emphasis>port</db:emphasis> = 0, QAbstractSocket::BindMode <db:emphasis>mode</db:emphasis> = DefaultForPlatform)</db:title>
<db:methodsynopsis>
<db:type>bool</db:type>
<db:methodname>bind</db:methodname>
<db:methodparam>
<db:type>quint16</db:type>
<db:parameter>port</db:parameter>
<db:initializer>0</db:initializer>
</db:methodparam>
<db:methodparam>
<db:type>QAbstractSocket::BindMode</db:type>
<db:parameter>mode</db:parameter>
<db:initializer>DefaultForPlatform</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">bool bind(quint16 port, QAbstractSocket::BindMode mode)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>Binds to <db:link xlink:href="qhostaddress.xml">QHostAddress</db:link>:Any on port <db:code role="parameter">port</db:code>, using the <db:link xlink:href="qabstractsocket.xml#BindFlag-enum">BindMode</db:link> <db:code role="parameter">mode</db:code>.</db:para>
<db:para>By default, the socket is bound using the <db:link xlink:href="qabstractsocket.xml#BindFlag-enum">DefaultForPlatform</db:link> <db:link xlink:href="qabstractsocket.xml#BindFlag-enum">BindMode</db:link>. If a port is not specified, a random port is chosen.</db:para>
<db:para>This function was introduced in Qt 5.0.</db:para>
</db:section>
<db:section xml:id="bytesAvailable">
<db:title>[override virtual] qint64 QAbstractSocket::bytesAvailable() const</db:title>
<db:methodsynopsis>
<db:modifier>virtual</db:modifier>
<db:modifier>const</db:modifier>
<db:type>qint64</db:type>
<db:methodname>bytesAvailable</db:methodname>
<db:void/>
<db:modifier>override</db:modifier>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">qint64 bytesAvailable() const override</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Reimplements: <db:link xlink:href="qiodevice.xml#bytesAvailable" role="function">QIODevice::bytesAvailable() const</db:link>.</db:para>
<db:para>Returns the number of incoming bytes that are waiting to be read.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qabstractsocket.xml#bytesToWrite">bytesToWrite</db:link>()</db:member>
<db:member><db:link xlink:href="qiodevice.xml#read">read</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="bytesToWrite">
<db:title>[override virtual] qint64 QAbstractSocket::bytesToWrite() const</db:title>
<db:methodsynopsis>
<db:modifier>virtual</db:modifier>
<db:modifier>const</db:modifier>
<db:type>qint64</db:type>
<db:methodname>bytesToWrite</db:methodname>
<db:void/>
<db:modifier>override</db:modifier>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">qint64 bytesToWrite() const override</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Reimplements: <db:link xlink:href="qiodevice.xml#bytesToWrite" role="function">QIODevice::bytesToWrite() const</db:link>.</db:para>
<db:para>Returns the number of bytes that are waiting to be written. The bytes are written when control goes back to the event loop or when <db:link xlink:href="qabstractsocket.xml#flush">flush</db:link>() is called.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qabstractsocket.xml#bytesAvailable">bytesAvailable</db:link>()</db:member>
<db:member><db:link xlink:href="qabstractsocket.xml#flush">flush</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="close">
<db:title>[override virtual] void QAbstractSocket::close()</db:title>
<db:methodsynopsis>
<db:modifier>virtual</db:modifier>
<db:void/>
<db:methodname>close</db:methodname>
<db:void/>
<db:modifier>override</db:modifier>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void close() override</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Reimplements: <db:link xlink:href="qiodevice.xml#close" role="function">QIODevice::close()</db:link>.</db:para>
<db:para>Closes the I/O device for the socket and calls <db:link xlink:href="qabstractsocket.xml#disconnectFromHost">disconnectFromHost</db:link>() to close the socket's connection.</db:para>
<db:para>See <db:link xlink:href="qiodevice.xml#close">QIODevice::close</db:link>() for a description of the actions that occur when an I/O device is closed.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qabstractsocket.xml#abort">abort</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="connectToHost">
<db:title>[virtual] void QAbstractSocket::connectToHost(const QString &amp;<db:emphasis>hostName</db:emphasis>, quint16 <db:emphasis>port</db:emphasis>, QIODeviceBase::OpenMode <db:emphasis>openMode</db:emphasis> = ReadWrite, QAbstractSocket::NetworkLayerProtocol <db:emphasis>protocol</db:emphasis> = AnyIPProtocol)</db:title>
<db:methodsynopsis>
<db:modifier>virtual</db:modifier>
<db:void/>
<db:methodname>connectToHost</db:methodname>
<db:methodparam>
<db:type>const QString &amp;</db:type>
<db:parameter>hostName</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>quint16</db:type>
<db:parameter>port</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>QIODeviceBase::OpenMode</db:type>
<db:parameter>openMode</db:parameter>
<db:initializer>ReadWrite</db:initializer>
</db:methodparam>
<db:methodparam>
<db:type>QAbstractSocket::NetworkLayerProtocol</db:type>
<db:parameter>protocol</db:parameter>
<db:initializer>AnyIPProtocol</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void connectToHost(const QString &amp;hostName, quint16 port, QIODeviceBase::OpenMode openMode, QAbstractSocket::NetworkLayerProtocol protocol)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Attempts to make a connection to <db:code role="parameter">hostName</db:code> on the given <db:code role="parameter">port</db:code>. The <db:code role="parameter">protocol</db:code> parameter can be used to specify which network protocol to use (eg. IPv4 or IPv6).</db:para>
<db:para>The socket is opened in the given <db:code role="parameter">openMode</db:code> and first enters <db:link xlink:href="qabstractsocket.xml#SocketState-enum">HostLookupState</db:link>, then performs a host name lookup of <db:code role="parameter">hostName</db:code>. If the lookup succeeds, <db:link xlink:href="qabstractsocket.xml#hostFound">hostFound</db:link>() is emitted and <db:link xlink:href="qabstractsocket.xml">QAbstractSocket</db:link> enters <db:link xlink:href="qabstractsocket.xml#SocketState-enum">ConnectingState</db:link>. It then attempts to connect to the address or addresses returned by the lookup. Finally, if a connection is established, <db:link xlink:href="qabstractsocket.xml">QAbstractSocket</db:link> enters <db:link xlink:href="qabstractsocket.xml#SocketState-enum">ConnectedState</db:link> and emits <db:link xlink:href="qabstractsocket.xml#connected">connected</db:link>().</db:para>
<db:para>At any point, the socket can emit <db:link xlink:href="qabstractsocket.xml#errorOccurred">errorOccurred</db:link>() to signal that an error occurred.</db:para>
<db:para><db:code role="parameter">hostName</db:code> may be an IP address in string form (e.g., &quot;43.195.83.32&quot;), or it may be a host name (e.g., &quot;example.com&quot;). <db:link xlink:href="qabstractsocket.xml">QAbstractSocket</db:link> will do a lookup only if required. <db:code role="parameter">port</db:code> is in native byte order.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qabstractsocket.xml#state">state</db:link>()</db:member>
<db:member><db:link xlink:href="qabstractsocket.xml#peerName">peerName</db:link>()</db:member>
<db:member><db:link xlink:href="qabstractsocket.xml#peerAddress">peerAddress</db:link>()</db:member>
<db:member><db:link xlink:href="qabstractsocket.xml#peerPort">peerPort</db:link>()</db:member>
<db:member><db:link xlink:href="qabstractsocket.xml#waitForConnected">waitForConnected</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="connectToHost-1">
<db:title>void QAbstractSocket::connectToHost(const QHostAddress &amp;<db:emphasis>address</db:emphasis>, quint16 <db:emphasis>port</db:emphasis>, QIODeviceBase::OpenMode <db:emphasis>openMode</db:emphasis> = ReadWrite)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>connectToHost</db:methodname>
<db:methodparam>
<db:type>const QHostAddress &amp;</db:type>
<db:parameter>address</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>quint16</db:type>
<db:parameter>port</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>QIODeviceBase::OpenMode</db:type>
<db:parameter>openMode</db:parameter>
<db:initializer>ReadWrite</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">void connectToHost(const QHostAddress &amp;address, quint16 port, QIODeviceBase::OpenMode openMode)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>Attempts to make a connection to <db:code role="parameter">address</db:code> on port <db:code role="parameter">port</db:code>.</db:para>
</db:section>
<db:section xml:id="connected">
<db:title>void QAbstractSocket::connected()</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>connected</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void connected()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This signal is emitted after <db:link xlink:href="qabstractsocket.xml#connectToHost">connectToHost</db:link>() has been called and a connection has been successfully established.</db:para>
<db:note>
<db:para>On some operating systems the connected() signal may be directly emitted from the <db:link xlink:href="qabstractsocket.xml#connectToHost">connectToHost</db:link>() call for connections to the localhost.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qabstractsocket.xml#connectToHost">connectToHost</db:link>()</db:member>
<db:member><db:link xlink:href="qabstractsocket.xml#disconnected">disconnected</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="disconnectFromHost">
<db:title>[virtual] void QAbstractSocket::disconnectFromHost()</db:title>
<db:methodsynopsis>
<db:modifier>virtual</db:modifier>
<db:void/>
<db:methodname>disconnectFromHost</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void disconnectFromHost()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Attempts to close the socket. If there is pending data waiting to be written, <db:link xlink:href="qabstractsocket.xml">QAbstractSocket</db:link> will enter <db:link xlink:href="qabstractsocket.xml#SocketState-enum">ClosingState</db:link> and wait until all data has been written. Eventually, it will enter <db:link xlink:href="qabstractsocket.xml#SocketState-enum">UnconnectedState</db:link> and emit the <db:link xlink:href="qabstractsocket.xml#disconnected">disconnected</db:link>() signal.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qabstractsocket.xml#connectToHost">connectToHost</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="disconnected">
<db:title>void QAbstractSocket::disconnected()</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>disconnected</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void disconnected()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This signal is emitted when the socket has been disconnected.</db:para>
<db:warning>
<db:para>If you need to delete the <db:link xlink:href="qobject.xml#sender">sender</db:link>() of this signal in a slot connected to it, use the <db:link xlink:href="qobject.xml#deleteLater">deleteLater</db:link>() function.</db:para>
</db:warning>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qabstractsocket.xml#connectToHost">connectToHost</db:link>()</db:member>
<db:member><db:link xlink:href="qabstractsocket.xml#disconnectFromHost">disconnectFromHost</db:link>()</db:member>
<db:member><db:link xlink:href="qabstractsocket.xml#abort">abort</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="error">
<db:title>QAbstractSocket::SocketError QAbstractSocket::error() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QAbstractSocket::SocketError</db:type>
<db:methodname>error</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QAbstractSocket::SocketError error() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the type of error that last occurred.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qabstractsocket.xml#state">state</db:link>()</db:member>
<db:member><db:link xlink:href="qiodevice.xml#errorString">errorString</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="errorOccurred">
<db:title>[since 5.15] void QAbstractSocket::errorOccurred(QAbstractSocket::SocketError <db:emphasis>socketError</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>errorOccurred</db:methodname>
<db:methodparam>
<db:type>QAbstractSocket::SocketError</db:type>
<db:parameter>socketError</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void errorOccurred(QAbstractSocket::SocketError socketError)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This signal is emitted after an error occurred. The <db:code role="parameter">socketError</db:code> parameter describes the type of error that occurred.</db:para>
<db:para>When this signal is emitted, the socket may not be ready for a reconnect attempt. In that case, attempts to reconnect should be done from the event loop. For example, use a <db:link xlink:href="qtimer.xml#singleShot">QTimer::singleShot</db:link>() with 0 as the timeout.</db:para>
<db:para><db:link xlink:href="qabstractsocket.xml#SocketError-enum">QAbstractSocket::SocketError</db:link> is not a registered metatype, so for queued connections, you will have to register it with <db:link xlink:href="qmetatype.xml#Q_DECLARE_METATYPE">Q_DECLARE_METATYPE</db:link>() and <db:link xlink:href="qmetatype.xml#qRegisterMetaType-1">qRegisterMetaType</db:link>().</db:para>
<db:para>This function was introduced in Qt 5.15.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qabstractsocket.xml#error">error</db:link>()</db:member>
<db:member><db:link xlink:href="qiodevice.xml#errorString">errorString</db:link>()</db:member>
<db:member><db:link xlink:href="custom-types.xml">Creating Custom Qt Types</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="flush">
<db:title>bool QAbstractSocket::flush()</db:title>
<db:methodsynopsis>
<db:type>bool</db:type>
<db:methodname>flush</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool flush()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This function writes as much as possible from the internal write buffer to the underlying network socket, without blocking. If any data was written, this function returns <db:code>true</db:code>; otherwise false is returned.</db:para>
<db:para>Call this function if you need <db:link xlink:href="qabstractsocket.xml">QAbstractSocket</db:link> to start sending buffered data immediately. The number of bytes successfully written depends on the operating system. In most cases, you do not need to call this function, because <db:link xlink:href="qabstractsocket.xml">QAbstractSocket</db:link> will start sending data automatically once control goes back to the event loop. In the absence of an event loop, call <db:link xlink:href="qabstractsocket.xml#waitForBytesWritten">waitForBytesWritten</db:link>() instead.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qiodevice.xml#write">write</db:link>()</db:member>
<db:member><db:link xlink:href="qabstractsocket.xml#waitForBytesWritten">waitForBytesWritten</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="hostFound">
<db:title>void QAbstractSocket::hostFound()</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>hostFound</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void hostFound()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This signal is emitted after <db:link xlink:href="qabstractsocket.xml#connectToHost">connectToHost</db:link>() has been called and the host lookup has succeeded.</db:para>
<db:note>
<db:para>Since Qt 4.6.3 <db:link xlink:href="qabstractsocket.xml">QAbstractSocket</db:link> may emit hostFound() directly from the <db:link xlink:href="qabstractsocket.xml#connectToHost">connectToHost</db:link>() call since a DNS result could have been cached.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qabstractsocket.xml#connected">connected</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="isSequential">
<db:title>[override virtual] bool QAbstractSocket::isSequential() const</db:title>
<db:methodsynopsis>
<db:modifier>virtual</db:modifier>
<db:modifier>const</db:modifier>
<db:type>bool</db:type>
<db:methodname>isSequential</db:methodname>
<db:void/>
<db:modifier>override</db:modifier>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool isSequential() const override</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Reimplements: <db:link xlink:href="qiodevice.xml#isSequential" role="function">QIODevice::isSequential() const</db:link>.</db:para>
</db:section>
<db:section xml:id="isValid">
<db:title>bool QAbstractSocket::isValid() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>bool</db:type>
<db:methodname>isValid</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool isValid() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns <db:code>true</db:code> if the socket is valid and ready for use; otherwise returns <db:code>false</db:code>.</db:para>
<db:note>
<db:para>The socket's state must be <db:link xlink:href="qabstractsocket.xml#SocketState-enum">ConnectedState</db:link> before reading and writing can occur.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qabstractsocket.xml#state">state</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="localAddress">
<db:title>QHostAddress QAbstractSocket::localAddress() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QHostAddress</db:type>
<db:methodname>localAddress</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QHostAddress localAddress() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the host address of the local socket if available; otherwise returns <db:link xlink:href="qhostaddress.xml#SpecialAddress-enum">QHostAddress::Null</db:link>.</db:para>
<db:para>This is normally the main IP address of the host, but can be <db:link xlink:href="qhostaddress.xml#SpecialAddress-enum">QHostAddress::LocalHost</db:link> (127.0.0.1) for connections to the local host.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qabstractsocket.xml#localPort">localPort</db:link>()</db:member>
<db:member><db:link xlink:href="qabstractsocket.xml#peerAddress">peerAddress</db:link>()</db:member>
<db:member><db:link xlink:href="qabstractsocket.xml#setLocalAddress">setLocalAddress</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="localPort">
<db:title>quint16 QAbstractSocket::localPort() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>quint16</db:type>
<db:methodname>localPort</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">quint16 localPort() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the host port number (in native byte order) of the local socket if available; otherwise returns 0.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qabstractsocket.xml#localAddress">localAddress</db:link>()</db:member>
<db:member><db:link xlink:href="qabstractsocket.xml#peerPort">peerPort</db:link>()</db:member>
<db:member><db:link xlink:href="qabstractsocket.xml#setLocalPort">setLocalPort</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="pauseMode">
<db:title>[since 5.0] QAbstractSocket::PauseModes QAbstractSocket::pauseMode() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QAbstractSocket::PauseModes</db:type>
<db:methodname>pauseMode</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QAbstractSocket::PauseModes pauseMode() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the pause mode of this socket.</db:para>
<db:para>This function was introduced in Qt 5.0.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qabstractsocket.xml#setPauseMode">setPauseMode</db:link>()</db:member>
<db:member><db:link xlink:href="qabstractsocket.xml#resume">resume</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="peerAddress">
<db:title>QHostAddress QAbstractSocket::peerAddress() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QHostAddress</db:type>
<db:methodname>peerAddress</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QHostAddress peerAddress() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the address of the connected peer if the socket is in <db:link xlink:href="qabstractsocket.xml#SocketState-enum">ConnectedState</db:link>; otherwise returns <db:link xlink:href="qhostaddress.xml#SpecialAddress-enum">QHostAddress::Null</db:link>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qabstractsocket.xml#peerName">peerName</db:link>()</db:member>
<db:member><db:link xlink:href="qabstractsocket.xml#peerPort">peerPort</db:link>()</db:member>
<db:member><db:link xlink:href="qabstractsocket.xml#localAddress">localAddress</db:link>()</db:member>
<db:member><db:link xlink:href="qabstractsocket.xml#setPeerAddress">setPeerAddress</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="peerName">
<db:title>QString QAbstractSocket::peerName() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QString</db:type>
<db:methodname>peerName</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QString peerName() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the name of the peer as specified by <db:link xlink:href="qabstractsocket.xml#connectToHost">connectToHost</db:link>(), or an empty <db:link xlink:href="qstring.xml">QString</db:link> if <db:link xlink:href="qabstractsocket.xml#connectToHost">connectToHost</db:link>() has not been called.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qabstractsocket.xml#peerAddress">peerAddress</db:link>()</db:member>
<db:member><db:link xlink:href="qabstractsocket.xml#peerPort">peerPort</db:link>()</db:member>
<db:member><db:link xlink:href="qabstractsocket.xml#setPeerName">setPeerName</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="peerPort">
<db:title>quint16 QAbstractSocket::peerPort() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>quint16</db:type>
<db:methodname>peerPort</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">quint16 peerPort() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the port of the connected peer if the socket is in <db:link xlink:href="qabstractsocket.xml#SocketState-enum">ConnectedState</db:link>; otherwise returns 0.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qabstractsocket.xml#peerAddress">peerAddress</db:link>()</db:member>
<db:member><db:link xlink:href="qabstractsocket.xml#localPort">localPort</db:link>()</db:member>
<db:member><db:link xlink:href="qabstractsocket.xml#setPeerPort">setPeerPort</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="protocolTag">
<db:title>[since 5.13] QString QAbstractSocket::protocolTag() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QString</db:type>
<db:methodname>protocolTag</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QString protocolTag() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the protocol tag for this socket. If the protocol tag is set then this is passed to <db:link xlink:href="qnetworkproxyquery.xml">QNetworkProxyQuery</db:link> when this is created internally to indicate the protocol tag to be used.</db:para>
<db:para>This function was introduced in Qt 5.13.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qabstractsocket.xml#setProtocolTag">setProtocolTag</db:link>()</db:member>
<db:member><db:link xlink:href="qnetworkproxyquery.xml">QNetworkProxyQuery</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="proxy">
<db:title>QNetworkProxy QAbstractSocket::proxy() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QNetworkProxy</db:type>
<db:methodname>proxy</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QNetworkProxy proxy() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the network proxy for this socket. By default <db:link xlink:href="qnetworkproxy.xml#ProxyType-enum">QNetworkProxy::DefaultProxy</db:link> is used, which means this socket will query the default proxy settings for the application.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qabstractsocket.xml#setProxy">setProxy</db:link>()</db:member>
<db:member><db:link xlink:href="qnetworkproxy.xml">QNetworkProxy</db:link></db:member>
<db:member><db:link xlink:href="qnetworkproxyfactory.xml">QNetworkProxyFactory</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="proxyAuthenticationRequired">
<db:title>void QAbstractSocket::proxyAuthenticationRequired(const QNetworkProxy &amp;<db:emphasis>proxy</db:emphasis>, QAuthenticator *<db:emphasis>authenticator</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>proxyAuthenticationRequired</db:methodname>
<db:methodparam>
<db:type>const QNetworkProxy &amp;</db:type>
<db:parameter>proxy</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>QAuthenticator *</db:type>
<db:parameter>authenticator</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void proxyAuthenticationRequired(const QNetworkProxy &amp;proxy, QAuthenticator *authenticator)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This signal can be emitted when a <db:code role="parameter">proxy</db:code> that requires authentication is used. The <db:code role="parameter">authenticator</db:code> object can then be filled in with the required details to allow authentication and continue the connection.</db:para>
<db:note>
<db:para>It is not possible to use a QueuedConnection to connect to this signal, as the connection will fail if the authenticator has not been filled in with new information when the signal returns.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qauthenticator.xml">QAuthenticator</db:link></db:member>
<db:member><db:link xlink:href="qnetworkproxy.xml">QNetworkProxy</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="readBufferSize">
<db:title>qint64 QAbstractSocket::readBufferSize() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>qint64</db:type>
<db:methodname>readBufferSize</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">qint64 readBufferSize() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the size of the internal read buffer. This limits the amount of data that the client can receive before you call <db:link xlink:href="qiodevice.xml#read">read</db:link>() or <db:link xlink:href="qiodevice.xml#readAll">readAll</db:link>().</db:para>
<db:para>A read buffer size of 0 (the default) means that the buffer has no size limit, ensuring that no data is lost.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qabstractsocket.xml#setReadBufferSize">setReadBufferSize</db:link>()</db:member>
<db:member><db:link xlink:href="qiodevice.xml#read">read</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="readData">
<db:title>[override virtual protected] qint64 QAbstractSocket::readData(char *<db:emphasis>data</db:emphasis>, qint64 <db:emphasis>maxSize</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:modifier>virtual</db:modifier>
<db:type>qint64</db:type>
<db:methodname>readData</db:methodname>
<db:methodparam>
<db:type>char *</db:type>
<db:parameter>data</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>qint64</db:type>
<db:parameter>maxSize</db:parameter>
</db:methodparam>
<db:modifier>override</db:modifier>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">qint64 readData(char *data, qint64 maxSize) override</db:synopsisinfo>
<db:synopsisinfo role="access">protected</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Reimplements: <db:link xlink:href="qiodevice.xml#readData" role="function">QIODevice::readData(char *data, qint64 maxSize)</db:link>.</db:para>
</db:section>
<db:section xml:id="readLineData">
<db:title>[override virtual protected] qint64 QAbstractSocket::readLineData(char *<db:emphasis>data</db:emphasis>, qint64 <db:emphasis>maxlen</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:modifier>virtual</db:modifier>
<db:type>qint64</db:type>
<db:methodname>readLineData</db:methodname>
<db:methodparam>
<db:type>char *</db:type>
<db:parameter>data</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>qint64</db:type>
<db:parameter>maxlen</db:parameter>
</db:methodparam>
<db:modifier>override</db:modifier>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">qint64 readLineData(char *data, qint64 maxlen) override</db:synopsisinfo>
<db:synopsisinfo role="access">protected</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Reimplements: <db:link xlink:href="qiodevice.xml#readLineData" role="function">QIODevice::readLineData(char *data, qint64 maxSize)</db:link>.</db:para>
</db:section>
<db:section xml:id="resume">
<db:title>[virtual, since 5.0] void QAbstractSocket::resume()</db:title>
<db:methodsynopsis>
<db:modifier>virtual</db:modifier>
<db:void/>
<db:methodname>resume</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void resume()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Continues data transfer on the socket. This method should only be used after the socket has been set to pause upon notifications and a notification has been received. The only notification currently supported is <db:link xlink:href="qsslsocket.xml#sslErrors">QSslSocket::sslErrors</db:link>(). Calling this method if the socket is not paused results in undefined behavior.</db:para>
<db:para>This function was introduced in Qt 5.0.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qabstractsocket.xml#pauseMode">pauseMode</db:link>()</db:member>
<db:member><db:link xlink:href="qabstractsocket.xml#setPauseMode">setPauseMode</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setLocalAddress">
<db:title>[protected] void QAbstractSocket::setLocalAddress(const QHostAddress &amp;<db:emphasis>address</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>setLocalAddress</db:methodname>
<db:methodparam>
<db:type>const QHostAddress &amp;</db:type>
<db:parameter>address</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void setLocalAddress(const QHostAddress &amp;address)</db:synopsisinfo>
<db:synopsisinfo role="access">protected</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Sets the address on the local side of a connection to <db:code role="parameter">address</db:code>.</db:para>
<db:para>You can call this function in a subclass of <db:link xlink:href="qabstractsocket.xml">QAbstractSocket</db:link> to change the return value of the <db:link xlink:href="qabstractsocket.xml#localAddress">localAddress</db:link>() function after a connection has been established. This feature is commonly used by proxy connections for virtual connection settings.</db:para>
<db:para>Note that this function does not bind the local address of the socket prior to a connection (e.g., <db:link xlink:href="qabstractsocket.xml#bind">QAbstractSocket::bind</db:link>()).</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qabstractsocket.xml#localAddress">localAddress</db:link>()</db:member>
<db:member><db:link xlink:href="qabstractsocket.xml#setLocalPort">setLocalPort</db:link>()</db:member>
<db:member><db:link xlink:href="qabstractsocket.xml#setPeerAddress">setPeerAddress</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setLocalPort">
<db:title>[protected] void QAbstractSocket::setLocalPort(quint16 <db:emphasis>port</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>setLocalPort</db:methodname>
<db:methodparam>
<db:type>quint16</db:type>
<db:parameter>port</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void setLocalPort(quint16 port)</db:synopsisinfo>
<db:synopsisinfo role="access">protected</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Sets the port on the local side of a connection to <db:code role="parameter">port</db:code>.</db:para>
<db:para>You can call this function in a subclass of <db:link xlink:href="qabstractsocket.xml">QAbstractSocket</db:link> to change the return value of the <db:link xlink:href="qabstractsocket.xml#localPort">localPort</db:link>() function after a connection has been established. This feature is commonly used by proxy connections for virtual connection settings.</db:para>
<db:para>Note that this function does not bind the local port of the socket prior to a connection (e.g., <db:link xlink:href="qabstractsocket.xml#bind">QAbstractSocket::bind</db:link>()).</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qabstractsocket.xml#localPort">localPort</db:link>()</db:member>
<db:member><db:link xlink:href="qabstractsocket.xml#localAddress">localAddress</db:link>()</db:member>
<db:member><db:link xlink:href="qabstractsocket.xml#setLocalAddress">setLocalAddress</db:link>()</db:member>
<db:member><db:link xlink:href="qabstractsocket.xml#setPeerPort">setPeerPort</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setPauseMode">
<db:title>[since 5.0] void QAbstractSocket::setPauseMode(QAbstractSocket::PauseModes <db:emphasis>pauseMode</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>setPauseMode</db:methodname>
<db:methodparam>
<db:type>QAbstractSocket::PauseModes</db:type>
<db:parameter>pauseMode</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void setPauseMode(QAbstractSocket::PauseModes pauseMode)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Controls whether to pause upon receiving a notification. The <db:code role="parameter">pauseMode</db:code> parameter specifies the conditions in which the socket should be paused. The only notification currently supported is <db:link xlink:href="qsslsocket.xml#sslErrors">QSslSocket::sslErrors</db:link>(). If set to <db:link xlink:href="qabstractsocket.xml#PauseMode-enum">PauseOnSslErrors</db:link>, data transfer on the socket will be paused and needs to be enabled explicitly again by calling <db:link xlink:href="qabstractsocket.xml#resume">resume</db:link>(). By default this option is set to <db:link xlink:href="qabstractsocket.xml#PauseMode-enum">PauseNever</db:link>. This option must be called before connecting to the server, otherwise it will result in undefined behavior.</db:para>
<db:para>This function was introduced in Qt 5.0.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qabstractsocket.xml#pauseMode">pauseMode</db:link>()</db:member>
<db:member><db:link xlink:href="qabstractsocket.xml#resume">resume</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setPeerAddress">
<db:title>[protected] void QAbstractSocket::setPeerAddress(const QHostAddress &amp;<db:emphasis>address</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>setPeerAddress</db:methodname>
<db:methodparam>
<db:type>const QHostAddress &amp;</db:type>
<db:parameter>address</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void setPeerAddress(const QHostAddress &amp;address)</db:synopsisinfo>
<db:synopsisinfo role="access">protected</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Sets the address of the remote side of the connection to <db:code role="parameter">address</db:code>.</db:para>
<db:para>You can call this function in a subclass of <db:link xlink:href="qabstractsocket.xml">QAbstractSocket</db:link> to change the return value of the <db:link xlink:href="qabstractsocket.xml#peerAddress">peerAddress</db:link>() function after a connection has been established. This feature is commonly used by proxy connections for virtual connection settings.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qabstractsocket.xml#peerAddress">peerAddress</db:link>()</db:member>
<db:member><db:link xlink:href="qabstractsocket.xml#setPeerPort">setPeerPort</db:link>()</db:member>
<db:member><db:link xlink:href="qabstractsocket.xml#setLocalAddress">setLocalAddress</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setPeerName">
<db:title>[protected] void QAbstractSocket::setPeerName(const QString &amp;<db:emphasis>name</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>setPeerName</db:methodname>
<db:methodparam>
<db:type>const QString &amp;</db:type>
<db:parameter>name</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void setPeerName(const QString &amp;name)</db:synopsisinfo>
<db:synopsisinfo role="access">protected</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Sets the host name of the remote peer to <db:code role="parameter">name</db:code>.</db:para>
<db:para>You can call this function in a subclass of <db:link xlink:href="qabstractsocket.xml">QAbstractSocket</db:link> to change the return value of the <db:link xlink:href="qabstractsocket.xml#peerName">peerName</db:link>() function after a connection has been established. This feature is commonly used by proxy connections for virtual connection settings.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qabstractsocket.xml#peerName">peerName</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setPeerPort">
<db:title>[protected] void QAbstractSocket::setPeerPort(quint16 <db:emphasis>port</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>setPeerPort</db:methodname>
<db:methodparam>
<db:type>quint16</db:type>
<db:parameter>port</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void setPeerPort(quint16 port)</db:synopsisinfo>
<db:synopsisinfo role="access">protected</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Sets the port of the remote side of the connection to <db:code role="parameter">port</db:code>.</db:para>
<db:para>You can call this function in a subclass of <db:link xlink:href="qabstractsocket.xml">QAbstractSocket</db:link> to change the return value of the <db:link xlink:href="qabstractsocket.xml#peerPort">peerPort</db:link>() function after a connection has been established. This feature is commonly used by proxy connections for virtual connection settings.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qabstractsocket.xml#peerPort">peerPort</db:link>()</db:member>
<db:member><db:link xlink:href="qabstractsocket.xml#setPeerAddress">setPeerAddress</db:link>()</db:member>
<db:member><db:link xlink:href="qabstractsocket.xml#setLocalPort">setLocalPort</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setProtocolTag">
<db:title>[since 5.13] void QAbstractSocket::setProtocolTag(const QString &amp;<db:emphasis>tag</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>setProtocolTag</db:methodname>
<db:methodparam>
<db:type>const QString &amp;</db:type>
<db:parameter>tag</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void setProtocolTag(const QString &amp;tag)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Sets the protocol tag for this socket to <db:code role="parameter">tag</db:code>.</db:para>
<db:para>This function was introduced in Qt 5.13.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qabstractsocket.xml#protocolTag">protocolTag</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setProxy">
<db:title>void QAbstractSocket::setProxy(const QNetworkProxy &amp;<db:emphasis>networkProxy</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>setProxy</db:methodname>
<db:methodparam>
<db:type>const QNetworkProxy &amp;</db:type>
<db:parameter>networkProxy</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void setProxy(const QNetworkProxy &amp;networkProxy)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Sets the explicit network proxy for this socket to <db:code role="parameter">networkProxy</db:code>.</db:para>
<db:para>To disable the use of a proxy for this socket, use the <db:link xlink:href="qnetworkproxy.xml#ProxyType-enum">QNetworkProxy::NoProxy</db:link> proxy type:</db:para>
<db:programlisting language="cpp">socket-&amp;gt;setProxy(QNetworkProxy::NoProxy);
</db:programlisting>
<db:para>The default value for the proxy is <db:link xlink:href="qnetworkproxy.xml#ProxyType-enum">QNetworkProxy::DefaultProxy</db:link>, which means the socket will use the application settings: if a proxy is set with <db:link xlink:href="qnetworkproxy.xml#setApplicationProxy">QNetworkProxy::setApplicationProxy</db:link>, it will use that; otherwise, if a factory is set with <db:link xlink:href="qnetworkproxyfactory.xml#setApplicationProxyFactory">QNetworkProxyFactory::setApplicationProxyFactory</db:link>, it will query that factory with type <db:link xlink:href="qnetworkproxyquery.xml#QueryType-enum">QNetworkProxyQuery::TcpSocket</db:link>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qabstractsocket.xml#proxy">proxy</db:link>()</db:member>
<db:member><db:link xlink:href="qnetworkproxy.xml">QNetworkProxy</db:link></db:member>
<db:member><db:link xlink:href="qnetworkproxyfactory.xml#queryProxy">QNetworkProxyFactory::queryProxy</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setReadBufferSize">
<db:title>[virtual] void QAbstractSocket::setReadBufferSize(qint64 <db:emphasis>size</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:modifier>virtual</db:modifier>
<db:void/>
<db:methodname>setReadBufferSize</db:methodname>
<db:methodparam>
<db:type>qint64</db:type>
<db:parameter>size</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void setReadBufferSize(qint64 size)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Sets the size of <db:link xlink:href="qabstractsocket.xml">QAbstractSocket</db:link>'s internal read buffer to be <db:code role="parameter">size</db:code> bytes.</db:para>
<db:para>If the buffer size is limited to a certain size, <db:link xlink:href="qabstractsocket.xml">QAbstractSocket</db:link> won't buffer more than this size of data. Exceptionally, a buffer size of 0 means that the read buffer is unlimited and all incoming data is buffered. This is the default.</db:para>
<db:para>This option is useful if you only read the data at certain points in time (e.g., in a real-time streaming application) or if you want to protect your socket against receiving too much data, which may eventually cause your application to run out of memory.</db:para>
<db:para>Only <db:link xlink:href="qtcpsocket.xml">QTcpSocket</db:link> uses <db:link xlink:href="qabstractsocket.xml">QAbstractSocket</db:link>'s internal buffer; <db:link xlink:href="qudpsocket.xml">QUdpSocket</db:link> does not use any buffering at all, but rather relies on the implicit buffering provided by the operating system. Because of this, calling this function on <db:link xlink:href="qudpsocket.xml">QUdpSocket</db:link> has no effect.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qabstractsocket.xml#readBufferSize">readBufferSize</db:link>()</db:member>
<db:member><db:link xlink:href="qiodevice.xml#read">read</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setSocketDescriptor">
<db:title>[virtual] bool QAbstractSocket::setSocketDescriptor(qintptr <db:emphasis>socketDescriptor</db:emphasis>, QAbstractSocket::SocketState <db:emphasis>socketState</db:emphasis> = ConnectedState, QIODeviceBase::OpenMode <db:emphasis>openMode</db:emphasis> = ReadWrite)</db:title>
<db:methodsynopsis>
<db:modifier>virtual</db:modifier>
<db:type>bool</db:type>
<db:methodname>setSocketDescriptor</db:methodname>
<db:methodparam>
<db:type>qintptr</db:type>
<db:parameter>socketDescriptor</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>QAbstractSocket::SocketState</db:type>
<db:parameter>socketState</db:parameter>
<db:initializer>ConnectedState</db:initializer>
</db:methodparam>
<db:methodparam>
<db:type>QIODeviceBase::OpenMode</db:type>
<db:parameter>openMode</db:parameter>
<db:initializer>ReadWrite</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool setSocketDescriptor(qintptr socketDescriptor, QAbstractSocket::SocketState socketState, QIODeviceBase::OpenMode openMode)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Initializes <db:link xlink:href="qabstractsocket.xml">QAbstractSocket</db:link> with the native socket descriptor <db:code role="parameter">socketDescriptor</db:code>. Returns <db:code>true</db:code> if <db:code role="parameter">socketDescriptor</db:code> is accepted as a valid socket descriptor; otherwise returns <db:code>false</db:code>. The socket is opened in the mode specified by <db:code role="parameter">openMode</db:code>, and enters the socket state specified by <db:code role="parameter">socketState</db:code>. Read and write buffers are cleared, discarding any pending data.</db:para>
<db:para><db:emphasis role="bold">Note:</db:emphasis> It is not possible to initialize two abstract sockets with the same native socket descriptor.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qabstractsocket.xml#socketDescriptor">socketDescriptor</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setSocketError">
<db:title>[protected] void QAbstractSocket::setSocketError(QAbstractSocket::SocketError <db:emphasis>socketError</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>setSocketError</db:methodname>
<db:methodparam>
<db:type>QAbstractSocket::SocketError</db:type>
<db:parameter>socketError</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void setSocketError(QAbstractSocket::SocketError socketError)</db:synopsisinfo>
<db:synopsisinfo role="access">protected</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Sets the type of error that last occurred to <db:code role="parameter">socketError</db:code>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qabstractsocket.xml#setSocketState">setSocketState</db:link>()</db:member>
<db:member><db:link xlink:href="qiodevice.xml#setErrorString">setErrorString</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setSocketOption">
<db:title>[virtual] void QAbstractSocket::setSocketOption(QAbstractSocket::SocketOption <db:emphasis>option</db:emphasis>, const QVariant &amp;<db:emphasis>value</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:modifier>virtual</db:modifier>
<db:void/>
<db:methodname>setSocketOption</db:methodname>
<db:methodparam>
<db:type>QAbstractSocket::SocketOption</db:type>
<db:parameter>option</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const QVariant &amp;</db:type>
<db:parameter>value</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void setSocketOption(QAbstractSocket::SocketOption option, const QVariant &amp;value)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Sets the given <db:code role="parameter">option</db:code> to the value described by <db:code role="parameter">value</db:code>.</db:para>
<db:note>
<db:para>On Windows Runtime, <db:link xlink:href="qabstractsocket.xml#SocketOption-enum">QAbstractSocket::KeepAliveOption</db:link> must be set before the socket is connected.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qabstractsocket.xml#socketOption">socketOption</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setSocketState">
<db:title>[protected] void QAbstractSocket::setSocketState(QAbstractSocket::SocketState <db:emphasis>state</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>setSocketState</db:methodname>
<db:methodparam>
<db:type>QAbstractSocket::SocketState</db:type>
<db:parameter>state</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void setSocketState(QAbstractSocket::SocketState state)</db:synopsisinfo>
<db:synopsisinfo role="access">protected</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Sets the state of the socket to <db:code role="parameter">state</db:code>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qabstractsocket.xml#state">state</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="skipData">
<db:title>[override virtual protected] qint64 QAbstractSocket::skipData(qint64 <db:emphasis>maxSize</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:modifier>virtual</db:modifier>
<db:type>qint64</db:type>
<db:methodname>skipData</db:methodname>
<db:methodparam>
<db:type>qint64</db:type>
<db:parameter>maxSize</db:parameter>
</db:methodparam>
<db:modifier>override</db:modifier>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">qint64 skipData(qint64 maxSize) override</db:synopsisinfo>
<db:synopsisinfo role="access">protected</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Reimplements: <db:link xlink:href="qiodevice.xml#skipData" role="function">QIODevice::skipData(qint64 maxSize)</db:link>.</db:para>
</db:section>
<db:section xml:id="socketDescriptor">
<db:title>[virtual] qintptr QAbstractSocket::socketDescriptor() const</db:title>
<db:methodsynopsis>
<db:modifier>virtual</db:modifier>
<db:modifier>const</db:modifier>
<db:type>qintptr</db:type>
<db:methodname>socketDescriptor</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">qintptr socketDescriptor() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the native socket descriptor of the <db:link xlink:href="qabstractsocket.xml">QAbstractSocket</db:link> object if this is available; otherwise returns -1.</db:para>
<db:para>If the socket is using <db:link xlink:href="qnetworkproxy.xml">QNetworkProxy</db:link>, the returned descriptor may not be usable with native socket functions.</db:para>
<db:para>The socket descriptor is not available when <db:link xlink:href="qabstractsocket.xml">QAbstractSocket</db:link> is in <db:link xlink:href="qabstractsocket.xml#SocketState-enum">UnconnectedState</db:link>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qabstractsocket.xml#setSocketDescriptor">setSocketDescriptor</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="socketOption">
<db:title>[virtual] QVariant QAbstractSocket::socketOption(QAbstractSocket::SocketOption <db:emphasis>option</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:modifier>virtual</db:modifier>
<db:type>QVariant</db:type>
<db:methodname>socketOption</db:methodname>
<db:methodparam>
<db:type>QAbstractSocket::SocketOption</db:type>
<db:parameter>option</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QVariant socketOption(QAbstractSocket::SocketOption option)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the value of the <db:code role="parameter">option</db:code> option.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qabstractsocket.xml#setSocketOption">setSocketOption</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="socketType">
<db:title>QAbstractSocket::SocketType QAbstractSocket::socketType() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QAbstractSocket::SocketType</db:type>
<db:methodname>socketType</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QAbstractSocket::SocketType socketType() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the socket type (TCP, UDP, or other).</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtcpsocket.xml">QTcpSocket</db:link></db:member>
<db:member><db:link xlink:href="qudpsocket.xml">QUdpSocket</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="state">
<db:title>QAbstractSocket::SocketState QAbstractSocket::state() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QAbstractSocket::SocketState</db:type>
<db:methodname>state</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QAbstractSocket::SocketState state() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the state of the socket.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qabstractsocket.xml#error">error</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="stateChanged">
<db:title>void QAbstractSocket::stateChanged(QAbstractSocket::SocketState <db:emphasis>socketState</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>stateChanged</db:methodname>
<db:methodparam>
<db:type>QAbstractSocket::SocketState</db:type>
<db:parameter>socketState</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void stateChanged(QAbstractSocket::SocketState socketState)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This signal is emitted whenever <db:link xlink:href="qabstractsocket.xml">QAbstractSocket</db:link>'s state changes. The <db:code role="parameter">socketState</db:code> parameter is the new state.</db:para>
<db:para><db:link xlink:href="qabstractsocket.xml#SocketState-enum">QAbstractSocket::SocketState</db:link> is not a registered metatype, so for queued connections, you will have to register it with <db:link xlink:href="qmetatype.xml#Q_DECLARE_METATYPE">Q_DECLARE_METATYPE</db:link>() and <db:link xlink:href="qmetatype.xml#qRegisterMetaType-1">qRegisterMetaType</db:link>().</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qabstractsocket.xml#state">state</db:link>()</db:member>
<db:member><db:link xlink:href="custom-types.xml">Creating Custom Qt Types</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="waitForBytesWritten">
<db:title>[override virtual] bool QAbstractSocket::waitForBytesWritten(int <db:emphasis>msecs</db:emphasis> = 30000)</db:title>
<db:methodsynopsis>
<db:modifier>virtual</db:modifier>
<db:type>bool</db:type>
<db:methodname>waitForBytesWritten</db:methodname>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>msecs</db:parameter>
<db:initializer>30000</db:initializer>
</db:methodparam>
<db:modifier>override</db:modifier>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool waitForBytesWritten(int msecs) override</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Reimplements: <db:link xlink:href="qiodevice.xml#waitForBytesWritten" role="function">QIODevice::waitForBytesWritten(int msecs)</db:link>.</db:para>
<db:para>This function blocks until at least one byte has been written on the socket and the <db:link xlink:href="qiodevice.xml#bytesWritten">bytesWritten</db:link>() signal has been emitted. The function will timeout after <db:code role="parameter">msecs</db:code> milliseconds; the default timeout is 30000 milliseconds.</db:para>
<db:para>The function returns <db:code>true</db:code> if the <db:link xlink:href="qiodevice.xml#bytesWritten">bytesWritten</db:link>() signal is emitted; otherwise it returns <db:code>false</db:code> (if an error occurred or the operation timed out).</db:para>
<db:note>
<db:para>This function may fail randomly on Windows. Consider using the event loop and the <db:link xlink:href="qiodevice.xml#bytesWritten">bytesWritten</db:link>() signal if your software will run on Windows.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qabstractsocket.xml#waitForReadyRead">waitForReadyRead</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="waitForConnected">
<db:title>[virtual] bool QAbstractSocket::waitForConnected(int <db:emphasis>msecs</db:emphasis> = 30000)</db:title>
<db:methodsynopsis>
<db:modifier>virtual</db:modifier>
<db:type>bool</db:type>
<db:methodname>waitForConnected</db:methodname>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>msecs</db:parameter>
<db:initializer>30000</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool waitForConnected(int msecs)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Waits until the socket is connected, up to <db:code role="parameter">msecs</db:code> milliseconds. If the connection has been established, this function returns <db:code>true</db:code>; otherwise it returns <db:code>false</db:code>. In the case where it returns <db:code>false</db:code>, you can call <db:link xlink:href="qabstractsocket.xml#error">error</db:link>() to determine the cause of the error.</db:para>
<db:para>The following example waits up to one second for a connection to be established:</db:para>
<db:programlisting language="cpp">socket-&amp;gt;connectToHost(&quot;imap&quot;, 143);
if (socket-&amp;gt;waitForConnected(1000))
    qDebug(&quot;Connected!&quot;);
</db:programlisting>
<db:para>If msecs is -1, this function will not time out.</db:para>
<db:note>
<db:para>This function may wait slightly longer than <db:code role="parameter">msecs</db:code>, depending on the time it takes to complete the host lookup.</db:para>
</db:note>
<db:note>
<db:para>Multiple calls to this functions do not accumulate the time. If the function times out, the connecting process will be aborted.</db:para>
</db:note>
<db:note>
<db:para>This function may fail randomly on Windows. Consider using the event loop and the <db:link xlink:href="qabstractsocket.xml#connected">connected</db:link>() signal if your software will run on Windows.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qabstractsocket.xml#connectToHost">connectToHost</db:link>()</db:member>
<db:member><db:link xlink:href="qabstractsocket.xml#connected">connected</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="waitForDisconnected">
<db:title>[virtual] bool QAbstractSocket::waitForDisconnected(int <db:emphasis>msecs</db:emphasis> = 30000)</db:title>
<db:methodsynopsis>
<db:modifier>virtual</db:modifier>
<db:type>bool</db:type>
<db:methodname>waitForDisconnected</db:methodname>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>msecs</db:parameter>
<db:initializer>30000</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool waitForDisconnected(int msecs)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Waits until the socket has disconnected, up to <db:code role="parameter">msecs</db:code> milliseconds. If the connection was successfully disconnected, this function returns <db:code>true</db:code>; otherwise it returns <db:code>false</db:code> (if the operation timed out, if an error occurred, or if this <db:link xlink:href="qabstractsocket.xml">QAbstractSocket</db:link> is already disconnected). In the case where it returns <db:code>false</db:code>, you can call <db:link xlink:href="qabstractsocket.xml#error">error</db:link>() to determine the cause of the error.</db:para>
<db:para>The following example waits up to one second for a connection to be closed:</db:para>
<db:programlisting language="cpp">socket-&amp;gt;disconnectFromHost();
if (socket-&amp;gt;state() == QAbstractSocket::UnconnectedState
    || socket-&amp;gt;waitForDisconnected(1000)) {
        qDebug(&quot;Disconnected!&quot;);
}
</db:programlisting>
<db:para>If msecs is -1, this function will not time out.</db:para>
<db:note>
<db:para>This function may fail randomly on Windows. Consider using the event loop and the <db:link xlink:href="qabstractsocket.xml#disconnected">disconnected</db:link>() signal if your software will run on Windows.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qabstractsocket.xml#disconnectFromHost">disconnectFromHost</db:link>()</db:member>
<db:member><db:link xlink:href="qabstractsocket.xml#close">close</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="waitForReadyRead">
<db:title>[override virtual] bool QAbstractSocket::waitForReadyRead(int <db:emphasis>msecs</db:emphasis> = 30000)</db:title>
<db:methodsynopsis>
<db:modifier>virtual</db:modifier>
<db:type>bool</db:type>
<db:methodname>waitForReadyRead</db:methodname>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>msecs</db:parameter>
<db:initializer>30000</db:initializer>
</db:methodparam>
<db:modifier>override</db:modifier>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool waitForReadyRead(int msecs) override</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Reimplements: <db:link xlink:href="qiodevice.xml#waitForReadyRead" role="function">QIODevice::waitForReadyRead(int msecs)</db:link>.</db:para>
<db:para>This function blocks until new data is available for reading and the <db:link xlink:href="qiodevice.xml#readyRead">readyRead</db:link>() signal has been emitted. The function will timeout after <db:code role="parameter">msecs</db:code> milliseconds; the default timeout is 30000 milliseconds.</db:para>
<db:para>The function returns <db:code>true</db:code> if the <db:link xlink:href="qiodevice.xml#readyRead">readyRead</db:link>() signal is emitted and there is new data available for reading; otherwise it returns <db:code>false</db:code> (if an error occurred or the operation timed out).</db:para>
<db:note>
<db:para>This function may fail randomly on Windows. Consider using the event loop and the <db:link xlink:href="qiodevice.xml#readyRead">readyRead</db:link>() signal if your software will run on Windows.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qabstractsocket.xml#waitForBytesWritten">waitForBytesWritten</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="writeData">
<db:title>[override virtual protected] qint64 QAbstractSocket::writeData(const char *<db:emphasis>data</db:emphasis>, qint64 <db:emphasis>size</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:modifier>virtual</db:modifier>
<db:type>qint64</db:type>
<db:methodname>writeData</db:methodname>
<db:methodparam>
<db:type>const char *</db:type>
<db:parameter>data</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>qint64</db:type>
<db:parameter>size</db:parameter>
</db:methodparam>
<db:modifier>override</db:modifier>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">qint64 writeData(const char *data, qint64 size) override</db:synopsisinfo>
<db:synopsisinfo role="access">protected</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Reimplements: <db:link xlink:href="qiodevice.xml#writeData" role="function">QIODevice::writeData(const char *data, qint64 maxSize)</db:link>.</db:para>
</db:section>
</db:section>
</db:article>
