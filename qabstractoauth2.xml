<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en">
<db:info>
<db:title>QAbstractOAuth2 Class</db:title>
<db:productname>QtNetworkAuth</db:productname>
<db:edition>Qt Network Authorization | Commercial or GPLv3</db:edition>
<db:titleabbrev>Qt Network Authorization Reference Documentation</db:titleabbrev>
<db:abstract>
<db:para>The <db:link xlink:href="qabstractoauth2.xml">QAbstractOAuth2</db:link> class is the base of all implementations of OAuth 2 authentication methods.</db:para>
</db:abstract>
<db:pubdate>2024-02-14</db:pubdate>
<db:date>2024-02-14</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:variablelist>
<db:varlistentry>
<db:term>Header</db:term>
<db:listitem>
<db:para>QAbstractOAuth2</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>CMake</db:term>
<db:listitem>
<db:para>find_package(Qt6 REQUIRED COMPONENTS NetworkAuth)</db:para>
<db:para>target_link_libraries(mytarget PRIVATE Qt6::NetworkAuth)</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>qmake</db:term>
<db:listitem>
<db:para>QT += networkauth</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Inherits</db:term>
<db:listitem>
<db:para><db:link xlink:href="qabstractoauth.xml" xlink:role="class">QAbstractOAuth</db:link></db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Inherited By</db:term>
<db:listitem>
<db:para><db:link xlink:href="qoauth2authorizationcodeflow.xml" xlink:role="class">QOAuth2AuthorizationCodeFlow</db:link></db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Group</db:term>
<db:listitem>
<db:para>QAbstractOAuth2 is part of <db:simplelist><db:member>oauth</db:member></db:simplelist></db:para>
</db:listitem>
</db:varlistentry>
</db:variablelist>
<db:section xml:id="details">
<db:title>Detailed Description</db:title>
<db:para>The class defines the basic interface of the OAuth 2 authentication classes. By inheriting this class, you can create custom authentication methods using the OAuth 2 standard for different web services.</db:para>
<db:para>A description of how OAuth 2 works can be found in: <db:link xlink:href="https://tools.ietf.org/html/rfc6749">The OAuth 2.0 Authorization Framework</db:link></db:para>
</db:section>
<db:section xml:id="property-documentation">
<db:title>Property Documentation</db:title>
<db:section xml:id="clientIdentifierSharedKey-prop">
<db:title>clientIdentifierSharedKey : QString</db:title>
<db:fieldsynopsis>
<db:modifier>(Qt property)</db:modifier>
<db:type>QString</db:type>
<db:varname>clientIdentifierSharedKey</db:varname>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
<db:synopsisinfo role="getter">clientIdentifierSharedKey</db:synopsisinfo>
<db:synopsisinfo role="setter">setClientIdentifierSharedKey</db:synopsisinfo>
<db:synopsisinfo role="notifier">clientIdentifierSharedKeyChanged</db:synopsisinfo>
</db:fieldsynopsis>
<db:para>This property holds the client shared key used as a password if the server requires authentication to request the token.</db:para>
<db:para>
<db:emphasis role="bold">Access functions:
</db:emphasis>
</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:type><db:link xlink:href="qstring.xml">QString</db:link></db:type> <db:emphasis role="bold">clientIdentifierSharedKey</db:emphasis>() const</db:para>
</db:listitem>
<db:listitem>
<db:para><db:type>void</db:type> <db:emphasis role="bold">setClientIdentifierSharedKey</db:emphasis>(const <db:type><db:link xlink:href="qstring.xml">QString</db:link></db:type> &amp;<db:emphasis>clientIdentifierSharedKey</db:emphasis>)</db:para>
</db:listitem>
</db:itemizedlist>
<db:para>
<db:emphasis role="bold">Notifier signal:
</db:emphasis>
</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:type>void</db:type> <db:emphasis role="bold">clientIdentifierSharedKeyChanged</db:emphasis>(const <db:type><db:link xlink:href="qstring.xml">QString</db:link></db:type> &amp;<db:emphasis>clientIdentifierSharedKey</db:emphasis>)</db:para>
</db:listitem>
</db:itemizedlist>
</db:section>
<db:section xml:id="expiration-prop">
<db:title>[read-only] expiration : const QDateTime</db:title>
<db:fieldsynopsis>
<db:modifier>(Qt property)</db:modifier>
<db:type>QDateTime</db:type>
<db:varname>expiration</db:varname>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
<db:synopsisinfo role="getter">expirationAt</db:synopsisinfo>
<db:synopsisinfo role="notifier">expirationAtChanged</db:synopsisinfo>
</db:fieldsynopsis>
<db:para>This property holds the expiration time of the current access token.</db:para>
<db:para>
<db:emphasis role="bold">Access functions:
</db:emphasis>
</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:type><db:link xlink:href="qdatetime.xml">QDateTime</db:link></db:type> <db:emphasis role="bold">expirationAt</db:emphasis>() const</db:para>
</db:listitem>
</db:itemizedlist>
<db:para>
<db:emphasis role="bold">Notifier signal:
</db:emphasis>
</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:type>void</db:type> <db:emphasis role="bold">expirationAtChanged</db:emphasis>(const <db:type><db:link xlink:href="qdatetime.xml">QDateTime</db:link></db:type> &amp;<db:emphasis>expiration</db:emphasis>)</db:para>
</db:listitem>
</db:itemizedlist>
</db:section>
<db:section xml:id="scope-prop">
<db:title>scope : QString</db:title>
<db:fieldsynopsis>
<db:modifier>(Qt property)</db:modifier>
<db:type>QString</db:type>
<db:varname>scope</db:varname>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
<db:synopsisinfo role="getter">scope</db:synopsisinfo>
<db:synopsisinfo role="setter">setScope</db:synopsisinfo>
<db:synopsisinfo role="notifier">scopeChanged</db:synopsisinfo>
</db:fieldsynopsis>
<db:para>This property holds the desired scope which defines the permissions requested by the client.</db:para>
<db:para>
<db:emphasis role="bold">Access functions:
</db:emphasis>
</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:type><db:link xlink:href="qstring.xml">QString</db:link></db:type> <db:emphasis role="bold">scope</db:emphasis>() const</db:para>
</db:listitem>
<db:listitem>
<db:para><db:type>void</db:type> <db:emphasis role="bold">setScope</db:emphasis>(const <db:type><db:link xlink:href="qstring.xml">QString</db:link></db:type> &amp;<db:emphasis>scope</db:emphasis>)</db:para>
</db:listitem>
</db:itemizedlist>
<db:para>
<db:emphasis role="bold">Notifier signal:
</db:emphasis>
</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:type>void</db:type> <db:emphasis role="bold">scopeChanged</db:emphasis>(const <db:type><db:link xlink:href="qstring.xml">QString</db:link></db:type> &amp;<db:emphasis>scope</db:emphasis>)</db:para>
</db:listitem>
</db:itemizedlist>
</db:section>
<db:section xml:id="state-prop">
<db:title>state : QString</db:title>
<db:fieldsynopsis>
<db:modifier>(Qt property)</db:modifier>
<db:type>QString</db:type>
<db:varname>state</db:varname>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
<db:synopsisinfo role="getter">state</db:synopsisinfo>
<db:synopsisinfo role="setter">setState</db:synopsisinfo>
<db:synopsisinfo role="notifier">stateChanged</db:synopsisinfo>
</db:fieldsynopsis>
<db:para>This property holds the string sent to the server during authentication. The state is used to identify and validate the request when the callback is received.</db:para>
<db:para>
<db:emphasis role="bold">Access functions:
</db:emphasis>
</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:type><db:link xlink:href="qstring.xml">QString</db:link></db:type> <db:emphasis role="bold">state</db:emphasis>() const</db:para>
</db:listitem>
<db:listitem>
<db:para><db:type>void</db:type> <db:emphasis role="bold">setState</db:emphasis>(const <db:type><db:link xlink:href="qstring.xml">QString</db:link></db:type> &amp;<db:emphasis>state</db:emphasis>)</db:para>
</db:listitem>
</db:itemizedlist>
<db:para>
<db:emphasis role="bold">Notifier signal:
</db:emphasis>
</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:type>void</db:type> <db:emphasis role="bold">stateChanged</db:emphasis>(const <db:type><db:link xlink:href="qstring.xml">QString</db:link></db:type> &amp;<db:emphasis>state</db:emphasis>)</db:para>
</db:listitem>
</db:itemizedlist>
</db:section>
<db:section xml:id="userAgent-prop">
<db:title>userAgent : QString</db:title>
<db:fieldsynopsis>
<db:modifier>(Qt property)</db:modifier>
<db:type>QString</db:type>
<db:varname>userAgent</db:varname>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
<db:synopsisinfo role="getter">userAgent</db:synopsisinfo>
<db:synopsisinfo role="setter">setUserAgent</db:synopsisinfo>
<db:synopsisinfo role="notifier">userAgentChanged</db:synopsisinfo>
</db:fieldsynopsis>
<db:para>This property holds the User-Agent header used to create the network requests.</db:para>
<db:para>The default value is &quot;QtOAuth/1.0 (+https://www.qt.io)&quot;.</db:para>
<db:para>
<db:emphasis role="bold">Access functions:
</db:emphasis>
</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:type><db:link xlink:href="qstring.xml">QString</db:link></db:type> <db:emphasis role="bold">userAgent</db:emphasis>() const</db:para>
</db:listitem>
<db:listitem>
<db:para><db:type>void</db:type> <db:emphasis role="bold">setUserAgent</db:emphasis>(const <db:type><db:link xlink:href="qstring.xml">QString</db:link></db:type> &amp;<db:emphasis>userAgent</db:emphasis>)</db:para>
</db:listitem>
</db:itemizedlist>
<db:para>
<db:emphasis role="bold">Notifier signal:
</db:emphasis>
</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:type>void</db:type> <db:emphasis role="bold">userAgentChanged</db:emphasis>(const <db:type><db:link xlink:href="qstring.xml">QString</db:link></db:type> &amp;<db:emphasis>userAgent</db:emphasis>)</db:para>
</db:listitem>
</db:itemizedlist>
</db:section>
</db:section>
<db:section xml:id="member-function-documentation">
<db:title>Member Function Documentation</db:title>
<db:section xml:id="QAbstractOAuth2">
<db:title>[explicit] QAbstractOAuth2::QAbstractOAuth2(QObject *<db:emphasis>parent</db:emphasis> = nullptr)</db:title>
<db:constructorsynopsis>
<db:methodname>QAbstractOAuth2</db:methodname>
<db:methodparam>
<db:type>QObject *</db:type>
<db:parameter>parent</db:parameter>
<db:initializer>nullptr</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">constructor</db:synopsisinfo>
<db:synopsisinfo role="signature">QAbstractOAuth2(QObject *parent)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:constructorsynopsis>
<db:para>Constructs a <db:link xlink:href="qabstractoauth2.xml">QAbstractOAuth2</db:link> object using <db:code role="parameter">parent</db:code> as parent.</db:para>
</db:section>
<db:section xml:id="QAbstractOAuth2-1">
<db:title>[explicit] QAbstractOAuth2::QAbstractOAuth2(QNetworkAccessManager *<db:emphasis>manager</db:emphasis>, QObject *<db:emphasis>parent</db:emphasis> = nullptr)</db:title>
<db:constructorsynopsis>
<db:methodname>QAbstractOAuth2</db:methodname>
<db:methodparam>
<db:type>QNetworkAccessManager *</db:type>
<db:parameter>manager</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>QObject *</db:type>
<db:parameter>parent</db:parameter>
<db:initializer>nullptr</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">constructor</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">QAbstractOAuth2(QNetworkAccessManager *manager, QObject *parent)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:constructorsynopsis>
<db:para>Constructs a <db:link xlink:href="qabstractoauth2.xml">QAbstractOAuth2</db:link> object using <db:code role="parameter">parent</db:code> as parent and sets <db:code role="parameter">manager</db:code> as the network access manager.</db:para>
</db:section>
<db:section xml:id="dtor.QAbstractOAuth2">
<db:title>[virtual] QAbstractOAuth2::~QAbstractOAuth2()</db:title>
<db:destructorsynopsis>
<db:modifier>virtual</db:modifier>
<db:methodname>~QAbstractOAuth2</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">destructor</db:synopsisinfo>
<db:synopsisinfo role="signature">~QAbstractOAuth2()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:destructorsynopsis>
<db:para>Destroys the <db:link xlink:href="qabstractoauth2.xml">QAbstractOAuth2</db:link> instance.</db:para>
</db:section>
<db:section xml:id="authorizationCallbackReceived">
<db:title>void QAbstractOAuth2::authorizationCallbackReceived(const QVariantMap &amp;<db:emphasis>data</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>authorizationCallbackReceived</db:methodname>
<db:methodparam>
<db:type>const QVariantMap &amp;</db:type>
<db:parameter>data</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void authorizationCallbackReceived(const QVariantMap &amp;data)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Signal emitted when the reply server receives the authorization callback from the server: <db:code role="parameter">data</db:code> contains the values received from the server.</db:para>
</db:section>
<db:section xml:id="createAuthenticatedUrl">
<db:title>[virtual] QUrl QAbstractOAuth2::createAuthenticatedUrl(const QUrl &amp;<db:emphasis>url</db:emphasis>, const QVariantMap &amp;<db:emphasis>parameters</db:emphasis> = QVariantMap())</db:title>
<db:methodsynopsis>
<db:modifier>virtual</db:modifier>
<db:type>QUrl</db:type>
<db:methodname>createAuthenticatedUrl</db:methodname>
<db:methodparam>
<db:type>const QUrl &amp;</db:type>
<db:parameter>url</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const QVariantMap &amp;</db:type>
<db:parameter>parameters</db:parameter>
<db:initializer>QVariantMap()</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QUrl createAuthenticatedUrl(const QUrl &amp;url, const QVariantMap &amp;parameters)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>The returned URL is based on <db:code role="parameter">url</db:code>, combining it with the given <db:code role="parameter">parameters</db:code> and the access token.</db:para>
</db:section>
<db:section xml:id="deleteResource">
<db:title>[override virtual] QNetworkReply *QAbstractOAuth2::deleteResource(const QUrl &amp;<db:emphasis>url</db:emphasis>, const QVariantMap &amp;<db:emphasis>parameters</db:emphasis> = QVariantMap())</db:title>
<db:methodsynopsis>
<db:modifier>virtual</db:modifier>
<db:type>QNetworkReply *</db:type>
<db:methodname>deleteResource</db:methodname>
<db:methodparam>
<db:type>const QUrl &amp;</db:type>
<db:parameter>url</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const QVariantMap &amp;</db:type>
<db:parameter>parameters</db:parameter>
<db:initializer>QVariantMap()</db:initializer>
</db:methodparam>
<db:modifier>override</db:modifier>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QNetworkReply * deleteResource(const QUrl &amp;url, const QVariantMap &amp;parameters) override</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Reimplements: <db:link xlink:href="qabstractoauth.xml#deleteResource" role="function">QAbstractOAuth::deleteResource(const QUrl &amp;url, const QVariantMap &amp;parameters)</db:link>.</db:para>
<db:para>Sends an authenticated DELETE request and returns a new <db:link xlink:href="qnetworkreply.xml">QNetworkReply</db:link>. The <db:code role="parameter">url</db:code> and <db:code role="parameter">parameters</db:code> are used to create the request.</db:para>
<db:para><db:emphasis role="bold">See also</db:emphasis>: <db:link xlink:href="https://tools.ietf.org/html/rfc2616#section-9.7">Hypertext Transfer Protocol – HTTP/1.1: DELETE</db:link></db:para>
</db:section>
<db:section xml:id="error">
<db:title>void QAbstractOAuth2::error(const QString &amp;<db:emphasis>error</db:emphasis>, const QString &amp;<db:emphasis>errorDescription</db:emphasis>, const QUrl &amp;<db:emphasis>uri</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>error</db:methodname>
<db:methodparam>
<db:type>const QString &amp;</db:type>
<db:parameter>error</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const QString &amp;</db:type>
<db:parameter>errorDescription</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const QUrl &amp;</db:type>
<db:parameter>uri</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void error(const QString &amp;error, const QString &amp;errorDescription, const QUrl &amp;uri)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Signal emitted when the server responds to the request with an error: <db:code role="parameter">error</db:code> is the name of the error; <db:code role="parameter">errorDescription</db:code> describes the error and <db:code role="parameter">uri</db:code> is an optional URI containing more information about the error.</db:para>
</db:section>
<db:section xml:id="get">
<db:title>[override virtual] QNetworkReply *QAbstractOAuth2::get(const QUrl &amp;<db:emphasis>url</db:emphasis>, const QVariantMap &amp;<db:emphasis>parameters</db:emphasis> = QVariantMap())</db:title>
<db:methodsynopsis>
<db:modifier>virtual</db:modifier>
<db:type>QNetworkReply *</db:type>
<db:methodname>get</db:methodname>
<db:methodparam>
<db:type>const QUrl &amp;</db:type>
<db:parameter>url</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const QVariantMap &amp;</db:type>
<db:parameter>parameters</db:parameter>
<db:initializer>QVariantMap()</db:initializer>
</db:methodparam>
<db:modifier>override</db:modifier>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QNetworkReply * get(const QUrl &amp;url, const QVariantMap &amp;parameters) override</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Reimplements: <db:link xlink:href="qabstractoauth.xml#get" role="function">QAbstractOAuth::get(const QUrl &amp;url, const QVariantMap &amp;parameters)</db:link>.</db:para>
<db:para>Sends an authenticated GET request and returns a new <db:link xlink:href="qnetworkreply.xml">QNetworkReply</db:link>. The <db:code role="parameter">url</db:code> and <db:code role="parameter">parameters</db:code> are used to create the request.</db:para>
<db:para><db:emphasis role="bold">See also</db:emphasis>: <db:link xlink:href="https://tools.ietf.org/html/rfc2616#section-9.3">Hypertext Transfer Protocol – HTTP/1.1: GET</db:link></db:para>
</db:section>
<db:section xml:id="head">
<db:title>[override virtual] QNetworkReply *QAbstractOAuth2::head(const QUrl &amp;<db:emphasis>url</db:emphasis>, const QVariantMap &amp;<db:emphasis>parameters</db:emphasis> = QVariantMap())</db:title>
<db:methodsynopsis>
<db:modifier>virtual</db:modifier>
<db:type>QNetworkReply *</db:type>
<db:methodname>head</db:methodname>
<db:methodparam>
<db:type>const QUrl &amp;</db:type>
<db:parameter>url</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const QVariantMap &amp;</db:type>
<db:parameter>parameters</db:parameter>
<db:initializer>QVariantMap()</db:initializer>
</db:methodparam>
<db:modifier>override</db:modifier>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QNetworkReply * head(const QUrl &amp;url, const QVariantMap &amp;parameters) override</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Reimplements: <db:link xlink:href="qabstractoauth.xml#head" role="function">QAbstractOAuth::head(const QUrl &amp;url, const QVariantMap &amp;parameters)</db:link>.</db:para>
<db:para>Sends an authenticated HEAD request and returns a new <db:link xlink:href="qnetworkreply.xml">QNetworkReply</db:link>. The <db:code role="parameter">url</db:code> and <db:code role="parameter">parameters</db:code> are used to create the request.</db:para>
<db:para><db:emphasis role="bold">See also</db:emphasis>: <db:link xlink:href="https://tools.ietf.org/html/rfc2616#section-9.4">Hypertext Transfer Protocol – HTTP/1.1: HEAD</db:link></db:para>
</db:section>
<db:section xml:id="post">
<db:title>[override virtual] QNetworkReply *QAbstractOAuth2::post(const QUrl &amp;<db:emphasis>url</db:emphasis>, const QVariantMap &amp;<db:emphasis>parameters</db:emphasis> = QVariantMap())</db:title>
<db:methodsynopsis>
<db:modifier>virtual</db:modifier>
<db:type>QNetworkReply *</db:type>
<db:methodname>post</db:methodname>
<db:methodparam>
<db:type>const QUrl &amp;</db:type>
<db:parameter>url</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const QVariantMap &amp;</db:type>
<db:parameter>parameters</db:parameter>
<db:initializer>QVariantMap()</db:initializer>
</db:methodparam>
<db:modifier>override</db:modifier>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QNetworkReply * post(const QUrl &amp;url, const QVariantMap &amp;parameters) override</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Reimplements: <db:link xlink:href="qabstractoauth.xml#post" role="function">QAbstractOAuth::post(const QUrl &amp;url, const QVariantMap &amp;parameters)</db:link>.</db:para>
<db:para>Sends an authenticated POST request and returns a new <db:link xlink:href="qnetworkreply.xml">QNetworkReply</db:link>. The <db:code role="parameter">url</db:code> and <db:code role="parameter">parameters</db:code> are used to create the request.</db:para>
<db:para><db:emphasis role="bold">See also</db:emphasis>: <db:link xlink:href="https://tools.ietf.org/html/rfc2616#section-9.5">Hypertext Transfer Protocol – HTTP/1.1: POST</db:link></db:para>
</db:section>
<db:section xml:id="post-1">
<db:title>[virtual] QNetworkReply *QAbstractOAuth2::post(const QUrl &amp;<db:emphasis>url</db:emphasis>, const QByteArray &amp;<db:emphasis>data</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:modifier>virtual</db:modifier>
<db:type>QNetworkReply *</db:type>
<db:methodname>post</db:methodname>
<db:methodparam>
<db:type>const QUrl &amp;</db:type>
<db:parameter>url</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const QByteArray &amp;</db:type>
<db:parameter>data</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">QNetworkReply * post(const QUrl &amp;url, const QByteArray &amp;data)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>Sends an authenticated POST request and returns a new <db:link xlink:href="qnetworkreply.xml">QNetworkReply</db:link>. The <db:code role="parameter">url</db:code> and <db:code role="parameter">data</db:code> are used to create the request.</db:para>
<db:para>{Hypertext Transfer Protocol – HTTP/1.1: POST}</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qabstractoauth2.xml#post">post</db:link>()</db:member>
<db:member><db:link xlink:href="https://tools.ietf.org/html/rfc2616#section-9.6">https://tools.ietf.org/html/rfc2616#section-9.6</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="post-2">
<db:title>[virtual] QNetworkReply *QAbstractOAuth2::post(const QUrl &amp;<db:emphasis>url</db:emphasis>, QHttpMultiPart *<db:emphasis>multiPart</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:modifier>virtual</db:modifier>
<db:type>QNetworkReply *</db:type>
<db:methodname>post</db:methodname>
<db:methodparam>
<db:type>const QUrl &amp;</db:type>
<db:parameter>url</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>QHttpMultiPart *</db:type>
<db:parameter>multiPart</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">2</db:synopsisinfo>
<db:synopsisinfo role="signature">QNetworkReply * post(const QUrl &amp;url, QHttpMultiPart *multiPart)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>Sends an authenticated POST request and returns a new <db:link xlink:href="qnetworkreply.xml">QNetworkReply</db:link>. The <db:code role="parameter">url</db:code> and <db:code role="parameter">multiPart</db:code> are used to create the request.</db:para>
<db:para>{Hypertext Transfer Protocol – HTTP/1.1: POST}</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qabstractoauth2.xml#post">post</db:link>()</db:member>
<db:member><db:link xlink:href="qhttpmultipart.xml">QHttpMultiPart</db:link></db:member>
<db:member><db:link xlink:href="https://tools.ietf.org/html/rfc2616#section-9.6">https://tools.ietf.org/html/rfc2616#section-9.6</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="prepareRequest">
<db:title>[override virtual] void QAbstractOAuth2::prepareRequest(QNetworkRequest *<db:emphasis>request</db:emphasis>, const QByteArray &amp;<db:emphasis>verb</db:emphasis>, const QByteArray &amp;<db:emphasis>body</db:emphasis> = QByteArray())</db:title>
<db:methodsynopsis>
<db:modifier>virtual</db:modifier>
<db:void/>
<db:methodname>prepareRequest</db:methodname>
<db:methodparam>
<db:type>QNetworkRequest *</db:type>
<db:parameter>request</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const QByteArray &amp;</db:type>
<db:parameter>verb</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const QByteArray &amp;</db:type>
<db:parameter>body</db:parameter>
<db:initializer>QByteArray()</db:initializer>
</db:methodparam>
<db:modifier>override</db:modifier>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void prepareRequest(QNetworkRequest *request, const QByteArray &amp;verb, const QByteArray &amp;body) override</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Reimplements: <db:link xlink:href="qabstractoauth.xml#prepareRequest" role="function">QAbstractOAuth::prepareRequest(QNetworkRequest *request, const QByteArray &amp;verb, const QByteArray &amp;body)</db:link>.</db:para>
</db:section>
<db:section xml:id="put">
<db:title>[override virtual] QNetworkReply *QAbstractOAuth2::put(const QUrl &amp;<db:emphasis>url</db:emphasis>, const QVariantMap &amp;<db:emphasis>parameters</db:emphasis> = QVariantMap())</db:title>
<db:methodsynopsis>
<db:modifier>virtual</db:modifier>
<db:type>QNetworkReply *</db:type>
<db:methodname>put</db:methodname>
<db:methodparam>
<db:type>const QUrl &amp;</db:type>
<db:parameter>url</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const QVariantMap &amp;</db:type>
<db:parameter>parameters</db:parameter>
<db:initializer>QVariantMap()</db:initializer>
</db:methodparam>
<db:modifier>override</db:modifier>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QNetworkReply * put(const QUrl &amp;url, const QVariantMap &amp;parameters) override</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Reimplements: <db:link xlink:href="qabstractoauth.xml#put" role="function">QAbstractOAuth::put(const QUrl &amp;url, const QVariantMap &amp;parameters)</db:link>.</db:para>
<db:para>Sends an authenticated PUT request and returns a new <db:link xlink:href="qnetworkreply.xml">QNetworkReply</db:link>. The <db:code role="parameter">url</db:code> and <db:code role="parameter">parameters</db:code> are used to create the request.</db:para>
<db:para><db:emphasis role="bold">See also</db:emphasis>: <db:link xlink:href="https://tools.ietf.org/html/rfc2616#section-9.6">Hypertext Transfer Protocol – HTTP/1.1: PUT</db:link></db:para>
</db:section>
<db:section xml:id="put-1">
<db:title>[virtual] QNetworkReply *QAbstractOAuth2::put(const QUrl &amp;<db:emphasis>url</db:emphasis>, const QByteArray &amp;<db:emphasis>data</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:modifier>virtual</db:modifier>
<db:type>QNetworkReply *</db:type>
<db:methodname>put</db:methodname>
<db:methodparam>
<db:type>const QUrl &amp;</db:type>
<db:parameter>url</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const QByteArray &amp;</db:type>
<db:parameter>data</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">QNetworkReply * put(const QUrl &amp;url, const QByteArray &amp;data)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>Sends an authenticated PUT request and returns a new <db:link xlink:href="qnetworkreply.xml">QNetworkReply</db:link>. The <db:code role="parameter">url</db:code> and <db:code role="parameter">data</db:code> are used to create the request.</db:para>
<db:para>{Hypertext Transfer Protocol – HTTP/1.1: PUT}</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qabstractoauth2.xml#put">put</db:link>()</db:member>
<db:member><db:link xlink:href="https://tools.ietf.org/html/rfc2616#section-9.6">https://tools.ietf.org/html/rfc2616#section-9.6</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="put-2">
<db:title>[virtual] QNetworkReply *QAbstractOAuth2::put(const QUrl &amp;<db:emphasis>url</db:emphasis>, QHttpMultiPart *<db:emphasis>multiPart</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:modifier>virtual</db:modifier>
<db:type>QNetworkReply *</db:type>
<db:methodname>put</db:methodname>
<db:methodparam>
<db:type>const QUrl &amp;</db:type>
<db:parameter>url</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>QHttpMultiPart *</db:type>
<db:parameter>multiPart</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">2</db:synopsisinfo>
<db:synopsisinfo role="signature">QNetworkReply * put(const QUrl &amp;url, QHttpMultiPart *multiPart)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>Sends an authenticated PUT request and returns a new <db:link xlink:href="qnetworkreply.xml">QNetworkReply</db:link>. The <db:code role="parameter">url</db:code> and <db:code role="parameter">multiPart</db:code> are used to create the request.</db:para>
<db:para>{Hypertext Transfer Protocol – HTTP/1.1: PUT}</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qabstractoauth2.xml#put">put</db:link>()</db:member>
<db:member><db:link xlink:href="qhttpmultipart.xml">QHttpMultiPart</db:link></db:member>
<db:member><db:link xlink:href="https://tools.ietf.org/html/rfc2616#section-9.6">https://tools.ietf.org/html/rfc2616#section-9.6</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="refreshToken">
<db:title>QString QAbstractOAuth2::refreshToken() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QString</db:type>
<db:methodname>refreshToken</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="associated-property">refreshToken</db:synopsisinfo>
<db:synopsisinfo role="signature">QString refreshToken() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Gets the current refresh token.</db:para>
<db:para>Refresh tokens usually have longer lifespans than access tokens, so it makes sense to save them for later use.</db:para>
<db:para>Returns the current refresh token or an empty string, if there is no refresh token available.</db:para>
<db:note>
<db:para>Getter function for property refreshToken. </db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qabstractoauth2.xml#setRefreshToken">setRefreshToken</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="responseType">
<db:title>QString QAbstractOAuth2::responseType() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QString</db:type>
<db:methodname>responseType</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QString responseType() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the <db:link xlink:href="https://tools.ietf.org/html/rfc6749#section-3.1.1">response_type</db:link> used.</db:para>
</db:section>
<db:section xml:id="setRefreshToken">
<db:title>void QAbstractOAuth2::setRefreshToken(const QString &amp;<db:emphasis>refreshToken</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>setRefreshToken</db:methodname>
<db:methodparam>
<db:type>const QString &amp;</db:type>
<db:parameter>refreshToken</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="associated-property">refreshToken</db:synopsisinfo>
<db:synopsisinfo role="signature">void setRefreshToken(const QString &amp;refreshToken)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Sets the new refresh token <db:code role="parameter">refreshToken</db:code> to be used.</db:para>
<db:para>A custom refresh token can be used to refresh the access token via this method and then the access token can be refreshed via <db:link xlink:href="qoauth2authorizationcodeflow.xml#refreshAccessToken">QOAuth2AuthorizationCodeFlow::refreshAccessToken</db:link>().</db:para>
<db:note>
<db:para>Setter function for property refreshToken. </db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qabstractoauth2.xml#refreshToken">refreshToken</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setSslConfiguration">
<db:title>[since 6.5] void QAbstractOAuth2::setSslConfiguration(const QSslConfiguration &amp;<db:emphasis>configuration</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>setSslConfiguration</db:methodname>
<db:methodparam>
<db:type>const QSslConfiguration &amp;</db:type>
<db:parameter>configuration</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void setSslConfiguration(const QSslConfiguration &amp;configuration)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Sets the TLS <db:code role="parameter">configuration</db:code> to be used when establishing a mutual TLS connection between the client and the Authorization Server.</db:para>
<db:para>This function was introduced in Qt 6.5.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qabstractoauth2.xml#sslConfiguration">sslConfiguration</db:link>()</db:member>
<db:member><db:link xlink:href="qabstractoauth2.xml#sslConfigurationChanged">sslConfigurationChanged</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="sslConfiguration">
<db:title>[since 6.5] QSslConfiguration QAbstractOAuth2::sslConfiguration() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QSslConfiguration</db:type>
<db:methodname>sslConfiguration</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QSslConfiguration sslConfiguration() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the TLS configuration to be used when establishing a mutual TLS connection between the client and the Authorization Server.</db:para>
<db:para>This function was introduced in Qt 6.5.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qabstractoauth2.xml#setSslConfiguration">setSslConfiguration</db:link>()</db:member>
<db:member><db:link xlink:href="qabstractoauth2.xml#sslConfigurationChanged">sslConfigurationChanged</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="sslConfigurationChanged">
<db:title>[since 6.5] void QAbstractOAuth2::sslConfigurationChanged(const QSslConfiguration &amp;<db:emphasis>configuration</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>sslConfigurationChanged</db:methodname>
<db:methodparam>
<db:type>const QSslConfiguration &amp;</db:type>
<db:parameter>configuration</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void sslConfigurationChanged(const QSslConfiguration &amp;configuration)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>The signal is emitted when the TLS configuration has changed. The <db:code role="parameter">configuration</db:code> parameter contains the new TLS configuration.</db:para>
<db:para>This function was introduced in Qt 6.5.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qabstractoauth2.xml#sslConfiguration">sslConfiguration</db:link>()</db:member>
<db:member><db:link xlink:href="qabstractoauth2.xml#setSslConfiguration">setSslConfiguration</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
</db:section>
</db:article>
