<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en">
<db:info>
<db:title>QSharedMemory Class</db:title>
<db:productname>QtCore</db:productname>
<db:edition>Qt 6.4.3 Reference Documentation</db:edition>
<db:titleabbrev>Qt Core Reference Documentation</db:titleabbrev>
<db:abstract>
<db:para>The <db:link xlink:href="qsharedmemory.xml">QSharedMemory</db:link> class provides access to a shared memory segment.</db:para>
</db:abstract>
<db:pubdate>2024-01-26</db:pubdate>
<db:date>2024-01-26</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:variablelist>
<db:varlistentry>
<db:term>Header</db:term>
<db:listitem>
<db:para>QSharedMemory</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>CMake</db:term>
<db:listitem>
<db:para>find_package(Qt6 REQUIRED COMPONENTS Core)</db:para>
<db:para>target_link_libraries(mytarget PRIVATE Qt6::Core)</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>qmake</db:term>
<db:listitem>
<db:para>QT += core</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Inherits</db:term>
<db:listitem>
<db:para><db:link xlink:href="qobject.xml" xlink:role="class">QObject</db:link></db:para>
</db:listitem>
</db:varlistentry>
</db:variablelist>
<db:section xml:id="details">
<db:title>Detailed Description</db:title>
<db:para><db:link xlink:href="qsharedmemory.xml">QSharedMemory</db:link> provides access to a shared memory segment by multiple threads and processes. It also provides a way for a single thread or process to lock the memory for exclusive access.</db:para>
<db:para>When using this class, be aware of the following platform differences:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para>Windows: <db:link xlink:href="qsharedmemory.xml">QSharedMemory</db:link> does not &quot;own&quot; the shared memory segment. When all threads or processes that have an instance of <db:link xlink:href="qsharedmemory.xml">QSharedMemory</db:link> attached to a particular shared memory segment have either destroyed their instance of <db:link xlink:href="qsharedmemory.xml">QSharedMemory</db:link> or exited, the Windows kernel releases the shared memory segment automatically.</db:para>
</db:listitem>
<db:listitem>
<db:para>Unix: <db:link xlink:href="qsharedmemory.xml">QSharedMemory</db:link> &quot;owns&quot; the shared memory segment. When the last thread or process that has an instance of <db:link xlink:href="qsharedmemory.xml">QSharedMemory</db:link> attached to a particular shared memory segment detaches from the segment by destroying its instance of <db:link xlink:href="qsharedmemory.xml">QSharedMemory</db:link>, the Unix kernel release the shared memory segment. But if that last thread or process crashes without running the <db:link xlink:href="qsharedmemory.xml">QSharedMemory</db:link> destructor, the shared memory segment survives the crash.</db:para>
</db:listitem>
<db:listitem>
<db:para>HP-UX: Only one attach to a shared memory segment is allowed per process. This means that <db:link xlink:href="qsharedmemory.xml">QSharedMemory</db:link> should not be used across multiple threads in the same process in HP-UX.</db:para>
</db:listitem>
<db:listitem>
<db:para>Apple platforms: Sandboxed applications (including apps shipped through the Apple App Store) require the use of POSIX shared memory (instead of System V shared memory), which adds a number of limitations, including:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para>The key must be in the form &lt;application group identifier&gt;/&lt;custom identifier&gt;, as documented <db:link xlink:href="https://developer.apple.com/library/archive/documentation/Security/Conceptual/AppSandboxDesignGuide/AppSandboxInDepth/AppSandboxInDepth.html#//apple_ref/doc/uid/TP40011183-CH3-SW24">here</db:link> and <db:link xlink:href="https://developer.apple.com/documentation/bundleresources/entitlements/com_apple_security_application-groups">here</db:link>.</db:para>
</db:listitem>
<db:listitem>
<db:para>The key length is limited to 30 characters.</db:para>
</db:listitem>
<db:listitem>
<db:para>On process exit, the named shared memory entries are not cleaned up, so restarting the application and re-creating the shared memory under the same name will fail. To work around this, fall back to attaching to the existing shared memory entry:</db:para>
<db:programlisting language="cpp">QSharedMemory shm(&quot;DEVTEAMID.app-group/shared&quot;);
if (!shm.create(42) &amp;amp;&amp;amp; shm.error() == QSharedMemory::AlreadyExists)
    shm.attach();
</db:programlisting>
</db:listitem>
</db:itemizedlist>
<db:para>Qt for iOS comes with support for POSIX shared memory out of the box. With Qt for macOS an additional configure flag must be added when building Qt to enable the feature. To enable the feature pass -feature-ipc_posix Note that the pre-built Qt libraries for macOS available through the Qt installer do not include this feature.</db:para>
</db:listitem>
</db:itemizedlist>
<db:para>Remember to lock the shared memory with <db:link xlink:href="qsharedmemory.xml#lock">lock</db:link>() before reading from or writing to the shared memory, and remember to release the lock with <db:link xlink:href="qsharedmemory.xml#unlock">unlock</db:link>() after you are done.</db:para>
<db:para><db:link xlink:href="qsharedmemory.xml">QSharedMemory</db:link> automatically destroys the shared memory segment when the last instance of <db:link xlink:href="qsharedmemory.xml">QSharedMemory</db:link> is detached from the segment, and no references to the segment remain.</db:para>
<db:warning>
<db:para><db:link xlink:href="qsharedmemory.xml">QSharedMemory</db:link> changes the key in a Qt-specific way, unless otherwise specified. Interoperation with non-Qt applications is achieved by first creating a default shared memory with <db:link xlink:href="qsharedmemory.xml#QSharedMemory">QSharedMemory</db:link>() and then setting a native key with <db:link xlink:href="qsharedmemory.xml#setNativeKey">setNativeKey</db:link>(). When using native keys, shared memory is not protected against multiple accesses on it (for example, unable to <db:link xlink:href="qsharedmemory.xml#lock">lock</db:link>()) and a user-defined mechanism should be used to achieve such protection.</db:para>
</db:warning>
</db:section>
<db:section xml:id="member-type-documentation">
<db:title>Member Type Documentation</db:title>
<db:section xml:id="AccessMode-enum">
<db:title>enum QSharedMemory::AccessMode</db:title>
<db:enumsynopsis>
<db:enumname>AccessMode</db:enumname>
<db:enumitem>
<db:enumidentifier>ReadOnly</db:enumidentifier>
<db:enumvalue>0</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>ReadWrite</db:enumidentifier>
<db:enumvalue>1</db:enumvalue>
</db:enumitem>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:enumsynopsis>
<db:informaltable>
<db:thead>
<db:tr>
<db:th>Constant</db:th>
<db:th>Value</db:th>
<db:th>Description</db:th>
</db:tr>
</db:thead>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qsharedmemory.xml">QSharedMemory</db:link></db:emphasis>::ReadOnly</db:code></db:para>
</db:td>
<db:td><db:code>0</db:code></db:td>
<db:td>
<db:para>The shared memory segment is read-only. Writing to the shared memory segment is not allowed. An attempt to write to a shared memory segment created with ReadOnly causes the program to abort.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qsharedmemory.xml">QSharedMemory</db:link></db:emphasis>::ReadWrite</db:code></db:para>
</db:td>
<db:td><db:code>1</db:code></db:td>
<db:td>
<db:para>Reading and writing the shared memory segment are both allowed.</db:para>
</db:td>
</db:tr>
</db:informaltable>
</db:section>
<db:section xml:id="SharedMemoryError-enum">
<db:title>enum QSharedMemory::SharedMemoryError</db:title>
<db:enumsynopsis>
<db:enumname>SharedMemoryError</db:enumname>
<db:enumitem>
<db:enumidentifier>NoError</db:enumidentifier>
<db:enumvalue>0</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>PermissionDenied</db:enumidentifier>
<db:enumvalue>1</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>InvalidSize</db:enumidentifier>
<db:enumvalue>2</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>KeyError</db:enumidentifier>
<db:enumvalue>3</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>AlreadyExists</db:enumidentifier>
<db:enumvalue>4</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>NotFound</db:enumidentifier>
<db:enumvalue>5</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>LockError</db:enumidentifier>
<db:enumvalue>6</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>OutOfResources</db:enumidentifier>
<db:enumvalue>7</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>UnknownError</db:enumidentifier>
<db:enumvalue>8</db:enumvalue>
</db:enumitem>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:enumsynopsis>
<db:informaltable>
<db:thead>
<db:tr>
<db:th>Constant</db:th>
<db:th>Value</db:th>
<db:th>Description</db:th>
</db:tr>
</db:thead>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qsharedmemory.xml">QSharedMemory</db:link></db:emphasis>::NoError</db:code></db:para>
</db:td>
<db:td><db:code>0</db:code></db:td>
<db:td>
<db:para>No error occurred.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qsharedmemory.xml">QSharedMemory</db:link></db:emphasis>::PermissionDenied</db:code></db:para>
</db:td>
<db:td><db:code>1</db:code></db:td>
<db:td>
<db:para>The operation failed because the caller didn't have the required permissions.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qsharedmemory.xml">QSharedMemory</db:link></db:emphasis>::InvalidSize</db:code></db:para>
</db:td>
<db:td><db:code>2</db:code></db:td>
<db:td>
<db:para>A create operation failed because the requested size was invalid.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qsharedmemory.xml">QSharedMemory</db:link></db:emphasis>::KeyError</db:code></db:para>
</db:td>
<db:td><db:code>3</db:code></db:td>
<db:td>
<db:para>The operation failed because of an invalid key.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qsharedmemory.xml">QSharedMemory</db:link></db:emphasis>::AlreadyExists</db:code></db:para>
</db:td>
<db:td><db:code>4</db:code></db:td>
<db:td>
<db:para>A <db:link xlink:href="qsharedmemory.xml#create">create</db:link>() operation failed because a shared memory segment with the specified key already existed.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qsharedmemory.xml">QSharedMemory</db:link></db:emphasis>::NotFound</db:code></db:para>
</db:td>
<db:td><db:code>5</db:code></db:td>
<db:td>
<db:para>An <db:link xlink:href="qsharedmemory.xml#attach">attach</db:link>() failed because a shared memory segment with the specified key could not be found.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qsharedmemory.xml">QSharedMemory</db:link></db:emphasis>::LockError</db:code></db:para>
</db:td>
<db:td><db:code>6</db:code></db:td>
<db:td>
<db:para>The attempt to <db:link xlink:href="qsharedmemory.xml#lock">lock</db:link>() the shared memory segment failed because <db:link xlink:href="qsharedmemory.xml#create">create</db:link>() or <db:link xlink:href="qsharedmemory.xml#attach">attach</db:link>() failed and returned false, or because a system error occurred in <db:link xlink:href="qsystemsemaphore.xml#acquire">QSystemSemaphore::acquire</db:link>().</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qsharedmemory.xml">QSharedMemory</db:link></db:emphasis>::OutOfResources</db:code></db:para>
</db:td>
<db:td><db:code>7</db:code></db:td>
<db:td>
<db:para>A <db:link xlink:href="qsharedmemory.xml#create">create</db:link>() operation failed because there was not enough memory available to fill the request.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qsharedmemory.xml">QSharedMemory</db:link></db:emphasis>::UnknownError</db:code></db:para>
</db:td>
<db:td><db:code>8</db:code></db:td>
<db:td>
<db:para>Something else happened and it was bad.</db:para>
</db:td>
</db:tr>
</db:informaltable>
</db:section>
</db:section>
<db:section xml:id="member-function-documentation">
<db:title>Member Function Documentation</db:title>
<db:section xml:id="QSharedMemory">
<db:title>QSharedMemory::QSharedMemory(const QString &amp;<db:emphasis>key</db:emphasis>, QObject *<db:emphasis>parent</db:emphasis> = nullptr)</db:title>
<db:constructorsynopsis>
<db:methodname>QSharedMemory</db:methodname>
<db:methodparam>
<db:type>const QString &amp;</db:type>
<db:parameter>key</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>QObject *</db:type>
<db:parameter>parent</db:parameter>
<db:initializer>nullptr</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">constructor</db:synopsisinfo>
<db:synopsisinfo role="signature">QSharedMemory(const QString &amp;key, QObject *parent)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:constructorsynopsis>
<db:para>Constructs a shared memory object with the given <db:code role="parameter">parent</db:code> and with its key set to <db:code role="parameter">key</db:code>. Because its key is set, its <db:link xlink:href="qsharedmemory.xml#create">create</db:link>() and <db:link xlink:href="qsharedmemory.xml#attach">attach</db:link>() functions can be called.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qsharedmemory.xml#setKey">setKey</db:link>()</db:member>
<db:member><db:link xlink:href="qsharedmemory.xml#create">create</db:link>()</db:member>
<db:member><db:link xlink:href="qsharedmemory.xml#attach">attach</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="QSharedMemory-1">
<db:title>QSharedMemory::QSharedMemory(QObject *<db:emphasis>parent</db:emphasis> = nullptr)</db:title>
<db:constructorsynopsis>
<db:methodname>QSharedMemory</db:methodname>
<db:methodparam>
<db:type>QObject *</db:type>
<db:parameter>parent</db:parameter>
<db:initializer>nullptr</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">constructor</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">QSharedMemory(QObject *parent)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:constructorsynopsis>
<db:para>This function overloads <db:link xlink:href="qsharedmemory.xml#QSharedMemory">QSharedMemory</db:link>().</db:para>
<db:para>Constructs a shared memory object with the given <db:code role="parameter">parent</db:code>. The shared memory object's key is not set by the constructor, so the shared memory object does not have an underlying shared memory segment attached. The key must be set with <db:link xlink:href="qsharedmemory.xml#setKey">setKey</db:link>() or <db:link xlink:href="qsharedmemory.xml#setNativeKey">setNativeKey</db:link>() before <db:link xlink:href="qsharedmemory.xml#create">create</db:link>() or <db:link xlink:href="qsharedmemory.xml#attach">attach</db:link>() can be used.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qsharedmemory.xml#setKey">setKey</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="dtor.QSharedMemory">
<db:title>[virtual] QSharedMemory::~QSharedMemory()</db:title>
<db:destructorsynopsis>
<db:modifier>virtual</db:modifier>
<db:methodname>~QSharedMemory</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">destructor</db:synopsisinfo>
<db:synopsisinfo role="signature">~QSharedMemory()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:destructorsynopsis>
<db:para>The destructor clears the key, which forces the shared memory object to <db:link xlink:href="qsharedmemory.xml#detach">detach</db:link> from its underlying shared memory segment. If this shared memory object is the last one connected to the shared memory segment, the <db:link xlink:href="qsharedmemory.xml#detach">detach</db:link>() operation destroys the shared memory segment.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qsharedmemory.xml#detach">detach</db:link>()</db:member>
<db:member><db:link xlink:href="qsharedmemory.xml#isAttached">isAttached</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="attach">
<db:title>bool QSharedMemory::attach(QSharedMemory::AccessMode <db:emphasis>mode</db:emphasis> = ReadWrite)</db:title>
<db:methodsynopsis>
<db:type>bool</db:type>
<db:methodname>attach</db:methodname>
<db:methodparam>
<db:type>QSharedMemory::AccessMode</db:type>
<db:parameter>mode</db:parameter>
<db:initializer>ReadWrite</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool attach(QSharedMemory::AccessMode mode)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Attempts to attach the process to the shared memory segment identified by the key that was passed to the constructor or to a call to <db:link xlink:href="qsharedmemory.xml#setKey">setKey</db:link>() or <db:link xlink:href="qsharedmemory.xml#setNativeKey">setNativeKey</db:link>(). The access <db:code role="parameter">mode</db:code> is <db:link xlink:href="qsharedmemory.xml#AccessMode-enum">ReadWrite</db:link> by default. It can also be <db:link xlink:href="qsharedmemory.xml#AccessMode-enum">ReadOnly</db:link>. Returns true if the attach operation is successful. If false is returned, call <db:link xlink:href="qsharedmemory.xml#error">error</db:link>() to determine which error occurred. After attaching the shared memory segment, a pointer to the shared memory can be obtained by calling <db:link xlink:href="qsharedmemory.xml#data">data</db:link>().</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qsharedmemory.xml#isAttached">isAttached</db:link>()</db:member>
<db:member><db:link xlink:href="qsharedmemory.xml#detach">detach</db:link>()</db:member>
<db:member><db:link xlink:href="qsharedmemory.xml#create">create</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="constData">
<db:title>const void *QSharedMemory::constData() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>const void *</db:type>
<db:methodname>constData</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">const void * constData() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns a const pointer to the contents of the shared memory segment, if one is attached. Otherwise it returns null. Remember to lock the shared memory with <db:link xlink:href="qsharedmemory.xml#lock">lock</db:link>() before reading from or writing to the shared memory, and remember to release the lock with <db:link xlink:href="qsharedmemory.xml#unlock">unlock</db:link>() after you are done.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qsharedmemory.xml#attach">attach</db:link>()</db:member>
<db:member><db:link xlink:href="qsharedmemory.xml#create">create</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="create">
<db:title>bool QSharedMemory::create(qsizetype <db:emphasis>size</db:emphasis>, QSharedMemory::AccessMode <db:emphasis>mode</db:emphasis> = ReadWrite)</db:title>
<db:methodsynopsis>
<db:type>bool</db:type>
<db:methodname>create</db:methodname>
<db:methodparam>
<db:type>qsizetype</db:type>
<db:parameter>size</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>QSharedMemory::AccessMode</db:type>
<db:parameter>mode</db:parameter>
<db:initializer>ReadWrite</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool create(qsizetype size, QSharedMemory::AccessMode mode)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Creates a shared memory segment of <db:code role="parameter">size</db:code> bytes with the key passed to the constructor, set with <db:link xlink:href="qsharedmemory.xml#setKey">setKey</db:link>() or set with <db:link xlink:href="qsharedmemory.xml#setNativeKey">setNativeKey</db:link>(), then attaches to the new shared memory segment with the given access <db:code role="parameter">mode</db:code> and returns <db:code>true</db:code>. If a shared memory segment identified by the key already exists, the attach operation is not performed and <db:code>false</db:code> is returned. When the return value is <db:code>false</db:code>, call <db:link xlink:href="qsharedmemory.xml#error">error</db:link>() to determine which error occurred.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qsharedmemory.xml#error">error</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="data">
<db:title>void *QSharedMemory::data()</db:title>
<db:methodsynopsis>
<db:type>void *</db:type>
<db:methodname>data</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void * data()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns a pointer to the contents of the shared memory segment, if one is attached. Otherwise it returns null. Remember to lock the shared memory with <db:link xlink:href="qsharedmemory.xml#lock">lock</db:link>() before reading from or writing to the shared memory, and remember to release the lock with <db:link xlink:href="qsharedmemory.xml#unlock">unlock</db:link>() after you are done.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qsharedmemory.xml#attach">attach</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="data-1">
<db:title>const void *QSharedMemory::data() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>const void *</db:type>
<db:methodname>data</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">const void * data() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This function overloads <db:link xlink:href="qsharedmemory.xml#data">data</db:link>().</db:para>
</db:section>
<db:section xml:id="detach">
<db:title>bool QSharedMemory::detach()</db:title>
<db:methodsynopsis>
<db:type>bool</db:type>
<db:methodname>detach</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool detach()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Detaches the process from the shared memory segment. If this was the last process attached to the shared memory segment, then the shared memory segment is released by the system, i.e., the contents are destroyed. The function returns true if it detaches the shared memory segment. If it returns false, it usually means the segment either isn't attached, or it is locked by another process.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qsharedmemory.xml#attach">attach</db:link>()</db:member>
<db:member><db:link xlink:href="qsharedmemory.xml#isAttached">isAttached</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="error">
<db:title>QSharedMemory::SharedMemoryError QSharedMemory::error() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QSharedMemory::SharedMemoryError</db:type>
<db:methodname>error</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QSharedMemory::SharedMemoryError error() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns a value indicating whether an error occurred, and, if so, which error it was.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qsharedmemory.xml#errorString">errorString</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="errorString">
<db:title>QString QSharedMemory::errorString() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QString</db:type>
<db:methodname>errorString</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QString errorString() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns a text description of the last error that occurred. If <db:link xlink:href="qsharedmemory.xml#error">error</db:link>() returns an <db:link xlink:href="qsharedmemory.xml#SharedMemoryError-enum">error value</db:link>, call this function to get a text string that describes the error.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qsharedmemory.xml#error">error</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="isAttached">
<db:title>bool QSharedMemory::isAttached() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>bool</db:type>
<db:methodname>isAttached</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool isAttached() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns true if this process is attached to the shared memory segment.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qsharedmemory.xml#attach">attach</db:link>()</db:member>
<db:member><db:link xlink:href="qsharedmemory.xml#detach">detach</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="key">
<db:title>QString QSharedMemory::key() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QString</db:type>
<db:methodname>key</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QString key() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the key assigned with <db:link xlink:href="qsharedmemory.xml#setKey">setKey</db:link>() to this shared memory, or a null key if no key has been assigned, or if the segment is using a <db:link xlink:href="qsharedmemory.xml#nativeKey">nativeKey</db:link>(). The key is the identifier used by Qt applications to identify the shared memory segment.</db:para>
<db:para>You can find the native, platform specific, key used by the operating system by calling <db:link xlink:href="qsharedmemory.xml#nativeKey">nativeKey</db:link>().</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qsharedmemory.xml#setKey">setKey</db:link>()</db:member>
<db:member><db:link xlink:href="qsharedmemory.xml#setNativeKey">setNativeKey</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="lock">
<db:title>bool QSharedMemory::lock()</db:title>
<db:methodsynopsis>
<db:type>bool</db:type>
<db:methodname>lock</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool lock()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is a semaphore that locks the shared memory segment for access by this process and returns true. If another process has locked the segment, this function blocks until the lock is released. Then it acquires the lock and returns true. If this function returns false, it means that you have ignored a false return from <db:link xlink:href="qsharedmemory.xml#create">create</db:link>() or <db:link xlink:href="qsharedmemory.xml#attach">attach</db:link>(), that you have set the key with <db:link xlink:href="qsharedmemory.xml#setNativeKey">setNativeKey</db:link>() or that <db:link xlink:href="qsystemsemaphore.xml#acquire">QSystemSemaphore::acquire</db:link>() failed due to an unknown system error.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qsharedmemory.xml#unlock">unlock</db:link>()</db:member>
<db:member><db:link xlink:href="qsharedmemory.xml#data">data</db:link>()</db:member>
<db:member><db:link xlink:href="qsystemsemaphore.xml#acquire">QSystemSemaphore::acquire</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="nativeKey">
<db:title>QString QSharedMemory::nativeKey() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QString</db:type>
<db:methodname>nativeKey</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QString nativeKey() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the native, platform specific, key for this shared memory object. The native key is the identifier used by the operating system to identify the shared memory segment.</db:para>
<db:para>You can use the native key to access shared memory segments that have not been created by Qt, or to grant shared memory access to non-Qt applications.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qsharedmemory.xml#setKey">setKey</db:link>()</db:member>
<db:member><db:link xlink:href="qsharedmemory.xml#setNativeKey">setNativeKey</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setKey">
<db:title>void QSharedMemory::setKey(const QString &amp;<db:emphasis>key</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>setKey</db:methodname>
<db:methodparam>
<db:type>const QString &amp;</db:type>
<db:parameter>key</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void setKey(const QString &amp;key)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Sets the platform independent <db:code role="parameter">key</db:code> for this shared memory object. If <db:code role="parameter">key</db:code> is the same as the current key, the function returns without doing anything.</db:para>
<db:para>You can call <db:link xlink:href="qsharedmemory.xml#key">key</db:link>() to retrieve the platform independent key. Internally, <db:link xlink:href="qsharedmemory.xml">QSharedMemory</db:link> converts this key into a platform specific key. If you instead call <db:link xlink:href="qsharedmemory.xml#nativeKey">nativeKey</db:link>(), you will get the platform specific, converted key.</db:para>
<db:para>If the shared memory object is attached to an underlying shared memory segment, it will <db:link xlink:href="qsharedmemory.xml#detach">detach</db:link> from it before setting the new key. This function does not do an <db:link xlink:href="qsharedmemory.xml#attach">attach</db:link>().</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qsharedmemory.xml#key">key</db:link>()</db:member>
<db:member><db:link xlink:href="qsharedmemory.xml#nativeKey">nativeKey</db:link>()</db:member>
<db:member><db:link xlink:href="qsharedmemory.xml#isAttached">isAttached</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setNativeKey">
<db:title>void QSharedMemory::setNativeKey(const QString &amp;<db:emphasis>key</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>setNativeKey</db:methodname>
<db:methodparam>
<db:type>const QString &amp;</db:type>
<db:parameter>key</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void setNativeKey(const QString &amp;key)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Sets the native, platform specific, <db:code role="parameter">key</db:code> for this shared memory object. If <db:code role="parameter">key</db:code> is the same as the current native key, the function returns without doing anything. If all you want is to assign a key to a segment, you should call <db:link xlink:href="qsharedmemory.xml#setKey">setKey</db:link>() instead.</db:para>
<db:para>You can call <db:link xlink:href="qsharedmemory.xml#nativeKey">nativeKey</db:link>() to retrieve the native key. If a native key has been assigned, calling <db:link xlink:href="qsharedmemory.xml#key">key</db:link>() will return a null string.</db:para>
<db:para>If the shared memory object is attached to an underlying shared memory segment, it will <db:link xlink:href="qsharedmemory.xml#detach">detach</db:link> from it before setting the new key. This function does not do an <db:link xlink:href="qsharedmemory.xml#attach">attach</db:link>().</db:para>
<db:para>The application will not be portable if you set a native key.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qsharedmemory.xml#nativeKey">nativeKey</db:link>()</db:member>
<db:member><db:link xlink:href="qsharedmemory.xml#key">key</db:link>()</db:member>
<db:member><db:link xlink:href="qsharedmemory.xml#isAttached">isAttached</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="size">
<db:title>qsizetype QSharedMemory::size() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>qsizetype</db:type>
<db:methodname>size</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">qsizetype size() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the size of the attached shared memory segment. If no shared memory segment is attached, 0 is returned.</db:para>
<db:note>
<db:para>The size of the segment may be larger than the requested size that was passed to <db:link xlink:href="qsharedmemory.xml#create">create</db:link>().</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qsharedmemory.xml#create">create</db:link>()</db:member>
<db:member><db:link xlink:href="qsharedmemory.xml#attach">attach</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="unlock">
<db:title>bool QSharedMemory::unlock()</db:title>
<db:methodsynopsis>
<db:type>bool</db:type>
<db:methodname>unlock</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool unlock()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Releases the lock on the shared memory segment and returns true, if the lock is currently held by this process. If the segment is not locked, or if the lock is held by another process, nothing happens and false is returned.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qsharedmemory.xml#lock">lock</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
</db:section>
</db:article>
