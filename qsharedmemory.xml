<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en_US">
<db:info>
<db:title>QSharedMemory Class</db:title>
<db:productname>QtCore</db:productname>
<db:titleabbrev>Qt Core Reference Documentation</db:titleabbrev>
<db:abstract>
<db:para>The <db:link xlink:href="qsharedmemory.xml">QSharedMemory</db:link> class provides access to a shared memory segment.</db:para>
<db:para>This class was introduced in Qt 4.4.</db:para>
</db:abstract>
<db:pubdate>2025-06-29</db:pubdate>
<db:date>2025-06-29</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:variablelist>
<db:varlistentry>
<db:term>Header</db:term>
<db:listitem>
<db:para>QSharedMemory</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Since</db:term>
<db:listitem>
<db:para>Qt 4.4</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Inherits</db:term>
<db:listitem>
<db:para><db:link xlink:href="qobject.xml" xlink:role="class">QObject</db:link></db:para>
</db:listitem>
</db:varlistentry>
</db:variablelist>
<db:section xml:id="details">
<db:title>Detailed Description</db:title>
<db:para><db:link xlink:href="qsharedmemory.xml">QSharedMemory</db:link> provides access to a shared memory segment by multiple threads and processes. It also provides a way for a single thread or process to lock the memory for exclusive access.</db:para>
<db:para>When using this class, be aware of the following platform differences:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para>Windows: <db:link xlink:href="qsharedmemory.xml">QSharedMemory</db:link> does not &quot;own&quot; the shared memory segment. When all threads or processes that have an instance of <db:link xlink:href="qsharedmemory.xml">QSharedMemory</db:link> attached to a particular shared memory segment have either destroyed their instance of <db:link xlink:href="qsharedmemory.xml">QSharedMemory</db:link> or exited, the Windows kernel releases the shared memory segment automatically.</db:para>
</db:listitem>
<db:listitem>
<db:para>Unix: <db:link xlink:href="qsharedmemory.xml">QSharedMemory</db:link> &quot;owns&quot; the shared memory segment. When the last thread or process that has an instance of <db:link xlink:href="qsharedmemory.xml">QSharedMemory</db:link> attached to a particular shared memory segment detaches from the segment by destroying its instance of <db:link xlink:href="qsharedmemory.xml">QSharedMemory</db:link>, the Unix kernel release the shared memory segment. But if that last thread or process crashes without running the <db:link xlink:href="qsharedmemory.xml">QSharedMemory</db:link> destructor, the shared memory segment survives the crash.</db:para>
</db:listitem>
<db:listitem>
<db:para>HP-UX: Only one attach to a shared memory segment is allowed per process. This means that <db:link xlink:href="qsharedmemory.xml">QSharedMemory</db:link> should not be used across multiple threads in the same process in HP-UX.</db:para>
</db:listitem>
</db:itemizedlist>
<db:para>Remember to lock the shared memory with <db:link xlink:href="qsharedmemory.xml#lock">lock</db:link>() before reading from or writing to the shared memory, and remember to release the lock with <db:link xlink:href="qsharedmemory.xml#unlock">unlock</db:link>() after you are done.</db:para>
<db:para>Unlike QtSharedMemory, <db:link xlink:href="qsharedmemory.xml">QSharedMemory</db:link> automatically destroys the shared memory segment when the last instance of <db:link xlink:href="qsharedmemory.xml">QSharedMemory</db:link> is detached from the segment, and no references to the segment remain. Do not mix using QtSharedMemory and <db:link xlink:href="qsharedmemory.xml">QSharedMemory</db:link>. Port everything to <db:link xlink:href="qsharedmemory.xml">QSharedMemory</db:link>.</db:para>
<db:warning>
<db:para><db:link xlink:href="qsharedmemory.xml">QSharedMemory</db:link> changes the key in a Qt-specific way, unless otherwise specified. Interoperation with non-Qt applications is achieved by first creating a default shared memory with <db:link xlink:href="qsharedmemory.xml#QSharedMemory">QSharedMemory</db:link>() and then setting a native key with <db:link xlink:href="qsharedmemory.xml#setNativeKey">setNativeKey</db:link>(). When using native keys, shared memory is not protected against multiple accesses on it (e.g. unable to <db:link xlink:href="qsharedmemory.xml#lock">lock</db:link>()) and a user-defined mechanism should be used to achieve a such protection.</db:para>
</db:warning>
</db:section>
<db:section xml:id="member-type-documentation">
<db:title>Member Type Documentation</db:title>
<db:section xml:id="AccessMode-enum">
<db:title>enum QSharedMemory::AccessMode</db:title>
<db:informaltable>
<db:thead>
<db:tr>
<db:th>Constant</db:th>
<db:th>Value</db:th>
<db:th>Description</db:th>
</db:tr>
</db:thead>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qsharedmemory.xml">QSharedMemory</db:link></db:emphasis>::ReadOnly</db:code></db:para>
</db:td>
<db:td><db:code>0</db:code></db:td>
<db:td>
<db:para>The shared memory segment is read-only. Writing to the shared memory segment is not allowed. An attempt to write to a shared memory segment created with ReadOnly causes the program to abort.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qsharedmemory.xml">QSharedMemory</db:link></db:emphasis>::ReadWrite</db:code></db:para>
</db:td>
<db:td><db:code>1</db:code></db:td>
<db:td>
<db:para>Reading and writing the shared memory segment are both allowed.</db:para>
</db:td>
</db:tr>
</db:informaltable>
</db:section>
<db:section xml:id="SharedMemoryError-enum">
<db:title>enum QSharedMemory::SharedMemoryError</db:title>
<db:informaltable>
<db:thead>
<db:tr>
<db:th>Constant</db:th>
<db:th>Value</db:th>
<db:th>Description</db:th>
</db:tr>
</db:thead>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qsharedmemory.xml">QSharedMemory</db:link></db:emphasis>::NoError</db:code></db:para>
</db:td>
<db:td><db:code>0</db:code></db:td>
<db:td>
<db:para>No error occurred.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qsharedmemory.xml">QSharedMemory</db:link></db:emphasis>::PermissionDenied</db:code></db:para>
</db:td>
<db:td><db:code>1</db:code></db:td>
<db:td>
<db:para>The operation failed because the caller didn't have the required permissions.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qsharedmemory.xml">QSharedMemory</db:link></db:emphasis>::InvalidSize</db:code></db:para>
</db:td>
<db:td><db:code>2</db:code></db:td>
<db:td>
<db:para>A create operation failed because the requested size was invalid.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qsharedmemory.xml">QSharedMemory</db:link></db:emphasis>::KeyError</db:code></db:para>
</db:td>
<db:td><db:code>3</db:code></db:td>
<db:td>
<db:para>The operation failed because of an invalid key.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qsharedmemory.xml">QSharedMemory</db:link></db:emphasis>::AlreadyExists</db:code></db:para>
</db:td>
<db:td><db:code>4</db:code></db:td>
<db:td>
<db:para>A <db:link xlink:href="qsharedmemory.xml#create">create</db:link>() operation failed because a shared memory segment with the specified key already existed.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qsharedmemory.xml">QSharedMemory</db:link></db:emphasis>::NotFound</db:code></db:para>
</db:td>
<db:td><db:code>5</db:code></db:td>
<db:td>
<db:para>An <db:link xlink:href="qsharedmemory.xml#attach">attach</db:link>() failed because a shared memory segment with the specified key could not be found.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qsharedmemory.xml">QSharedMemory</db:link></db:emphasis>::LockError</db:code></db:para>
</db:td>
<db:td><db:code>6</db:code></db:td>
<db:td>
<db:para>The attempt to <db:link xlink:href="qsharedmemory.xml#lock">lock</db:link>() the shared memory segment failed because <db:link xlink:href="qsharedmemory.xml#create">create</db:link>() or <db:link xlink:href="qsharedmemory.xml#attach">attach</db:link>() failed and returned false, or because a system error occurred in <db:link xlink:href="qsystemsemaphore.xml#acquire">QSystemSemaphore::acquire</db:link>().</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qsharedmemory.xml">QSharedMemory</db:link></db:emphasis>::OutOfResources</db:code></db:para>
</db:td>
<db:td><db:code>7</db:code></db:td>
<db:td>
<db:para>A <db:link xlink:href="qsharedmemory.xml#create">create</db:link>() operation failed because there was not enough memory available to fill the request.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qsharedmemory.xml">QSharedMemory</db:link></db:emphasis>::UnknownError</db:code></db:para>
</db:td>
<db:td><db:code>8</db:code></db:td>
<db:td>
<db:para>Something else happened and it was bad.</db:para>
</db:td>
</db:tr>
</db:informaltable>
</db:section>
</db:section>
<db:section xml:id="member-function-documentation">
<db:title>Member Function Documentation</db:title>
<db:section xml:id="QSharedMemory">
<db:title>QSharedMemory::QSharedMemory(const QString &amp;<db:emphasis>key</db:emphasis>, QObject *<db:emphasis>parent</db:emphasis> = 0)</db:title>
<db:para>Constructs a shared memory object with the given <db:code role="parameter">parent</db:code> and with its key set to <db:code role="parameter">key</db:code>. Because its key is set, its <db:link xlink:href="qsharedmemory.xml#create">create</db:link>() and <db:link xlink:href="qsharedmemory.xml#attach">attach</db:link>() functions can be called.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qsharedmemory.xml#setKey">setKey</db:link>()</db:member>
<db:member><db:link xlink:href="qsharedmemory.xml#create">create</db:link>()</db:member>
<db:member><db:link xlink:href="qsharedmemory.xml#attach">attach</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="QSharedMemory-2">
<db:title>QSharedMemory::QSharedMemory(QObject *<db:emphasis>parent</db:emphasis> = 0)</db:title>
<db:para>This function overloads <db:link xlink:href="qsharedmemory.xml#QSharedMemory">QSharedMemory</db:link>().</db:para>
<db:para>Constructs a shared memory object with the given <db:code role="parameter">parent</db:code>. The shared memory object's key is not set by the constructor, so the shared memory object does not have an underlying shared memory segment attached. The key must be set with <db:link xlink:href="qsharedmemory.xml#setKey">setKey</db:link>() or <db:link xlink:href="qsharedmemory.xml#setNativeKey">setNativeKey</db:link>() before <db:link xlink:href="qsharedmemory.xml#create">create</db:link>() or <db:link xlink:href="qsharedmemory.xml#attach">attach</db:link>() can be used.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qsharedmemory.xml#setKey">setKey</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="dtor.QSharedMemory">
<db:title>[virtual noexcept] QSharedMemory::~QSharedMemory()</db:title>
<db:para>The destructor clears the key, which forces the shared memory object to <db:link xlink:href="qsharedmemory.xml#detach">detach</db:link> from its underlying shared memory segment. If this shared memory object is the last one connected to the shared memory segment, the <db:link xlink:href="qsharedmemory.xml#detach">detach</db:link>() operation destroys the shared memory segment.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qsharedmemory.xml#detach">detach</db:link>()</db:member>
<db:member><db:link xlink:href="qsharedmemory.xml#isAttached">isAttached</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="attach">
<db:title>bool QSharedMemory::attach(QSharedMemory::AccessMode <db:emphasis>mode</db:emphasis> = ReadWrite)</db:title>
<db:para>Attempts to attach the process to the shared memory segment identified by the key that was passed to the constructor or to a call to <db:link xlink:href="qsharedmemory.xml#setKey">setKey</db:link>() or <db:link xlink:href="qsharedmemory.xml#setNativeKey">setNativeKey</db:link>(). The access <db:code role="parameter">mode</db:code> is <db:link xlink:href="qsharedmemory.xml#AccessMode-enum">ReadWrite</db:link> by default. It can also be <db:link xlink:href="qsharedmemory.xml#AccessMode-enum">ReadOnly</db:link>. Returns true if the attach operation is successful. If false is returned, call <db:link xlink:href="qsharedmemory.xml#error">error</db:link>() to determine which error occurred. After attaching the shared memory segment, a pointer to the shared memory can be obtained by calling <db:link xlink:href="qsharedmemory.xml#data">data</db:link>().</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qsharedmemory.xml#isAttached">isAttached</db:link>()</db:member>
<db:member><db:link xlink:href="qsharedmemory.xml#detach">detach</db:link>()</db:member>
<db:member><db:link xlink:href="qsharedmemory.xml#create">create</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="constData">
<db:title>const void *QSharedMemory::constData() const</db:title>
<db:para>Returns a const pointer to the contents of the shared memory segment, if one is attached. Otherwise it returns null. Remember to lock the shared memory with <db:link xlink:href="qsharedmemory.xml#lock">lock</db:link>() before reading from or writing to the shared memory, and remember to release the lock with <db:link xlink:href="qsharedmemory.xml#unlock">unlock</db:link>() after you are done.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qsharedmemory.xml#attach">attach</db:link>()</db:member>
<db:member><db:link xlink:href="qsharedmemory.xml#create">create</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="create">
<db:title>bool QSharedMemory::create(int <db:emphasis>size</db:emphasis>, QSharedMemory::AccessMode <db:emphasis>mode</db:emphasis> = ReadWrite)</db:title>
<db:para>Creates a shared memory segment of <db:code role="parameter">size</db:code> bytes with the key passed to the constructor, set with <db:link xlink:href="qsharedmemory.xml#setKey">setKey</db:link>() or set with <db:link xlink:href="qsharedmemory.xml#setNativeKey">setNativeKey</db:link>(), then attaches to the new shared memory segment with the given access <db:code role="parameter">mode</db:code> and returns <db:code>true</db:code>. If a shared memory segment identified by the key already exists, the attach operation is not performed and <db:code>false</db:code> is returned. When the return value is <db:code>false</db:code>, call <db:link xlink:href="qsharedmemory.xml#error">error</db:link>() to determine which error occurred.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qsharedmemory.xml#error">error</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="data">
<db:title>void *QSharedMemory::data()</db:title>
<db:para>Returns a pointer to the contents of the shared memory segment, if one is attached. Otherwise it returns null. Remember to lock the shared memory with <db:link xlink:href="qsharedmemory.xml#lock">lock</db:link>() before reading from or writing to the shared memory, and remember to release the lock with <db:link xlink:href="qsharedmemory.xml#unlock">unlock</db:link>() after you are done.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qsharedmemory.xml#attach">attach</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="data-1">
<db:title>const void *QSharedMemory::data() const</db:title>
<db:para>This function overloads <db:link xlink:href="qsharedmemory.xml#data">data</db:link>().</db:para>
</db:section>
<db:section xml:id="detach">
<db:title>bool QSharedMemory::detach()</db:title>
<db:para>Detaches the process from the shared memory segment. If this was the last process attached to the shared memory segment, then the shared memory segment is released by the system, i.e., the contents are destroyed. The function returns true if it detaches the shared memory segment. If it returns false, it usually means the segment either isn't attached, or it is locked by another process.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qsharedmemory.xml#attach">attach</db:link>()</db:member>
<db:member><db:link xlink:href="qsharedmemory.xml#isAttached">isAttached</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="error">
<db:title>QSharedMemory::SharedMemoryError QSharedMemory::error() const</db:title>
<db:para>Returns a value indicating whether an error occurred, and, if so, which error it was.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qsharedmemory.xml#errorString">errorString</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="errorString">
<db:title>QString QSharedMemory::errorString() const</db:title>
<db:para>Returns a text description of the last error that occurred. If <db:link xlink:href="qsharedmemory.xml#error">error</db:link>() returns an <db:link xlink:href="qsharedmemory.xml#SharedMemoryError-enum">error value</db:link>, call this function to get a text string that describes the error.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qsharedmemory.xml#error">error</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="isAttached">
<db:title>bool QSharedMemory::isAttached() const</db:title>
<db:para>Returns true if this process is attached to the shared memory segment.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qsharedmemory.xml#attach">attach</db:link>()</db:member>
<db:member><db:link xlink:href="qsharedmemory.xml#detach">detach</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="key">
<db:title>QString QSharedMemory::key() const</db:title>
<db:para>Returns the key assigned with <db:link xlink:href="qsharedmemory.xml#setKey">setKey</db:link>() to this shared memory, or a null key if no key has been assigned, or if the segment is using a <db:link xlink:href="qsharedmemory.xml#nativeKey">nativeKey</db:link>(). The key is the identifier used by Qt applications to identify the shared memory segment.</db:para>
<db:para>You can find the native, platform specific, key used by the operating system by calling <db:link xlink:href="qsharedmemory.xml#nativeKey">nativeKey</db:link>().</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qsharedmemory.xml#setKey">setKey</db:link>()</db:member>
<db:member><db:link xlink:href="qsharedmemory.xml#setNativeKey">setNativeKey</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="lock">
<db:title>bool QSharedMemory::lock()</db:title>
<db:para>This is a semaphore that locks the shared memory segment for access by this process and returns true. If another process has locked the segment, this function blocks until the lock is released. Then it acquires the lock and returns true. If this function returns false, it means that you have ignored a false return from <db:link xlink:href="qsharedmemory.xml#create">create</db:link>() or <db:link xlink:href="qsharedmemory.xml#attach">attach</db:link>(), that you have set the key with <db:link xlink:href="qsharedmemory.xml#setNativeKey">setNativeKey</db:link>() or that <db:link xlink:href="qsystemsemaphore.xml#acquire">QSystemSemaphore::acquire</db:link>() failed due to an unknown system error.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qsharedmemory.xml#unlock">unlock</db:link>()</db:member>
<db:member><db:link xlink:href="qsharedmemory.xml#data">data</db:link>()</db:member>
<db:member><db:link xlink:href="qsystemsemaphore.xml#acquire">QSystemSemaphore::acquire</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="nativeKey">
<db:title>[since 4.8] QString QSharedMemory::nativeKey() const</db:title>
<db:para>Returns the native, platform specific, key for this shared memory object. The native key is the identifier used by the operating system to identify the shared memory segment.</db:para>
<db:para>You can use the native key to access shared memory segments that have not been created by Qt, or to grant shared memory access to non-Qt applications.</db:para>
<db:para>This function was introduced in Qt 4.8.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qsharedmemory.xml#setKey">setKey</db:link>()</db:member>
<db:member><db:link xlink:href="qsharedmemory.xml#setNativeKey">setNativeKey</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setKey">
<db:title>void QSharedMemory::setKey(const QString &amp;<db:emphasis>key</db:emphasis>)</db:title>
<db:para>Sets the platform independent <db:code role="parameter">key</db:code> for this shared memory object. If <db:code role="parameter">key</db:code> is the same as the current key, the function returns without doing anything.</db:para>
<db:para>You can call <db:link xlink:href="qsharedmemory.xml#key">key</db:link>() to retrieve the platform independent key. Internally, <db:link xlink:href="qsharedmemory.xml">QSharedMemory</db:link> converts this key into a platform specific key. If you instead call <db:link xlink:href="qsharedmemory.xml#nativeKey">nativeKey</db:link>(), you will get the platform specific, converted key.</db:para>
<db:para>If the shared memory object is attached to an underlying shared memory segment, it will <db:link xlink:href="qsharedmemory.xml#detach">detach</db:link> from it before setting the new key. This function does not do an <db:link xlink:href="qsharedmemory.xml#attach">attach</db:link>().</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qsharedmemory.xml#key">key</db:link>()</db:member>
<db:member><db:link xlink:href="qsharedmemory.xml#nativeKey">nativeKey</db:link>()</db:member>
<db:member><db:link xlink:href="qsharedmemory.xml#isAttached">isAttached</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setNativeKey">
<db:title>[since 4.8] void QSharedMemory::setNativeKey(const QString &amp;<db:emphasis>key</db:emphasis>)</db:title>
<db:para>Sets the native, platform specific, <db:code role="parameter">key</db:code> for this shared memory object. If <db:code role="parameter">key</db:code> is the same as the current native key, the function returns without doing anything. If all you want is to assign a key to a segment, you should call <db:link xlink:href="qsharedmemory.xml#setKey">setKey</db:link>() instead.</db:para>
<db:para>You can call <db:link xlink:href="qsharedmemory.xml#nativeKey">nativeKey</db:link>() to retrieve the native key. If a native key has been assigned, calling <db:link xlink:href="qsharedmemory.xml#key">key</db:link>() will return a null string.</db:para>
<db:para>If the shared memory object is attached to an underlying shared memory segment, it will <db:link xlink:href="qsharedmemory.xml#detach">detach</db:link> from it before setting the new key. This function does not do an <db:link xlink:href="qsharedmemory.xml#attach">attach</db:link>().</db:para>
<db:para>The application will not be portable if you set a native key.</db:para>
<db:para>This function was introduced in Qt 4.8.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qsharedmemory.xml#nativeKey">nativeKey</db:link>()</db:member>
<db:member><db:link xlink:href="qsharedmemory.xml#key">key</db:link>()</db:member>
<db:member><db:link xlink:href="qsharedmemory.xml#isAttached">isAttached</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="size">
<db:title>int QSharedMemory::size() const</db:title>
<db:para>Returns the size of the attached shared memory segment. If no shared memory segment is attached, 0 is returned.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qsharedmemory.xml#create">create</db:link>()</db:member>
<db:member><db:link xlink:href="qsharedmemory.xml#attach">attach</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="unlock">
<db:title>bool QSharedMemory::unlock()</db:title>
<db:para>Releases the lock on the shared memory segment and returns true, if the lock is currently held by this process. If the segment is not locked, or if the lock is held by another process, nothing happens and false is returned.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qsharedmemory.xml#lock">lock</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
</db:section>
</db:article>
