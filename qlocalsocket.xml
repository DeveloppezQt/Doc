<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en_US">
<db:info>
<db:title>QLocalSocket Class</db:title>
<db:productname>QtNetwork</db:productname>
<db:titleabbrev>Qt Network Reference Documentation</db:titleabbrev>
<db:abstract>
<db:para>The <db:link xlink:href="qlocalsocket.xml">QLocalSocket</db:link> class provides a local socket.</db:para>
<db:para>This class was introduced in Qt 4.4.</db:para>
</db:abstract>
<db:pubdate>2025-06-29</db:pubdate>
<db:date>2025-06-29</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:variablelist>
<db:varlistentry>
<db:term>Header</db:term>
<db:listitem>
<db:para>QLocalSocket</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Since</db:term>
<db:listitem>
<db:para>Qt 4.4</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Inherits</db:term>
<db:listitem>
<db:para><db:link xlink:href="qiodevice.xml" xlink:role="class">QIODevice</db:link></db:para>
</db:listitem>
</db:varlistentry>
</db:variablelist>
<db:section xml:id="details">
<db:title>Detailed Description</db:title>
<db:para>On Windows this is a named pipe and on Unix this is a local domain socket.</db:para>
<db:para>If an error occurs, socketError() returns the type of error, and <db:link xlink:href="qiodevice.xml#errorString">errorString</db:link>() can be called to get a human readable description of what happened.</db:para>
<db:para>Although <db:link xlink:href="qlocalsocket.xml">QLocalSocket</db:link> is designed for use with an event loop, it's possible to use it without one. In that case, you must use <db:link xlink:href="qlocalsocket.xml#waitForConnected">waitForConnected</db:link>(), <db:link xlink:href="qlocalsocket.xml#waitForReadyRead">waitForReadyRead</db:link>(), <db:link xlink:href="qlocalsocket.xml#waitForBytesWritten">waitForBytesWritten</db:link>(), and <db:link xlink:href="qlocalsocket.xml#waitForDisconnected">waitForDisconnected</db:link>() which blocks until the operation is complete or the timeout expires.</db:para>
<db:para>Note that this feature is not supported on versions of Windows earlier than Windows XP.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qlocalserver.xml">QLocalServer</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="member-type-documentation">
<db:title>Member Type Documentation</db:title>
<db:section xml:id="LocalSocketError-enum">
<db:title>enum QLocalSocket::LocalSocketError</db:title>
<db:para>The LocalServerError enumeration represents the errors that can occur. The most recent error can be retrieved through a call to <db:link xlink:href="qlocalsocket.xml#error">QLocalSocket::error</db:link>().</db:para>
<db:informaltable>
<db:thead>
<db:tr>
<db:th>Constant</db:th>
<db:th>Value</db:th>
<db:th>Description</db:th>
</db:tr>
</db:thead>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qlocalsocket.xml">QLocalSocket</db:link></db:emphasis>::ConnectionRefusedError</db:code></db:para>
</db:td>
<db:td><db:code>QAbstractSocket::ConnectionRefusedError</db:code></db:td>
<db:td>
<db:para>The connection was refused by the peer (or timed out).</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qlocalsocket.xml">QLocalSocket</db:link></db:emphasis>::PeerClosedError</db:code></db:para>
</db:td>
<db:td><db:code>QAbstractSocket::RemoteHostClosedError</db:code></db:td>
<db:td>
<db:para>The remote socket closed the connection. Note that the client socket (i.e., this socket) will be closed after the remote close notification has been sent.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qlocalsocket.xml">QLocalSocket</db:link></db:emphasis>::ServerNotFoundError</db:code></db:para>
</db:td>
<db:td><db:code>QAbstractSocket::HostNotFoundError</db:code></db:td>
<db:td>
<db:para>The local socket name was not found.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qlocalsocket.xml">QLocalSocket</db:link></db:emphasis>::SocketAccessError</db:code></db:para>
</db:td>
<db:td><db:code>QAbstractSocket::SocketAccessError</db:code></db:td>
<db:td>
<db:para>The socket operation failed because the application lacked the required privileges.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qlocalsocket.xml">QLocalSocket</db:link></db:emphasis>::SocketResourceError</db:code></db:para>
</db:td>
<db:td><db:code>QAbstractSocket::SocketResourceError</db:code></db:td>
<db:td>
<db:para>The local system ran out of resources (e.g., too many sockets).</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qlocalsocket.xml">QLocalSocket</db:link></db:emphasis>::SocketTimeoutError</db:code></db:para>
</db:td>
<db:td><db:code>QAbstractSocket::SocketTimeoutError</db:code></db:td>
<db:td>
<db:para>The socket operation timed out.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qlocalsocket.xml">QLocalSocket</db:link></db:emphasis>::DatagramTooLargeError</db:code></db:para>
</db:td>
<db:td><db:code>QAbstractSocket::DatagramTooLargeError</db:code></db:td>
<db:td>
<db:para>The datagram was larger than the operating system's limit (which can be as low as 8192 bytes).</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qlocalsocket.xml">QLocalSocket</db:link></db:emphasis>::ConnectionError</db:code></db:para>
</db:td>
<db:td><db:code>QAbstractSocket::NetworkError</db:code></db:td>
<db:td>
<db:para>An error occurred with the connection.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qlocalsocket.xml">QLocalSocket</db:link></db:emphasis>::UnsupportedSocketOperationError</db:code></db:para>
</db:td>
<db:td><db:code>QAbstractSocket::UnsupportedSocketOperationError</db:code></db:td>
<db:td>
<db:para>The requested socket operation is not supported by the local operating system.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qlocalsocket.xml">QLocalSocket</db:link></db:emphasis>::OperationError</db:code></db:para>
</db:td>
<db:td><db:code>QAbstractSocket::OperationError</db:code></db:td>
<db:td>
<db:para>An operation was attempted while the socket was in a state that did not permit it.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qlocalsocket.xml">QLocalSocket</db:link></db:emphasis>::UnknownSocketError</db:code></db:para>
</db:td>
<db:td><db:code>QAbstractSocket::UnknownSocketError</db:code></db:td>
<db:td>
<db:para>An unidentified error occurred.</db:para>
</db:td>
</db:tr>
</db:informaltable>
</db:section>
<db:section xml:id="LocalSocketState-enum">
<db:title>enum QLocalSocket::LocalSocketState</db:title>
<db:para>This enum describes the different states in which a socket can be.</db:para>
<db:informaltable>
<db:thead>
<db:tr>
<db:th>Constant</db:th>
<db:th>Value</db:th>
<db:th>Description</db:th>
</db:tr>
</db:thead>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qlocalsocket.xml">QLocalSocket</db:link></db:emphasis>::UnconnectedState</db:code></db:para>
</db:td>
<db:td><db:code>QAbstractSocket::UnconnectedState</db:code></db:td>
<db:td>
<db:para>The socket is not connected.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qlocalsocket.xml">QLocalSocket</db:link></db:emphasis>::ConnectingState</db:code></db:para>
</db:td>
<db:td><db:code>QAbstractSocket::ConnectingState</db:code></db:td>
<db:td>
<db:para>The socket has started establishing a connection.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qlocalsocket.xml">QLocalSocket</db:link></db:emphasis>::ConnectedState</db:code></db:para>
</db:td>
<db:td><db:code>QAbstractSocket::ConnectedState</db:code></db:td>
<db:td>
<db:para>A connection is established.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qlocalsocket.xml">QLocalSocket</db:link></db:emphasis>::ClosingState</db:code></db:para>
</db:td>
<db:td><db:code>QAbstractSocket::ClosingState</db:code></db:td>
<db:td>
<db:para>The socket is about to close (data may still be waiting to be written).</db:para>
</db:td>
</db:tr>
</db:informaltable>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qlocalsocket.xml#state">QLocalSocket::state</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
</db:section>
<db:section xml:id="member-function-documentation">
<db:title>Member Function Documentation</db:title>
<db:section xml:id="QLocalSocket">
<db:title>QLocalSocket::QLocalSocket(QObject *<db:emphasis>parent</db:emphasis> = 0)</db:title>
<db:para>Creates a new local socket. The <db:code role="parameter">parent</db:code> argument is passed to <db:link xlink:href="qobject.xml">QObject</db:link>'s constructor.</db:para>
</db:section>
<db:section xml:id="dtor.QLocalSocket">
<db:title>[virtual noexcept] QLocalSocket::~QLocalSocket()</db:title>
<db:para>Destroys the socket, closing the connection if necessary.</db:para>
</db:section>
<db:section xml:id="abort">
<db:title>void QLocalSocket::abort()</db:title>
<db:para>Aborts the current connection and resets the socket. Unlike <db:link xlink:href="qlocalsocket.xml#disconnectFromServer">disconnectFromServer</db:link>(), this function immediately closes the socket, clearing any pending data in the write buffer.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qlocalsocket.xml#disconnectFromServer">disconnectFromServer</db:link>()</db:member>
<db:member><db:link xlink:href="qlocalsocket.xml#close">close</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="bytesAvailable">
<db:title>[override virtual] qint64 QLocalSocket::bytesAvailable() const</db:title>
<db:para>Reimplements: <db:link xlink:href="qiodevice.xml#bytesAvailable" role="function">QIODevice::bytesAvailable() const</db:link>.</db:para>
</db:section>
<db:section xml:id="bytesToWrite">
<db:title>[override virtual] qint64 QLocalSocket::bytesToWrite() const</db:title>
<db:para>Reimplements: <db:link xlink:href="qiodevice.xml#bytesToWrite" role="function">QIODevice::bytesToWrite() const</db:link>.</db:para>
</db:section>
<db:section xml:id="canReadLine">
<db:title>[override virtual] bool QLocalSocket::canReadLine() const</db:title>
<db:para>Reimplements: <db:link xlink:href="qiodevice.xml#canReadLine" role="function">QIODevice::canReadLine() const</db:link>.</db:para>
</db:section>
<db:section xml:id="close">
<db:title>[override virtual] void QLocalSocket::close()</db:title>
<db:para>Reimplements: <db:link xlink:href="qiodevice.xml#close" role="function">QIODevice::close()</db:link>.</db:para>
</db:section>
<db:section xml:id="connectToServer">
<db:title>[since 5.1] void QLocalSocket::connectToServer(QIODevice::OpenMode <db:emphasis>openMode</db:emphasis> = ReadWrite)</db:title>
<db:para>Attempts to make a connection to <db:link xlink:href="qlocalsocket.xml#serverName">serverName</db:link>(). <db:link xlink:href="qlocalsocket.xml#setServerName">setServerName</db:link>() must be called before you open the connection. Alternatively you can use connectToServer(const <db:link xlink:href="qstring.xml">QString</db:link> &amp;name, OpenMode openMode);</db:para>
<db:para>The socket is opened in the given <db:code role="parameter">openMode</db:code> and first enters <db:link xlink:href="qlocalsocket.xml#LocalSocketState-enum">ConnectingState</db:link>. If a connection is established, <db:link xlink:href="qlocalsocket.xml">QLocalSocket</db:link> enters <db:link xlink:href="qlocalsocket.xml#LocalSocketState-enum">ConnectedState</db:link> and emits <db:link xlink:href="qlocalsocket.xml#connected">connected</db:link>().</db:para>
<db:para>After calling this function, the socket can emit <db:link xlink:href="qlocalsocket.xml#error">error</db:link>() to signal that an error occurred.</db:para>
<db:para>This function was introduced in Qt 5.1.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qlocalsocket.xml#state">state</db:link>()</db:member>
<db:member><db:link xlink:href="qlocalsocket.xml#serverName">serverName</db:link>()</db:member>
<db:member><db:link xlink:href="qlocalsocket.xml#waitForConnected">waitForConnected</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="connectToServer-1">
<db:title>void QLocalSocket::connectToServer(const QString &amp;<db:emphasis>name</db:emphasis>, QIODevice::OpenMode <db:emphasis>openMode</db:emphasis> = ReadWrite)</db:title>
<db:para>This is an overloaded function.</db:para>
<db:para>Set the server <db:code role="parameter">name</db:code> and attempts to make a connection to it.</db:para>
<db:para>The socket is opened in the given <db:code role="parameter">openMode</db:code> and first enters <db:link xlink:href="qlocalsocket.xml#LocalSocketState-enum">ConnectingState</db:link>. If a connection is established, <db:link xlink:href="qlocalsocket.xml">QLocalSocket</db:link> enters <db:link xlink:href="qlocalsocket.xml#LocalSocketState-enum">ConnectedState</db:link> and emits <db:link xlink:href="qlocalsocket.xml#connected">connected</db:link>().</db:para>
<db:para>After calling this function, the socket can emit <db:link xlink:href="qlocalsocket.xml#error">error</db:link>() to signal that an error occurred.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qlocalsocket.xml#state">state</db:link>()</db:member>
<db:member><db:link xlink:href="qlocalsocket.xml#serverName">serverName</db:link>()</db:member>
<db:member><db:link xlink:href="qlocalsocket.xml#waitForConnected">waitForConnected</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="connected">
<db:title>void QLocalSocket::connected()</db:title>
<db:para>This signal is emitted after <db:link xlink:href="qlocalsocket.xml#connectToServer">connectToServer</db:link>() has been called and a connection has been successfully established.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qlocalsocket.xml#connectToServer">connectToServer</db:link>()</db:member>
<db:member><db:link xlink:href="qlocalsocket.xml#disconnected">disconnected</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="disconnectFromServer">
<db:title>void QLocalSocket::disconnectFromServer()</db:title>
<db:para>Attempts to close the socket. If there is pending data waiting to be written, <db:link xlink:href="qlocalsocket.xml">QLocalSocket</db:link> will enter <db:link xlink:href="qlocalsocket.xml#LocalSocketState-enum">ClosingState</db:link> and wait until all data has been written. Eventually, it will enter <db:link xlink:href="qlocalsocket.xml#LocalSocketState-enum">UnconnectedState</db:link> and emit the disconnectedFromServer() signal.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qlocalsocket.xml#connectToServer">connectToServer</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="disconnected">
<db:title>void QLocalSocket::disconnected()</db:title>
<db:para>This signal is emitted when the socket has been disconnected.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qlocalsocket.xml#connectToServer">connectToServer</db:link>()</db:member>
<db:member><db:link xlink:href="qlocalsocket.xml#disconnectFromServer">disconnectFromServer</db:link>()</db:member>
<db:member><db:link xlink:href="qlocalsocket.xml#abort">abort</db:link>()</db:member>
<db:member><db:link xlink:href="qlocalsocket.xml#connected">connected</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="error">
<db:title>QLocalSocket::LocalSocketError QLocalSocket::error() const</db:title>
<db:para>Returns the type of error that last occurred.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qlocalsocket.xml#state">state</db:link>()</db:member>
<db:member><db:link xlink:href="qiodevice.xml#errorString">errorString</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="error-1">
<db:title>void QLocalSocket::error(QLocalSocket::LocalSocketError <db:emphasis>socketError</db:emphasis>)</db:title>
<db:para>This signal is emitted after an error occurred. The <db:code role="parameter">socketError</db:code> parameter describes the type of error that occurred.</db:para>
<db:para><db:link xlink:href="qlocalsocket.xml#LocalSocketError-enum">QLocalSocket::LocalSocketError</db:link> is not a registered metatype, so for queued connections, you will have to register it with <db:link xlink:href="qmetatype.xml#Q_DECLARE_METATYPE">Q_DECLARE_METATYPE</db:link>() and qRegisterMetaType().</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qlocalsocket.xml#error">error</db:link>()</db:member>
<db:member><db:link xlink:href="qiodevice.xml#errorString">errorString</db:link>()</db:member>
<db:member><db:link xlink:href="custom-types.xml">Creating Custom Qt Types</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="flush">
<db:title>bool QLocalSocket::flush()</db:title>
<db:para>This function writes as much as possible from the internal write buffer to the socket, without blocking. If any data was written, this function returns true; otherwise false is returned.</db:para>
<db:para>Call this function if you need <db:link xlink:href="qlocalsocket.xml">QLocalSocket</db:link> to start sending buffered data immediately. The number of bytes successfully written depends on the operating system. In most cases, you do not need to call this function, because <db:link xlink:href="qlocalsocket.xml">QLocalSocket</db:link> will start sending data automatically once control goes back to the event loop. In the absence of an event loop, call <db:link xlink:href="qlocalsocket.xml#waitForBytesWritten">waitForBytesWritten</db:link>() instead.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qiodevice.xml#write">write</db:link>()</db:member>
<db:member><db:link xlink:href="qlocalsocket.xml#waitForBytesWritten">waitForBytesWritten</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="fullServerName">
<db:title>QString QLocalSocket::fullServerName() const</db:title>
<db:para>Returns the server path that the socket is connected to.</db:para>
<db:note>
<db:para>The return value of this function is platform specific.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qlocalsocket.xml#connectToServer">connectToServer</db:link>()</db:member>
<db:member><db:link xlink:href="qlocalsocket.xml#serverName">serverName</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="isSequential">
<db:title>[override virtual] bool QLocalSocket::isSequential() const</db:title>
<db:para>Reimplements: <db:link xlink:href="qiodevice.xml#isSequential" role="function">QIODevice::isSequential() const</db:link>.</db:para>
</db:section>
<db:section xml:id="isValid">
<db:title>bool QLocalSocket::isValid() const</db:title>
<db:para>Returns true if the socket is valid and ready for use; otherwise returns false.</db:para>
<db:note>
<db:para>The socket's state must be <db:link xlink:href="qlocalsocket.xml#LocalSocketState-enum">ConnectedState</db:link> before reading and writing can occur.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qlocalsocket.xml#state">state</db:link>()</db:member>
<db:member><db:link xlink:href="qlocalsocket.xml#connectToServer">connectToServer</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="open">
<db:title>[override virtual] bool QLocalSocket::open(QIODevice::OpenMode <db:emphasis>openMode</db:emphasis> = ReadWrite)</db:title>
<db:para>Reimplements: <db:link xlink:href="qiodevice.xml#open" role="function">QIODevice::open(QIODevice::OpenMode mode)</db:link>.</db:para>
<db:para>Equivalent to <db:link xlink:href="qlocalsocket.xml#connectToServer">connectToServer</db:link>(OpenMode mode). The socket is opened in the given <db:code role="parameter">openMode</db:code> to the server defined by <db:link xlink:href="qlocalsocket.xml#setServerName">setServerName</db:link>().</db:para>
<db:para>Note that unlike in most other <db:link xlink:href="qiodevice.xml">QIODevice</db:link> subclasses, open() may not open the device directly. The function return false if the socket was already connected or if the server to connect to was not defined and true in any other case. The <db:link xlink:href="qlocalsocket.xml#connected">connected</db:link>() or <db:link xlink:href="qlocalsocket.xml#error">error</db:link>() signals will be emitted once the device is actualy open (or the connection failed).</db:para>
<db:para>See <db:link xlink:href="qlocalsocket.xml#connectToServer">connectToServer</db:link>() for more details.</db:para>
</db:section>
<db:section xml:id="readBufferSize">
<db:title>qint64 QLocalSocket::readBufferSize() const</db:title>
<db:para>Returns the size of the internal read buffer. This limits the amount of data that the client can receive before you call <db:link xlink:href="qiodevice.xml#read">read</db:link>() or <db:link xlink:href="qiodevice.xml#readAll">readAll</db:link>(). A read buffer size of 0 (the default) means that the buffer has no size limit, ensuring that no data is lost.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qlocalsocket.xml#setReadBufferSize">setReadBufferSize</db:link>()</db:member>
<db:member><db:link xlink:href="qiodevice.xml#read">read</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="readData">
<db:title>[override virtual protected] qint64 QLocalSocket::readData(char *<db:emphasis>data</db:emphasis>, qint64 <db:emphasis>c</db:emphasis>)</db:title>
<db:para>Reimplements: <db:link xlink:href="qiodevice.xml#readData" role="function">QIODevice::readData(char *data, qint64 maxSize)</db:link>.</db:para>
</db:section>
<db:section xml:id="serverName">
<db:title>QString QLocalSocket::serverName() const</db:title>
<db:para>Returns the name of the peer as specified by <db:link xlink:href="qlocalsocket.xml#setServerName">setServerName</db:link>(), or an empty <db:link xlink:href="qstring.xml">QString</db:link> if <db:link xlink:href="qlocalsocket.xml#setServerName">setServerName</db:link>() has not been called or <db:link xlink:href="qlocalsocket.xml#connectToServer">connectToServer</db:link>() failed.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qlocalsocket.xml#setServerName">setServerName</db:link>()</db:member>
<db:member><db:link xlink:href="qlocalsocket.xml#connectToServer">connectToServer</db:link>()</db:member>
<db:member><db:link xlink:href="qlocalsocket.xml#fullServerName">fullServerName</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setReadBufferSize">
<db:title>void QLocalSocket::setReadBufferSize(qint64 <db:emphasis>size</db:emphasis>)</db:title>
<db:para>Sets the size of <db:link xlink:href="qlocalsocket.xml">QLocalSocket</db:link>'s internal read buffer to be <db:code role="parameter">size</db:code> bytes.</db:para>
<db:para>If the buffer size is limited to a certain size, <db:link xlink:href="qlocalsocket.xml">QLocalSocket</db:link> won't buffer more than this size of data. Exceptionally, a buffer size of 0 means that the read buffer is unlimited and all incoming data is buffered. This is the default.</db:para>
<db:para>This option is useful if you only read the data at certain points in time (e.g., in a real-time streaming application) or if you want to protect your socket against receiving too much data, which may eventually cause your application to run out of memory.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qlocalsocket.xml#readBufferSize">readBufferSize</db:link>()</db:member>
<db:member><db:link xlink:href="qiodevice.xml#read">read</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setServerName">
<db:title>[since 5.1] void QLocalSocket::setServerName(const QString &amp;<db:emphasis>name</db:emphasis>)</db:title>
<db:para>Set the <db:code role="parameter">name</db:code> of the peer to connect to. On Windows name is the name of a named pipe; on Unix name is the name of a local domain socket.</db:para>
<db:para>This function must be called when the socket is not connected.</db:para>
<db:para>This function was introduced in Qt 5.1.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qlocalsocket.xml#serverName">serverName</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setSocketDescriptor">
<db:title>bool QLocalSocket::setSocketDescriptor(qintptr <db:emphasis>socketDescriptor</db:emphasis>, QLocalSocket::LocalSocketState <db:emphasis>socketState</db:emphasis> = ConnectedState, QIODevice::OpenMode <db:emphasis>openMode</db:emphasis> = ReadWrite)</db:title>
<db:para>Initializes <db:link xlink:href="qlocalsocket.xml">QLocalSocket</db:link> with the native socket descriptor <db:code role="parameter">socketDescriptor</db:code>. Returns true if <db:link xlink:href="qlocalsocket.xml#socketDescriptor">socketDescriptor</db:link> is accepted as a valid socket descriptor; otherwise returns false. The socket is opened in the mode specified by <db:code role="parameter">openMode</db:code>, and enters the socket state specified by <db:code role="parameter">socketState</db:code>.</db:para>
<db:note>
<db:para>It is not possible to initialize two local sockets with the same native socket descriptor.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qlocalsocket.xml#socketDescriptor">socketDescriptor</db:link>()</db:member>
<db:member><db:link xlink:href="qlocalsocket.xml#state">state</db:link>()</db:member>
<db:member><db:link xlink:href="qiodevice.xml#openMode">openMode</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="socketDescriptor">
<db:title>qintptr QLocalSocket::socketDescriptor() const</db:title>
<db:para>Returns the native socket descriptor of the <db:link xlink:href="qlocalsocket.xml">QLocalSocket</db:link> object if this is available; otherwise returns -1.</db:para>
<db:para>The socket descriptor is not available when <db:link xlink:href="qlocalsocket.xml">QLocalSocket</db:link> is in <db:link xlink:href="qlocalsocket.xml#LocalSocketState-enum">UnconnectedState</db:link>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qlocalsocket.xml#setSocketDescriptor">setSocketDescriptor</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="state">
<db:title>QLocalSocket::LocalSocketState QLocalSocket::state() const</db:title>
<db:para>Returns the state of the socket.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qlocalsocket.xml#error">error</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="stateChanged">
<db:title>void QLocalSocket::stateChanged(QLocalSocket::LocalSocketState <db:emphasis>socketState</db:emphasis>)</db:title>
<db:para>This signal is emitted whenever <db:link xlink:href="qlocalsocket.xml">QLocalSocket</db:link>'s state changes. The <db:code role="parameter">socketState</db:code> parameter is the new state.</db:para>
<db:para>QLocalSocket::SocketState is not a registered metatype, so for queued connections, you will have to register it with <db:link xlink:href="qmetatype.xml#Q_DECLARE_METATYPE">Q_DECLARE_METATYPE</db:link>() and qRegisterMetaType().</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qlocalsocket.xml#state">state</db:link>()</db:member>
<db:member><db:link xlink:href="custom-types.xml">Creating Custom Qt Types</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="waitForBytesWritten">
<db:title>[override virtual] bool QLocalSocket::waitForBytesWritten(int <db:emphasis>msecs</db:emphasis> = 30000)</db:title>
<db:para>Reimplements: <db:link xlink:href="qiodevice.xml#waitForBytesWritten" role="function">QIODevice::waitForBytesWritten(int msecs)</db:link>.</db:para>
</db:section>
<db:section xml:id="waitForConnected">
<db:title>bool QLocalSocket::waitForConnected(int <db:emphasis>msecs</db:emphasis> = 30000)</db:title>
<db:para>Waits until the socket is connected, up to <db:code role="parameter">msecs</db:code> milliseconds. If the connection has been established, this function returns true; otherwise it returns false. In the case where it returns false, you can call <db:link xlink:href="qlocalsocket.xml#error">error</db:link>() to determine the cause of the error.</db:para>
<db:para>The following example waits up to one second for a connection to be established:</db:para>
<db:programlisting language="cpp">socket-&gt;connectToServer(&quot;market&quot;);
if (socket-&gt;waitForConnected(1000))
    qDebug(&quot;Connected!&quot;);
</db:programlisting>
<db:para>If <db:code role="parameter">msecs</db:code> is -1, this function will not time out.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qlocalsocket.xml#connectToServer">connectToServer</db:link>()</db:member>
<db:member><db:link xlink:href="qlocalsocket.xml#connected">connected</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="waitForDisconnected">
<db:title>bool QLocalSocket::waitForDisconnected(int <db:emphasis>msecs</db:emphasis> = 30000)</db:title>
<db:para>Waits until the socket has disconnected, up to <db:code role="parameter">msecs</db:code> milliseconds. If the connection has been disconnected, this function returns true; otherwise it returns false. In the case where it returns false, you can call <db:link xlink:href="qlocalsocket.xml#error">error</db:link>() to determine the cause of the error.</db:para>
<db:para>The following example waits up to one second for a connection to be closed:</db:para>
<db:programlisting language="cpp">socket-&gt;disconnectFromServer();
if (socket-&gt;waitForDisconnected(1000))
    qDebug(&quot;Disconnected!&quot;);
</db:programlisting>
<db:para>If <db:code role="parameter">msecs</db:code> is -1, this function will not time out.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qlocalsocket.xml#disconnectFromServer">disconnectFromServer</db:link>()</db:member>
<db:member><db:link xlink:href="qlocalsocket.xml#close">close</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="waitForReadyRead">
<db:title>[override virtual] bool QLocalSocket::waitForReadyRead(int <db:emphasis>msecs</db:emphasis> = 30000)</db:title>
<db:para>Reimplements: <db:link xlink:href="qiodevice.xml#waitForReadyRead" role="function">QIODevice::waitForReadyRead(int msecs)</db:link>.</db:para>
<db:para>This function blocks until data is available for reading and the <db:link xlink:href="qiodevice.xml#readyRead">readyRead</db:link>() signal has been emitted. The function will timeout after <db:code role="parameter">msecs</db:code> milliseconds; the default timeout is 30000 milliseconds.</db:para>
<db:para>The function returns true if data is available for reading; otherwise it returns false (if an error occurred or the operation timed out).</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qlocalsocket.xml#waitForBytesWritten">waitForBytesWritten</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="writeData">
<db:title>[override virtual protected] qint64 QLocalSocket::writeData(const char *<db:emphasis>data</db:emphasis>, qint64 <db:emphasis>c</db:emphasis>)</db:title>
<db:para>Reimplements: <db:link xlink:href="qiodevice.xml#writeData" role="function">QIODevice::writeData(const char *data, qint64 maxSize)</db:link>.</db:para>
</db:section>
</db:section>
</db:article>
