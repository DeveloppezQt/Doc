<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en">
<db:info>
<db:title>QLocalSocket Class</db:title>
<db:productname>QtNetwork</db:productname>
<db:edition>Qt 6.5.3 Reference Documentation</db:edition>
<db:titleabbrev>Qt Network Reference Documentation</db:titleabbrev>
<db:abstract>
<db:para>The <db:link xlink:href="qlocalsocket.xml">QLocalSocket</db:link> class provides a local socket.</db:para>
</db:abstract>
<db:pubdate>2024-02-14</db:pubdate>
<db:date>2024-02-14</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:variablelist>
<db:varlistentry>
<db:term>Header</db:term>
<db:listitem>
<db:para>QLocalSocket</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>CMake</db:term>
<db:listitem>
<db:para>find_package(Qt6 REQUIRED COMPONENTS Network)</db:para>
<db:para>target_link_libraries(mytarget PRIVATE Qt6::Network)</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>qmake</db:term>
<db:listitem>
<db:para>QT += network</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Inherits</db:term>
<db:listitem>
<db:para><db:link xlink:href="qiodevice.xml" xlink:role="class">QIODevice</db:link></db:para>
</db:listitem>
</db:varlistentry>
</db:variablelist>
<db:section xml:id="details">
<db:title>Detailed Description</db:title>
<db:para>On Windows this is a named pipe and on Unix this is a local domain socket.</db:para>
<db:para>If an error occurs, <db:link xlink:href="qlocalsocket.xml#error">error</db:link>() returns the type of error, and <db:link xlink:href="qiodevice.xml#errorString">errorString</db:link>() can be called to get a human readable description of what happened.</db:para>
<db:para>Although <db:link xlink:href="qlocalsocket.xml">QLocalSocket</db:link> is designed for use with an event loop, it's possible to use it without one. In that case, you must use <db:link xlink:href="qlocalsocket.xml#waitForConnected">waitForConnected</db:link>(), <db:link xlink:href="qlocalsocket.xml#waitForReadyRead">waitForReadyRead</db:link>(), <db:link xlink:href="qlocalsocket.xml#waitForBytesWritten">waitForBytesWritten</db:link>(), and <db:link xlink:href="qlocalsocket.xml#waitForDisconnected">waitForDisconnected</db:link>() which blocks until the operation is complete or the timeout expires.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qlocalserver.xml">QLocalServer</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="member-type-documentation">
<db:title>Member Type Documentation</db:title>
<db:section xml:id="LocalSocketError-enum">
<db:title>enum QLocalSocket::LocalSocketError</db:title>
<db:enumsynopsis>
<db:enumname>LocalSocketError</db:enumname>
<db:enumitem>
<db:enumidentifier>ConnectionRefusedError</db:enumidentifier>
<db:enumvalue>QAbstractSocket::ConnectionRefusedError</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>PeerClosedError</db:enumidentifier>
<db:enumvalue>QAbstractSocket::RemoteHostClosedError</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>ServerNotFoundError</db:enumidentifier>
<db:enumvalue>QAbstractSocket::HostNotFoundError</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>SocketAccessError</db:enumidentifier>
<db:enumvalue>QAbstractSocket::SocketAccessError</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>SocketResourceError</db:enumidentifier>
<db:enumvalue>QAbstractSocket::SocketResourceError</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>SocketTimeoutError</db:enumidentifier>
<db:enumvalue>QAbstractSocket::SocketTimeoutError</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>DatagramTooLargeError</db:enumidentifier>
<db:enumvalue>QAbstractSocket::DatagramTooLargeError</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>ConnectionError</db:enumidentifier>
<db:enumvalue>QAbstractSocket::NetworkError</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>UnsupportedSocketOperationError</db:enumidentifier>
<db:enumvalue>QAbstractSocket::UnsupportedSocketOperationError</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>UnknownSocketError</db:enumidentifier>
<db:enumvalue>QAbstractSocket::UnknownSocketError</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>OperationError</db:enumidentifier>
<db:enumvalue>QAbstractSocket::OperationError</db:enumvalue>
</db:enumitem>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:enumsynopsis>
<db:para>The LocalServerError enumeration represents the errors that can occur. The most recent error can be retrieved through a call to <db:link xlink:href="qlocalsocket.xml#error">QLocalSocket::error</db:link>().</db:para>
<db:informaltable>
<db:thead>
<db:tr>
<db:th>Constant</db:th>
<db:th>Value</db:th>
<db:th>Description</db:th>
</db:tr>
</db:thead>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qlocalsocket.xml">QLocalSocket</db:link></db:emphasis>::ConnectionRefusedError</db:code></db:para>
</db:td>
<db:td><db:code>QAbstractSocket::ConnectionRefusedError</db:code></db:td>
<db:td>
<db:para>The connection was refused by the peer (or timed out).</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qlocalsocket.xml">QLocalSocket</db:link></db:emphasis>::PeerClosedError</db:code></db:para>
</db:td>
<db:td><db:code>QAbstractSocket::RemoteHostClosedError</db:code></db:td>
<db:td>
<db:para>The remote socket closed the connection. Note that the client socket (i.e., this socket) will be closed after the remote close notification has been sent.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qlocalsocket.xml">QLocalSocket</db:link></db:emphasis>::ServerNotFoundError</db:code></db:para>
</db:td>
<db:td><db:code>QAbstractSocket::HostNotFoundError</db:code></db:td>
<db:td>
<db:para>The local socket name was not found.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qlocalsocket.xml">QLocalSocket</db:link></db:emphasis>::SocketAccessError</db:code></db:para>
</db:td>
<db:td><db:code>QAbstractSocket::SocketAccessError</db:code></db:td>
<db:td>
<db:para>The socket operation failed because the application lacked the required privileges.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qlocalsocket.xml">QLocalSocket</db:link></db:emphasis>::SocketResourceError</db:code></db:para>
</db:td>
<db:td><db:code>QAbstractSocket::SocketResourceError</db:code></db:td>
<db:td>
<db:para>The local system ran out of resources (e.g., too many sockets).</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qlocalsocket.xml">QLocalSocket</db:link></db:emphasis>::SocketTimeoutError</db:code></db:para>
</db:td>
<db:td><db:code>QAbstractSocket::SocketTimeoutError</db:code></db:td>
<db:td>
<db:para>The socket operation timed out.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qlocalsocket.xml">QLocalSocket</db:link></db:emphasis>::DatagramTooLargeError</db:code></db:para>
</db:td>
<db:td><db:code>QAbstractSocket::DatagramTooLargeError</db:code></db:td>
<db:td>
<db:para>The datagram was larger than the operating system's limit (which can be as low as 8192 bytes).</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qlocalsocket.xml">QLocalSocket</db:link></db:emphasis>::ConnectionError</db:code></db:para>
</db:td>
<db:td><db:code>QAbstractSocket::NetworkError</db:code></db:td>
<db:td>
<db:para>An error occurred with the connection.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qlocalsocket.xml">QLocalSocket</db:link></db:emphasis>::UnsupportedSocketOperationError</db:code></db:para>
</db:td>
<db:td><db:code>QAbstractSocket::UnsupportedSocketOperationError</db:code></db:td>
<db:td>
<db:para>The requested socket operation is not supported by the local operating system.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qlocalsocket.xml">QLocalSocket</db:link></db:emphasis>::OperationError</db:code></db:para>
</db:td>
<db:td><db:code>QAbstractSocket::OperationError</db:code></db:td>
<db:td>
<db:para>An operation was attempted while the socket was in a state that did not permit it.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qlocalsocket.xml">QLocalSocket</db:link></db:emphasis>::UnknownSocketError</db:code></db:para>
</db:td>
<db:td><db:code>QAbstractSocket::UnknownSocketError</db:code></db:td>
<db:td>
<db:para>An unidentified error occurred.</db:para>
</db:td>
</db:tr>
</db:informaltable>
</db:section>
<db:section xml:id="LocalSocketState-enum">
<db:title>enum QLocalSocket::LocalSocketState</db:title>
<db:enumsynopsis>
<db:enumname>LocalSocketState</db:enumname>
<db:enumitem>
<db:enumidentifier>UnconnectedState</db:enumidentifier>
<db:enumvalue>QAbstractSocket::UnconnectedState</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>ConnectingState</db:enumidentifier>
<db:enumvalue>QAbstractSocket::ConnectingState</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>ConnectedState</db:enumidentifier>
<db:enumvalue>QAbstractSocket::ConnectedState</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>ClosingState</db:enumidentifier>
<db:enumvalue>QAbstractSocket::ClosingState</db:enumvalue>
</db:enumitem>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:enumsynopsis>
<db:para>This enum describes the different states in which a socket can be.</db:para>
<db:informaltable>
<db:thead>
<db:tr>
<db:th>Constant</db:th>
<db:th>Value</db:th>
<db:th>Description</db:th>
</db:tr>
</db:thead>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qlocalsocket.xml">QLocalSocket</db:link></db:emphasis>::UnconnectedState</db:code></db:para>
</db:td>
<db:td><db:code>QAbstractSocket::UnconnectedState</db:code></db:td>
<db:td>
<db:para>The socket is not connected.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qlocalsocket.xml">QLocalSocket</db:link></db:emphasis>::ConnectingState</db:code></db:para>
</db:td>
<db:td><db:code>QAbstractSocket::ConnectingState</db:code></db:td>
<db:td>
<db:para>The socket has started establishing a connection.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qlocalsocket.xml">QLocalSocket</db:link></db:emphasis>::ConnectedState</db:code></db:para>
</db:td>
<db:td><db:code>QAbstractSocket::ConnectedState</db:code></db:td>
<db:td>
<db:para>A connection is established.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qlocalsocket.xml">QLocalSocket</db:link></db:emphasis>::ClosingState</db:code></db:para>
</db:td>
<db:td><db:code>QAbstractSocket::ClosingState</db:code></db:td>
<db:td>
<db:para>The socket is about to close (data may still be waiting to be written).</db:para>
</db:td>
</db:tr>
</db:informaltable>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qlocalsocket.xml#state">QLocalSocket::state</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="SocketOption-enum">
<db:title>[since 6.2] enum QLocalSocket::SocketOption</db:title>
<db:bridgehead renderas="sect2">flags QLocalSocket::SocketOptions</db:bridgehead>
<db:enumsynopsis>
<db:enumname>SocketOption</db:enumname>
<db:enumitem>
<db:enumidentifier>NoOptions</db:enumidentifier>
<db:enumvalue>0x00</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>AbstractNamespaceOption</db:enumidentifier>
<db:enumvalue>0x01</db:enumvalue>
</db:enumitem>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:enumsynopsis>
<db:typedefsynopsis>
<db:typedefname>QLocalSocket::SocketOptions</db:typedefname>
</db:typedefsynopsis>
<db:para>This enum describes the possible options that can be used to connect to a server. Currently, on Linux and Android it is used for specifying connection to a server listening to a socket bound to an abstract address.</db:para>
<db:informaltable>
<db:thead>
<db:tr>
<db:th>Constant</db:th>
<db:th>Value</db:th>
<db:th>Description</db:th>
</db:tr>
</db:thead>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qlocalsocket.xml">QLocalSocket</db:link></db:emphasis>::NoOptions</db:code></db:para>
</db:td>
<db:td><db:code>0x00</db:code></db:td>
<db:td>
<db:para>No options have been set.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qlocalsocket.xml">QLocalSocket</db:link></db:emphasis>::AbstractNamespaceOption</db:code></db:para>
</db:td>
<db:td><db:code>0x01</db:code></db:td>
<db:td>
<db:para>The socket will try to connect to an abstract address. This flag is specific to Linux and Android. On other platforms is ignored.</db:para>
</db:td>
</db:tr>
</db:informaltable>
<db:para>This enum was introduced or modified in Qt 6.2.</db:para>
<db:para>The <db:code>SocketOptions</db:code> type is a typedef for <db:code><db:link xlink:href="qflags.xml">QFlags</db:link>&lt;SocketOption&gt;. </db:code>It stores an OR combination of <db:code>SocketOption</db:code> values.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qlocalsocket.xml#socketOptions-prop">socketOptions</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
</db:section>
<db:section xml:id="property-documentation">
<db:title>Property Documentation</db:title>
<db:section xml:id="socketOptions-prop">
<db:title>[bindable, since 6.2] socketOptions : SocketOptions</db:title>
<db:fieldsynopsis>
<db:modifier>(Qt property)</db:modifier>
<db:type>SocketOptions</db:type>
<db:varname>socketOptions</db:varname>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
<db:synopsisinfo role="getter">socketOptions</db:synopsisinfo>
<db:synopsisinfo role="setter">setSocketOptions</db:synopsisinfo>
</db:fieldsynopsis>
<db:para>This property supports <db:link xlink:href="qproperty.xml">QProperty</db:link> bindings.</db:para>
<db:para>This property holds the socket options.</db:para>
<db:para>Options must be set while the socket is in <db:link xlink:href="qlocalsocket.xml#LocalSocketState-enum">UnconnectedState</db:link> state.</db:para>
<db:para>This property was introduced in Qt 6.2.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qlocalsocket.xml#connectToServer">connectToServer</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
</db:section>
<db:section xml:id="member-function-documentation">
<db:title>Member Function Documentation</db:title>
<db:section xml:id="QLocalSocket">
<db:title>QLocalSocket::QLocalSocket(QObject *<db:emphasis>parent</db:emphasis> = nullptr)</db:title>
<db:constructorsynopsis>
<db:methodname>QLocalSocket</db:methodname>
<db:methodparam>
<db:type>QObject *</db:type>
<db:parameter>parent</db:parameter>
<db:initializer>nullptr</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">constructor</db:synopsisinfo>
<db:synopsisinfo role="signature">QLocalSocket(QObject *parent)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:constructorsynopsis>
<db:para>Creates a new local socket. The <db:code role="parameter">parent</db:code> argument is passed to <db:link xlink:href="qobject.xml">QObject</db:link>'s constructor.</db:para>
</db:section>
<db:section xml:id="dtor.QLocalSocket">
<db:title>[virtual] QLocalSocket::~QLocalSocket()</db:title>
<db:destructorsynopsis>
<db:modifier>virtual</db:modifier>
<db:methodname>~QLocalSocket</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">destructor</db:synopsisinfo>
<db:synopsisinfo role="signature">~QLocalSocket()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:destructorsynopsis>
<db:para>Destroys the socket, closing the connection if necessary.</db:para>
</db:section>
<db:section xml:id="abort">
<db:title>void QLocalSocket::abort()</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>abort</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void abort()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Aborts the current connection and resets the socket. Unlike <db:link xlink:href="qlocalsocket.xml#disconnectFromServer">disconnectFromServer</db:link>(), this function immediately closes the socket, clearing any pending data in the write buffer.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qlocalsocket.xml#disconnectFromServer">disconnectFromServer</db:link>()</db:member>
<db:member><db:link xlink:href="qlocalsocket.xml#close">close</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="bytesAvailable">
<db:title>[override virtual] qint64 QLocalSocket::bytesAvailable() const</db:title>
<db:methodsynopsis>
<db:modifier>virtual</db:modifier>
<db:modifier>const</db:modifier>
<db:type>qint64</db:type>
<db:methodname>bytesAvailable</db:methodname>
<db:void/>
<db:modifier>override</db:modifier>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">qint64 bytesAvailable() const override</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Reimplements: <db:link xlink:href="qiodevice.xml#bytesAvailable" role="function">QIODevice::bytesAvailable() const</db:link>.</db:para>
</db:section>
<db:section xml:id="bytesToWrite">
<db:title>[override virtual] qint64 QLocalSocket::bytesToWrite() const</db:title>
<db:methodsynopsis>
<db:modifier>virtual</db:modifier>
<db:modifier>const</db:modifier>
<db:type>qint64</db:type>
<db:methodname>bytesToWrite</db:methodname>
<db:void/>
<db:modifier>override</db:modifier>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">qint64 bytesToWrite() const override</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Reimplements: <db:link xlink:href="qiodevice.xml#bytesToWrite" role="function">QIODevice::bytesToWrite() const</db:link>.</db:para>
</db:section>
<db:section xml:id="canReadLine">
<db:title>[override virtual] bool QLocalSocket::canReadLine() const</db:title>
<db:methodsynopsis>
<db:modifier>virtual</db:modifier>
<db:modifier>const</db:modifier>
<db:type>bool</db:type>
<db:methodname>canReadLine</db:methodname>
<db:void/>
<db:modifier>override</db:modifier>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool canReadLine() const override</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Reimplements: <db:link xlink:href="qiodevice.xml#canReadLine" role="function">QIODevice::canReadLine() const</db:link>.</db:para>
</db:section>
<db:section xml:id="close">
<db:title>[override virtual] void QLocalSocket::close()</db:title>
<db:methodsynopsis>
<db:modifier>virtual</db:modifier>
<db:void/>
<db:methodname>close</db:methodname>
<db:void/>
<db:modifier>override</db:modifier>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void close() override</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Reimplements: <db:link xlink:href="qiodevice.xml#close" role="function">QIODevice::close()</db:link>.</db:para>
<db:para>Closes the I/O device for the socket and calls <db:link xlink:href="qlocalsocket.xml#disconnectFromServer">disconnectFromServer</db:link>() to close the socket's connection.</db:para>
<db:para>See <db:link xlink:href="qiodevice.xml#close">QIODevice::close</db:link>() for a description of the actions that occur when an I/O device is closed.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qlocalsocket.xml#abort">abort</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="connectToServer">
<db:title>void QLocalSocket::connectToServer(QIODeviceBase::OpenMode <db:emphasis>openMode</db:emphasis> = ReadWrite)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>connectToServer</db:methodname>
<db:methodparam>
<db:type>QIODeviceBase::OpenMode</db:type>
<db:parameter>openMode</db:parameter>
<db:initializer>ReadWrite</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void connectToServer(QIODeviceBase::OpenMode openMode)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Attempts to make a connection to <db:link xlink:href="qlocalsocket.xml#serverName">serverName</db:link>(). <db:link xlink:href="qlocalsocket.xml#setServerName">setServerName</db:link>() must be called before you open the connection. Alternatively you can use connectToServer(const <db:link xlink:href="qstring.xml">QString</db:link> &amp;name, OpenMode openMode);</db:para>
<db:para>The socket is opened in the given <db:code role="parameter">openMode</db:code> and first enters <db:link xlink:href="qlocalsocket.xml#LocalSocketState-enum">ConnectingState</db:link>. If a connection is established, <db:link xlink:href="qlocalsocket.xml">QLocalSocket</db:link> enters <db:link xlink:href="qlocalsocket.xml#LocalSocketState-enum">ConnectedState</db:link> and emits <db:link xlink:href="qlocalsocket.xml#connected">connected</db:link>().</db:para>
<db:para>After calling this function, the socket can emit <db:link xlink:href="qlocalsocket.xml#errorOccurred">errorOccurred</db:link>() to signal that an error occurred.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qlocalsocket.xml#state">state</db:link>()</db:member>
<db:member><db:link xlink:href="qlocalsocket.xml#serverName">serverName</db:link>()</db:member>
<db:member><db:link xlink:href="qlocalsocket.xml#waitForConnected">waitForConnected</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="connectToServer-1">
<db:title>void QLocalSocket::connectToServer(const QString &amp;<db:emphasis>name</db:emphasis>, QIODeviceBase::OpenMode <db:emphasis>openMode</db:emphasis> = ReadWrite)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>connectToServer</db:methodname>
<db:methodparam>
<db:type>const QString &amp;</db:type>
<db:parameter>name</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>QIODeviceBase::OpenMode</db:type>
<db:parameter>openMode</db:parameter>
<db:initializer>ReadWrite</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">void connectToServer(const QString &amp;name, QIODeviceBase::OpenMode openMode)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>Set the server <db:code role="parameter">name</db:code> and attempts to make a connection to it.</db:para>
<db:para>The socket is opened in the given <db:code role="parameter">openMode</db:code> and first enters <db:link xlink:href="qlocalsocket.xml#LocalSocketState-enum">ConnectingState</db:link>. If a connection is established, <db:link xlink:href="qlocalsocket.xml">QLocalSocket</db:link> enters <db:link xlink:href="qlocalsocket.xml#LocalSocketState-enum">ConnectedState</db:link> and emits <db:link xlink:href="qlocalsocket.xml#connected">connected</db:link>().</db:para>
<db:para>After calling this function, the socket can emit <db:link xlink:href="qlocalsocket.xml#errorOccurred">errorOccurred</db:link>() to signal that an error occurred.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qlocalsocket.xml#state">state</db:link>()</db:member>
<db:member><db:link xlink:href="qlocalsocket.xml#serverName">serverName</db:link>()</db:member>
<db:member><db:link xlink:href="qlocalsocket.xml#waitForConnected">waitForConnected</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="connected">
<db:title>void QLocalSocket::connected()</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>connected</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void connected()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This signal is emitted after <db:link xlink:href="qlocalsocket.xml#connectToServer">connectToServer</db:link>() has been called and a connection has been successfully established.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qlocalsocket.xml#connectToServer">connectToServer</db:link>()</db:member>
<db:member><db:link xlink:href="qlocalsocket.xml#disconnected">disconnected</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="disconnectFromServer">
<db:title>void QLocalSocket::disconnectFromServer()</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>disconnectFromServer</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void disconnectFromServer()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Attempts to close the socket. If there is pending data waiting to be written, <db:link xlink:href="qlocalsocket.xml">QLocalSocket</db:link> will enter <db:link xlink:href="qlocalsocket.xml#LocalSocketState-enum">ClosingState</db:link> and wait until all data has been written. Eventually, it will enter <db:link xlink:href="qlocalsocket.xml#LocalSocketState-enum">UnconnectedState</db:link> and emit the <db:link xlink:href="qlocalsocket.xml#disconnected">disconnected</db:link>() signal.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qlocalsocket.xml#connectToServer">connectToServer</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="disconnected">
<db:title>void QLocalSocket::disconnected()</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>disconnected</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void disconnected()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This signal is emitted when the socket has been disconnected.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qlocalsocket.xml#connectToServer">connectToServer</db:link>()</db:member>
<db:member><db:link xlink:href="qlocalsocket.xml#disconnectFromServer">disconnectFromServer</db:link>()</db:member>
<db:member><db:link xlink:href="qlocalsocket.xml#abort">abort</db:link>()</db:member>
<db:member><db:link xlink:href="qlocalsocket.xml#connected">connected</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="error">
<db:title>QLocalSocket::LocalSocketError QLocalSocket::error() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QLocalSocket::LocalSocketError</db:type>
<db:methodname>error</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QLocalSocket::LocalSocketError error() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the type of error that last occurred.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qlocalsocket.xml#state">state</db:link>()</db:member>
<db:member><db:link xlink:href="qiodevice.xml#errorString">errorString</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="errorOccurred">
<db:title>void QLocalSocket::errorOccurred(QLocalSocket::LocalSocketError <db:emphasis>socketError</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>errorOccurred</db:methodname>
<db:methodparam>
<db:type>QLocalSocket::LocalSocketError</db:type>
<db:parameter>socketError</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void errorOccurred(QLocalSocket::LocalSocketError socketError)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This signal is emitted after an error occurred. The <db:code role="parameter">socketError</db:code> parameter describes the type of error that occurred.</db:para>
<db:para><db:link xlink:href="qlocalsocket.xml#LocalSocketError-enum">QLocalSocket::LocalSocketError</db:link> is not a registered metatype, so for queued connections, you will have to register it with <db:link xlink:href="qmetatype.xml#Q_DECLARE_METATYPE">Q_DECLARE_METATYPE</db:link>() and <db:link xlink:href="qmetatype.xml#qRegisterMetaType-3">qRegisterMetaType</db:link>().</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qlocalsocket.xml#error">error</db:link>()</db:member>
<db:member><db:link xlink:href="qiodevice.xml#errorString">errorString</db:link>()</db:member>
<db:member><db:link xlink:href="custom-types.xml">Creating Custom Qt Types</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="flush">
<db:title>bool QLocalSocket::flush()</db:title>
<db:methodsynopsis>
<db:type>bool</db:type>
<db:methodname>flush</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool flush()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This function writes as much as possible from the internal write buffer to the socket, without blocking. If any data was written, this function returns true; otherwise false is returned.</db:para>
<db:para>Call this function if you need <db:link xlink:href="qlocalsocket.xml">QLocalSocket</db:link> to start sending buffered data immediately. The number of bytes successfully written depends on the operating system. In most cases, you do not need to call this function, because <db:link xlink:href="qlocalsocket.xml">QLocalSocket</db:link> will start sending data automatically once control goes back to the event loop. In the absence of an event loop, call <db:link xlink:href="qlocalsocket.xml#waitForBytesWritten">waitForBytesWritten</db:link>() instead.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qiodevice.xml#write">write</db:link>()</db:member>
<db:member><db:link xlink:href="qlocalsocket.xml#waitForBytesWritten">waitForBytesWritten</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="fullServerName">
<db:title>QString QLocalSocket::fullServerName() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QString</db:type>
<db:methodname>fullServerName</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QString fullServerName() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the server path that the socket is connected to.</db:para>
<db:note>
<db:para>The return value of this function is platform specific.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qlocalsocket.xml#connectToServer">connectToServer</db:link>()</db:member>
<db:member><db:link xlink:href="qlocalsocket.xml#serverName">serverName</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="isSequential">
<db:title>[override virtual] bool QLocalSocket::isSequential() const</db:title>
<db:methodsynopsis>
<db:modifier>virtual</db:modifier>
<db:modifier>const</db:modifier>
<db:type>bool</db:type>
<db:methodname>isSequential</db:methodname>
<db:void/>
<db:modifier>override</db:modifier>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool isSequential() const override</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Reimplements: <db:link xlink:href="qiodevice.xml#isSequential" role="function">QIODevice::isSequential() const</db:link>.</db:para>
</db:section>
<db:section xml:id="isValid">
<db:title>bool QLocalSocket::isValid() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>bool</db:type>
<db:methodname>isValid</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool isValid() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns true if the socket is valid and ready for use; otherwise returns false.</db:para>
<db:note>
<db:para>The socket's state must be <db:link xlink:href="qlocalsocket.xml#LocalSocketState-enum">ConnectedState</db:link> before reading and writing can occur.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qlocalsocket.xml#state">state</db:link>()</db:member>
<db:member><db:link xlink:href="qlocalsocket.xml#connectToServer">connectToServer</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="open">
<db:title>[override virtual] bool QLocalSocket::open(QIODeviceBase::OpenMode <db:emphasis>openMode</db:emphasis> = ReadWrite)</db:title>
<db:methodsynopsis>
<db:modifier>virtual</db:modifier>
<db:type>bool</db:type>
<db:methodname>open</db:methodname>
<db:methodparam>
<db:type>QIODeviceBase::OpenMode</db:type>
<db:parameter>openMode</db:parameter>
<db:initializer>ReadWrite</db:initializer>
</db:methodparam>
<db:modifier>override</db:modifier>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool open(QIODeviceBase::OpenMode openMode) override</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Reimplements: <db:link xlink:href="qiodevice.xml#open" role="function">QIODevice::open(QIODeviceBase::OpenMode mode)</db:link>.</db:para>
<db:para>Equivalent to <db:link xlink:href="qlocalsocket.xml#connectToServer">connectToServer</db:link>(OpenMode mode). The socket is opened in the given <db:code role="parameter">openMode</db:code> to the server defined by <db:link xlink:href="qlocalsocket.xml#setServerName">setServerName</db:link>().</db:para>
<db:para>Note that unlike in most other <db:link xlink:href="qiodevice.xml">QIODevice</db:link> subclasses, open() may not open the device directly. The function return false if the socket was already connected or if the server to connect to was not defined and true in any other case. The <db:link xlink:href="qlocalsocket.xml#connected">connected</db:link>() or <db:link xlink:href="qlocalsocket.xml#errorOccurred">errorOccurred</db:link>() signals will be emitted once the device is actually open (or the connection failed).</db:para>
<db:para>See <db:link xlink:href="qlocalsocket.xml#connectToServer">connectToServer</db:link>() for more details.</db:para>
</db:section>
<db:section xml:id="readBufferSize">
<db:title>qint64 QLocalSocket::readBufferSize() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>qint64</db:type>
<db:methodname>readBufferSize</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">qint64 readBufferSize() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the size of the internal read buffer. This limits the amount of data that the client can receive before you call <db:link xlink:href="qiodevice.xml#read">read</db:link>() or <db:link xlink:href="qiodevice.xml#readAll">readAll</db:link>(). A read buffer size of 0 (the default) means that the buffer has no size limit, ensuring that no data is lost.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qlocalsocket.xml#setReadBufferSize">setReadBufferSize</db:link>()</db:member>
<db:member><db:link xlink:href="qiodevice.xml#read">read</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="readData">
<db:title>[override virtual protected] qint64 QLocalSocket::readData(char *<db:emphasis>data</db:emphasis>, qint64 <db:emphasis>c</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:modifier>virtual</db:modifier>
<db:type>qint64</db:type>
<db:methodname>readData</db:methodname>
<db:methodparam>
<db:type>char *</db:type>
<db:parameter>data</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>qint64</db:type>
<db:parameter>c</db:parameter>
</db:methodparam>
<db:modifier>override</db:modifier>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">qint64 readData(char *data, qint64 c) override</db:synopsisinfo>
<db:synopsisinfo role="access">protected</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Reimplements: <db:link xlink:href="qiodevice.xml#readData" role="function">QIODevice::readData(char *data, qint64 maxSize)</db:link>.</db:para>
</db:section>
<db:section xml:id="readLineData">
<db:title>[override virtual protected] qint64 QLocalSocket::readLineData(char *<db:emphasis>data</db:emphasis>, qint64 <db:emphasis>maxSize</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:modifier>virtual</db:modifier>
<db:type>qint64</db:type>
<db:methodname>readLineData</db:methodname>
<db:methodparam>
<db:type>char *</db:type>
<db:parameter>data</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>qint64</db:type>
<db:parameter>maxSize</db:parameter>
</db:methodparam>
<db:modifier>override</db:modifier>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">qint64 readLineData(char *data, qint64 maxSize) override</db:synopsisinfo>
<db:synopsisinfo role="access">protected</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Reimplements: <db:link xlink:href="qiodevice.xml#readLineData" role="function">QIODevice::readLineData(char *data, qint64 maxSize)</db:link>.</db:para>
</db:section>
<db:section xml:id="serverName">
<db:title>QString QLocalSocket::serverName() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QString</db:type>
<db:methodname>serverName</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QString serverName() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the name of the peer as specified by <db:link xlink:href="qlocalsocket.xml#setServerName">setServerName</db:link>(), or an empty <db:link xlink:href="qstring.xml">QString</db:link> if <db:link xlink:href="qlocalsocket.xml#setServerName">setServerName</db:link>() has not been called or <db:link xlink:href="qlocalsocket.xml#connectToServer">connectToServer</db:link>() failed.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qlocalsocket.xml#setServerName">setServerName</db:link>()</db:member>
<db:member><db:link xlink:href="qlocalsocket.xml#connectToServer">connectToServer</db:link>()</db:member>
<db:member><db:link xlink:href="qlocalsocket.xml#fullServerName">fullServerName</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setReadBufferSize">
<db:title>void QLocalSocket::setReadBufferSize(qint64 <db:emphasis>size</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>setReadBufferSize</db:methodname>
<db:methodparam>
<db:type>qint64</db:type>
<db:parameter>size</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void setReadBufferSize(qint64 size)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Sets the size of <db:link xlink:href="qlocalsocket.xml">QLocalSocket</db:link>'s internal read buffer to be <db:code role="parameter">size</db:code> bytes.</db:para>
<db:para>If the buffer size is limited to a certain size, <db:link xlink:href="qlocalsocket.xml">QLocalSocket</db:link> won't buffer more than this size of data. Exceptionally, a buffer size of 0 means that the read buffer is unlimited and all incoming data is buffered. This is the default.</db:para>
<db:para>This option is useful if you only read the data at certain points in time (e.g., in a real-time streaming application) or if you want to protect your socket against receiving too much data, which may eventually cause your application to run out of memory.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qlocalsocket.xml#readBufferSize">readBufferSize</db:link>()</db:member>
<db:member><db:link xlink:href="qiodevice.xml#read">read</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setServerName">
<db:title>void QLocalSocket::setServerName(const QString &amp;<db:emphasis>name</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>setServerName</db:methodname>
<db:methodparam>
<db:type>const QString &amp;</db:type>
<db:parameter>name</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void setServerName(const QString &amp;name)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Set the <db:code role="parameter">name</db:code> of the peer to connect to. On Windows name is the name of a named pipe; on Unix name is the name of a local domain socket.</db:para>
<db:para>This function must be called when the socket is not connected.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qlocalsocket.xml#serverName">serverName</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setSocketDescriptor">
<db:title>bool QLocalSocket::setSocketDescriptor(qintptr <db:emphasis>socketDescriptor</db:emphasis>, QLocalSocket::LocalSocketState <db:emphasis>socketState</db:emphasis> = ConnectedState, QIODeviceBase::OpenMode <db:emphasis>openMode</db:emphasis> = ReadWrite)</db:title>
<db:methodsynopsis>
<db:type>bool</db:type>
<db:methodname>setSocketDescriptor</db:methodname>
<db:methodparam>
<db:type>qintptr</db:type>
<db:parameter>socketDescriptor</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>QLocalSocket::LocalSocketState</db:type>
<db:parameter>socketState</db:parameter>
<db:initializer>ConnectedState</db:initializer>
</db:methodparam>
<db:methodparam>
<db:type>QIODeviceBase::OpenMode</db:type>
<db:parameter>openMode</db:parameter>
<db:initializer>ReadWrite</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool setSocketDescriptor(qintptr socketDescriptor, QLocalSocket::LocalSocketState socketState, QIODeviceBase::OpenMode openMode)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Initializes <db:link xlink:href="qlocalsocket.xml">QLocalSocket</db:link> with the native socket descriptor <db:code role="parameter">socketDescriptor</db:code>. Returns true if <db:link xlink:href="qlocalsocket.xml#socketDescriptor">socketDescriptor</db:link> is accepted as a valid socket descriptor; otherwise returns false. The socket is opened in the mode specified by <db:code role="parameter">openMode</db:code>, and enters the socket state specified by <db:code role="parameter">socketState</db:code>.</db:para>
<db:note>
<db:para>It is not possible to initialize two local sockets with the same native socket descriptor.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qlocalsocket.xml#socketDescriptor">socketDescriptor</db:link>()</db:member>
<db:member><db:link xlink:href="qlocalsocket.xml#state">state</db:link>()</db:member>
<db:member><db:link xlink:href="qiodevice.xml#openMode">openMode</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="skipData">
<db:title>[override virtual protected] qint64 QLocalSocket::skipData(qint64 <db:emphasis>maxSize</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:modifier>virtual</db:modifier>
<db:type>qint64</db:type>
<db:methodname>skipData</db:methodname>
<db:methodparam>
<db:type>qint64</db:type>
<db:parameter>maxSize</db:parameter>
</db:methodparam>
<db:modifier>override</db:modifier>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">qint64 skipData(qint64 maxSize) override</db:synopsisinfo>
<db:synopsisinfo role="access">protected</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Reimplements: <db:link xlink:href="qiodevice.xml#skipData" role="function">QIODevice::skipData(qint64 maxSize)</db:link>.</db:para>
</db:section>
<db:section xml:id="socketDescriptor">
<db:title>qintptr QLocalSocket::socketDescriptor() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>qintptr</db:type>
<db:methodname>socketDescriptor</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">qintptr socketDescriptor() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the native socket descriptor of the <db:link xlink:href="qlocalsocket.xml">QLocalSocket</db:link> object if this is available; otherwise returns -1.</db:para>
<db:para>The socket descriptor is not available when <db:link xlink:href="qlocalsocket.xml">QLocalSocket</db:link> is in <db:link xlink:href="qlocalsocket.xml#LocalSocketState-enum">UnconnectedState</db:link>. The type of the descriptor depends on the platform:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para>On Windows, the returned value is a <db:link xlink:href="https://docs.microsoft.com/en-us/windows/win32/winsock/socket-handles-2">Winsock 2 Socket Handle</db:link>.</db:para>
</db:listitem>
<db:listitem>
<db:para>On INTEGRITY, the returned value is the <db:link xlink:href="qtcpsocket.xml">QTcpSocket</db:link> socket descriptor and the type is defined by <db:link xlink:href="qabstractsocket.xml#socketDescriptor">socketDescriptor</db:link>.</db:para>
</db:listitem>
<db:listitem>
<db:para>On all other UNIX-like operating systems, the type is a file descriptor representing a socket.</db:para>
</db:listitem>
</db:itemizedlist>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qlocalsocket.xml#setSocketDescriptor">setSocketDescriptor</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="state">
<db:title>QLocalSocket::LocalSocketState QLocalSocket::state() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QLocalSocket::LocalSocketState</db:type>
<db:methodname>state</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QLocalSocket::LocalSocketState state() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the state of the socket.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qlocalsocket.xml#error">error</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="stateChanged">
<db:title>void QLocalSocket::stateChanged(QLocalSocket::LocalSocketState <db:emphasis>socketState</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>stateChanged</db:methodname>
<db:methodparam>
<db:type>QLocalSocket::LocalSocketState</db:type>
<db:parameter>socketState</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void stateChanged(QLocalSocket::LocalSocketState socketState)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This signal is emitted whenever <db:link xlink:href="qlocalsocket.xml">QLocalSocket</db:link>'s state changes. The <db:code role="parameter">socketState</db:code> parameter is the new state.</db:para>
<db:para>QLocalSocket::SocketState is not a registered metatype, so for queued connections, you will have to register it with <db:link xlink:href="qmetatype.xml#Q_DECLARE_METATYPE">Q_DECLARE_METATYPE</db:link>() and <db:link xlink:href="qmetatype.xml#qRegisterMetaType-3">qRegisterMetaType</db:link>().</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qlocalsocket.xml#state">state</db:link>()</db:member>
<db:member><db:link xlink:href="custom-types.xml">Creating Custom Qt Types</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="waitForBytesWritten">
<db:title>[override virtual] bool QLocalSocket::waitForBytesWritten(int <db:emphasis>msecs</db:emphasis> = 30000)</db:title>
<db:methodsynopsis>
<db:modifier>virtual</db:modifier>
<db:type>bool</db:type>
<db:methodname>waitForBytesWritten</db:methodname>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>msecs</db:parameter>
<db:initializer>30000</db:initializer>
</db:methodparam>
<db:modifier>override</db:modifier>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool waitForBytesWritten(int msecs) override</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Reimplements: <db:link xlink:href="qiodevice.xml#waitForBytesWritten" role="function">QIODevice::waitForBytesWritten(int msecs)</db:link>.</db:para>
</db:section>
<db:section xml:id="waitForConnected">
<db:title>bool QLocalSocket::waitForConnected(int <db:emphasis>msecs</db:emphasis> = 30000)</db:title>
<db:methodsynopsis>
<db:type>bool</db:type>
<db:methodname>waitForConnected</db:methodname>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>msecs</db:parameter>
<db:initializer>30000</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool waitForConnected(int msecs)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Waits until the socket is connected, up to <db:code role="parameter">msecs</db:code> milliseconds. If the connection has been established, this function returns true; otherwise it returns false. In the case where it returns false, you can call <db:link xlink:href="qlocalsocket.xml#error">error</db:link>() to determine the cause of the error.</db:para>
<db:para>The following example waits up to one second for a connection to be established:</db:para>
<db:programlisting language="cpp">socket-&amp;gt;connectToServer(&quot;market&quot;);
if (socket-&amp;gt;waitForConnected(1000))
    qDebug(&quot;Connected!&quot;);
</db:programlisting>
<db:para>If <db:code role="parameter">msecs</db:code> is -1, this function will not time out.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qlocalsocket.xml#connectToServer">connectToServer</db:link>()</db:member>
<db:member><db:link xlink:href="qlocalsocket.xml#connected">connected</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="waitForDisconnected">
<db:title>bool QLocalSocket::waitForDisconnected(int <db:emphasis>msecs</db:emphasis> = 30000)</db:title>
<db:methodsynopsis>
<db:type>bool</db:type>
<db:methodname>waitForDisconnected</db:methodname>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>msecs</db:parameter>
<db:initializer>30000</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool waitForDisconnected(int msecs)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Waits until the socket has disconnected, up to <db:code role="parameter">msecs</db:code> milliseconds. If the connection was successfully disconnected, this function returns true; otherwise it returns false (if the operation timed out, if an error occurred, or if this <db:link xlink:href="qlocalsocket.xml">QLocalSocket</db:link> is already disconnected). In the case where it returns false, you can call <db:link xlink:href="qlocalsocket.xml#error">error</db:link>() to determine the cause of the error.</db:para>
<db:para>The following example waits up to one second for a connection to be closed:</db:para>
<db:programlisting language="cpp">socket-&amp;gt;disconnectFromServer();
if (socket-&amp;gt;state() == QLocalSocket::UnconnectedState
    || socket-&amp;gt;waitForDisconnected(1000)) {
    qDebug(&quot;Disconnected!&quot;);
}
</db:programlisting>
<db:para>If <db:code role="parameter">msecs</db:code> is -1, this function will not time out.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qlocalsocket.xml#disconnectFromServer">disconnectFromServer</db:link>()</db:member>
<db:member><db:link xlink:href="qlocalsocket.xml#close">close</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="waitForReadyRead">
<db:title>[override virtual] bool QLocalSocket::waitForReadyRead(int <db:emphasis>msecs</db:emphasis> = 30000)</db:title>
<db:methodsynopsis>
<db:modifier>virtual</db:modifier>
<db:type>bool</db:type>
<db:methodname>waitForReadyRead</db:methodname>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>msecs</db:parameter>
<db:initializer>30000</db:initializer>
</db:methodparam>
<db:modifier>override</db:modifier>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool waitForReadyRead(int msecs) override</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Reimplements: <db:link xlink:href="qiodevice.xml#waitForReadyRead" role="function">QIODevice::waitForReadyRead(int msecs)</db:link>.</db:para>
<db:para>This function blocks until data is available for reading and the <db:link xlink:href="qiodevice.xml#readyRead">readyRead</db:link>() signal has been emitted. The function will timeout after <db:code role="parameter">msecs</db:code> milliseconds; the default timeout is 30000 milliseconds.</db:para>
<db:para>The function returns true if data is available for reading; otherwise it returns false (if an error occurred or the operation timed out).</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qlocalsocket.xml#waitForBytesWritten">waitForBytesWritten</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="writeData">
<db:title>[override virtual protected] qint64 QLocalSocket::writeData(const char *<db:emphasis>data</db:emphasis>, qint64 <db:emphasis>c</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:modifier>virtual</db:modifier>
<db:type>qint64</db:type>
<db:methodname>writeData</db:methodname>
<db:methodparam>
<db:type>const char *</db:type>
<db:parameter>data</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>qint64</db:type>
<db:parameter>c</db:parameter>
</db:methodparam>
<db:modifier>override</db:modifier>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">qint64 writeData(const char *data, qint64 c) override</db:synopsisinfo>
<db:synopsisinfo role="access">protected</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Reimplements: <db:link xlink:href="qiodevice.xml#writeData" role="function">QIODevice::writeData(const char *data, qint64 maxSize)</db:link>.</db:para>
</db:section>
</db:section>
</db:article>
