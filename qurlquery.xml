<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en">
<db:info>
<db:title>QUrlQuery Class</db:title>
<db:productname>QtCore</db:productname>
<db:edition>Qt 5.5.1 Reference Documentation</db:edition>
<db:titleabbrev>Qt Core Reference Documentation</db:titleabbrev>
<db:abstract>
<db:para>The <db:link xlink:href="qurlquery.xml">QUrlQuery</db:link> class provides a way to manipulate a key-value pairs in a URL's query.</db:para>
<db:para>This class was introduced in Qt 5.0.</db:para>
<db:note>
<db:para>All functions in this class are reentrant.</db:para>
</db:note>
</db:abstract>
<db:pubdate>2025-06-29</db:pubdate>
<db:date>2025-06-29</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:variablelist>
<db:varlistentry>
<db:term>Header</db:term>
<db:listitem>
<db:para>QUrlQuery</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Since</db:term>
<db:listitem>
<db:para>Qt 5.0</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>qmake</db:term>
<db:listitem>
<db:para>QT += core</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Group</db:term>
<db:listitem>
<db:para>QUrlQuery is part of <db:simplelist><db:member><db:link xlink:href="io.xml">Input/Output and Networking</db:link></db:member><db:member>network</db:member><db:member><db:link xlink:href="shared.xml">Implicitly Shared Classes</db:link></db:member></db:simplelist>
</db:para>
</db:listitem>
</db:varlistentry>
</db:variablelist>
<db:section xml:id="details">
<db:title>Detailed Description</db:title>
<db:para>It is used to parse the query strings found in URLs like the following:</db:para>
<db:mediaobject>
<db:imageobject>
<db:imagedata fileref="images/qurl-querystring.png"/>
</db:imageobject>
</db:mediaobject>
<db:para>Query strings like the above are used to transmit options in the URL and are usually decoded into multiple key-value pairs. The one above would contain two entries in its list, with keys &quot;type&quot; and &quot;color&quot;. <db:link xlink:href="qurlquery.xml">QUrlQuery</db:link> can also be used to create a query string suitable for use in QUrl::setQuery() from the individual components of the query.</db:para>
<db:para>The most common way of parsing a query string is to initialize it in the constructor by passing it the query string. Otherwise, the <db:link xlink:href="qurlquery.xml#setQuery">setQuery</db:link>() method can be used to set the query to be parsed. That method can also be used to parse a query with non-standard delimiters, after having set them using the setQueryDelimiters() function.</db:para>
<db:para>The encoded query string can be obtained again using <db:link xlink:href="qurlquery.xml#query">query</db:link>(). This will take all the internally-stored items and encode the string using the delimiters.</db:para>
<db:section xml:id="encoding">
<db:title>Encoding</db:title>
<db:para>All of the getter methods in <db:link xlink:href="qurlquery.xml">QUrlQuery</db:link> support an optional parameter of type <db:link xlink:href="qurl.xml#ComponentFormattingOption-enum">QUrl::ComponentFormattingOptions</db:link>, including <db:link xlink:href="qurlquery.xml#query">query</db:link>(), which dictate how to encode the data in question. Except for <db:link xlink:href="qurl.xml#ComponentFormattingOption-enum">QUrl::FullyDecoded</db:link>, the returned value must still be considered a percent-encoded string, as there are certain values which cannot be expressed in decoded form (like control characters, byte sequences not decodable to UTF-8). For that reason, the percent character is always represented by the string &quot;%25&quot;.</db:para>
<db:section xml:id="handling-of-spaces-and-plus">
<db:title>Handling of spaces and plus (&quot;+&quot;)</db:title>
<db:para>Web browsers usually encode spaces found in HTML FORM elements to a plus sign (&quot;+&quot;) and plus signs to its percent-encoded form (%2B). However, the Internet specifications governing URLs do not consider spaces and the plus character equivalent.</db:para>
<db:para>For that reason, <db:link xlink:href="qurlquery.xml">QUrlQuery</db:link> never encodes the space character to &quot;+&quot; and will never decode &quot;+&quot; to a space character. Instead, space characters will be rendered &quot;%20&quot; in encoded form.</db:para>
<db:para>To support encoding like that of HTML forms, <db:link xlink:href="qurlquery.xml">QUrlQuery</db:link> also never decodes the &quot;%2B&quot; sequence to a plus sign nor encode a plus sign. In fact, any &quot;%2B&quot; or &quot;+&quot; sequences found in the keys, values, or query string are left exactly like written (except for the uppercasing of &quot;%2b&quot; to &quot;%2B&quot;).</db:para>
</db:section>
<db:section xml:id="full-decoding">
<db:title>Full decoding</db:title>
<db:para>With <db:link xlink:href="qurl.xml#ComponentFormattingOption-enum">QUrl::FullyDecoded</db:link> formatting, all percent-encoded sequences will be decoded fully and the '%' character is used to represent itself. <db:link xlink:href="qurl.xml#ComponentFormattingOption-enum">QUrl::FullyDecoded</db:link> should be used with care, since it may cause data loss. See the documentation of <db:link xlink:href="qurl.xml#ComponentFormattingOption-enum">QUrl::FullyDecoded</db:link> for information on what data may be lost.</db:para>
<db:para>This formatting mode should be used only when dealing with text presented to the user in contexts where percent-encoding is not desired. Note that <db:link xlink:href="qurlquery.xml">QUrlQuery</db:link> setters and query methods do not support the counterpart <db:link xlink:href="qurl.xml#ParsingMode-enum">QUrl::DecodedMode</db:link> parsing, so using <db:link xlink:href="qurl.xml#ComponentFormattingOption-enum">QUrl::FullyDecoded</db:link> to obtain a listing of keys may result in keys not found in the object.</db:para>
</db:section>
</db:section>
<db:section xml:id="non-standard-delimiters">
<db:title>Non-standard delimiters</db:title>
<db:para>By default, <db:link xlink:href="qurlquery.xml">QUrlQuery</db:link> uses an equal sign (&quot;=&quot;) to separate a key from its value, and an ampersand (&quot;&amp;&quot;) to separate key-value pairs from each other. It is possible to change the delimiters that <db:link xlink:href="qurlquery.xml">QUrlQuery</db:link> uses for parsing and for reconstructing the query by calling setQueryDelimiters().</db:para>
<db:para>Non-standard delimiters should be chosen from among what RFC 3986 calls &quot;sub-delimiters&quot;. They are:</db:para>
<db:programlisting language="cpp">sub-delims    = &quot;!&quot; / &quot;$&quot; / &quot;&amp;&quot; / &quot;'&quot; / &quot;(&quot; / &quot;)&quot;
              / &quot;*&quot; / &quot;+&quot; / &quot;,&quot; / &quot;;&quot; / &quot;=&quot;
</db:programlisting>
<db:para>Use of other characters is not supported and may result in unexpected behaviour. <db:link xlink:href="qurlquery.xml">QUrlQuery</db:link> does not verify that you passed a valid delimiter.</db:para>
</db:section>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qurl.xml">QUrl</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="member-function-documentation">
<db:title>Member Function Documentation</db:title>
<db:section xml:id="QUrlQuery">
<db:title>QUrlQuery::QUrlQuery()</db:title>
<db:para>Constructs an empty <db:link xlink:href="qurlquery.xml">QUrlQuery</db:link> object. A query can be set afterwards by calling <db:link xlink:href="qurlquery.xml#setQuery">setQuery</db:link>() or items can be added by using <db:link xlink:href="qurlquery.xml#addQueryItem">addQueryItem</db:link>().</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qurlquery.xml#setQuery">setQuery</db:link>()</db:member>
<db:member><db:link xlink:href="qurlquery.xml#addQueryItem">addQueryItem</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="QUrlQuery-1">
<db:title>[explicit] QUrlQuery::QUrlQuery(const QString &amp;<db:emphasis>queryString</db:emphasis>)</db:title>
<db:para>Constructs a <db:link xlink:href="qurlquery.xml">QUrlQuery</db:link> object and parses the <db:code role="parameter">queryString</db:code> query string, using the default query delimiters. To parse a query string using other delimiters, you should first set them using setQueryDelimiters() and then set the query with <db:link xlink:href="qurlquery.xml#setQuery">setQuery</db:link>().</db:para>
</db:section>
<db:section xml:id="QUrlQuery-2">
<db:title>[explicit] QUrlQuery::QUrlQuery(const QUrl &amp;<db:emphasis>url</db:emphasis>)</db:title>
<db:para>Constructs a <db:link xlink:href="qurlquery.xml">QUrlQuery</db:link> object and parses the query string found in the <db:code role="parameter">url</db:code> URL, using the default query delimiters. To parse a query string using other delimiters, you should first set them using setQueryDelimiters() and then set the query with <db:link xlink:href="qurlquery.xml#setQuery">setQuery</db:link>().</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="">QUrl::query()</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="QUrlQuery-3">
<db:title>QUrlQuery::QUrlQuery(const QUrlQuery &amp;<db:emphasis>other</db:emphasis>)</db:title>
<db:para>Copies the contents of the <db:code role="parameter">other</db:code> <db:link xlink:href="qurlquery.xml">QUrlQuery</db:link> object, including the query delimiters.</db:para>
</db:section>
<db:section xml:id="dtor.QUrlQuery">
<db:title>[noexcept] QUrlQuery::~QUrlQuery()</db:title>
<db:para>Destroys this <db:link xlink:href="qurlquery.xml">QUrlQuery</db:link> object.</db:para>
</db:section>
<db:section xml:id="addQueryItem">
<db:title>void QUrlQuery::addQueryItem(const QString &amp;<db:emphasis>key</db:emphasis>, const QString &amp;<db:emphasis>value</db:emphasis>)</db:title>
<db:para>Appends the pair <db:code role="parameter">key</db:code> = <db:code role="parameter">value</db:code> to the end of the query string of the URL. This method does not overwrite existing items that might exist with the same key.</db:para>
<db:note>
<db:para>This method does not treat spaces (ASCII 0x20) and plus (&quot;+&quot;) signs as the same, like HTML forms do. If you need spaces to be represented as plus signs, use actual plus signs.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qurlquery.xml#hasQueryItem">hasQueryItem</db:link>()</db:member>
<db:member><db:link xlink:href="qurlquery.xml#queryItemValue">queryItemValue</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="allQueryItemValues">
<db:title>QStringList QUrlQuery::allQueryItemValues(const QString &amp;<db:emphasis>key</db:emphasis>, QUrl::ComponentFormattingOptions <db:emphasis>encoding</db:emphasis> = QUrl::PrettyDecoded) const</db:title>
<db:para>Returns the a list of query string values whose key is equal to <db:code role="parameter">key</db:code> from the URL, using the options specified in <db:code role="parameter">encoding</db:code> to encode the return value. If the key <db:code role="parameter">key</db:code> is not found, this function returns an empty list.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qurlquery.xml#queryItemValue">queryItemValue</db:link>()</db:member>
<db:member><db:link xlink:href="qurlquery.xml#addQueryItem">addQueryItem</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="clear">
<db:title>void QUrlQuery::clear()</db:title>
<db:para>Clears this <db:link xlink:href="qurlquery.xml">QUrlQuery</db:link> object by removing all of the key-value pairs currently stored. If the query delimiters have been changed, this function will leave them with their changed values.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qurlquery.xml#isEmpty">isEmpty</db:link>()</db:member>
<db:member><db:link xlink:href="">setQueryDelimiters()</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="defaultQueryPairDelimiter">
<db:title>[static] int QUrlQuery::defaultQueryPairDelimiter()</db:title>
<db:para>Returns the default character for separating keys-value pairs from each other, an ampersand (&quot;&amp;&quot;).</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="">setQueryDelimiters()</db:link></db:member>
<db:member><db:link xlink:href="qurlquery.xml#queryPairDelimiter">queryPairDelimiter</db:link>()</db:member>
<db:member><db:link xlink:href="qurlquery.xml#defaultQueryValueDelimiter">defaultQueryValueDelimiter</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="defaultQueryValueDelimiter">
<db:title>[static] int QUrlQuery::defaultQueryValueDelimiter()</db:title>
<db:para>Returns the default character for separating keys from values in the query, an equal sign (&quot;=&quot;).</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="">setQueryDelimiters()</db:link></db:member>
<db:member><db:link xlink:href="qurlquery.xml#queryValueDelimiter">queryValueDelimiter</db:link>()</db:member>
<db:member><db:link xlink:href="qurlquery.xml#defaultQueryPairDelimiter">defaultQueryPairDelimiter</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="hasQueryItem">
<db:title>bool QUrlQuery::hasQueryItem(const QString &amp;<db:emphasis>key</db:emphasis>) const</db:title>
<db:para>Returns true if there is a query string pair whose key is equal to <db:code role="parameter">key</db:code> from the URL.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qurlquery.xml#addQueryItem">addQueryItem</db:link>()</db:member>
<db:member><db:link xlink:href="qurlquery.xml#queryItemValue">queryItemValue</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="isEmpty">
<db:title>bool QUrlQuery::isEmpty() const</db:title>
<db:para>Returns true if this <db:link xlink:href="qurlquery.xml">QUrlQuery</db:link> object contains no key-value pairs, such as after being default-constructed or after parsing an empty query string.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qurlquery.xml#setQuery">setQuery</db:link>()</db:member>
<db:member><db:link xlink:href="qurlquery.xml#clear">clear</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="query">
<db:title>QString QUrlQuery::query(QUrl::ComponentFormattingOptions <db:emphasis>encoding</db:emphasis> = QUrl::PrettyDecoded) const</db:title>
<db:para>Returns the reconstructed query string, formed from the key-value pairs currently stored in this <db:link xlink:href="qurlquery.xml">QUrlQuery</db:link> object and separated by the query delimiters chosen for this object. The keys and values are encoded using the options given by the <db:code role="parameter">encoding</db:code> parameter.</db:para>
<db:para>For this function, the only ambiguous delimiter is the hash (&quot;#&quot;), as in URLs it is used to separate the query string from the fragment that may follow.</db:para>
<db:para>The order of the key-value pairs in the returned string is exactly the same as in the original query.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qurlquery.xml#setQuery">setQuery</db:link>()</db:member>
<db:member><db:link xlink:href="">QUrl::setQuery()</db:link></db:member>
<db:member><db:link xlink:href="">QUrl::fragment()</db:link></db:member>
<db:member><db:link xlink:href="qurlquery.xml#encoding">Encoding</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="queryItemValue">
<db:title>QString QUrlQuery::queryItemValue(const QString &amp;<db:emphasis>key</db:emphasis>, QUrl::ComponentFormattingOptions <db:emphasis>encoding</db:emphasis> = QUrl::PrettyDecoded) const</db:title>
<db:para>Returns the query value associated with key <db:code role="parameter">key</db:code> from the URL, using the options specified in <db:code role="parameter">encoding</db:code> to encode the return value. If the key <db:code role="parameter">key</db:code> is not found, this function returns an empty string. If you need to distinguish between an empty value and a non-existent key, you should check for the key's presence first using <db:link xlink:href="qurlquery.xml#hasQueryItem">hasQueryItem</db:link>().</db:para>
<db:para>If the key <db:code role="parameter">key</db:code> is multiply defined, this function will return the first one found, in the order they were present in the query string or added using <db:link xlink:href="qurlquery.xml#addQueryItem">addQueryItem</db:link>().</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qurlquery.xml#addQueryItem">addQueryItem</db:link>()</db:member>
<db:member><db:link xlink:href="qurlquery.xml#allQueryItemValues">allQueryItemValues</db:link>()</db:member>
<db:member><db:link xlink:href="qurlquery.xml#encoding">Encoding</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="queryItems">
<db:title>int QUrlQuery::queryItems(QUrl::ComponentFormattingOptions <db:emphasis>encoding</db:emphasis> = QUrl::PrettyDecoded) const</db:title>
<db:para>Returns the query string of the URL, as a map of keys and values, using the options specified in <db:code role="parameter">encoding</db:code> to encode the items. The order of the elements is the same as the one found in the query string or set with setQueryItems().</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="">setQueryItems()</db:link></db:member>
<db:member><db:link xlink:href="qurlquery.xml#encoding">Encoding</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="queryPairDelimiter">
<db:title>int QUrlQuery::queryPairDelimiter() const</db:title>
<db:para>Returns the character used to delimit between keys-value pairs when reconstructing the query string in <db:link xlink:href="qurlquery.xml#query">query</db:link>() or when parsing in <db:link xlink:href="qurlquery.xml#setQuery">setQuery</db:link>().</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="">setQueryDelimiters()</db:link></db:member>
<db:member><db:link xlink:href="qurlquery.xml#queryValueDelimiter">queryValueDelimiter</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="queryValueDelimiter">
<db:title>int QUrlQuery::queryValueDelimiter() const</db:title>
<db:para>Returns the character used to delimit between keys and values when reconstructing the query string in <db:link xlink:href="qurlquery.xml#query">query</db:link>() or when parsing in <db:link xlink:href="qurlquery.xml#setQuery">setQuery</db:link>().</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="">setQueryDelimiters()</db:link></db:member>
<db:member><db:link xlink:href="qurlquery.xml#queryPairDelimiter">queryPairDelimiter</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="removeAllQueryItems">
<db:title>void QUrlQuery::removeAllQueryItems(const QString &amp;<db:emphasis>key</db:emphasis>)</db:title>
<db:para>Removes all the query string pairs whose key is equal to <db:code role="parameter">key</db:code> from the URL.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qurlquery.xml#removeQueryItem">removeQueryItem</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="removeQueryItem">
<db:title>void QUrlQuery::removeQueryItem(const QString &amp;<db:emphasis>key</db:emphasis>)</db:title>
<db:para>Removes the query string pair whose key is equal to <db:code role="parameter">key</db:code> from the URL. If there are multiple items with a key equal to <db:code role="parameter">key</db:code>, it removes the first item in the order they were present in the query string or added with <db:link xlink:href="qurlquery.xml#addQueryItem">addQueryItem</db:link>().</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qurlquery.xml#removeAllQueryItems">removeAllQueryItems</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setQuery">
<db:title>void QUrlQuery::setQuery(const QString &amp;<db:emphasis>queryString</db:emphasis>)</db:title>
<db:para>Parses the query string in <db:code role="parameter">queryString</db:code> and sets the internal items to the values found there. If any delimiters have been specified with setQueryDelimiters(), this function will use them instead of the default delimiters to parse the string.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qurlquery.xml#query">query</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="swap">
<db:title>void QUrlQuery::swap(QUrlQuery &amp;<db:emphasis>other</db:emphasis>)</db:title>
<db:para>Swaps this URL query instance with <db:code role="parameter">other</db:code>. This function is very fast and never fails.</db:para>
</db:section>
<db:section xml:id="toString">
<db:title>QString QUrlQuery::toString(QUrl::ComponentFormattingOptions <db:emphasis>encoding</db:emphasis> = QUrl::PrettyDecoded) const</db:title>
<db:para>Returns this <db:link xlink:href="qurlquery.xml">QUrlQuery</db:link> as a <db:link xlink:href="qstring.xml">QString</db:link>. <db:code role="parameter">encoding</db:code> can be used to specify the URL string encoding of the return value.</db:para>
</db:section>
<db:section xml:id="operator-not-eq">
<db:title>bool QUrlQuery::operator!=(const QUrlQuery &amp;<db:emphasis>other</db:emphasis>) const</db:title>
<db:para>Returns true if <db:code role="parameter">other</db:code> is not equal to this <db:link xlink:href="qurlquery.xml">QUrlQuery</db:link>. Otherwise, returns false.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qurlquery.xml#operator-eq-eq">operator==</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="operator-eq">
<db:title>[since 5.2] QUrlQuery &amp;QUrlQuery::operator=(QUrlQuery &amp;&amp;<db:emphasis>other</db:emphasis>)</db:title>
<db:para>Move-assigns <db:code role="parameter">other</db:code> to this <db:link xlink:href="qurlquery.xml">QUrlQuery</db:link> instance.</db:para>
<db:para>This function was introduced in Qt 5.2.</db:para>
</db:section>
<db:section xml:id="operator-eq-1">
<db:title>QUrlQuery &amp;QUrlQuery::operator=(const QUrlQuery &amp;<db:emphasis>other</db:emphasis>)</db:title>
<db:para>Copies the contents of the <db:code role="parameter">other</db:code> <db:link xlink:href="qurlquery.xml">QUrlQuery</db:link> object, including the query delimiters.</db:para>
</db:section>
<db:section xml:id="operator-eq-eq">
<db:title>bool QUrlQuery::operator==(const QUrlQuery &amp;<db:emphasis>other</db:emphasis>) const</db:title>
<db:para>Returns true if this object and the <db:code role="parameter">other</db:code> object contain the same contents, in the same order, and use the same query delimiters.</db:para>
</db:section>
</db:section>
</db:article>
