<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en">
<db:info>
<db:title>QRhiBuffer Class</db:title>
<db:productname>QtGui</db:productname>
<db:edition>Qt 6.9.1 Reference Documentation</db:edition>
<db:titleabbrev>Qt GUI Reference Documentation</db:titleabbrev>
<db:abstract>
<db:para>Vertex, index, or uniform (constant) buffer resource.</db:para>
<db:para>This class was introduced in Qt 6.6.</db:para>
</db:abstract>
<db:pubdate>2025-06-29</db:pubdate>
<db:date>2025-06-29</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:variablelist>
<db:varlistentry>
<db:term>Header</db:term>
<db:listitem>
<db:para>rhi/qrhi.h</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Since</db:term>
<db:listitem>
<db:para>Qt 6.6</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>CMake</db:term>
<db:listitem>
<db:para>find_package(Qt6 REQUIRED COMPONENTS Gui)</db:para>
<db:para>target_link_libraries(mytarget PRIVATE Qt6::GuiPrivate)</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>qmake</db:term>
<db:listitem>
<db:para>QT += gui-private</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Inherits</db:term>
<db:listitem>
<db:para><db:link xlink:href="qrhiresource.xml" xlink:role="class">QRhiResource</db:link></db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Inherited By</db:term>
<db:listitem>
<db:para/>
</db:listitem>
</db:varlistentry>
</db:variablelist>
<db:section xml:id="details">
<db:title>Detailed Description</db:title>
<db:note>
<db:para>This is a RHI API with limited compatibility guarantees, see <db:link xlink:href="qrhi.xml">QRhi</db:link> for details.</db:para>
</db:note>
<db:para>A <db:link xlink:href="qrhibuffer.xml">QRhiBuffer</db:link> encapsulates zero, one, or more native buffer objects (such as a <db:code>VkBuffer</db:code> or <db:code>MTLBuffer</db:code>). With some graphics APIs and backends certain types of buffers may not use a native buffer object at all (e.g. OpenGL if uniform buffer objects are not used), but this is transparent to the user of the <db:link xlink:href="qrhibuffer.xml">QRhiBuffer</db:link> API. Similarly, the fact that some types of buffers may use two or three native buffers underneath, in order to allow efficient per-frame content update without stalling the GPU pipeline, is mostly invisible to the applications and libraries.</db:para>
<db:para>A <db:link xlink:href="qrhibuffer.xml">QRhiBuffer</db:link> instance is always created by calling <db:link xlink:href="qrhi.xml#newBuffer">the QRhi's newBuffer() function</db:link>. This creates no native graphics resources. To do that, call create() after setting the appropriate options, such as the type, usage flags, size, although in most cases these are already set based on the arguments passed to <db:link xlink:href="qrhi.xml#newBuffer">newBuffer</db:link>().</db:para>
<db:section xml:id="example-usage">
<db:title>Example usage</db:title>
<db:para>To create a uniform buffer for a shader where the GLSL uniform block contains a single <db:code>mat4</db:code> member, and update the contents:</db:para>
<db:programlisting language="cpp">QRhiBuffer *ubuf = rhi-&gt;newBuffer(QRhiBuffer::Dynamic, QRhiBuffer::UniformBuffer, 64);
if (!ubuf-&gt;create()) { error(); }
QRhiResourceUpdateBatch *batch = rhi-&gt;nextResourceUpdateBatch();
QMatrix4x4 mvp;
// ... set up the modelview-projection matrix
batch-&gt;updateDynamicBuffer(ubuf, 0, 64, mvp.constData());
// ...
commandBuffer-&gt;resourceUpdate(batch); // or, alternatively, pass 'batch' to a beginPass() call
</db:programlisting>
<db:para>An example of creating a buffer with vertex data:</db:para>
<db:programlisting language="cpp">const float vertices[] = { -1.0f, -1.0f, 1.0f, -1.0f, 0.0f, 1.0f };
QRhiBuffer *vbuf = rhi-&gt;newBuffer(QRhiBuffer::Immutable, QRhiBuffer::VertexBuffer, sizeof(vertices));
if (!vbuf-&gt;create()) { error(); }
QRhiResourceUpdateBatch *batch = rhi-&gt;nextResourceUpdateBatch();
batch-&gt;uploadStaticBuffer(vbuf, vertices);
// ...
commandBuffer-&gt;resourceUpdate(batch); // or, alternatively, pass 'batch' to a beginPass() call
</db:programlisting>
<db:para>An index buffer:</db:para>
<db:programlisting language="cpp">static const quint16 indices[] = { 0, 1, 2 };
QRhiBuffer *ibuf = rhi-&gt;newBuffer(QRhiBuffer::Immutable, QRhiBuffer::IndexBuffer, sizeof(indices));
if (!ibuf-&gt;create()) { error(); }
QRhiResourceUpdateBatch *batch = rhi-&gt;nextResourceUpdateBatch();
batch-&gt;uploadStaticBuffer(ibuf, indices);
// ...
commandBuffer-&gt;resourceUpdate(batch); // or, alternatively, pass 'batch' to a beginPass() call
</db:programlisting>
</db:section>
<db:section xml:id="common-patterns">
<db:title>Common patterns</db:title>
<db:para>A call to create() destroys any existing native resources if create() was successfully called before. If those native resources are still in use by an in-flight frame (i.e., there's a chance they are still read by the GPU), the destroying of those resources is deferred automatically. Thus a very common and convenient pattern to safely increase the size of an already initialized buffer is the following. In practice this drops and creates a whole new set of native resources underneath, so it is not necessarily a cheap operation, but is more convenient and still faster than the alternatives, because by not destroying the <db:code>buf</db:code> object itself, all references to it stay valid in other data structures (e.g., in any <db:link xlink:href="qrhishaderresourcebinding.xml">QRhiShaderResourceBinding</db:link> the <db:link xlink:href="qrhibuffer.xml">QRhiBuffer</db:link> is referenced from).</db:para>
<db:programlisting language="cpp">if (buf-&gt;size() &lt; newSize) {
    buf-&gt;setSize(newSize);
    if (!buf-&gt;create()) { error(); }
}
// continue using buf, fill it with new data
</db:programlisting>
<db:para>When working with uniform buffers, it will sometimes be necessary to combine data for multiple draw calls into a single buffer for efficiency reasons. Be aware of the aligment requirements: with some graphics APIs offsets for a uniform buffer must be aligned to 256 bytes. This applies both to <db:link xlink:href="qrhishaderresourcebinding.xml">QRhiShaderResourceBinding</db:link> and to the dynamic offsets passed to <db:link xlink:href="qrhicommandbuffer.xml#setShaderResources">setShaderResources</db:link>(). Use the <db:link xlink:href="qrhi.xml#ubufAlignment">ubufAlignment</db:link>() and <db:link xlink:href="qrhi.xml#ubufAligned">ubufAligned</db:link>() functions to create portable code. As an example, the following is an outline for issuing multiple (<db:code>N</db:code>) draw calls with the same pipeline and geometry, but with a different data in the uniform buffers exposed at binding point 0. This assumes the buffer is exposed via <db:link xlink:href="qrhishaderresourcebinding.xml#uniformBufferWithDynamicOffset">uniformBufferWithDynamicOffset</db:link>() which allows passing a <db:link xlink:href="qrhicommandbuffer.xml#DynamicOffset-typedef">QRhiCommandBuffer::DynamicOffset</db:link> list to <db:link xlink:href="qrhicommandbuffer.xml#setShaderResources">setShaderResources</db:link>().</db:para>
<db:programlisting language="cpp">const int N = 2;
const int UB_SIZE = 64 + 4; // assuming a uniform block with { mat4 matrix; float opacity; }
const int ONE_UBUF_SIZE = rhi-&gt;ubufAligned(UB_SIZE);
const int TOTAL_UBUF_SIZE = N * ONE_UBUF_SIZE;
QRhiBuffer *ubuf = rhi-&gt;newBuffer(QRhiBuffer::Dynamic, QRhiBuffer::UniformBuffer, TOTAL_UBUF_SIZE);
if (!ubuf-&gt;create()) { error(); }
QRhiResourceUpdateBatch *batch = rhi-&gt;nextResourceUpdateBatch();
for (int i = 0; i &lt; N; ++i) {
    batch-&gt;updateDynamicBuffer(ubuf, i * ONE_UBUF_SIZE, 64, matrix.constData());
    batch-&gt;updateDynamicBuffer(ubuf, i * ONE_UBUF_SIZE + 64, 4, &amp;opacity);
}
// ...
// beginPass(), set pipeline, etc., and then:
for (int i = 0; i &lt; N; ++i) {
    QRhiCommandBuffer::DynamicOffset dynOfs[] = { { 0, i * ONE_UBUF_SIZE } };
    cb-&gt;setShaderResources(srb, 1, dynOfs);
    cb-&gt;draw(36);
}
</db:programlisting>
</db:section>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qrhiresourceupdatebatch.xml">QRhiResourceUpdateBatch</db:link></db:member>
<db:member><db:link xlink:href="qrhi.xml">QRhi</db:link></db:member>
<db:member><db:link xlink:href="qrhicommandbuffer.xml">QRhiCommandBuffer</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="member-type-documentation">
<db:title>Member Type Documentation</db:title>
<db:section xml:id="Type-enum">
<db:title>enum QRhiBuffer::Type</db:title>
<db:para>Specifies storage type of buffer resource.</db:para>
<db:informaltable>
<db:thead>
<db:tr>
<db:th>Constant</db:th>
<db:th>Value</db:th>
<db:th>Description</db:th>
</db:tr>
</db:thead>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qrhibuffer.xml">QRhiBuffer</db:link></db:emphasis>::Immutable</db:code></db:para>
</db:td>
<db:td><db:code>0</db:code></db:td>
<db:td>
<db:para>Indicates that the data is not expected to change ever after the initial upload. Under the hood such buffer resources are typically placed in device local (GPU) memory (on systems where applicable). Uploading new data is possible, but may be expensive. The upload typically happens by copying to a separate, host visible staging buffer from which a GPU buffer-to-buffer copy is issued into the actual GPU-only buffer.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qrhibuffer.xml">QRhiBuffer</db:link></db:emphasis>::Static</db:code></db:para>
</db:td>
<db:td><db:code>1</db:code></db:td>
<db:td>
<db:para>Indicates that the data is expected to change only infrequently. Typically placed in device local (GPU) memory, where applicable. On backends where host visible staging buffers are used for uploading, the staging buffers are kept around for this type, unlike with Immutable, so subsequent uploads do not suffer in performance. Frequent updates, especially updates in consecutive frames, should be avoided.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qrhibuffer.xml">QRhiBuffer</db:link></db:emphasis>::Dynamic</db:code></db:para>
</db:td>
<db:td><db:code>2</db:code></db:td>
<db:td>
<db:para>Indicates that the data is expected to change frequently. Not recommended for large buffers. Typically backed by host visible memory in 2 copies in order to allow for changing without stalling the graphics pipeline. The double buffering is managed transparently to the applications and is not exposed in the API here in any form. This is the recommended, and, with some backends, the only possible, type for buffers with <db:link xlink:href="qrhibuffer.xml#UsageFlag-enum">UniformBuffer</db:link> usage.</db:para>
</db:td>
</db:tr>
</db:informaltable>
</db:section>
<db:section xml:id="UsageFlag-enum">
<db:title>enum QRhiBuffer::UsageFlag</db:title>
<db:bridgehead renderas="sect2">flags QRhiBuffer::UsageFlags</db:bridgehead>
<db:para>Flag values to specify how the buffer is going to be used.</db:para>
<db:informaltable>
<db:thead>
<db:tr>
<db:th>Constant</db:th>
<db:th>Value</db:th>
<db:th>Description</db:th>
</db:tr>
</db:thead>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qrhibuffer.xml">QRhiBuffer</db:link></db:emphasis>::VertexBuffer</db:code></db:para>
</db:td>
<db:td><db:code>1 &lt;&lt; 0</db:code></db:td>
<db:td>
<db:para>Vertex buffer. This allows the <db:link xlink:href="qrhibuffer.xml">QRhiBuffer</db:link> to be used in <db:link xlink:href="qrhicommandbuffer.xml#setVertexInput">setVertexInput</db:link>().</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qrhibuffer.xml">QRhiBuffer</db:link></db:emphasis>::IndexBuffer</db:code></db:para>
</db:td>
<db:td><db:code>1 &lt;&lt; 1</db:code></db:td>
<db:td>
<db:para>Index buffer. This allows the <db:link xlink:href="qrhibuffer.xml">QRhiBuffer</db:link> to be used in <db:link xlink:href="qrhicommandbuffer.xml#setVertexInput">setVertexInput</db:link>().</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qrhibuffer.xml">QRhiBuffer</db:link></db:emphasis>::UniformBuffer</db:code></db:para>
</db:td>
<db:td><db:code>1 &lt;&lt; 2</db:code></db:td>
<db:td>
<db:para>Uniform buffer (also called constant buffer). This allows the <db:link xlink:href="qrhibuffer.xml">QRhiBuffer</db:link> to be used in combination with <db:link xlink:href="qrhishaderresourcebinding.xml#Type-enum">UniformBuffer</db:link>. When <db:link xlink:href="qrhi.xml#Feature-enum">NonDynamicUniformBuffers</db:link> is reported as not supported, this usage can only be combined with the type Dynamic.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qrhibuffer.xml">QRhiBuffer</db:link></db:emphasis>::StorageBuffer</db:code></db:para>
</db:td>
<db:td><db:code>1 &lt;&lt; 3</db:code></db:td>
<db:td>
<db:para>Storage buffer. This allows the <db:link xlink:href="qrhibuffer.xml">QRhiBuffer</db:link> to be used in combination with <db:link xlink:href="qrhishaderresourcebinding.xml#Type-enum">BufferLoad</db:link>, <db:link xlink:href="qrhishaderresourcebinding.xml#Type-enum">BufferStore</db:link>, or <db:link xlink:href="qrhishaderresourcebinding.xml#Type-enum">BufferLoadStore</db:link>. This usage can only be combined with the types Immutable or Static, and is only available when the <db:link xlink:href="qrhi.xml#Feature-enum">Compute feature</db:link> is reported as supported.</db:para>
</db:td>
</db:tr>
</db:informaltable>
<db:para>The <db:code>UsageFlags</db:code> type is a typedef for <db:code><db:link xlink:href="qflags.xml">QFlags</db:link>&lt;UsageFlag&gt;. </db:code>It stores an OR combination of <db:code>UsageFlag</db:code> values.</db:para>
</db:section>
</db:section>
<db:section xml:id="member-function-documentation">
<db:title>Member Function Documentation</db:title>
<db:section xml:id="beginFullDynamicBufferUpdateForCurrentFrame">
<db:title>[virtual] char *QRhiBuffer::beginFullDynamicBufferUpdateForCurrentFrame()</db:title>
<db:para>Returns a pointer to a memory block with the host visible buffer data.</db:para>
<db:para>This is a shortcut for medium-to-large dynamic uniform buffers that have their <db:emphasis role="bold">entire</db:emphasis> contents (or at least all regions that are read by the shaders in the current frame) changed <db:emphasis role="bold">in every frame</db:emphasis> and the <db:link xlink:href="qrhiresourceupdatebatch.xml">QRhiResourceUpdateBatch</db:link>-based update mechanism is seen too heavy due to the amount of data copying involved.</db:para>
<db:para>The call to this function must be eventually followed by a call to endFullDynamicUniformBufferUpdateForCurrentFrame(), before recording any render or compute pass that relies on this buffer.</db:para>
<db:warning>
<db:para>Updating data via this method is not compatible with <db:link xlink:href="qrhiresourceupdatebatch.xml">QRhiResourceUpdateBatch</db:link>-based updates and readbacks. Unexpected behavior may occur when attempting to combine the two update models for the same buffer. Similarly, the data updated this direct way may not be visible to <db:link xlink:href="qrhiresourceupdatebatch.xml#readBackBuffer">readBackBuffer operations</db:link>, depending on the backend.</db:para>
</db:warning>
<db:warning>
<db:para>When updating buffer data via this method, the update must be done in every frame, otherwise backends that perform double or triple buffering of resources may end up in unexpected behavior.</db:para>
</db:warning>
<db:warning>
<db:para>Partial updates are not possible with this approach since some backends may choose a strategy where the previous contents of the buffer is lost upon calling this function. Data must be written to all regions that are read by shaders in the frame currently being prepared.</db:para>
</db:warning>
<db:warning>
<db:para>This function can only be called when recording a frame, so between <db:link xlink:href="qrhi.xml#beginFrame">QRhi::beginFrame</db:link>() and <db:link xlink:href="qrhi.xml#endFrame">QRhi::endFrame</db:link>().</db:para>
</db:warning>
<db:warning>
<db:para>This function can only be called on Dynamic buffers.</db:para>
</db:warning>
</db:section>
<db:section xml:id="endFullDynamicBufferUpdateForCurrentFrame">
<db:title>[virtual] void QRhiBuffer::endFullDynamicBufferUpdateForCurrentFrame()</db:title>
<db:para>To be called when the entire contents of the buffer data has been updated in the memory block returned from <db:link xlink:href="qrhibuffer.xml#beginFullDynamicBufferUpdateForCurrentFrame">beginFullDynamicBufferUpdateForCurrentFrame</db:link>().</db:para>
</db:section>
<db:section xml:id="nativeBuffer">
<db:title>[virtual] QRhiBuffer::NativeBuffer QRhiBuffer::nativeBuffer()</db:title>
<db:para>Returns the underlying native resources for this buffer. The returned value will be empty if exposing the underlying native resources is not supported by the backend.</db:para>
<db:para>A <db:link xlink:href="qrhibuffer.xml">QRhiBuffer</db:link> may be backed by multiple native buffer objects, depending on the type() and the <db:link xlink:href="qrhi.xml">QRhi</db:link> backend in use. When this is the case, all of them are returned in the objects array in the returned struct, with slotCount specifying the number of native buffer objects. While <db:link xlink:href="qrhi.xml#beginFrame">recording a frame</db:link>, <db:link xlink:href="qrhi.xml#currentFrameSlot">QRhi::currentFrameSlot</db:link>() can be used to determine which of the native buffers <db:link xlink:href="qrhi.xml">QRhi</db:link> is using for operations that read or write from this <db:link xlink:href="qrhibuffer.xml">QRhiBuffer</db:link> within the frame being recorded.</db:para>
<db:para>In some cases a <db:link xlink:href="qrhibuffer.xml">QRhiBuffer</db:link> will not be backed by a native buffer object at all. In this case slotCount will be set to 0 and no valid native objects are returned. This is not an error, and is perfectly valid when a given backend does not use native buffers for QRhiBuffers with certain types or usages.</db:para>
<db:note>
<db:para>Be aware that <db:link xlink:href="qrhi.xml">QRhi</db:link> backends may employ various buffer update strategies. Unlike textures, where uploading image data always means recording a buffer-to-image (or similar) copy command on the command buffer, buffers, in particular Dynamic and <db:link xlink:href="qrhibuffer.xml#UsageFlag-enum">UniformBuffer</db:link> ones, can operate in many different ways. For example, a <db:link xlink:href="qrhibuffer.xml">QRhiBuffer</db:link> with usage type <db:link xlink:href="qrhibuffer.xml#UsageFlag-enum">UniformBuffer</db:link> may not even be backed by a native buffer object at all if uniform buffers are not used or supported by a given backend and graphics API. There are also differences to how data is written to the buffer and the type of backing memory used. For buffers backed by host visible memory, calling this function guarantees that pending host writes are executed for all the returned native buffers.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qrhi.xml#currentFrameSlot">QRhi::currentFrameSlot</db:link>()</db:member>
<db:member><db:link xlink:href="qrhi.xml#ResourceLimit-enum">QRhi::FramesInFlight</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="resourceType">
<db:title>[override virtual] QRhiResource::Type QRhiBuffer::resourceType() const</db:title>
<db:para>Returns the resource type.</db:para>
</db:section>
</db:section>
</db:article>
