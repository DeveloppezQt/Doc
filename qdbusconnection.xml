<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en">
<db:info>
<db:title>QDBusConnection Class</db:title>
<db:productname>QtDBus</db:productname>
<db:edition>Qt 6.7.2 Reference Documentation</db:edition>
<db:titleabbrev>Qt D-Bus Reference Documentation</db:titleabbrev>
<db:abstract>
<db:para>The <db:link xlink:href="qdbusconnection.xml">QDBusConnection</db:link> class represents a connection to the D-Bus bus daemon.</db:para>
</db:abstract>
<db:pubdate>2024-12-27</db:pubdate>
<db:date>2024-12-27</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:variablelist>
<db:varlistentry>
<db:term>Header</db:term>
<db:listitem>
<db:para>QDBusConnection</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>CMake</db:term>
<db:listitem>
<db:para>find_package(Qt6 REQUIRED COMPONENTS DBus)</db:para>
<db:para>target_link_libraries(mytarget PRIVATE Qt6::DBus)</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>qmake</db:term>
<db:listitem>
<db:para>QT += dbus</db:para>
</db:listitem>
</db:varlistentry>
</db:variablelist>
<db:section xml:id="details">
<db:title>Detailed Description</db:title>
<db:para>This class is the initial point in a D-Bus session. Using it, you can get access to remote objects, interfaces; connect remote signals to your object's slots; register objects, etc.</db:para>
<db:para>D-Bus connections are created using the <db:link xlink:href="qdbusconnection.xml#connectToBus">connectToBus</db:link>() function, which opens a connection to the server daemon and does the initial handshaking, associating that connection with a name. Further attempts to connect using the same name will return the same connection.</db:para>
<db:para>The connection is then torn down using the <db:link xlink:href="qdbusconnection.xml#disconnectFromBus">disconnectFromBus</db:link>() function.</db:para>
<db:para>Once disconnected, calling <db:link xlink:href="qdbusconnection.xml#connectToBus">connectToBus</db:link>() will not reestablish a connection, you must create a new <db:link xlink:href="qdbusconnection.xml">QDBusConnection</db:link> instance.</db:para>
<db:para>As a convenience for the two most common connection types, the <db:link xlink:href="qdbusconnection.xml#sessionBus">sessionBus</db:link>() and <db:link xlink:href="qdbusconnection.xml#systemBus">systemBus</db:link>() functions return open connections to the session server daemon and the system server daemon, respectively. Those connections are opened when first used and are closed when the <db:link xlink:href="qcoreapplication.xml">QCoreApplication</db:link> destructor is run.</db:para>
<db:para>D-Bus also supports peer-to-peer connections, without the need for a bus server daemon. Using this facility, two applications can talk to each other and exchange messages. This can be achieved by passing an address to <db:link xlink:href="qdbusconnection.xml#connectToBus">connectToBus</db:link>() function, which was opened by another D-Bus application using <db:link xlink:href="qdbusserver.xml">QDBusServer</db:link>.</db:para>
</db:section>
<db:section xml:id="member-type-documentation">
<db:title>Member Type Documentation</db:title>
<db:section xml:id="BusType-enum">
<db:title>enum QDBusConnection::BusType</db:title>
<db:enumsynopsis>
<db:enumname>BusType</db:enumname>
<db:enumitem>
<db:enumidentifier>SessionBus</db:enumidentifier>
<db:enumvalue>0</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>SystemBus</db:enumidentifier>
<db:enumvalue>1</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>ActivationBus</db:enumidentifier>
<db:enumvalue>2</db:enumvalue>
</db:enumitem>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:enumsynopsis>
<db:para>Specifies the type of the bus connection. The valid bus types are:</db:para>
<db:informaltable>
<db:thead>
<db:tr>
<db:th>Constant</db:th>
<db:th>Value</db:th>
<db:th>Description</db:th>
</db:tr>
</db:thead>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qdbusconnection.xml">QDBusConnection</db:link></db:emphasis>::SessionBus</db:code></db:para>
</db:td>
<db:td><db:code>0</db:code></db:td>
<db:td>
<db:para>the session bus, associated with the running desktop session</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qdbusconnection.xml">QDBusConnection</db:link></db:emphasis>::SystemBus</db:code></db:para>
</db:td>
<db:td><db:code>1</db:code></db:td>
<db:td>
<db:para>the system bus, used to communicate with system-wide processes</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qdbusconnection.xml">QDBusConnection</db:link></db:emphasis>::ActivationBus</db:code></db:para>
</db:td>
<db:td><db:code>2</db:code></db:td>
<db:td>
<db:para>the activation bus, the &quot;alias&quot; for the bus that started the service</db:para>
</db:td>
</db:tr>
</db:informaltable>
<db:para>On the Session Bus, one can find other applications by the same user that are sharing the same desktop session (hence the name). On the System Bus, however, processes shared for the whole system are usually found.</db:para>
</db:section>
<db:section xml:id="ConnectionCapability-enum">
<db:title>enum QDBusConnection::ConnectionCapability</db:title>
<db:bridgehead renderas="sect2">flags QDBusConnection::ConnectionCapabilities</db:bridgehead>
<db:enumsynopsis>
<db:enumname>ConnectionCapability</db:enumname>
<db:enumitem>
<db:enumidentifier>UnixFileDescriptorPassing</db:enumidentifier>
<db:enumvalue>0x0001</db:enumvalue>
</db:enumitem>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:enumsynopsis>
<db:typedefsynopsis>
<db:typedefname>QDBusConnection::ConnectionCapabilities</db:typedefname>
</db:typedefsynopsis>
<db:para>This enum describes the available capabilities for a D-Bus connection.</db:para>
<db:informaltable>
<db:thead>
<db:tr>
<db:th>Constant</db:th>
<db:th>Value</db:th>
<db:th>Description</db:th>
</db:tr>
</db:thead>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qdbusconnection.xml">QDBusConnection</db:link></db:emphasis>::UnixFileDescriptorPassing</db:code></db:para>
</db:td>
<db:td><db:code>0x0001</db:code></db:td>
<db:td>
<db:para>enables passing of Unix file descriptors to other processes (see <db:link xlink:href="qdbusunixfiledescriptor.xml">QDBusUnixFileDescriptor</db:link>)</db:para>
</db:td>
</db:tr>
</db:informaltable>
<db:para>The <db:code>ConnectionCapabilities</db:code> type is a typedef for <db:code><db:link xlink:href="qflags.xml">QFlags</db:link>&lt;ConnectionCapability&gt;. </db:code>It stores an OR combination of <db:code>ConnectionCapability</db:code> values.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qdbusconnection.xml#connectionCapabilities">connectionCapabilities</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="RegisterOption-enum">
<db:title>enum QDBusConnection::RegisterOption</db:title>
<db:bridgehead renderas="sect2">flags QDBusConnection::RegisterOptions</db:bridgehead>
<db:enumsynopsis>
<db:enumname>RegisterOption</db:enumname>
<db:enumitem>
<db:enumidentifier>ExportAdaptors</db:enumidentifier>
<db:enumvalue>0x01</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>ExportScriptableSlots</db:enumidentifier>
<db:enumvalue>0x10</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>ExportScriptableSignals</db:enumidentifier>
<db:enumvalue>0x20</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>ExportScriptableProperties</db:enumidentifier>
<db:enumvalue>0x40</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>ExportScriptableInvokables</db:enumidentifier>
<db:enumvalue>0x80</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>ExportScriptableContents</db:enumidentifier>
<db:enumvalue>0xf0</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>ExportNonScriptableSlots</db:enumidentifier>
<db:enumvalue>0x100</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>ExportNonScriptableSignals</db:enumidentifier>
<db:enumvalue>0x200</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>ExportNonScriptableProperties</db:enumidentifier>
<db:enumvalue>0x400</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>ExportNonScriptableInvokables</db:enumidentifier>
<db:enumvalue>0x800</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>ExportNonScriptableContents</db:enumidentifier>
<db:enumvalue>0xf00</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>ExportAllSlots</db:enumidentifier>
<db:enumvalue>ExportScriptableSlots|ExportNonScriptableSlots</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>ExportAllSignals</db:enumidentifier>
<db:enumvalue>ExportScriptableSignals|ExportNonScriptableSignals</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>ExportAllProperties</db:enumidentifier>
<db:enumvalue>ExportScriptableProperties|ExportNonScriptableProperties</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>ExportAllInvokables</db:enumidentifier>
<db:enumvalue>ExportScriptableInvokables|ExportNonScriptableInvokables</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>ExportAllContents</db:enumidentifier>
<db:enumvalue>ExportScriptableContents|ExportNonScriptableContents</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>ExportChildObjects</db:enumidentifier>
<db:enumvalue>0x1000</db:enumvalue>
</db:enumitem>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:enumsynopsis>
<db:typedefsynopsis>
<db:typedefname>QDBusConnection::RegisterOptions</db:typedefname>
</db:typedefsynopsis>
<db:para>Specifies the options for registering objects with the connection. The possible values are:</db:para>
<db:informaltable>
<db:thead>
<db:tr>
<db:th>Constant</db:th>
<db:th>Value</db:th>
<db:th>Description</db:th>
</db:tr>
</db:thead>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qdbusconnection.xml">QDBusConnection</db:link></db:emphasis>::ExportAdaptors</db:code></db:para>
</db:td>
<db:td><db:code>0x01</db:code></db:td>
<db:td>
<db:para>export the contents of adaptors found in this object</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qdbusconnection.xml">QDBusConnection</db:link></db:emphasis>::ExportScriptableSlots</db:code></db:para>
</db:td>
<db:td><db:code>0x10</db:code></db:td>
<db:td>
<db:para>export this object's scriptable slots</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qdbusconnection.xml">QDBusConnection</db:link></db:emphasis>::ExportScriptableSignals</db:code></db:para>
</db:td>
<db:td><db:code>0x20</db:code></db:td>
<db:td>
<db:para>export this object's scriptable signals</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qdbusconnection.xml">QDBusConnection</db:link></db:emphasis>::ExportScriptableProperties</db:code></db:para>
</db:td>
<db:td><db:code>0x40</db:code></db:td>
<db:td>
<db:para>export this object's scriptable properties</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qdbusconnection.xml">QDBusConnection</db:link></db:emphasis>::ExportScriptableInvokables</db:code></db:para>
</db:td>
<db:td><db:code>0x80</db:code></db:td>
<db:td>
<db:para>export this object's scriptable invokables</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qdbusconnection.xml">QDBusConnection</db:link></db:emphasis>::ExportScriptableContents</db:code></db:para>
</db:td>
<db:td><db:code>0xf0</db:code></db:td>
<db:td>
<db:para>shorthand form for ExportScriptableSlots | ExportScriptableSignals | ExportScriptableProperties</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qdbusconnection.xml">QDBusConnection</db:link></db:emphasis>::ExportNonScriptableSlots</db:code></db:para>
</db:td>
<db:td><db:code>0x100</db:code></db:td>
<db:td>
<db:para>export this object's non-scriptable slots</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qdbusconnection.xml">QDBusConnection</db:link></db:emphasis>::ExportNonScriptableSignals</db:code></db:para>
</db:td>
<db:td><db:code>0x200</db:code></db:td>
<db:td>
<db:para>export this object's non-scriptable signals</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qdbusconnection.xml">QDBusConnection</db:link></db:emphasis>::ExportNonScriptableProperties</db:code></db:para>
</db:td>
<db:td><db:code>0x400</db:code></db:td>
<db:td>
<db:para>export this object's non-scriptable properties</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qdbusconnection.xml">QDBusConnection</db:link></db:emphasis>::ExportNonScriptableInvokables</db:code></db:para>
</db:td>
<db:td><db:code>0x800</db:code></db:td>
<db:td>
<db:para>export this object's non-scriptable invokables</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qdbusconnection.xml">QDBusConnection</db:link></db:emphasis>::ExportNonScriptableContents</db:code></db:para>
</db:td>
<db:td><db:code>0xf00</db:code></db:td>
<db:td>
<db:para>shorthand form for ExportNonScriptableSlots | ExportNonScriptableSignals | ExportNonScriptableProperties</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qdbusconnection.xml">QDBusConnection</db:link></db:emphasis>::ExportAllSlots</db:code></db:para>
</db:td>
<db:td><db:code>ExportScriptableSlots|ExportNonScriptableSlots</db:code></db:td>
<db:td>
<db:para>export all of this object's slots</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qdbusconnection.xml">QDBusConnection</db:link></db:emphasis>::ExportAllSignals</db:code></db:para>
</db:td>
<db:td><db:code>ExportScriptableSignals|ExportNonScriptableSignals</db:code></db:td>
<db:td>
<db:para>export all of this object's signals</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qdbusconnection.xml">QDBusConnection</db:link></db:emphasis>::ExportAllProperties</db:code></db:para>
</db:td>
<db:td><db:code>ExportScriptableProperties|ExportNonScriptableProperties</db:code></db:td>
<db:td>
<db:para>export all of this object's properties</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qdbusconnection.xml">QDBusConnection</db:link></db:emphasis>::ExportAllInvokables</db:code></db:para>
</db:td>
<db:td><db:code>ExportScriptableInvokables|ExportNonScriptableInvokables</db:code></db:td>
<db:td>
<db:para>export all of this object's invokables</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qdbusconnection.xml">QDBusConnection</db:link></db:emphasis>::ExportAllContents</db:code></db:para>
</db:td>
<db:td><db:code>ExportScriptableContents|ExportNonScriptableContents</db:code></db:td>
<db:td>
<db:para>export all of this object's contents</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qdbusconnection.xml">QDBusConnection</db:link></db:emphasis>::ExportChildObjects</db:code></db:para>
</db:td>
<db:td><db:code>0x1000</db:code></db:td>
<db:td>
<db:para>export this object's child objects</db:para>
</db:td>
</db:tr>
</db:informaltable>
<db:para>The <db:code>RegisterOptions</db:code> type is a typedef for <db:code><db:link xlink:href="qflags.xml">QFlags</db:link>&lt;RegisterOption&gt;. </db:code>It stores an OR combination of <db:code>RegisterOption</db:code> values.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qdbusconnection.xml#registerObject">registerObject</db:link>()</db:member>
<db:member><db:link xlink:href="qdbusabstractadaptor.xml">QDBusAbstractAdaptor</db:link></db:member>
<db:member><db:link xlink:href="usingadaptors.xml">Using adaptors</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="UnregisterMode-enum">
<db:title>enum QDBusConnection::UnregisterMode</db:title>
<db:enumsynopsis>
<db:enumname>UnregisterMode</db:enumname>
<db:enumitem>
<db:enumidentifier>UnregisterNode</db:enumidentifier>
<db:enumvalue>0</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>UnregisterTree</db:enumidentifier>
<db:enumvalue>1</db:enumvalue>
</db:enumitem>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:enumsynopsis>
<db:para>The mode for unregistering an object path:</db:para>
<db:informaltable>
<db:thead>
<db:tr>
<db:th>Constant</db:th>
<db:th>Value</db:th>
<db:th>Description</db:th>
</db:tr>
</db:thead>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qdbusconnection.xml">QDBusConnection</db:link></db:emphasis>::UnregisterNode</db:code></db:para>
</db:td>
<db:td><db:code>0</db:code></db:td>
<db:td>
<db:para>unregister this node only: do not unregister child objects</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qdbusconnection.xml">QDBusConnection</db:link></db:emphasis>::UnregisterTree</db:code></db:para>
</db:td>
<db:td><db:code>1</db:code></db:td>
<db:td>
<db:para>unregister this node and all its sub-tree</db:para>
</db:td>
</db:tr>
</db:informaltable>
<db:para>Note, however, if this object was registered with the <db:link xlink:href="qdbusconnection.xml#RegisterOption-enum">ExportChildObjects</db:link> option, UnregisterNode will unregister the child objects too.</db:para>
</db:section>
</db:section>
<db:section xml:id="member-function-documentation">
<db:title>Member Function Documentation</db:title>
<db:section xml:id="QDBusConnection">
<db:title>[explicit] QDBusConnection::QDBusConnection(const QString &amp;<db:emphasis>name</db:emphasis>)</db:title>
<db:constructorsynopsis>
<db:methodname>QDBusConnection</db:methodname>
<db:methodparam>
<db:type>const QString &amp;</db:type>
<db:parameter>name</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">constructor</db:synopsisinfo>
<db:synopsisinfo role="signature">QDBusConnection(const QString &amp;name)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:constructorsynopsis>
<db:para>Creates a <db:link xlink:href="qdbusconnection.xml">QDBusConnection</db:link> object attached to the connection with name <db:code role="parameter">name</db:code>.</db:para>
<db:para>This does not open the connection. You have to call <db:link xlink:href="qdbusconnection.xml#connectToBus">connectToBus</db:link>() to open it.</db:para>
</db:section>
<db:section xml:id="QDBusConnection-1">
<db:title>QDBusConnection::QDBusConnection(const QDBusConnection &amp;<db:emphasis>other</db:emphasis>)</db:title>
<db:constructorsynopsis>
<db:methodname>QDBusConnection</db:methodname>
<db:methodparam>
<db:type>const QDBusConnection &amp;</db:type>
<db:parameter>other</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">copy-constructor</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">QDBusConnection(const QDBusConnection &amp;other)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:constructorsynopsis>
<db:para>Creates a copy of the <db:code role="parameter">other</db:code> connection.</db:para>
</db:section>
<db:section xml:id="dtor.QDBusConnection">
<db:title>QDBusConnection::~QDBusConnection()</db:title>
<db:destructorsynopsis>
<db:methodname>~QDBusConnection</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">destructor</db:synopsisinfo>
<db:synopsisinfo role="signature">~QDBusConnection()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:destructorsynopsis>
<db:para>Disposes of this object. This does not close the connection: you have to call <db:link xlink:href="qdbusconnection.xml#disconnectFromBus">disconnectFromBus</db:link>() to do that.</db:para>
</db:section>
<db:section xml:id="asyncCall">
<db:title>QDBusPendingCall QDBusConnection::asyncCall(const QDBusMessage &amp;<db:emphasis>message</db:emphasis>, int <db:emphasis>timeout</db:emphasis> = -1) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QDBusPendingCall</db:type>
<db:methodname>asyncCall</db:methodname>
<db:methodparam>
<db:type>const QDBusMessage &amp;</db:type>
<db:parameter>message</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>timeout</db:parameter>
<db:initializer>-1</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QDBusPendingCall asyncCall(const QDBusMessage &amp;message, int timeout) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Sends the <db:code role="parameter">message</db:code> over this connection and returns immediately. This function is suitable for method calls only. It returns an object of type <db:link xlink:href="qdbuspendingcall.xml">QDBusPendingCall</db:link> which can be used to track the status of the reply.</db:para>
<db:para>If no reply is received within <db:code role="parameter">timeout</db:code> milliseconds, an automatic error will be delivered indicating the expiration of the call. The default <db:code role="parameter">timeout</db:code> is -1, which will be replaced with an implementation-defined value that is suitable for inter-process communications (generally, 25 seconds). This timeout is also the upper limit for waiting in QDBusPendingCall::waitForFinished().</db:para>
<db:para>See the <db:link xlink:href="qdbusabstractinterface.xml#asyncCall-1">QDBusInterface::asyncCall</db:link>() function for a more friendly way of placing calls.</db:para>
<db:note>
<db:para>Method calls to objects registered by the application itself are never asynchronous due to implementation limitations.</db:para>
</db:note>
</db:section>
<db:section xml:id="baseService">
<db:title>QString QDBusConnection::baseService() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QString</db:type>
<db:methodname>baseService</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QString baseService() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the unique connection name for this connection, if this <db:link xlink:href="qdbusconnection.xml">QDBusConnection</db:link> object is connected, or an empty <db:link xlink:href="qstring.xml">QString</db:link> otherwise.</db:para>
<db:para>A Unique Connection Name is a string in the form &quot;:x.xxx&quot; (where x are decimal digits) that is assigned by the D-Bus server daemon upon connection. It uniquely identifies this client in the bus.</db:para>
<db:para>This function returns an empty <db:link xlink:href="qstring.xml">QString</db:link> for peer-to-peer connections.</db:para>
</db:section>
<db:section xml:id="call">
<db:title>QDBusMessage QDBusConnection::call(const QDBusMessage &amp;<db:emphasis>message</db:emphasis>, QDBus::CallMode <db:emphasis>mode</db:emphasis> = QDBus::Block, int <db:emphasis>timeout</db:emphasis> = -1) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QDBusMessage</db:type>
<db:methodname>call</db:methodname>
<db:methodparam>
<db:type>const QDBusMessage &amp;</db:type>
<db:parameter>message</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>QDBus::CallMode</db:type>
<db:parameter>mode</db:parameter>
<db:initializer>QDBus::Block</db:initializer>
</db:methodparam>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>timeout</db:parameter>
<db:initializer>-1</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QDBusMessage call(const QDBusMessage &amp;message, QDBus::CallMode mode, int timeout) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Sends the <db:code role="parameter">message</db:code> over this connection and blocks, waiting for a reply, for at most <db:code role="parameter">timeout</db:code> milliseconds. This function is suitable for method calls only. It returns the reply message as its return value, which will be either of type <db:link xlink:href="qdbusmessage.xml#MessageType-enum">QDBusMessage::ReplyMessage</db:link> or <db:link xlink:href="qdbusmessage.xml#MessageType-enum">QDBusMessage::ErrorMessage</db:link>.</db:para>
<db:para>If no reply is received within <db:code role="parameter">timeout</db:code> milliseconds, an automatic error will be delivered indicating the expiration of the call. The default <db:code role="parameter">timeout</db:code> is -1, which will be replaced with an implementation-defined value that is suitable for inter-process communications (generally, 25 seconds).</db:para>
<db:para>See the <db:link xlink:href="qdbusabstractinterface.xml#call-1">QDBusInterface::call</db:link>() function for a more friendly way of placing calls.</db:para>
<db:warning>
<db:para>If <db:code role="parameter">mode</db:code> is <db:link xlink:href="qdbus.xml#CallMode-enum">QDBus::BlockWithGui</db:link>, this function will reenter the Qt event loop in order to wait for the reply. During the wait, it may deliver signals and other method calls to your application. Therefore, it must be prepared to handle a reentrancy whenever a call is placed with call().</db:para>
</db:warning>
</db:section>
<db:section xml:id="callWithCallback">
<db:title>bool QDBusConnection::callWithCallback(const QDBusMessage &amp;<db:emphasis>message</db:emphasis>, QObject *<db:emphasis>receiver</db:emphasis>, const char *<db:emphasis>returnMethod</db:emphasis>, const char *<db:emphasis>errorMethod</db:emphasis>, int <db:emphasis>timeout</db:emphasis> = -1) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>bool</db:type>
<db:methodname>callWithCallback</db:methodname>
<db:methodparam>
<db:type>const QDBusMessage &amp;</db:type>
<db:parameter>message</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>QObject *</db:type>
<db:parameter>receiver</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const char *</db:type>
<db:parameter>returnMethod</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const char *</db:type>
<db:parameter>errorMethod</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>timeout</db:parameter>
<db:initializer>-1</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool callWithCallback(const QDBusMessage &amp;message, QObject *receiver, const char *returnMethod, const char *errorMethod, int timeout) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Sends the <db:code role="parameter">message</db:code> over this connection and returns immediately. When the reply is received, the method <db:code role="parameter">returnMethod</db:code> is called in the <db:code role="parameter">receiver</db:code> object. If an error occurs, the method <db:code role="parameter">errorMethod</db:code> will be called instead.</db:para>
<db:para>If no reply is received within <db:code role="parameter">timeout</db:code> milliseconds, an automatic error will be delivered indicating the expiration of the call. The default <db:code role="parameter">timeout</db:code> is -1, which will be replaced with an implementation-defined value that is suitable for inter-process communications (generally, 25 seconds).</db:para>
<db:para>This function is suitable for method calls only. It is guaranteed that the slot will be called exactly once with the reply, as long as the parameter types match and no error occurs.</db:para>
<db:para>Returns <db:code>true</db:code> if the message was sent, or false if the message could not be sent.</db:para>
</db:section>
<db:section xml:id="connect">
<db:title>bool QDBusConnection::connect(const QString &amp;<db:emphasis>service</db:emphasis>, const QString &amp;<db:emphasis>path</db:emphasis>, const QString &amp;<db:emphasis>interface</db:emphasis>, const QString &amp;<db:emphasis>name</db:emphasis>, QObject *<db:emphasis>receiver</db:emphasis>, const char *<db:emphasis>slot</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>bool</db:type>
<db:methodname>connect</db:methodname>
<db:methodparam>
<db:type>const QString &amp;</db:type>
<db:parameter>service</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const QString &amp;</db:type>
<db:parameter>path</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const QString &amp;</db:type>
<db:parameter>interface</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const QString &amp;</db:type>
<db:parameter>name</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>QObject *</db:type>
<db:parameter>receiver</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const char *</db:type>
<db:parameter>slot</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool connect(const QString &amp;service, const QString &amp;path, const QString &amp;interface, const QString &amp;name, QObject *receiver, const char *slot)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Connects the signal specified by the <db:code role="parameter">service</db:code>, <db:code role="parameter">path</db:code>, <db:code role="parameter">interface</db:code> and <db:code role="parameter">name</db:code> parameters to the slot <db:code role="parameter">slot</db:code> in object <db:code role="parameter">receiver</db:code>. The arguments <db:code role="parameter">service</db:code> and <db:code role="parameter">path</db:code> can be empty, denoting a connection to any signal of the (<db:code role="parameter">interface</db:code>, <db:code role="parameter">name</db:code>) pair, from any remote application.</db:para>
<db:para>Returns <db:code>true</db:code> if the connection was successful.</db:para>
<db:warning>
<db:para>The signal will only be delivered to the slot if the parameters match. This verification can be done only when the signal is received, not at connection time.</db:para>
</db:warning>
</db:section>
<db:section xml:id="connect-1">
<db:title>bool QDBusConnection::connect(const QString &amp;<db:emphasis>service</db:emphasis>, const QString &amp;<db:emphasis>path</db:emphasis>, const QString &amp;<db:emphasis>interface</db:emphasis>, const QString &amp;<db:emphasis>name</db:emphasis>, const QString &amp;<db:emphasis>signature</db:emphasis>, QObject *<db:emphasis>receiver</db:emphasis>, const char *<db:emphasis>slot</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>bool</db:type>
<db:methodname>connect</db:methodname>
<db:methodparam>
<db:type>const QString &amp;</db:type>
<db:parameter>service</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const QString &amp;</db:type>
<db:parameter>path</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const QString &amp;</db:type>
<db:parameter>interface</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const QString &amp;</db:type>
<db:parameter>name</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const QString &amp;</db:type>
<db:parameter>signature</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>QObject *</db:type>
<db:parameter>receiver</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const char *</db:type>
<db:parameter>slot</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">bool connect(const QString &amp;service, const QString &amp;path, const QString &amp;interface, const QString &amp;name, const QString &amp;signature, QObject *receiver, const char *slot)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>Connects the signal to the slot <db:code role="parameter">slot</db:code> in object <db:code role="parameter">receiver</db:code>. Unlike the previous <db:link xlink:href="qdbusconnection.xml#connect">connect</db:link>() overload, this function allows one to specify the parameter signature to be connected using the <db:code role="parameter">signature</db:code> variable. The function will then verify that this signature can be delivered to the slot specified by <db:code role="parameter">slot</db:code> and return false otherwise.</db:para>
<db:para>Returns <db:code>true</db:code> if the connection was successful.</db:para>
<db:note>
<db:para>This function verifies that the signal signature matches the slot's parameters, but it does not verify that the actual signal exists with the given signature in the remote service.</db:para>
</db:note>
</db:section>
<db:section xml:id="connect-2">
<db:title>bool QDBusConnection::connect(const QString &amp;<db:emphasis>service</db:emphasis>, const QString &amp;<db:emphasis>path</db:emphasis>, const QString &amp;<db:emphasis>interface</db:emphasis>, const QString &amp;<db:emphasis>name</db:emphasis>, const QStringList &amp;<db:emphasis>argumentMatch</db:emphasis>, const QString &amp;<db:emphasis>signature</db:emphasis>, QObject *<db:emphasis>receiver</db:emphasis>, const char *<db:emphasis>slot</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>bool</db:type>
<db:methodname>connect</db:methodname>
<db:methodparam>
<db:type>const QString &amp;</db:type>
<db:parameter>service</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const QString &amp;</db:type>
<db:parameter>path</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const QString &amp;</db:type>
<db:parameter>interface</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const QString &amp;</db:type>
<db:parameter>name</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const QStringList &amp;</db:type>
<db:parameter>argumentMatch</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const QString &amp;</db:type>
<db:parameter>signature</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>QObject *</db:type>
<db:parameter>receiver</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const char *</db:type>
<db:parameter>slot</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">2</db:synopsisinfo>
<db:synopsisinfo role="signature">bool connect(const QString &amp;service, const QString &amp;path, const QString &amp;interface, const QString &amp;name, const QStringList &amp;argumentMatch, const QString &amp;signature, QObject *receiver, const char *slot)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>Connects the signal to the slot <db:code role="parameter">slot</db:code> in object <db:code role="parameter">receiver</db:code>. Unlike the previous <db:link xlink:href="qdbusconnection.xml#connect">connect</db:link>() overload, this function allows one to specify the parameter signature to be connected using the <db:code role="parameter">signature</db:code> variable. The function will then verify that this signature can be delivered to the slot specified by <db:code role="parameter">slot</db:code> and return false otherwise.</db:para>
<db:para>The <db:code role="parameter">argumentMatch</db:code> parameter lists the string parameters to be matched, in sequential order. Note that, to match an empty string, you need to pass a <db:link xlink:href="qstring.xml">QString</db:link> that is empty but not null (i.e., <db:link xlink:href="qstring.xml">QString</db:link>(&quot;&quot;)). A null <db:link xlink:href="qstring.xml">QString</db:link> skips matching at that position.</db:para>
<db:para>Returns <db:code>true</db:code> if the connection was successful.</db:para>
<db:note>
<db:para>This function verifies that the signal signature matches the slot's parameters, but it does not verify that the actual signal exists with the given signature in the remote service.</db:para>
</db:note>
</db:section>
<db:section xml:id="connectToBus">
<db:title>[static] QDBusConnection QDBusConnection::connectToBus(QDBusConnection::BusType <db:emphasis>type</db:emphasis>, const QString &amp;<db:emphasis>name</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:modifier>static</db:modifier>
<db:type>QDBusConnection</db:type>
<db:methodname>connectToBus</db:methodname>
<db:methodparam>
<db:type>QDBusConnection::BusType</db:type>
<db:parameter>type</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const QString &amp;</db:type>
<db:parameter>name</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QDBusConnection connectToBus(QDBusConnection::BusType type, const QString &amp;name)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Opens a connection of type <db:code role="parameter">type</db:code> to one of the known buses and associate with it the connection name <db:code role="parameter">name</db:code>. Returns a <db:link xlink:href="qdbusconnection.xml">QDBusConnection</db:link> object associated with that connection.</db:para>
</db:section>
<db:section xml:id="connectToBus-1">
<db:title>[static] QDBusConnection QDBusConnection::connectToBus(const QString &amp;<db:emphasis>address</db:emphasis>, const QString &amp;<db:emphasis>name</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:modifier>static</db:modifier>
<db:type>QDBusConnection</db:type>
<db:methodname>connectToBus</db:methodname>
<db:methodparam>
<db:type>const QString &amp;</db:type>
<db:parameter>address</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const QString &amp;</db:type>
<db:parameter>name</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">QDBusConnection connectToBus(const QString &amp;address, const QString &amp;name)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Opens a connection to a private bus on address <db:code role="parameter">address</db:code> and associate with it the connection name <db:code role="parameter">name</db:code>. Returns a <db:link xlink:href="qdbusconnection.xml">QDBusConnection</db:link> object associated with that connection.</db:para>
</db:section>
<db:section xml:id="connectToPeer">
<db:title>[static] QDBusConnection QDBusConnection::connectToPeer(const QString &amp;<db:emphasis>address</db:emphasis>, const QString &amp;<db:emphasis>name</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:modifier>static</db:modifier>
<db:type>QDBusConnection</db:type>
<db:methodname>connectToPeer</db:methodname>
<db:methodparam>
<db:type>const QString &amp;</db:type>
<db:parameter>address</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const QString &amp;</db:type>
<db:parameter>name</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QDBusConnection connectToPeer(const QString &amp;address, const QString &amp;name)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Opens a peer-to-peer connection on address <db:code role="parameter">address</db:code> and associate with it the connection name <db:code role="parameter">name</db:code>. Returns a <db:link xlink:href="qdbusconnection.xml">QDBusConnection</db:link> object associated with that connection.</db:para>
</db:section>
<db:section xml:id="connectionCapabilities">
<db:title>QDBusConnection::ConnectionCapabilities QDBusConnection::connectionCapabilities() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QDBusConnection::ConnectionCapabilities</db:type>
<db:methodname>connectionCapabilities</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QDBusConnection::ConnectionCapabilities connectionCapabilities() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the capabilities of this connection as negotiated with the bus server or peer. If this <db:link xlink:href="qdbusconnection.xml">QDBusConnection</db:link> is not connected, this function returns no capabilities.</db:para>
</db:section>
<db:section xml:id="disconnect">
<db:title>bool QDBusConnection::disconnect(const QString &amp;<db:emphasis>service</db:emphasis>, const QString &amp;<db:emphasis>path</db:emphasis>, const QString &amp;<db:emphasis>interface</db:emphasis>, const QString &amp;<db:emphasis>name</db:emphasis>, QObject *<db:emphasis>receiver</db:emphasis>, const char *<db:emphasis>slot</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>bool</db:type>
<db:methodname>disconnect</db:methodname>
<db:methodparam>
<db:type>const QString &amp;</db:type>
<db:parameter>service</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const QString &amp;</db:type>
<db:parameter>path</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const QString &amp;</db:type>
<db:parameter>interface</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const QString &amp;</db:type>
<db:parameter>name</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>QObject *</db:type>
<db:parameter>receiver</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const char *</db:type>
<db:parameter>slot</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool disconnect(const QString &amp;service, const QString &amp;path, const QString &amp;interface, const QString &amp;name, QObject *receiver, const char *slot)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Disconnects the signal specified by the <db:code role="parameter">service</db:code>, <db:code role="parameter">path</db:code>, <db:code role="parameter">interface</db:code> and <db:code role="parameter">name</db:code> parameters from the slot <db:code role="parameter">slot</db:code> in object <db:code role="parameter">receiver</db:code>. The arguments must be the same as passed to the <db:link xlink:href="qdbusconnection.xml#connect">connect</db:link>() function.</db:para>
<db:para>Returns <db:code>true</db:code> if the disconnection was successful.</db:para>
</db:section>
<db:section xml:id="disconnect-1">
<db:title>bool QDBusConnection::disconnect(const QString &amp;<db:emphasis>service</db:emphasis>, const QString &amp;<db:emphasis>path</db:emphasis>, const QString &amp;<db:emphasis>interface</db:emphasis>, const QString &amp;<db:emphasis>name</db:emphasis>, const QString &amp;<db:emphasis>signature</db:emphasis>, QObject *<db:emphasis>receiver</db:emphasis>, const char *<db:emphasis>slot</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>bool</db:type>
<db:methodname>disconnect</db:methodname>
<db:methodparam>
<db:type>const QString &amp;</db:type>
<db:parameter>service</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const QString &amp;</db:type>
<db:parameter>path</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const QString &amp;</db:type>
<db:parameter>interface</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const QString &amp;</db:type>
<db:parameter>name</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const QString &amp;</db:type>
<db:parameter>signature</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>QObject *</db:type>
<db:parameter>receiver</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const char *</db:type>
<db:parameter>slot</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">bool disconnect(const QString &amp;service, const QString &amp;path, const QString &amp;interface, const QString &amp;name, const QString &amp;signature, QObject *receiver, const char *slot)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>Disconnects the signal specified by the <db:code role="parameter">service</db:code>, <db:code role="parameter">path</db:code>, <db:code role="parameter">interface</db:code>, <db:code role="parameter">name</db:code>, and <db:code role="parameter">signature</db:code> parameters from the slot <db:code role="parameter">slot</db:code> in object <db:code role="parameter">receiver</db:code>. The arguments must be the same as passed to the <db:link xlink:href="qdbusconnection.xml#connect">connect</db:link>() function.</db:para>
<db:para>Returns <db:code>true</db:code> if the disconnection was successful.</db:para>
</db:section>
<db:section xml:id="disconnect-2">
<db:title>bool QDBusConnection::disconnect(const QString &amp;<db:emphasis>service</db:emphasis>, const QString &amp;<db:emphasis>path</db:emphasis>, const QString &amp;<db:emphasis>interface</db:emphasis>, const QString &amp;<db:emphasis>name</db:emphasis>, const QStringList &amp;<db:emphasis>argumentMatch</db:emphasis>, const QString &amp;<db:emphasis>signature</db:emphasis>, QObject *<db:emphasis>receiver</db:emphasis>, const char *<db:emphasis>slot</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>bool</db:type>
<db:methodname>disconnect</db:methodname>
<db:methodparam>
<db:type>const QString &amp;</db:type>
<db:parameter>service</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const QString &amp;</db:type>
<db:parameter>path</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const QString &amp;</db:type>
<db:parameter>interface</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const QString &amp;</db:type>
<db:parameter>name</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const QStringList &amp;</db:type>
<db:parameter>argumentMatch</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const QString &amp;</db:type>
<db:parameter>signature</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>QObject *</db:type>
<db:parameter>receiver</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const char *</db:type>
<db:parameter>slot</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">2</db:synopsisinfo>
<db:synopsisinfo role="signature">bool disconnect(const QString &amp;service, const QString &amp;path, const QString &amp;interface, const QString &amp;name, const QStringList &amp;argumentMatch, const QString &amp;signature, QObject *receiver, const char *slot)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>Disconnects the signal specified by the <db:code role="parameter">service</db:code>, <db:code role="parameter">path</db:code>, <db:code role="parameter">interface</db:code>, <db:code role="parameter">name</db:code>, <db:code role="parameter">argumentMatch</db:code>, and <db:code role="parameter">signature</db:code> parameters from the slot <db:code role="parameter">slot</db:code> in object <db:code role="parameter">receiver</db:code>. The arguments must be the same as passed to the <db:link xlink:href="qdbusconnection.xml#connect">connect</db:link>() function.</db:para>
<db:para>Returns <db:code>true</db:code> if the disconnection was successful.</db:para>
</db:section>
<db:section xml:id="disconnectFromBus">
<db:title>[static] void QDBusConnection::disconnectFromBus(const QString &amp;<db:emphasis>name</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:modifier>static</db:modifier>
<db:void/>
<db:methodname>disconnectFromBus</db:methodname>
<db:methodparam>
<db:type>const QString &amp;</db:type>
<db:parameter>name</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void disconnectFromBus(const QString &amp;name)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Closes the bus connection of name <db:code role="parameter">name</db:code>.</db:para>
<db:para>Note that if there are still <db:link xlink:href="qdbusconnection.xml">QDBusConnection</db:link> objects associated with the same connection, the connection will not be closed until all references are dropped. However, no further references can be created using the <db:link xlink:href="qdbusconnection.xml">QDBusConnection</db:link> constructor.</db:para>
</db:section>
<db:section xml:id="disconnectFromPeer">
<db:title>[static] void QDBusConnection::disconnectFromPeer(const QString &amp;<db:emphasis>name</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:modifier>static</db:modifier>
<db:void/>
<db:methodname>disconnectFromPeer</db:methodname>
<db:methodparam>
<db:type>const QString &amp;</db:type>
<db:parameter>name</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void disconnectFromPeer(const QString &amp;name)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Closes the peer connection of name <db:code role="parameter">name</db:code>.</db:para>
<db:para>Note that if there are still <db:link xlink:href="qdbusconnection.xml">QDBusConnection</db:link> objects associated with the same connection, the connection will not be closed until all references are dropped. However, no further references can be created using the <db:link xlink:href="qdbusconnection.xml">QDBusConnection</db:link> constructor.</db:para>
</db:section>
<db:section xml:id="interface">
<db:title>QDBusConnectionInterface *QDBusConnection::interface() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QDBusConnectionInterface *</db:type>
<db:methodname>interface</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QDBusConnectionInterface * interface() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns a <db:link xlink:href="qdbusconnectioninterface.xml">QDBusConnectionInterface</db:link> object that represents the D-Bus server interface on this connection.</db:para>
</db:section>
<db:section xml:id="isConnected">
<db:title>bool QDBusConnection::isConnected() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>bool</db:type>
<db:methodname>isConnected</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool isConnected() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns <db:code>true</db:code> if this <db:link xlink:href="qdbusconnection.xml">QDBusConnection</db:link> object is connected.</db:para>
</db:section>
<db:section xml:id="lastError">
<db:title>QDBusError QDBusConnection::lastError() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QDBusError</db:type>
<db:methodname>lastError</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QDBusError lastError() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the last error that happened in this connection.</db:para>
<db:para>This function is provided for low-level code. If you're using <db:link xlink:href="qdbusabstractinterface.xml#call-1">QDBusInterface::call</db:link>(), error codes are reported by its return value.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qdbusinterface.xml">QDBusInterface</db:link></db:member>
<db:member><db:link xlink:href="qdbusmessage.xml">QDBusMessage</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="localMachineId">
<db:title>[static] QByteArray QDBusConnection::localMachineId()</db:title>
<db:methodsynopsis>
<db:modifier>static</db:modifier>
<db:type>QByteArray</db:type>
<db:methodname>localMachineId</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QByteArray localMachineId()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the local machine ID as known to the D-Bus system. Each node or host that runs D-Bus has a unique identifier that can be used to distinguish it from other hosts if they are sharing resources like the filesystem.</db:para>
<db:para>Note that the local machine ID is not guaranteed to be persistent across boots of the system, so this identifier should not be stored in persistent storage (like the filesystem). It is guaranteed to remain constant only during the lifetime of this boot session.</db:para>
</db:section>
<db:section xml:id="name">
<db:title>QString QDBusConnection::name() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QString</db:type>
<db:methodname>name</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QString name() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the connection name for this connection, as given as the name parameter to <db:link xlink:href="qdbusconnection.xml#connectToBus">connectToBus</db:link>().</db:para>
<db:para>The connection name can be used to uniquely identify actual underlying connections to buses. Copies made from a single connection will always implicitly share the underlying connection, and hence will have the same connection name.</db:para>
<db:para>Inversely, two connections having different connection names will always either be connected to different buses, or have a different unique name (as returned by <db:link xlink:href="qdbusconnection.xml#baseService">baseService</db:link>()) on that bus.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qdbusconnection.xml#connectToBus">connectToBus</db:link>()</db:member>
<db:member><db:link xlink:href="qdbusconnection.xml#disconnectFromBus">disconnectFromBus</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="objectRegisteredAt">
<db:title>QObject *QDBusConnection::objectRegisteredAt(const QString &amp;<db:emphasis>path</db:emphasis>) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QObject *</db:type>
<db:methodname>objectRegisteredAt</db:methodname>
<db:methodparam>
<db:type>const QString &amp;</db:type>
<db:parameter>path</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QObject * objectRegisteredAt(const QString &amp;path) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Return the object that was registered with the <db:link xlink:href="qdbusconnection.xml#registerObject">registerObject</db:link>() at the object path given by <db:code role="parameter">path</db:code>.</db:para>
</db:section>
<db:section xml:id="registerObject">
<db:title>bool QDBusConnection::registerObject(const QString &amp;<db:emphasis>path</db:emphasis>, QObject *<db:emphasis>object</db:emphasis>, QDBusConnection::RegisterOptions <db:emphasis>options</db:emphasis> = ExportAdaptors)</db:title>
<db:methodsynopsis>
<db:type>bool</db:type>
<db:methodname>registerObject</db:methodname>
<db:methodparam>
<db:type>const QString &amp;</db:type>
<db:parameter>path</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>QObject *</db:type>
<db:parameter>object</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>QDBusConnection::RegisterOptions</db:type>
<db:parameter>options</db:parameter>
<db:initializer>ExportAdaptors</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool registerObject(const QString &amp;path, QObject *object, QDBusConnection::RegisterOptions options)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Registers the object <db:code role="parameter">object</db:code> at path <db:code role="parameter">path</db:code> and returns <db:code>true</db:code> if the registration was successful. The <db:code role="parameter">options</db:code> parameter specifies how much of the object <db:code role="parameter">object</db:code> will be exposed through D-Bus.</db:para>
<db:para>This function does not replace existing objects: if there is already an object registered at path <db:code role="parameter">path</db:code>, this function will return false. Use <db:link xlink:href="qdbusconnection.xml#unregisterObject">unregisterObject</db:link>() to unregister it first.</db:para>
<db:para>The <db:link xlink:href="qdbusconnection.xml#RegisterOption-enum">ExportChildObjects</db:link> flag exports child objects on D-Bus based on the path of the registered objects and the <db:link xlink:href="qobject.xml#objectName-prop">QObject::objectName</db:link> of the child. Therefore, it is important for the child object to have an object name.</db:para>
<db:para>You cannot register an object as a child object of an object that was registered with <db:link xlink:href="qdbusconnection.xml#RegisterOption-enum">ExportChildObjects</db:link>.</db:para>
</db:section>
<db:section xml:id="registerObject-1">
<db:title>bool QDBusConnection::registerObject(const QString &amp;<db:emphasis>path</db:emphasis>, const QString &amp;<db:emphasis>interface</db:emphasis>, QObject *<db:emphasis>object</db:emphasis>, QDBusConnection::RegisterOptions <db:emphasis>options</db:emphasis> = ExportAdaptors)</db:title>
<db:methodsynopsis>
<db:type>bool</db:type>
<db:methodname>registerObject</db:methodname>
<db:methodparam>
<db:type>const QString &amp;</db:type>
<db:parameter>path</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const QString &amp;</db:type>
<db:parameter>interface</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>QObject *</db:type>
<db:parameter>object</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>QDBusConnection::RegisterOptions</db:type>
<db:parameter>options</db:parameter>
<db:initializer>ExportAdaptors</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">bool registerObject(const QString &amp;path, const QString &amp;interface, QObject *object, QDBusConnection::RegisterOptions options)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>Registers the object <db:code role="parameter">object</db:code> at path <db:code role="parameter">path</db:code> with interface name <db:code role="parameter">interface</db:code> and returns <db:code>true</db:code> if the registration was successful. The <db:code role="parameter">options</db:code> parameter specifies how much of the object <db:code role="parameter">object</db:code> will be exposed through D-Bus.</db:para>
<db:para>This function does not replace existing objects: if there is already an object registered at path <db:code role="parameter">path</db:code>, this function will return false. Use <db:link xlink:href="qdbusconnection.xml#unregisterObject">unregisterObject</db:link>() to unregister it first.</db:para>
<db:para>The <db:link xlink:href="qdbusconnection.xml#RegisterOption-enum">ExportChildObjects</db:link> flag exports child objects on D-Bus based on the path of the registered objects and the <db:link xlink:href="qobject.xml#objectName-prop">QObject::objectName</db:link> of the child. Therefore, it is important for the child object to have an object name.</db:para>
<db:para>You cannot register an object as a child object of an object that was registered with <db:link xlink:href="qdbusconnection.xml#RegisterOption-enum">ExportChildObjects</db:link>.</db:para>
</db:section>
<db:section xml:id="registerService">
<db:title>bool QDBusConnection::registerService(const QString &amp;<db:emphasis>serviceName</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>bool</db:type>
<db:methodname>registerService</db:methodname>
<db:methodparam>
<db:type>const QString &amp;</db:type>
<db:parameter>serviceName</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool registerService(const QString &amp;serviceName)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Attempts to register the <db:code role="parameter">serviceName</db:code> on the D-Bus server and returns <db:code>true</db:code> if the registration succeeded. The registration will fail if the name is already registered by another application.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qdbusconnection.xml#unregisterService">unregisterService</db:link>()</db:member>
<db:member><db:link xlink:href="qdbusconnectioninterface.xml#registerService">QDBusConnectionInterface::registerService</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="send">
<db:title>bool QDBusConnection::send(const QDBusMessage &amp;<db:emphasis>message</db:emphasis>) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>bool</db:type>
<db:methodname>send</db:methodname>
<db:methodparam>
<db:type>const QDBusMessage &amp;</db:type>
<db:parameter>message</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool send(const QDBusMessage &amp;message) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Sends the <db:code role="parameter">message</db:code> over this connection, without waiting for a reply. This is suitable for errors, signals, and return values as well as calls whose return values are not necessary.</db:para>
<db:para>Returns <db:code>true</db:code> if the message was queued successfully, false otherwise.</db:para>
</db:section>
<db:section xml:id="sessionBus">
<db:title>[static] QDBusConnection QDBusConnection::sessionBus()</db:title>
<db:methodsynopsis>
<db:modifier>static</db:modifier>
<db:type>QDBusConnection</db:type>
<db:methodname>sessionBus</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QDBusConnection sessionBus()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns a <db:link xlink:href="qdbusconnection.xml">QDBusConnection</db:link> object opened with the session bus. The object reference returned by this function is valid until the application terminates, at which point the connection will be closed and the object deleted.</db:para>
</db:section>
<db:section xml:id="swap">
<db:title>void QDBusConnection::swap(QDBusConnection &amp;<db:emphasis>other</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>swap</db:methodname>
<db:methodparam>
<db:type>QDBusConnection &amp;</db:type>
<db:parameter>other</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void swap(QDBusConnection &amp;other)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Swaps this <db:link xlink:href="qdbusconnection.xml">QDBusConnection</db:link> instance with <db:code role="parameter">other</db:code>.</db:para>
</db:section>
<db:section xml:id="systemBus">
<db:title>[static] QDBusConnection QDBusConnection::systemBus()</db:title>
<db:methodsynopsis>
<db:modifier>static</db:modifier>
<db:type>QDBusConnection</db:type>
<db:methodname>systemBus</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QDBusConnection systemBus()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns a <db:link xlink:href="qdbusconnection.xml">QDBusConnection</db:link> object opened with the system bus. The object reference returned by this function is valid until the <db:link xlink:href="qcoreapplication.xml">QCoreApplication</db:link>'s destructor is run, when the connection will be closed and the object, deleted.</db:para>
</db:section>
<db:section xml:id="unregisterObject">
<db:title>void QDBusConnection::unregisterObject(const QString &amp;<db:emphasis>path</db:emphasis>, QDBusConnection::UnregisterMode <db:emphasis>mode</db:emphasis> = UnregisterNode)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>unregisterObject</db:methodname>
<db:methodparam>
<db:type>const QString &amp;</db:type>
<db:parameter>path</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>QDBusConnection::UnregisterMode</db:type>
<db:parameter>mode</db:parameter>
<db:initializer>UnregisterNode</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void unregisterObject(const QString &amp;path, QDBusConnection::UnregisterMode mode)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Unregisters an object that was registered with the <db:link xlink:href="qdbusconnection.xml#registerObject">registerObject</db:link>() at the object path given by <db:code role="parameter">path</db:code> and, if <db:code role="parameter">mode</db:code> is <db:link xlink:href="qdbusconnection.xml#UnregisterMode-enum">QDBusConnection::UnregisterTree</db:link>, all of its sub-objects too.</db:para>
<db:para>Note that you cannot unregister objects that were not registered with <db:link xlink:href="qdbusconnection.xml#registerObject">registerObject</db:link>().</db:para>
</db:section>
<db:section xml:id="unregisterService">
<db:title>bool QDBusConnection::unregisterService(const QString &amp;<db:emphasis>serviceName</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>bool</db:type>
<db:methodname>unregisterService</db:methodname>
<db:methodparam>
<db:type>const QString &amp;</db:type>
<db:parameter>serviceName</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool unregisterService(const QString &amp;serviceName)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Unregisters the service <db:code role="parameter">serviceName</db:code> that was previously registered with <db:link xlink:href="qdbusconnection.xml#registerService">registerService</db:link>() and returns <db:code>true</db:code> if it succeeded.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qdbusconnection.xml#registerService">registerService</db:link>()</db:member>
<db:member><db:link xlink:href="qdbusconnectioninterface.xml#unregisterService">QDBusConnectionInterface::unregisterService</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="operator-eq-1">
<db:title>QDBusConnection &amp;QDBusConnection::operator=(const QDBusConnection &amp;<db:emphasis>other</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>QDBusConnection &amp;</db:type>
<db:methodname>operator=</db:methodname>
<db:methodparam>
<db:type>const QDBusConnection &amp;</db:type>
<db:parameter>other</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">copy-assign</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">QDBusConnection &amp; operator=(const QDBusConnection &amp;other)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Creates a copy of the connection <db:code role="parameter">other</db:code> in this object. Note that the connection this object referenced before the copy, is not spontaneously disconnected.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qdbusconnection.xml#disconnectFromBus">disconnectFromBus</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
</db:section>
<db:section xml:id="obsolete">
<db:title>Obsolete Members for QDBusConnection</db:title>
<db:para><db:emphasis role="bold">The following members of class <db:link xlink:href="qdbusconnection.xml">QDBusConnection</db:link> are deprecated.</db:emphasis> We strongly advise against using them in new code.</db:para>
<db:section xml:id="obsolete-member-function-documentation">
<db:title>Obsolete Member Function Documentation</db:title>
<db:section xml:id="callWithCallback-1">
<db:title>bool QDBusConnection::callWithCallback(const QDBusMessage &amp;<db:emphasis>message</db:emphasis>, QObject *<db:emphasis>receiver</db:emphasis>, const char *<db:emphasis>returnMethod</db:emphasis>, int <db:emphasis>timeout</db:emphasis> = -1) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>bool</db:type>
<db:methodname>callWithCallback</db:methodname>
<db:methodparam>
<db:type>const QDBusMessage &amp;</db:type>
<db:parameter>message</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>QObject *</db:type>
<db:parameter>receiver</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const char *</db:type>
<db:parameter>returnMethod</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>timeout</db:parameter>
<db:initializer>-1</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">bool callWithCallback(const QDBusMessage &amp;message, QObject *receiver, const char *returnMethod, int timeout) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">deprecated</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This function is deprecated. We strongly advise against using it in new code.</db:para>
<db:para>This is an overloaded function.</db:para>
<db:para>Sends the <db:code role="parameter">message</db:code> over this connection and returns immediately. When the reply is received, the method <db:code role="parameter">returnMethod</db:code> is called in the <db:code role="parameter">receiver</db:code> object.</db:para>
<db:para>This function is suitable for method calls only. It is guaranteed that the slot will be called exactly once with the reply, as long as the parameter types match and no error occurs.</db:para>
<db:para>This function is dangerous because it cannot report errors, including the expiration of the timeout.</db:para>
<db:para>Returns <db:code>true</db:code> if the message was sent, or false if the message could not be sent.</db:para>
</db:section>
</db:section>
</db:section>
</db:article>
