<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en">
<db:info>
<db:title>PinchHandler QML Type</db:title>
<db:productname>QtQuick</db:productname>
<db:edition>Qt 6.8.3 Reference Documentation</db:edition>
<db:titleabbrev>Qt Quick Reference Documentation</db:titleabbrev>
<db:abstract>
<db:para>Handler for pinch gestures.</db:para>
</db:abstract>
<db:pubdate>2025-06-29</db:pubdate>
<db:date>2025-06-29</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:variablelist>
<db:varlistentry>
<db:term>Import Statement</db:term>
<db:listitem>
<db:para>import QtQuick</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Inherits</db:term>
<db:listitem>
<db:para><db:link xlink:href="qml-qtquick-multipointhandler.xml">MultiPointHandler</db:link></db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Group</db:term>
<db:listitem>
<db:para>PinchHandler is part of <db:simplelist><db:member>qtquick-input-handlers</db:member></db:simplelist>
</db:para>
</db:listitem>
</db:varlistentry>
</db:variablelist>
<db:section xml:id="details">
<db:title>Detailed Description</db:title>
<db:para><db:link xlink:href="qml-qtquick-pinchhandler.xml">PinchHandler</db:link> is a handler that interprets a multi-finger gesture to interactively rotate, zoom, and drag an Item. Like other Input Handlers, by default it is fully functional, and manipulates its <db:link xlink:href="qt-add-ui.xml#target">target</db:link>, which is the Item within which it is declared.</db:para>
<db:programlisting language="qml">import QtQuick

Rectangle {
    width: 400
    height: 300
    color: &quot;lightsteelblue&quot;
    PinchHandler { }
}
</db:programlisting>
<db:para>It has properties to restrict the range of dragging, rotation, and zoom.</db:para>
<db:para>If it is declared within one Item but is assigned a different <db:link xlink:href="qt-add-ui.xml#target">target</db:link>, it handles events within the bounds of the outer Item but manipulates the <db:code>target</db:code> Item instead:</db:para>
<db:programlisting language="qml">import QtQuick

Item {
    width: 640
    height: 480

    Rectangle {
        id: map
        color: &quot;aqua&quot;
        width: 400
        height: 300
    }

    PinchHandler {
        target: map
    }
}
</db:programlisting>
<db:para>A third way to use it is to set <db:link xlink:href="qt-add-ui.xml#target">target</db:link> to <db:code>null</db:code> and react to property changes in some other way:</db:para>
<db:programlisting language="qml">import QtQuick

Window {
    width: 320; height: 240
    visible: true
    title: handler.persistentRotation.toFixed(1) + &quot;Â° &quot; +
           handler.persistentTranslation.x.toFixed(1) + &quot;, &quot; +
           handler.persistentTranslation.y.toFixed(1) + &quot; &quot; +
           (handler.persistentScale * 100).toFixed(1) + &quot;%&quot;

    PinchHandler {
        id: handler
        target: null
        persistentScale: 0.25
        onTranslationChanged: (delta) =&gt; {
            image.x -= delta.x
            image.y -= delta.y
        }
    }

    Image {
        id: image
        source: &quot;images/album-cover.jpg&quot;
        scale: handler.persistentScale
        x: -600; y: -450
    }
}
</db:programlisting>
<db:mediaobject>
<db:imageobject>
<db:imagedata fileref="images/touchpoints-pinchhandler.png"/>
</db:imageobject>
</db:mediaobject>
<db:note>
<db:para>The pinch begins when the number of fingers pressed is between <db:link xlink:href="qml-qtquick-multipointhandler.xml#minimumPointCount-prop">minimumPointCount</db:link> and <db:link xlink:href="qml-qtquick-multipointhandler.xml#maximumPointCount-prop">maximumPointCount</db:link>, inclusive. Until then, <db:link xlink:href="qml-qtquick-pinchhandler.xml">PinchHandler</db:link> tracks the positions of any pressed fingers, but if it's a disallowed number, it does not scale or rotate its <db:link xlink:href="qt-add-ui.xml#target">target</db:link>, and the <db:link xlink:href="qml-qtquick-pinchhandler.xml#active-prop">active</db:link> property remains <db:code>false</db:code>.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qml-qtquick-pincharea.xml">PinchArea</db:link></db:member>
<db:member><db:link xlink:href="qpointerevent.xml#pointCount">QPointerEvent::pointCount</db:link>()</db:member>
<db:member><db:link xlink:href="qnativegestureevent.xml#fingerCount">QNativeGestureEvent::fingerCount</db:link>()</db:member>
<db:member><db:link xlink:href="qtquick-pointerhandlers-example.xml">Qt Quick Examples - Pointer Handlers</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="property-documentation">
<db:title>Property Documentation</db:title>
<db:section xml:id="acceptedDevices-prop">
<db:title>acceptedDevices : flags</db:title>
<db:para>The types of pointing devices that can activate this Pointer Handler.</db:para>
<db:para>By default, this property is set to <db:link xlink:href="qinputdevice.xml#DeviceType-enum">PointerDevice.AllDevices</db:link>. If you set it to an OR combination of device types, it will ignore events from non-matching devices.</db:para>
<db:para>For example, a control could be made to respond to mouse and stylus clicks in one way, and touchscreen taps in another way, with two handlers:</db:para>
<db:programlisting language="qml">Item {
   TapHandler {
       acceptedDevices: PointerDevice.Mouse | PointerDevice.TouchPad | PointerDevice.Stylus
       onTapped: console.log(&quot;clicked&quot;)
   }
   TapHandler {
       acceptedDevices: PointerDevice.TouchScreen
       onTapped: console.log(&quot;tapped&quot;)
   }
}
</db:programlisting>
<db:note>
<db:para>Not all platforms are yet able to distinguish mouse and touchpad; and on those that do, you often want to make mouse and touchpad behavior the same.</db:para>
</db:note>
</db:section>
<db:section xml:id="acceptedModifiers-prop">
<db:title>acceptedModifiers : flags</db:title>
<db:para>If this property is set, it will require the given keyboard modifiers to be pressed in order to react to pointer events, and otherwise ignore them.</db:para>
<db:para>If this property is set to <db:code>Qt.KeyboardModifierMask</db:code> (the default value), then the <db:link xlink:href="qml-qtquick-pointerhandler.xml">PointerHandler</db:link> ignores the modifier keys.</db:para>
<db:para>For example, an <db:link xlink:href="qml-qtquick-item.xml">Item</db:link> could have two handlers of the same type, one of which is enabled only if the required keyboard modifiers are pressed:</db:para>
<db:programlisting language="qml">Item {
   TapHandler {
       acceptedModifiers: Qt.ControlModifier
       onTapped: console.log(&quot;control-tapped&quot;)
   }
   TapHandler {
       acceptedModifiers: Qt.NoModifier
       onTapped: console.log(&quot;tapped&quot;)
   }
}
</db:programlisting>
<db:para>If you set <db:code>acceptedModifiers</db:code> to an OR combination of modifier keys, it means <db:emphasis>all</db:emphasis> of those modifiers must be pressed to activate the handler:</db:para>
<db:programlisting language="qml">Item {
   TapHandler {
       acceptedModifiers: Qt.ControlModifier | Qt.AltModifier | Qt.ShiftModifier
       onTapped: console.log(&quot;control-alt-shift-tapped&quot;)
   }
}
</db:programlisting>
<db:para>The available modifiers are as follows:</db:para>
<db:informaltable>
<db:thead>
<db:tr>
<db:th>Constant</db:th>
<db:th>Description</db:th>
</db:tr>
</db:thead>
<db:tr>
<db:td>
<db:para>NoModifier</db:para>
</db:td>
<db:td>
<db:para>No modifier key is allowed.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para>ShiftModifier</db:para>
</db:td>
<db:td>
<db:para>A Shift key on the keyboard must be pressed.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para>ControlModifier</db:para>
</db:td>
<db:td>
<db:para>A Ctrl key on the keyboard must be pressed.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para>AltModifier</db:para>
</db:td>
<db:td>
<db:para>An Alt key on the keyboard must be pressed.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para>MetaModifier</db:para>
</db:td>
<db:td>
<db:para>A Meta key on the keyboard must be pressed.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para>KeypadModifier</db:para>
</db:td>
<db:td>
<db:para>A keypad button must be pressed.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para>GroupSwitchModifier</db:para>
</db:td>
<db:td>
<db:para>X11 only (unless activated on Windows by a command line argument). A Mode_switch key on the keyboard must be pressed.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para>KeyboardModifierMask</db:para>
</db:td>
<db:td>
<db:para>The handler does not care which modifiers are pressed.</db:para>
</db:td>
</db:tr>
</db:informaltable>
<db:para>If you need even more complex behavior than can be achieved with combinations of multiple handlers with multiple modifier flags, you can check the modifiers in JavaScript code:</db:para>
<db:programlisting language="qml">Item {
    TapHandler {
        onTapped:
            switch (point.modifiers) {
            case Qt.ControlModifier | Qt.AltModifier:
                console.log(&quot;CTRL+ALT&quot;);
                break;
            case Qt.ControlModifier | Qt.AltModifier | Qt.MetaModifier:
                console.log(&quot;CTRL+META+ALT&quot;);
                break;
            default:
                console.log(&quot;other modifiers&quot;, point.modifiers);
                break;
            }
    }
}
</db:programlisting>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qt.xml#KeyboardModifier-enum">Qt::KeyboardModifier</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="acceptedPointerTypes-prop">
<db:title>acceptedPointerTypes : flags</db:title>
<db:para>The types of pointing instruments (finger, stylus, eraser, etc.) that can activate this Pointer Handler.</db:para>
<db:para>By default, this property is set to <db:link xlink:href="qpointingdevice.xml#PointerType-enum">PointerDevice.AllPointerTypes</db:link>. If you set it to an OR combination of device types, it will ignore events from non-matching <db:link xlink:href="qml-qtquick-pointerdevice.xml">devices</db:link>.</db:para>
<db:para>For example, a control could be made to respond to mouse, touch, and stylus clicks in some way, but delete itself if tapped with an eraser tool on a graphics tablet, with two handlers:</db:para>
<db:programlisting language="qml">Rectangle {
   id: rect
   TapHandler {
       acceptedPointerTypes: PointerDevice.Generic | PointerDevice.Finger | PointerDevice.Pen
       onTapped: console.log(&quot;clicked&quot;)
   }
   TapHandler {
       acceptedPointerTypes: PointerDevice.Eraser
       onTapped: rect.destroy()
   }
}
</db:programlisting>
</db:section>
<db:section xml:id="active-prop">
<db:title>[read-only] active : bool</db:title>
<db:para>This property is <db:code>true</db:code> when all the constraints (epecially <db:link xlink:href="qml-qtquick-multipointhandler.xml#minimumPointCount-prop">minimumPointCount</db:link> and <db:link xlink:href="qml-qtquick-multipointhandler.xml#maximumPointCount-prop">maximumPointCount</db:link>) are satisfied and the <db:link xlink:href="qt-add-ui.xml#target">target</db:link>, if any, is being manipulated.</db:para>
</db:section>
<db:section xml:id="activeRotation-prop">
<db:title>[read-only] activeRotation : real</db:title>
<db:para>The rotation of the pinch gesture in degrees, with positive values clockwise. It is <db:code>0</db:code> when the gesture begins. If <db:link xlink:href="qt-add-ui.xml#target">target</db:link> is not null, this will be automatically added to its <db:link xlink:href="qml-qtquick-item.xml#rotation-prop">rotation</db:link>. Otherwise, bindings can be used to do arbitrary things with this value.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qml-qtquick-pinchhandler.xml#rotationAxis.activeValue-prop">QtQuick::PinchHandler::rotationAxis.activeValue</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="activeScale-prop">
<db:title>[read-only] activeScale : real</db:title>
<db:para>The scale factor while the pinch gesture is being performed. It is 1.0 when the gesture begins, increases as the touchpoints are spread apart, and decreases as the touchpoints are brought together. If <db:link xlink:href="qt-add-ui.xml#target">target</db:link> is not null, its <db:link xlink:href="qml-qtquick-item.xml#scale-prop">scale</db:link> will be automatically multiplied by this value. Otherwise, bindings can be used to do arbitrary things with this value.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qml-qtquick-pinchhandler.xml#scaleAxis.activeValue-prop">QtQuick::PinchHandler::scaleAxis.activeValue</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="activeTranslation-prop">
<db:title>[read-only] activeTranslation : point</db:title>
<db:para>The translation of the cluster of points while the pinch gesture is being performed. It is <db:code>0, 0</db:code> when the gesture begins, and increases as the <db:link xlink:href="qml-qtquick-eventpoint.xml">eventPoint(s)</db:link> are dragged downward and to the right. After the gesture ends, it stays the same; and when the next pinch gesture begins, it is reset to <db:code>0, 0</db:code> again.</db:para>
<db:note>
<db:para>On some touchpads, such as on a macOS trackpad, native gestures do not generate any translation values, and this property stays at <db:code>(0, 0)</db:code>.</db:para>
</db:note>
</db:section>
<db:section xml:id="centroid-prop">
<db:title>[read-only] centroid : QtQuick::handlerPoint</db:title>
<db:para>A point exactly in the middle of the currently-pressed touch points. The <db:link xlink:href="qt-add-ui.xml#target">target</db:link> will be rotated around this point.</db:para>
</db:section>
<db:section xml:id="cursorShape-prop">
<db:title>cursorShape : Qt::CursorShape</db:title>
<db:para>This property holds the cursor shape that will appear whenever the mouse is hovering over the <db:link xlink:href="qml-qtquick-pinchhandler.xml#parent-prop">parent</db:link> item while <db:link xlink:href="qml-qtquick-pinchhandler.xml#active-prop">active</db:link> is <db:code>true</db:code>.</db:para>
<db:para>The available cursor shapes are:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para>Qt.ArrowCursor</db:para>
</db:listitem>
<db:listitem>
<db:para>Qt.UpArrowCursor</db:para>
</db:listitem>
<db:listitem>
<db:para>Qt.CrossCursor</db:para>
</db:listitem>
<db:listitem>
<db:para>Qt.WaitCursor</db:para>
</db:listitem>
<db:listitem>
<db:para>Qt.IBeamCursor</db:para>
</db:listitem>
<db:listitem>
<db:para>Qt.SizeVerCursor</db:para>
</db:listitem>
<db:listitem>
<db:para>Qt.SizeHorCursor</db:para>
</db:listitem>
<db:listitem>
<db:para>Qt.SizeBDiagCursor</db:para>
</db:listitem>
<db:listitem>
<db:para>Qt.SizeFDiagCursor</db:para>
</db:listitem>
<db:listitem>
<db:para>Qt.SizeAllCursor</db:para>
</db:listitem>
<db:listitem>
<db:para>Qt.BlankCursor</db:para>
</db:listitem>
<db:listitem>
<db:para>Qt.SplitVCursor</db:para>
</db:listitem>
<db:listitem>
<db:para>Qt.SplitHCursor</db:para>
</db:listitem>
<db:listitem>
<db:para>Qt.PointingHandCursor</db:para>
</db:listitem>
<db:listitem>
<db:para>Qt.ForbiddenCursor</db:para>
</db:listitem>
<db:listitem>
<db:para>Qt.WhatsThisCursor</db:para>
</db:listitem>
<db:listitem>
<db:para>Qt.BusyCursor</db:para>
</db:listitem>
<db:listitem>
<db:para>Qt.OpenHandCursor</db:para>
</db:listitem>
<db:listitem>
<db:para>Qt.ClosedHandCursor</db:para>
</db:listitem>
<db:listitem>
<db:para>Qt.DragCopyCursor</db:para>
</db:listitem>
<db:listitem>
<db:para>Qt.DragMoveCursor</db:para>
</db:listitem>
<db:listitem>
<db:para>Qt.DragLinkCursor</db:para>
</db:listitem>
</db:itemizedlist>
<db:para>The default value is not set, which allows the <db:link xlink:href="qquickitem.xml#cursor">cursor</db:link> of <db:link xlink:href="qml-qtquick-pinchhandler.xml#parent-prop">parent</db:link> item to appear. This property can be reset to the same initial condition by setting it to undefined.</db:para>
<db:note>
<db:para>When this property has not been set, or has been set to <db:code>undefined</db:code>, if you read the value it will return <db:code>Qt.ArrowCursor</db:code>.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qt.xml#CursorShape-enum">Qt::CursorShape</db:link></db:member>
<db:member><db:link xlink:href="qquickitem.xml#cursor">QQuickItem::cursor</db:link>()</db:member>
<db:member><db:link xlink:href="qml-qtquick-hoverhandler.xml#cursorShape-prop">HoverHandler::cursorShape</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="dragThreshold-prop">
<db:title>dragThreshold : int</db:title>
<db:para>The distance in pixels that the user must drag an <db:link xlink:href="qml-qtquick-eventpoint.xml">eventPoint</db:link> in order to have it treated as a drag gesture.</db:para>
<db:para>The default value depends on the platform and screen resolution. It can be reset back to the default value by setting it to undefined. The behavior when a drag gesture begins varies in different handlers.</db:para>
</db:section>
<db:section xml:id="enabled-prop">
<db:title>enabled : bool</db:title>
<db:para>If a <db:link xlink:href="qml-qtquick-pointerhandler.xml">PointerHandler</db:link> is disabled, it will reject all events and no signals will be emitted.</db:para>
</db:section>
<db:section xml:id="grabPermissions-prop">
<db:title>grabPermissions : flags</db:title>
<db:para>This property specifies the permissions when this handler's logic decides to take over the exclusive grab, or when it is asked to approve grab takeover or cancellation by another handler.</db:para>
<db:informaltable>
<db:thead>
<db:tr>
<db:th>Constant</db:th>
<db:th>Description</db:th>
</db:tr>
</db:thead>
<db:tr>
<db:td>
<db:para>PointerHandler.TakeOverForbidden</db:para>
</db:td>
<db:td>
<db:para>This handler neither takes from nor gives grab permission to any type of Item or Handler.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para>PointerHandler.CanTakeOverFromHandlersOfSameType</db:para>
</db:td>
<db:td>
<db:para>This handler can take the exclusive grab from another handler of the same class.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para>PointerHandler.CanTakeOverFromHandlersOfDifferentType</db:para>
</db:td>
<db:td>
<db:para>This handler can take the exclusive grab from any kind of handler.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para>PointerHandler.CanTakeOverFromItems</db:para>
</db:td>
<db:td>
<db:para>This handler can take the exclusive grab from any type of Item.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para>PointerHandler.CanTakeOverFromAnything</db:para>
</db:td>
<db:td>
<db:para>This handler can take the exclusive grab from any type of Item or Handler.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para>PointerHandler.ApprovesTakeOverByHandlersOfSameType</db:para>
</db:td>
<db:td>
<db:para>This handler gives permission for another handler of the same class to take the grab.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para>PointerHandler.ApprovesTakeOverByHandlersOfDifferentType</db:para>
</db:td>
<db:td>
<db:para>This handler gives permission for any kind of handler to take the grab.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para>PointerHandler.ApprovesTakeOverByItems</db:para>
</db:td>
<db:td>
<db:para>This handler gives permission for any kind of Item to take the grab.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para>PointerHandler.ApprovesCancellation</db:para>
</db:td>
<db:td>
<db:para>This handler will allow its grab to be set to null.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para>PointerHandler.ApprovesTakeOverByAnything</db:para>
</db:td>
<db:td>
<db:para>This handler gives permission for any type of Item or Handler to take the grab.</db:para>
</db:td>
</db:tr>
</db:informaltable>
<db:para>The default is <db:code>PointerHandler.CanTakeOverFromItems | PointerHandler.CanTakeOverFromHandlersOfDifferentType | PointerHandler.ApprovesTakeOverByAnything</db:code> which allows most takeover scenarios but avoids e.g. two PinchHandlers fighting over the same touchpoints.</db:para>
</db:section>
<db:section xml:id="margin-prop">
<db:title>margin : real</db:title>
<db:para>The margin beyond the bounds of the <db:link xlink:href="qml-qtquick-pinchhandler.xml#parent-prop">parent</db:link> item within which an <db:link xlink:href="qml-qtquick-eventpoint.xml">eventPoint</db:link> can activate this handler. For example, on a <db:link xlink:href="qml-qtquick-pinchhandler.xml">PinchHandler</db:link> where the <db:link xlink:href="qml-qtquick-pinchhandler.xml#target-prop">target</db:link> is also the <db:code>parent</db:code>, it's useful to set this to a distance at least half the width of a typical user's finger, so that if the <db:code>parent</db:code> has been scaled down to a very small size, the pinch gesture is still possible. Or, if a <db:link xlink:href="qml-qtquick-taphandler.xml">TapHandler</db:link>-based button is placed near the screen edge, it can be used to comply with Fitts's Law: react to mouse clicks at the screen edge even though the button is visually spaced away from the edge by a few pixels.</db:para>
<db:para>The default value is 0.</db:para>
<db:mediaobject>
<db:imageobject>
<db:imagedata fileref="images/pointerHandlerMargin.png"/>
</db:imageobject>
</db:mediaobject>
</db:section>
<db:section xml:id="parent-prop">
<db:title>parent : Item</db:title>
<db:para>The <db:link xlink:href="qml-qtquick-item.xml">Item</db:link> which is the scope of the handler; the Item in which it was declared. The handler will handle events on behalf of this Item, which means a pointer event is relevant if at least one of its <db:link xlink:href="qml-qtquick-eventpoint.xml">eventPoints</db:link> occurs within the Item's interior. Initially <db:link xlink:href="qml-qtquick-pinchhandler.xml#target-prop">target()</db:link> is the same, but it can be reassigned.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qml-qtquick-pinchhandler.xml#target-prop">target</db:link></db:member>
<db:member><db:link xlink:href="qobject.xml#parent">QObject::parent</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="persistentRotation-prop">
<db:title>persistentRotation : real</db:title>
<db:para>The rotation to be applied to the <db:link xlink:href="qt-add-ui.xml#target">target</db:link> if it is not null. Otherwise, bindings can be used to do arbitrary things with this value. While the pinch gesture is being performed, <db:link xlink:href="qml-qtquick-pinchhandler.xml#activeRotation-prop">activeRotation</db:link> is continuously added; after the gesture ends, it stays the same; and when the next pinch gesture begins, it begins to be modified by <db:link xlink:href="qml-qtquick-pinchhandler.xml#activeRotation-prop">activeRotation</db:link> again.</db:para>
<db:para>It's possible to set this property, as a way of synchronizing the basis rotation with a rotation that was set in some other way, for example by another handler. If you set this property directly, <db:code>activeRotation</db:code> does not change, and <db:code>rotationChanged(0)</db:code> is emitted.</db:para>
</db:section>
<db:section xml:id="persistentScale-prop">
<db:title>persistentScale : real</db:title>
<db:para>The scale factor that will automatically be set on the <db:link xlink:href="qt-add-ui.xml#target">target</db:link> if it is not null. Otherwise, bindings can be used to do arbitrary things with this value. While the pinch gesture is being performed, it is continuously multiplied by <db:link xlink:href="qml-qtquick-pinchhandler.xml#activeScale-prop">activeScale</db:link>; after the gesture ends, it stays the same; and when the next pinch gesture begins, it begins to be multiplied by <db:link xlink:href="qml-qtquick-pinchhandler.xml#activeScale-prop">activeScale</db:link> again.</db:para>
<db:para>It's possible to set this property, as a way of synchronizing the basis scale with a scale that was set in some other way, for example by another handler. If you set this property directly, <db:code>activeScale</db:code> does not change, and <db:code>scaleChanged(1)</db:code> is emitted.</db:para>
</db:section>
<db:section xml:id="persistentTranslation-prop">
<db:title>persistentTranslation : point</db:title>
<db:para>The translation to be applied to the <db:link xlink:href="qt-add-ui.xml#target">target</db:link> if it is not <db:code>null</db:code>. Otherwise, bindings can be used to do arbitrary things with this value. While the pinch gesture is being performed, <db:link xlink:href="qml-qtquick-pinchhandler.xml#activeTranslation-prop">activeTranslation</db:link> is continuously added to it; after the gesture ends, it stays the same.</db:para>
<db:para>It's possible to set this property, as a way of synchronizing the basis translation with a translation that was set in some other way, for example by another handler. If you set this property directly, <db:code>activeTranslation</db:code> does not change, and <db:code>translationChanged({0, 0})</db:code> is emitted.</db:para>
<db:note>
<db:para>On some touchpads, such as on a macOS trackpad, native gestures do not generate any translation values, and this property stays at <db:code>(0, 0)</db:code>.</db:para>
</db:note>
</db:section>
<db:section xml:id="rotationAxis-prop">
<db:title>rotationAxis group</db:title>
<db:bridgehead renderas="sect2" xml:id="rotationAxis.activeValue-prop">[read-only] rotationAxis.activeValue : real</db:bridgehead>
<db:bridgehead renderas="sect2" xml:id="rotationAxis.enabled-prop">rotationAxis.enabled : bool</db:bridgehead>
<db:bridgehead renderas="sect2" xml:id="rotationAxis.maximum-prop">rotationAxis.maximum : real</db:bridgehead>
<db:bridgehead renderas="sect2" xml:id="rotationAxis.minimum-prop">rotationAxis.minimum : real</db:bridgehead>
<db:para><db:code>rotationAxis</db:code> controls the constraints for setting the <db:link xlink:href="qml-qtquick-item.xml#rotation-prop">rotation</db:link> of the <db:link xlink:href="qt-add-ui.xml#target">target</db:link> item according to the rotation of the group of touchpoints.</db:para>
<db:para><db:code>minimum</db:code> is the minimum acceptable rotation. <db:code>maximum</db:code> is the maximum acceptable rotation. If <db:code>enabled</db:code> is true, rotation is allowed. <db:code>activeValue</db:code> is the same as <db:link xlink:href="qml-qtquick-pinchhandler.xml#activeRotation-prop">QtQuick::PinchHandler::activeRotation</db:link>.</db:para>
<db:para>The <db:code>activeValueChanged</db:code> signal is emitted when <db:code>activeValue</db:code> changes, to provide the increment by which it changed. This is intended for incrementally adjusting one property via multiple handlers.</db:para>
<db:programlisting language="qml">import QtQuick

Rectangle {
    width: 100; height: 100
    color: &quot;lightsteelblue&quot;; antialiasing: true

    PinchHandler {
        id: handler
        target: null
        xAxis.onActiveValueChanged: (delta) =&gt; parent.radius -= delta
        yAxis.onActiveValueChanged: (delta) =&gt; parent.border.width += delta
        rotationAxis.onActiveValueChanged: (delta) =&gt; parent.rotation += delta // add
        scaleAxis.onActiveValueChanged: (delta) =&gt; parent.scale *= delta // multiply
    }

    WheelHandler {
        acceptedModifiers: Qt.NoModifier
        property: &quot;rotation&quot;
    }

    WheelHandler {
        acceptedModifiers: Qt.ControlModifier
        property: &quot;scale&quot;
    }
}
</db:programlisting>
<db:note>
<db:para>The snippet is contrived: <db:link xlink:href="qml-qtquick-pinchhandler.xml">PinchHandler</db:link> already knows how to move, scale and rotate its parent item, but this code achieves different behavior in a less-declarative way, to illustrate how to use <db:code>activeValueChanged</db:code> in special cases.</db:para>
</db:note>
</db:section>
<db:section xml:id="scaleAxis-prop">
<db:title>scaleAxis group</db:title>
<db:bridgehead renderas="sect2" xml:id="scaleAxis.activeValue-prop">[read-only] scaleAxis.activeValue : real</db:bridgehead>
<db:bridgehead renderas="sect2" xml:id="scaleAxis.enabled-prop">scaleAxis.enabled : bool</db:bridgehead>
<db:bridgehead renderas="sect2" xml:id="scaleAxis.maximum-prop">scaleAxis.maximum : real</db:bridgehead>
<db:bridgehead renderas="sect2" xml:id="scaleAxis.minimum-prop">scaleAxis.minimum : real</db:bridgehead>
<db:para><db:code>scaleAxis</db:code> controls the constraints for setting the <db:link xlink:href="qml-qtquick-item.xml#scale-prop">scale</db:link> of the <db:link xlink:href="qt-add-ui.xml#target">target</db:link> item according to the distance between the touchpoints.</db:para>
<db:para><db:code>minimum</db:code> is the minimum acceptable scale. <db:code>maximum</db:code> is the maximum acceptable scale. If <db:code>enabled</db:code> is true, scaling is allowed. <db:code>activeValue</db:code> is the same as <db:link xlink:href="qml-qtquick-pinchhandler.xml#activeScale-prop">QtQuick::PinchHandler::activeScale</db:link>.</db:para>
<db:para>The <db:code>activeValueChanged</db:code> signal is emitted when <db:code>activeValue</db:code> changes, to provide the multiplier for the incremental change. This is intended for incrementally adjusting one property via multiple handlers.</db:para>
<db:programlisting language="qml">import QtQuick

Rectangle {
    width: 100; height: 100
    color: &quot;lightsteelblue&quot;; antialiasing: true

    PinchHandler {
        id: handler
        target: null
        xAxis.onActiveValueChanged: (delta) =&gt; parent.radius -= delta
        yAxis.onActiveValueChanged: (delta) =&gt; parent.border.width += delta
        rotationAxis.onActiveValueChanged: (delta) =&gt; parent.rotation += delta // add
        scaleAxis.onActiveValueChanged: (delta) =&gt; parent.scale *= delta // multiply
    }

    WheelHandler {
        acceptedModifiers: Qt.NoModifier
        property: &quot;rotation&quot;
    }

    WheelHandler {
        acceptedModifiers: Qt.ControlModifier
        property: &quot;scale&quot;
    }
}
</db:programlisting>
<db:note>
<db:para>The snippet is contrived: <db:link xlink:href="qml-qtquick-pinchhandler.xml">PinchHandler</db:link> already knows how to move, scale and rotate its parent item, but this code achieves different behavior in a less-declarative way, to illustrate how to use <db:code>activeValueChanged</db:code> in special cases.</db:para>
</db:note>
</db:section>
<db:section xml:id="target-prop">
<db:title>target : Item</db:title>
<db:para>The Item which this handler will manipulate.</db:para>
<db:para>By default, it is the same as the <db:link xlink:href="qml-qtquick-pinchhandler.xml#parent-prop">parent</db:link>, the Item within which the handler is declared. However, it can sometimes be useful to set the target to a different Item, in order to handle events within one item but manipulate another; or to <db:code>null</db:code>, to disable the default behavior and do something else instead.</db:para>
</db:section>
<db:section xml:id="xAxis-prop">
<db:title>xAxis group</db:title>
<db:bridgehead renderas="sect2" xml:id="xAxis.activeValue-prop">[read-only] xAxis.activeValue : real</db:bridgehead>
<db:bridgehead renderas="sect2" xml:id="xAxis.enabled-prop">xAxis.enabled : bool</db:bridgehead>
<db:bridgehead renderas="sect2" xml:id="xAxis.maximum-prop">xAxis.maximum : real</db:bridgehead>
<db:bridgehead renderas="sect2" xml:id="xAxis.minimum-prop">xAxis.minimum : real</db:bridgehead>
<db:para><db:code>xAxis</db:code> controls the constraints for horizontal translation of the <db:link xlink:href="qt-add-ui.xml#target">target</db:link> item.</db:para>
<db:para><db:code>minimum</db:code> is the minimum acceptable x coordinate of the translation. <db:code>maximum</db:code> is the maximum acceptable x coordinate of the translation. If <db:code>enabled</db:code> is true, horizontal dragging is allowed.</db:para>
<db:para>The <db:code>activeValueChanged</db:code> signal is emitted when <db:code>activeValue</db:code> changes, to provide the increment by which it changed. This is intended for incrementally adjusting one property via multiple handlers.</db:para>
<db:programlisting language="qml">import QtQuick

Rectangle {
    width: 100; height: 100
    color: &quot;lightsteelblue&quot;; antialiasing: true

    PinchHandler {
        id: handler
        target: null
        xAxis.onActiveValueChanged: (delta) =&gt; parent.radius -= delta
        yAxis.onActiveValueChanged: (delta) =&gt; parent.border.width += delta
        rotationAxis.onActiveValueChanged: (delta) =&gt; parent.rotation += delta // add
        scaleAxis.onActiveValueChanged: (delta) =&gt; parent.scale *= delta // multiply
    }

    WheelHandler {
        acceptedModifiers: Qt.NoModifier
        property: &quot;rotation&quot;
    }

    WheelHandler {
        acceptedModifiers: Qt.ControlModifier
        property: &quot;scale&quot;
    }
}
</db:programlisting>
<db:note>
<db:para>The snippet is contrived: <db:link xlink:href="qml-qtquick-pinchhandler.xml">PinchHandler</db:link> already knows how to move, scale and rotate its parent item, but this code achieves different behavior in a less-declarative way, to illustrate how to use <db:code>activeValueChanged</db:code> in special cases.</db:para>
</db:note>
</db:section>
<db:section xml:id="yAxis-prop">
<db:title>yAxis group</db:title>
<db:bridgehead renderas="sect2" xml:id="yAxis.activeValue-prop">[read-only] yAxis.activeValue : real</db:bridgehead>
<db:bridgehead renderas="sect2" xml:id="yAxis.enabled-prop">yAxis.enabled : bool</db:bridgehead>
<db:bridgehead renderas="sect2" xml:id="yAxis.maximum-prop">yAxis.maximum : real</db:bridgehead>
<db:bridgehead renderas="sect2" xml:id="yAxis.minimum-prop">yAxis.minimum : real</db:bridgehead>
<db:para><db:code>yAxis</db:code> controls the constraints for vertical translation of the <db:link xlink:href="qt-add-ui.xml#target">target</db:link> item.</db:para>
<db:para><db:code>minimum</db:code> is the minimum acceptable y coordinate of the translation. <db:code>maximum</db:code> is the maximum acceptable y coordinate of the translation. If <db:code>enabled</db:code> is true, vertical dragging is allowed.</db:para>
<db:para>The <db:code>activeValueChanged</db:code> signal is emitted when <db:code>activeValue</db:code> changes, to provide the increment by which it changed. This is intended for incrementally adjusting one property via multiple handlers.</db:para>
<db:programlisting language="qml">import QtQuick

Rectangle {
    width: 100; height: 100
    color: &quot;lightsteelblue&quot;; antialiasing: true

    PinchHandler {
        id: handler
        target: null
        xAxis.onActiveValueChanged: (delta) =&gt; parent.radius -= delta
        yAxis.onActiveValueChanged: (delta) =&gt; parent.border.width += delta
        rotationAxis.onActiveValueChanged: (delta) =&gt; parent.rotation += delta // add
        scaleAxis.onActiveValueChanged: (delta) =&gt; parent.scale *= delta // multiply
    }

    WheelHandler {
        acceptedModifiers: Qt.NoModifier
        property: &quot;rotation&quot;
    }

    WheelHandler {
        acceptedModifiers: Qt.ControlModifier
        property: &quot;scale&quot;
    }
}
</db:programlisting>
<db:note>
<db:para>The snippet is contrived: <db:link xlink:href="qml-qtquick-pinchhandler.xml">PinchHandler</db:link> already knows how to move, scale and rotate its parent item, but this code achieves different behavior in a less-declarative way, to illustrate how to use <db:code>activeValueChanged</db:code> in special cases.</db:para>
</db:note>
</db:section>
</db:section>
<db:section xml:id="signal-documentation">
<db:title>Signal Documentation</db:title>
<db:section xml:id="canceled-signal">
<db:title>canceled(eventPoint <db:emphasis>point</db:emphasis>)</db:title>
<db:para>If this handler has already grabbed the given <db:code role="parameter">point</db:code>, this signal is emitted when the grab is stolen by a different Pointer Handler or Item.</db:para>
<db:note>
<db:para>The corresponding handler is <db:code>onCanceled</db:code>.</db:para>
</db:note>
</db:section>
<db:section xml:id="grabChanged-signal">
<db:title>grabChanged(PointerDevice::GrabTransition <db:emphasis>transition</db:emphasis>, eventPoint <db:emphasis>point</db:emphasis>)</db:title>
<db:para>This signal is emitted when the grab has changed in some way which is relevant to this handler.</db:para>
<db:para>The <db:code role="parameter">transition</db:code> (verb) tells what happened. The <db:code role="parameter">point</db:code> (object) is the point that was grabbed or ungrabbed.</db:para>
<db:para>Valid values for <db:code role="parameter">transition</db:code> are:</db:para>
<db:informaltable>
<db:thead>
<db:tr>
<db:th>Constant</db:th>
<db:th>Description</db:th>
</db:tr>
</db:thead>
<db:tr>
<db:td>
<db:para>PointerDevice.GrabExclusive</db:para>
</db:td>
<db:td>
<db:para>This handler has taken primary responsibility for handling the <db:code role="parameter">point</db:code>.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para>PointerDevice.UngrabExclusive</db:para>
</db:td>
<db:td>
<db:para>This handler has given up its previous exclusive grab.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para>PointerDevice.CancelGrabExclusive</db:para>
</db:td>
<db:td>
<db:para>This handler's exclusive grab has been taken over or cancelled.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para>PointerDevice.GrabPassive</db:para>
</db:td>
<db:td>
<db:para>This handler has acquired a passive grab, to monitor the <db:code role="parameter">point</db:code>.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para>PointerDevice.UngrabPassive</db:para>
</db:td>
<db:td>
<db:para>This handler has given up its previous passive grab.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para>PointerDevice.CancelGrabPassive</db:para>
</db:td>
<db:td>
<db:para>This handler's previous passive grab has terminated abnormally.</db:para>
</db:td>
</db:tr>
</db:informaltable>
<db:note>
<db:para>The corresponding handler is <db:code>onGrabChanged</db:code>.</db:para>
</db:note>
</db:section>
<db:section xml:id="rotationChanged-signal">
<db:title>rotationChanged(qreal <db:emphasis>delta</db:emphasis>)</db:title>
<db:para>The <db:code>rotationChanged</db:code> signal is emitted when <db:link xlink:href="qml-qtquick-pinchhandler.xml#activeRotation-prop">activeRotation</db:link> (and therefore <db:link xlink:href="qml-qtquick-pinchhandler.xml#persistentRotation-prop">persistentRotation</db:link>) changes. The <db:code role="parameter">delta</db:code> value gives the additive change in rotation. For example, if the user moves fingers to change the pinch distance so that <db:code>activeRotation</db:code> changes from 10 to 30 degrees, <db:code>rotationChanged(20)</db:code> will be emitted. You can use that to incrementally change the rotation of an item:</db:para>
<db:programlisting language="qml">import QtQuick

Rectangle {
    width: 100; height: 100
    color: &quot;lightsteelblue&quot;

    PinchHandler {
        id: handler
        target: null
        onRotationChanged: (delta) =&gt; parent.rotation += delta // add
        onScaleChanged: (delta) =&gt; parent.scale *= delta // multiply
    }
}
</db:programlisting>
<db:note>
<db:para>If you set the <db:link xlink:href="qml-qtquick-pinchhandler.xml#persistentRotation-prop">persistentRotation</db:link> property directly, <db:code>delta</db:code> is <db:code>0</db:code>.</db:para>
</db:note>
<db:note>
<db:para>The corresponding handler is <db:code>onRotationChanged</db:code>.</db:para>
</db:note>
</db:section>
<db:section xml:id="scaleChanged-signal">
<db:title>scaleChanged(qreal <db:emphasis>delta</db:emphasis>)</db:title>
<db:para>The <db:code>scaleChanged</db:code> signal is emitted when <db:link xlink:href="qml-qtquick-pinchhandler.xml#activeScale-prop">activeScale</db:link> (and therefore <db:link xlink:href="qml-qtquick-pinchhandler.xml#persistentScale-prop">persistentScale</db:link>) changes. The <db:code role="parameter">delta</db:code> value gives the multiplicative change in scale. For example, if the user moves fingers to change the pinch distance so that <db:code>activeScale</db:code> changes from 2 to 2.5, <db:code>scaleChanged(1.25)</db:code> will be emitted. You can use that to incrementally change the scale of an item:</db:para>
<db:programlisting language="qml">import QtQuick

Rectangle {
    width: 100; height: 100
    color: &quot;lightsteelblue&quot;

    PinchHandler {
        id: handler
        target: null
        onRotationChanged: (delta) =&gt; parent.rotation += delta // add
        onScaleChanged: (delta) =&gt; parent.scale *= delta // multiply
    }
}
</db:programlisting>
<db:note>
<db:para>If you set the <db:link xlink:href="qml-qtquick-pinchhandler.xml#persistentScale-prop">persistentScale</db:link> property directly, <db:code>delta</db:code> is <db:code>1</db:code>.</db:para>
</db:note>
<db:note>
<db:para>The corresponding handler is <db:code>onScaleChanged</db:code>.</db:para>
</db:note>
</db:section>
<db:section xml:id="translationChanged-signal">
<db:title>translationChanged(QVector2D <db:emphasis>delta</db:emphasis>)</db:title>
<db:para>The <db:code>translationChanged</db:code> signal is emitted when <db:link xlink:href="qml-qtquick-pinchhandler.xml#activeTranslation-prop">activeTranslation</db:link> (and therefore <db:link xlink:href="qml-qtquick-pinchhandler.xml#persistentTranslation-prop">persistentTranslation</db:link>) changes. The <db:code role="parameter">delta</db:code> vector gives the change in translation. You can use that to incrementally change the position of an item:</db:para>
<db:programlisting language="qml">import QtQuick

Window {
    width: 320; height: 240
    visible: true
    title: handler.persistentRotation.toFixed(1) + &quot;Â° &quot; +
           handler.persistentTranslation.x.toFixed(1) + &quot;, &quot; +
           handler.persistentTranslation.y.toFixed(1) + &quot; &quot; +
           (handler.persistentScale * 100).toFixed(1) + &quot;%&quot;

    PinchHandler {
        id: handler
        target: null
        persistentScale: 0.25
        onTranslationChanged: (delta) =&gt; {
            image.x -= delta.x
            image.y -= delta.y
        }
    }

    Image {
        id: image
        source: &quot;images/album-cover.jpg&quot;
        scale: handler.persistentScale
        x: -600; y: -450
    }
}
</db:programlisting>
<db:note>
<db:para>If you set the <db:link xlink:href="qml-qtquick-pinchhandler.xml#persistentTranslation-prop">persistentTranslation</db:link> property directly, <db:code>delta</db:code> is <db:code>0, 0</db:code>.</db:para>
</db:note>
<db:note>
<db:para>The corresponding handler is <db:code>onTranslationChanged</db:code>.</db:para>
</db:note>
</db:section>
</db:section>
<db:section xml:id="obsolete">
<db:title>Obsolete Members for PinchHandler</db:title>
<db:para><db:emphasis role="bold">The following members of QML type <db:link xlink:href="qml-qtquick-pinchhandler.xml">PinchHandler</db:link> are deprecated.</db:emphasis> We strongly advise against using them in new code.</db:para>
<db:section xml:id="obsolete-property-documentation">
<db:title>Obsolete Property Documentation</db:title>
<db:section xml:id="maximumRotation-prop">
<db:title>[deprecated in 6.5] maximumRotation : real</db:title>
<db:para>This property is deprecated since QtQuick 6.5. We strongly advise against using it in new code.</db:para>
<db:para>Use <db:link xlink:href="qml-qtquick-pinchhandler.xml#rotationAxis-prop">rotationAxis</db:link>.maximum</db:para>
<db:para>The maximum acceptable <db:link xlink:href="qml-qtquick-item.xml#rotation-prop">rotation</db:link> to be applied to the <db:link xlink:href="qt-add-ui.xml#target">target</db:link>.</db:para>
</db:section>
<db:section xml:id="maximumScale-prop">
<db:title>[deprecated in 6.5] maximumScale : real</db:title>
<db:para>This property is deprecated since QtQuick 6.5. We strongly advise against using it in new code.</db:para>
<db:para>Use <db:link xlink:href="qml-qtquick-pinchhandler.xml#scaleAxis-prop">scaleAxis</db:link>.maximum</db:para>
<db:para>The maximum acceptable <db:link xlink:href="qml-qtquick-item.xml#scale-prop">scale</db:link> to be applied to the <db:link xlink:href="qt-add-ui.xml#target">target</db:link>.</db:para>
</db:section>
<db:section xml:id="minimumRotation-prop">
<db:title>[deprecated in 6.5] minimumRotation : real</db:title>
<db:para>This property is deprecated since QtQuick 6.5. We strongly advise against using it in new code.</db:para>
<db:para>Use <db:link xlink:href="qml-qtquick-pinchhandler.xml#rotationAxis-prop">rotationAxis</db:link>.minimum</db:para>
<db:para>The minimum acceptable <db:link xlink:href="qml-qtquick-item.xml#rotation-prop">rotation</db:link> to be applied to the <db:link xlink:href="qt-add-ui.xml#target">target</db:link>.</db:para>
</db:section>
<db:section xml:id="minimumScale-prop">
<db:title>[deprecated in 6.5] minimumScale : real</db:title>
<db:para>This property is deprecated since QtQuick 6.5. We strongly advise against using it in new code.</db:para>
<db:para>Use <db:link xlink:href="qml-qtquick-pinchhandler.xml#scaleAxis-prop">scaleAxis</db:link>.minimum</db:para>
<db:para>The minimum acceptable <db:link xlink:href="qml-qtquick-item.xml#scale-prop">scale</db:link> to be applied to the <db:link xlink:href="qt-add-ui.xml#target">target</db:link>.</db:para>
</db:section>
<db:section xml:id="rotation-prop">
<db:title>[read-only, deprecated in 6.5] rotation : vector2d</db:title>
<db:para>This property is deprecated since QtQuick 6.5. We strongly advise against using it in new code.</db:para>
<db:para>Use <db:link xlink:href="qml-qtquick-pinchhandler.xml#activeRotation-prop">activeRotation</db:link></db:para>
</db:section>
<db:section xml:id="scale-prop">
<db:title>[read-only, deprecated in 6.5] scale : vector2d</db:title>
<db:para>This property is deprecated since QtQuick 6.5. We strongly advise against using it in new code.</db:para>
<db:para>Use <db:link xlink:href="qml-qtquick-pinchhandler.xml#persistentScale-prop">persistentScale</db:link></db:para>
</db:section>
<db:section xml:id="translation-prop">
<db:title>[read-only, deprecated in 6.5] translation : vector2d</db:title>
<db:para>This property is deprecated since QtQuick 6.5. We strongly advise against using it in new code.</db:para>
<db:para>Use <db:link xlink:href="qml-qtquick-pinchhandler.xml#activeTranslation-prop">activeTranslation</db:link></db:para>
</db:section>
</db:section>
</db:section>
</db:article>
