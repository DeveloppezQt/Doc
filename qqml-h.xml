<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en">
<db:info>
<db:title>&lt;qqml.h&gt; - Functions to register C++ types to QML</db:title>
<db:productname>QtQml</db:productname>
<db:edition>Qt 6.9.1 Reference Documentation</db:edition>
<db:titleabbrev>Qt Qml Reference Documentation</db:titleabbrev>
<db:abstract>
<db:para>Qt Qml Reference Documentation.</db:para></db:abstract>
<db:pubdate>2025-06-29</db:pubdate>
<db:date>2025-06-29</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:variablelist>
<db:varlistentry>
<db:term>Header</db:term>
<db:listitem>
<db:para>qqml.h</db:para>
</db:listitem>
</db:varlistentry>
</db:variablelist>
<db:section xml:id="details">
<db:title>Detailed Description</db:title>
<db:para>This header provides a collection of functions that allow the registration of C++ types to QML.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtqml-cppintegration-overview.xml">Overview - QML and C++ Integration</db:link></db:member>
<db:member><db:link xlink:href="">qqmlintegration.h</db:link></db:member>
<db:member><db:link xlink:href="qtqml-tooling-qmltyperegistrar.xml">qmltyperegistrar</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="type-documentation">
<db:title>Type Documentation</db:title>
<db:section xml:id="QQmlModuleImportSpecialVersions-enum">
<db:title>enum QQmlModuleImportSpecialVersions</db:title>
<db:para>Defines some special values that can be passed to the version arguments of <db:link xlink:href="qqml-h.xml#qmlRegisterModuleImport">qmlRegisterModuleImport</db:link>() and <db:link xlink:href="qqml-h.xml#qmlUnregisterModuleImport">qmlUnregisterModuleImport</db:link>().</db:para>
<db:informaltable>
<db:thead>
<db:tr>
<db:th>Constant</db:th>
<db:th>Value</db:th>
<db:th>Description</db:th>
</db:tr>
</db:thead>
<db:tr>
<db:td>
<db:para><db:code>QQmlModuleImportModuleAny</db:code></db:para>
</db:td>
<db:td><db:code>-1</db:code></db:td>
<db:td>
<db:para>When passed as majorVersion of the base module, signifies that the import is to be applied to any version of the module.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code>QQmlModuleImportLatest</db:code></db:para>
</db:td>
<db:td><db:code>-1</db:code></db:td>
<db:td>
<db:para>When passed as major or minor version of the imported module, signifies that the latest overall, or latest minor version of a specified major version shall be imported.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code>QQmlModuleImportAuto</db:code></db:para>
</db:td>
<db:td><db:code>-2</db:code></db:td>
<db:td>
<db:para>When passed as major version of the imported module, signifies that the version of the base module shall be forwarded.</db:para>
</db:td>
</db:tr>
</db:informaltable>
</db:section>
</db:section>
<db:section xml:id="function-documentation">
<db:title>Function Documentation</db:title>
<db:section xml:id="qmlAttachedPropertiesObject">
<db:title>QObject *qmlAttachedPropertiesObject(const QObject *<db:emphasis>attachee</db:emphasis>, bool <db:emphasis>create</db:emphasis> = true)</db:title>
<db:para>The form of this template function is:</db:para>
<db:programlisting language="cpp">template&lt;typename T&gt; QObject *qmlAttachedPropertiesObject(const QObject *attachee, bool create = true)
</db:programlisting>
<db:para>This returns the attached object instance that has been attached to the specified <db:code role="parameter">attachee</db:code> by the attaching type <db:emphasis>T</db:emphasis>.</db:para>
<db:para>If <db:code role="parameter">create</db:code> is true and type <db:emphasis>T</db:emphasis> is a valid attaching type, this creates and returns a new attached object instance.</db:para>
<db:para>Returns nullptr if type <db:emphasis>T</db:emphasis> is not a valid attaching type, or if <db:code role="parameter">create</db:code> is false and no attachment object instance has previously been created for <db:code role="parameter">attachee</db:code>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qqmlintegration-h.xml#QML_ATTACHED">QML_ATTACHED</db:link>()</db:member>
<db:member><db:link xlink:href="qtqml-cppintegration-definetypes.xml#providing-attached-properties">Providing Attached Properties</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="qmlClearTypeRegistrations">
<db:title>void qmlClearTypeRegistrations()</db:title>
<db:para>Clears all stored type registrations, such as those produced with <db:link xlink:href="qqml-h.xml#qmlRegisterType">qmlRegisterType</db:link>().</db:para>
<db:para>Do not call this function while a <db:link xlink:href="qqmlengine.xml">QQmlEngine</db:link> exists or behavior will be undefined. Any existing QQmlEngines must be deleted before calling this function. This function only affects the application global cache. Delete the <db:link xlink:href="qqmlengine.xml">QQmlEngine</db:link> to clear all cached data relating to that engine.</db:para>
</db:section>
<db:section xml:id="qmlExtendedObject">
<db:title>QObject *qmlExtendedObject(QObject *<db:emphasis>base</db:emphasis>)</db:title>
<db:para>This function returns the extension object that belongs to <db:code role="parameter">base</db:code>, if there is any. Otherwise it returns nullptr.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qqmlintegration-h.xml#QML_EXTENDED">QML_EXTENDED</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="qmlProtectModule">
<db:title>bool qmlProtectModule(const char *<db:emphasis>uri</db:emphasis>, int <db:emphasis>majVersion</db:emphasis>)</db:title>
<db:para>This function protects a module from further modification. This can be used to prevent other plugins from injecting types into your module. It can also be a performance improvement, as it allows the engine to skip checking for the possibility of new types or plugins when this import is reached.</db:para>
<db:para>Once qmlProtectModule has been called, a QML engine will not search for a new qmldir file to load the module anymore. It will re-use any qmldir files it has loaded before, though. Therefore, types present at this point continue to work. Mind that different QML engines may load different modules. The module protection, however, is global and affects all engines. The overhead of locating qmldir files and loading plugins may be noticeable with slow file systems. Therefore, protecting a module once you are sure you won't need to load it anymore can be a good optimization. Mind also that the module lock not only affects plugins but also any other qmldir directives, like import or prefer, as well as any composite types or scripts declared in a qmldir file.</db:para>
<db:para>In addition, after this function is called, any attempt to register C++ types into this uri, major version combination will lead to a runtime error.</db:para>
<db:para>Returns true if the module with <db:code role="parameter">uri</db:code> as a <db:link xlink:href="qtqml-modules-identifiedmodules.xml">module identifier</db:link> and <db:code role="parameter">majVersion</db:code> as a major version number was found and locked, otherwise returns false. The module must contain exported types in order to be found.</db:para>
</db:section>
<db:section xml:id="qmlRegisterAnonymousType">
<db:title>int qmlRegisterAnonymousType(const char *<db:emphasis>uri</db:emphasis>, int <db:emphasis>versionMajor</db:emphasis>)</db:title>
<db:para>This template function registers the C++ type in the QML system as an anonymous type. The resulting QML type does not have a name. Therefore, instances of this type cannot be created from the QML system. You can, however, access instances of the type when they are exposed as properties of other types.</db:para>
<db:para>Use this function when the type will not be referenced by name, specifically for C++ types that are used on the left-hand side of a property binding. To indicate to which module the type belongs use <db:code role="parameter">uri</db:code> and <db:code role="parameter">versionMajor</db:code>.</db:para>
<db:para>For example, consider the following two classes:</db:para>
<db:programlisting language="cpp">class Bar : public QObject
{
    Q_OBJECT
    Q_PROPERTY(QString baz READ baz WRITE setBaz NOTIFY bazChanged)

public:
    Bar() {}

    QString baz() const { return mBaz; }

    void setBaz(const QString &amp;baz)
    {
        if (baz == mBaz)
            return;

        mBaz = baz;
        emit bazChanged();
    }

signals:
    void bazChanged();

private:
    QString mBaz;
};

class Foo : public QObject
{
    Q_OBJECT
    Q_PROPERTY(Bar *bar READ bar CONSTANT FINAL)

public:
    Foo() {}

    Bar *bar() { return &amp;mBar; }

private:
    Bar mBar;
};
</db:programlisting>
<db:para>In QML, we assign a string to the baz property of bar:</db:para>
<db:programlisting language="cpp">Foo {
    bar.baz: &quot;abc&quot;
    Component.onCompleted: print(bar.baz)
}
</db:programlisting>
<db:para>For the QML engine to know that the Bar type has a baz property, we have to make Bar known:</db:para>
<db:programlisting language="cpp">qmlRegisterType&lt;Foo&gt;(&quot;App&quot;, 1, 0, &quot;Foo&quot;);
qmlRegisterAnonymousType&lt;Bar&gt;(&quot;App&quot;, 1);
</db:programlisting>
<db:para>As the Foo type is instantiated in QML, it must be registered with the version of <db:link xlink:href="qqml-h.xml#qmlRegisterType">qmlRegisterType</db:link>() that takes an element name.</db:para>
<db:para>Returns the QML type id.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qqmlintegration-h.xml#QML_ANONYMOUS">QML_ANONYMOUS</db:link></db:member>
<db:member><db:link xlink:href="qtqml-cppintegration-overview.xml#choosing-the-correct-integration-method-between-c-and-qml">Choosing the Correct Integration Method Between C++ and QML</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="qmlRegisterExtendedType">
<db:title>int qmlRegisterExtendedType(const char *<db:emphasis>uri</db:emphasis>, int <db:emphasis>versionMajor</db:emphasis>, int <db:emphasis>versionMinor</db:emphasis>, const char *<db:emphasis>qmlName</db:emphasis>)</db:title>
<db:para>This template function registers the C++ type and its extension object in the QML system with the name <db:code role="parameter">qmlName</db:code> in the library imported from <db:code role="parameter">uri</db:code> having version number composed from <db:code role="parameter">versionMajor</db:code> and <db:code role="parameter">versionMinor</db:code>. Properties not available in the main type will be searched for in the extension object.</db:para>
<db:para>Returns the QML type id.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qqmlintegration-h.xml#QML_EXTENDED">QML_EXTENDED</db:link>()</db:member>
<db:member><db:link xlink:href="qqml-h.xml#qmlRegisterType">qmlRegisterType</db:link>()</db:member>
<db:member><db:link xlink:href="qtqml-cppintegration-definetypes.xml#registering-extension-objects">Registering Extension Objects</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="qmlRegisterExtendedUncreatableType">
<db:title>int qmlRegisterExtendedUncreatableType(const char *<db:emphasis>uri</db:emphasis>, int <db:emphasis>versionMajor</db:emphasis>, int <db:emphasis>versionMinor</db:emphasis>, const char *<db:emphasis>qmlName</db:emphasis>, const QString &amp;<db:emphasis>reason</db:emphasis>)</db:title>
<db:para>This template function registers the C++ type and its extension in the QML system with the name <db:code role="parameter">qmlName</db:code> in the library imported from <db:code role="parameter">uri</db:code> having version number composed from <db:code role="parameter">versionMajor</db:code> and <db:code role="parameter">versionMinor</db:code>.</db:para>
<db:para>While the type has a name and a type, it cannot be created. An error message with the given <db:code role="parameter">reason</db:code> is printed if the user attempts to create an instance of this type.</db:para>
<db:para>This is useful where the type is only intended for providing attached properties, enum values or an abstract base class with its extension.</db:para>
<db:para>Returns the QML type id.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qqmlintegration-h.xml#QML_EXTENDED">QML_EXTENDED</db:link>()</db:member>
<db:member><db:link xlink:href="qqmlintegration-h.xml#QML_UNCREATABLE">QML_UNCREATABLE</db:link>()</db:member>
<db:member><db:link xlink:href="qqml-h.xml#qmlRegisterUncreatableType">qmlRegisterUncreatableType</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="qmlRegisterModule">
<db:title>void qmlRegisterModule(const char *<db:emphasis>uri</db:emphasis>, int <db:emphasis>versionMajor</db:emphasis>, int <db:emphasis>versionMinor</db:emphasis>)</db:title>
<db:para>This function registers a module in a particular <db:code role="parameter">uri</db:code> with a version specified in <db:code role="parameter">versionMajor</db:code> and <db:code role="parameter">versionMinor</db:code>.</db:para>
<db:para>This can be used to make a certain module version available, even if no types are registered for that version. This is particularly useful for keeping the versions of related modules in sync.</db:para>
</db:section>
<db:section xml:id="qmlRegisterModuleImport">
<db:title>void qmlRegisterModuleImport(const char *<db:emphasis>uri</db:emphasis>, int <db:emphasis>moduleMajor</db:emphasis>, const char *<db:emphasis>import</db:emphasis>, int <db:emphasis>importMajor</db:emphasis> = QQmlModuleImportLatest, int <db:emphasis>importMinor</db:emphasis> = QQmlModuleImportLatest)</db:title>
<db:para>Registers a qmldir-import for module <db:code role="parameter">uri</db:code> of major version <db:code role="parameter">moduleMajor</db:code>.</db:para>
<db:para>This has the same effect as an import statement in a qmldir file: Whenever <db:code role="parameter">uri</db:code> of version <db:code role="parameter">moduleMajor</db:code> is imported, <db:code role="parameter">import</db:code> of version <db:code role="parameter">importMajor</db:code>. <db:code role="parameter">importMinor</db:code> is automatically imported, too. If <db:code role="parameter">importMajor</db:code> is <db:link xlink:href="qqml-h.xml#QQmlModuleImportSpecialVersions-enum">QQmlModuleImportLatest</db:link> the latest version available of that module is imported, and <db:code role="parameter">importMinor</db:code> does not matter. If <db:code role="parameter">importMinor</db:code> is <db:link xlink:href="qqml-h.xml#QQmlModuleImportSpecialVersions-enum">QQmlModuleImportLatest</db:link> the latest minor version of a <db:code role="parameter">importMajor</db:code> is chosen. If <db:code role="parameter">importMajor</db:code> is <db:link xlink:href="qqml-h.xml#QQmlModuleImportSpecialVersions-enum">QQmlModuleImportAuto</db:link> the version of <db:code role="parameter">import</db:code> is version of <db:code role="parameter">uri</db:code> being imported, and <db:code role="parameter">importMinor</db:code> does not matter. If <db:code role="parameter">moduleMajor</db:code> is <db:link xlink:href="qqml-h.xml#QQmlModuleImportSpecialVersions-enum">QQmlModuleImportModuleAny</db:link> the module import is applied for any major version of <db:code role="parameter">uri</db:code>. For example, you may specify that whenever any version of MyModule is imported, the latest version of MyOtherModule should be imported. Then, the following call would be appropriate:</db:para>
<db:programlisting language="cpp">qmlRegisterModuleImport(&quot;MyModule&quot;, QQmlModuleImportModuleAny,
                        &quot;MyOtherModule&quot;, QQmlModuleImportLatest);
</db:programlisting>
<db:para>Or, you may specify that whenever major version 5 of &quot;MyModule&quot; is imported, then version 3.14 of &quot;MyOtherModule&quot; should be imported:</db:para>
<db:programlisting language="cpp">qmlRegisterModuleImport(&quot;MyModule&quot;, 5, &quot;MyOtherModule&quot;, 3, 14);
</db:programlisting>
<db:para>Finally, if you always want the same version of &quot;MyOtherModule&quot; to be imported whenever &quot;MyModule&quot; is imported, specify the following:</db:para>
<db:programlisting language="cpp">qmlRegisterModuleImport(&quot;MyModule&quot;, QQmlModuleImportModuleAny,
                        &quot;MyOtherModule&quot;, QQmlModuleImportAuto);
</db:programlisting>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qqml-h.xml#qmlUnregisterModuleImport">qmlUnregisterModuleImport</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="qmlRegisterRevision">
<db:title>int qmlRegisterRevision(const char *<db:emphasis>uri</db:emphasis>, int <db:emphasis>versionMajor</db:emphasis>, int <db:emphasis>versionMinor</db:emphasis>)</db:title>
<db:para>This template function registers the specified revision of a C++ type in the QML system with the library imported from <db:code role="parameter">uri</db:code> having the version number composed from <db:code role="parameter">versionMajor</db:code> and <db:code role="parameter">versionMinor</db:code>.</db:para>
<db:para>Returns the QML type id.</db:para>
<db:programlisting language="cpp">template&lt;typename T, int metaObjectRevision&gt;
int qmlRegisterRevision(const char *uri, int versionMajor, int versionMinor);
</db:programlisting>
<db:para>This function is typically used to register the revision of a base class to use for the specified version of the type (see <db:link xlink:href="qtqml-cppintegration-definetypes.xml#type-revisions-and-versions">Type Revisions and Versions</db:link>).</db:para>
</db:section>
<db:section xml:id="qmlRegisterSingletonInstance">
<db:title>int qmlRegisterSingletonInstance(const char *<db:emphasis>uri</db:emphasis>, int <db:emphasis>versionMajor</db:emphasis>, int <db:emphasis>versionMinor</db:emphasis>, const char *<db:emphasis>typeName</db:emphasis>, QObject *<db:emphasis>cppObject</db:emphasis>)</db:title>
<db:para>This function is used to register a singleton object <db:code role="parameter">cppObject</db:code>, with a particular <db:code role="parameter">uri</db:code> and <db:code role="parameter">typeName</db:code>. Its version is a combination of <db:code role="parameter">versionMajor</db:code> and <db:code role="parameter">versionMinor</db:code>.</db:para>
<db:para>Installing a singleton type into a URI allows you to provide arbitrary functionality (methods and properties) to QML code without requiring individual instances of the type to be instantiated by the client.</db:para>
<db:para>Use this function to register an object of the given type T as a singleton type.</db:para>
<db:para>A <db:link xlink:href="qobject.xml">QObject</db:link> singleton type may be referenced via the type name with which it was registered; in turn this type name may be used as the target in a <db:link xlink:href="qml-qtqml-connections.xml">Connections</db:link> type, or like any other type ID. However, there's one exception: a <db:link xlink:href="qobject.xml">QObject</db:link> singleton type property can't be aliased because the singleton type name does not identify an object within the same component as any other item.</db:para>
<db:note>
<db:para><db:code role="parameter">cppObject</db:code> must outlive the QML engine in which it is used. Moreover, cppObject must have the same thread affinity as the engine. If you want separate singleton instances for multiple engines, you need to use <db:link xlink:href="qqml-h.xml#qmlRegisterSingletonType">qmlRegisterSingletonType</db:link>. See <db:link xlink:href="">Threads and QObjects</db:link> for more information about thread safety.</db:para>
</db:note>
<db:para><db:emphasis role="bold">NOTE:</db:emphasis> qmlRegisterSingleton can only be used when all types of that module are registered procedurally.</db:para>
<db:para>Usage:</db:para>
<db:programlisting language="cpp">// First, define your QObject which provides the functionality.
class SingletonTypeExample : public QObject
{
    Q_OBJECT
    Q_PROPERTY(int someProperty READ someProperty WRITE setSomeProperty NOTIFY somePropertyChanged)

public:
    explicit SingletonTypeExample(QObject* parent = nullptr) : QObject(parent) {}

    Q_INVOKABLE int doSomething()
    {
        setSomeProperty(5);
        return m_someProperty;
    }

    int someProperty() const { return m_someProperty; }
    void setSomeProperty(int val) {
        if (m_someProperty != val) {
            m_someProperty = val;
            emit somePropertyChanged(val);
        }
    }

signals:
    void somePropertyChanged(int newValue);

private:
    int m_someProperty = 0;
};
</db:programlisting>
<db:programlisting language="cpp">// Second, create an instance of the object

// allocate example before the engine to ensure that it outlives it
QScopedPointer&lt;SingletonTypeExample&gt; example(new SingletonTypeExample);
QQmlEngine engine;

// Third, register the singleton type provider with QML by calling this
// function in an initialization function.
qmlRegisterSingletonInstance(&quot;Qt.example.qobjectSingleton&quot;, 1, 0, &quot;MyApi&quot;, example.get());
</db:programlisting>
<db:para>In order to use the registered singleton type in QML, you must import the URI with the corresponding version.</db:para>
<db:programlisting language="qml">import QtQuick 2.0
import Qt.example.qobjectSingleton 1.0
Item {
    id: root
    property int someValue: MyApi.someProperty

    Component.onCompleted: {
        console.log(MyApi.doSomething())
    }
}
</db:programlisting>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qqmlintegration-h.xml#QML_SINGLETON">QML_SINGLETON</db:link></db:member>
<db:member><db:link xlink:href="qqml-h.xml#qmlRegisterSingletonType">qmlRegisterSingletonType</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="qmlRegisterSingletonType">
<db:title>int qmlRegisterSingletonType(const QUrl &amp;<db:emphasis>url</db:emphasis>, const char *<db:emphasis>uri</db:emphasis>, int <db:emphasis>versionMajor</db:emphasis>, int <db:emphasis>versionMinor</db:emphasis>, const char *<db:emphasis>qmlName</db:emphasis>)</db:title>
<db:para>This function may be used to register a singleton type with the name <db:code role="parameter">qmlName</db:code>, in the library imported from <db:code role="parameter">uri</db:code> having the version number composed from <db:code role="parameter">versionMajor</db:code> and <db:code role="parameter">versionMinor</db:code>. The type is defined by the QML file located at <db:code role="parameter">url</db:code>. The url must be an absolute URL, i.e. url.isRelative() == false.</db:para>
<db:para>In addition the type's QML file must have pragma Singleton statement among its import statements.</db:para>
<db:para>A singleton type may be referenced via the type name with which it was registered, and this typename may be used as the target in a <db:link xlink:href="qml-qtqml-connections.xml">Connections</db:link> type or otherwise used as any other type id would. One exception to this is that a singleton type property may not be aliased (because the singleton type name does not identify an object within the same component as any other item).</db:para>
<db:para>Usage:</db:para>
<db:programlisting language="qml">// First, define your QML singleton type which provides the functionality.
pragma Singleton
import QtQuick 2.0
Item {
    property int testProp1: 125
}
</db:programlisting>
<db:programlisting language="cpp">// Second, register the QML singleton type by calling this function in an initialization function.
qmlRegisterSingletonType(QUrl(&quot;file:///absolute/path/SingletonType.qml&quot;), &quot;Qt.example.qobjectSingleton&quot;, 1, 0, &quot;RegisteredSingleton&quot;);
</db:programlisting>
<db:para>In order to use the registered singleton type in QML, you must import the singleton type.</db:para>
<db:programlisting language="qml">import QtQuick 2.0
import Qt.example.qobjectSingleton 1.0
Item {
    id: root
    property int someValue: RegisteredSingleton.testProp1
}
</db:programlisting>
<db:para>It is also possible to have QML singleton types registered without using the qmlRegisterSingletonType function. That can be done by adding a pragma Singleton statement among the imports of the type's QML file. In addition the type must be defined in a qmldir file with a singleton keyword and the qmldir must be imported by the QML files using the singleton.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qqmlintegration-h.xml#QML_SINGLETON">QML_SINGLETON</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="qmlRegisterSingletonType-1">
<db:title>int qmlRegisterSingletonType(const char *<db:emphasis>uri</db:emphasis>, int <db:emphasis>versionMajor</db:emphasis>, int <db:emphasis>versionMinor</db:emphasis>, const char *<db:emphasis>typeName</db:emphasis>, std::function&lt;QJSValue (QQmlEngine *, QJSEngine *)&gt; <db:emphasis>callback</db:emphasis>)</db:title>
<db:para>This function may be used to register a singleton type provider <db:code role="parameter">callback</db:code> in a particular <db:code role="parameter">uri</db:code> and <db:code role="parameter">typeName</db:code> with a version specified in <db:code role="parameter">versionMajor</db:code> and <db:code role="parameter">versionMinor</db:code>.</db:para>
<db:para>Installing a singleton type allows developers to provide arbitrary functionality (methods and properties) to a client without requiring individual instances of the type to be instantiated by the client.</db:para>
<db:para>A singleton type may be either a <db:link xlink:href="qobject.xml">QObject</db:link> or a <db:link xlink:href="qjsvalue.xml">QJSValue</db:link>. This function should be used to register a singleton type provider function which returns a <db:link xlink:href="qjsvalue.xml">QJSValue</db:link> as a singleton type.</db:para>
<db:para><db:emphasis role="bold">NOTE:</db:emphasis> <db:link xlink:href="qjsvalue.xml">QJSValue</db:link> singleton type properties will <db:emphasis role="bold">not</db:emphasis> trigger binding re-evaluation if changed.</db:para>
<db:para>Usage:</db:para>
<db:programlisting language="cpp">// First, define the singleton type provider function (callback).
static QJSValue example_qjsvalue_singletontype_provider(QQmlEngine *engine, QJSEngine *scriptEngine)
{
    Q_UNUSED(engine)

    static int seedValue = 5;
    QJSValue example = scriptEngine-&gt;newObject();
    example.setProperty(&quot;someProperty&quot;, seedValue++);
    return example;
}

// Second, register the singleton type provider with QML by calling this function in an initialization function.
qmlRegisterSingletonType(&quot;Qt.example.qjsvalueApi&quot;, 1, 0, &quot;MyApi&quot;, example_qjsvalue_singletontype_provider);
</db:programlisting>
<db:para>Alternatively, you can use a C++11 lambda:</db:para>
<db:programlisting language="cpp">qmlRegisterSingletonType(&quot;Qt.example.qjsvalueApi&quot;, 1, 0, &quot;MyApi&quot;, [](QQmlEngine *engine, QJSEngine *scriptEngine) -&gt; QJSValue {
    Q_UNUSED(engine)

    static int seedValue = 5;
    QJSValue example = scriptEngine-&gt;newObject();
    example.setProperty(&quot;someProperty&quot;, seedValue++);
    return example;
});
</db:programlisting>
<db:para>In order to use the registered singleton type in QML, you must import the singleton type.</db:para>
<db:programlisting language="qml">import QtQuick 2.0
import Qt.example.qjsvalueApi 1.0 as ExampleApi
Item {
    id: root
    property int someValue: ExampleApi.MyApi.someProperty
}
</db:programlisting>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qqmlintegration-h.xml#QML_SINGLETON">QML_SINGLETON</db:link></db:member>
<db:member><db:link xlink:href="qtqml-cppintegration-overview.xml#choosing-the-correct-integration-method-between-c-and-qml">Choosing the Correct Integration Method Between C++ and QML</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="qmlRegisterSingletonType-2">
<db:title>int qmlRegisterSingletonType(const char *<db:emphasis>uri</db:emphasis>, int <db:emphasis>versionMajor</db:emphasis>, int <db:emphasis>versionMinor</db:emphasis>, const char *<db:emphasis>typeName</db:emphasis>, std::function&lt;QObject *(QQmlEngine *, QJSEngine *)&gt; <db:emphasis>callback</db:emphasis>)</db:title>
<db:para>This function may be used to register a singleton type provider <db:code role="parameter">callback</db:code> in a particular <db:code role="parameter">uri</db:code> and <db:code role="parameter">typeName</db:code> with a version specified in <db:code role="parameter">versionMajor</db:code> and <db:code role="parameter">versionMinor</db:code>.</db:para>
<db:para>Installing a singleton type into a uri allows developers to provide arbitrary functionality (methods and properties) to clients without requiring individual instances ot the type to be instantiated by the client.</db:para>
<db:para>A singleton type may be either a <db:link xlink:href="qobject.xml">QObject</db:link> or a <db:link xlink:href="qjsvalue.xml">QJSValue</db:link>. This function should be used to register a singleton type provider function which returns a <db:link xlink:href="qobject.xml">QObject</db:link> of the given type T as a singleton type.</db:para>
<db:para>A <db:link xlink:href="qobject.xml">QObject</db:link> singleton type may be referenced via the type name with which it was registered, and this typename may be used as the target in a <db:link xlink:href="qml-qtqml-connections.xml">Connections</db:link> type or otherwise used as any other type id would. One exception to this is that a <db:link xlink:href="qobject.xml">QObject</db:link> singleton type property may not be aliased.</db:para>
<db:para><db:emphasis role="bold">NOTE:</db:emphasis> A <db:link xlink:href="qobject.xml">QObject</db:link> singleton type instance returned from a singleton type provider is owned by the QML engine unless the object has explicit QQmlEngine::CppOwnership flag set.</db:para>
<db:para>Usage:</db:para>
<db:programlisting language="cpp">// First, define your QObject which provides the functionality.
class SingletonTypeExample : public QObject
{
    Q_OBJECT
    Q_PROPERTY (int someProperty READ someProperty WRITE setSomeProperty NOTIFY somePropertyChanged)

public:
    SingletonTypeExample(QObject *parent = nullptr)
        : QObject(parent), m_someProperty(0)
    {
    }

    ~SingletonTypeExample() {}

    Q_INVOKABLE int doSomething() { setSomeProperty(5); return m_someProperty; }

    int someProperty() const { return m_someProperty; }
    void setSomeProperty(int val) { m_someProperty = val; emit somePropertyChanged(val); }

signals:
    void somePropertyChanged(int newValue);

private:
    int m_someProperty;
};

// Second, define the singleton type provider function (callback).
static QObject *example_qobject_singletontype_provider(QQmlEngine *engine, QJSEngine *scriptEngine)
{
    Q_UNUSED(engine)
    Q_UNUSED(scriptEngine)

    SingletonTypeExample *example = new SingletonTypeExample();
    return example;
}

// Third, register the singleton type provider with QML by calling this function in an initialization function.
qmlRegisterSingletonType&lt;SingletonTypeExample&gt;(&quot;Qt.example.qobjectSingleton&quot;, 1, 0, &quot;MyApi&quot;, example_qobject_singletontype_provider);
</db:programlisting>
<db:para>Alternatively, you can use a C++11 lambda:</db:para>
<db:programlisting language="cpp">qmlRegisterSingletonType&lt;SingletonTypeExample&gt;(&quot;Qt.example.qobjectSingleton&quot;, 1, 0, &quot;MyApi&quot;, [](QQmlEngine *engine, QJSEngine *scriptEngine) -&gt; QObject * {
    Q_UNUSED(engine)
    Q_UNUSED(scriptEngine)

    SingletonTypeExample *example = new SingletonTypeExample();
    return example;
});
</db:programlisting>
<db:para>In order to use the registered singleton type in QML, you must import the singleton type.</db:para>
<db:programlisting language="qml">import QtQuick 2.0
import Qt.example.qobjectSingleton 1.0
Item {
    id: root
    property int someValue: MyApi.someProperty

    Component.onCompleted: {
        someValue = MyApi.doSomething()
    }
}
</db:programlisting>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qqmlintegration-h.xml#QML_SINGLETON">QML_SINGLETON</db:link></db:member>
<db:member><db:link xlink:href="qtqml-cppintegration-overview.xml#choosing-the-correct-integration-method-between-c-and-qml">Choosing the Correct Integration Method Between C++ and QML</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="qmlRegisterType">
<db:title>int qmlRegisterType(const char *<db:emphasis>uri</db:emphasis>, int <db:emphasis>versionMajor</db:emphasis>, int <db:emphasis>versionMinor</db:emphasis>, const char *<db:emphasis>qmlName</db:emphasis>)</db:title>
<db:para>This template function registers the C++ type in the QML system with the name <db:code role="parameter">qmlName</db:code>, in the library imported from <db:code role="parameter">uri</db:code> having the version number composed from <db:code role="parameter">versionMajor</db:code> and <db:code role="parameter">versionMinor</db:code>.</db:para>
<db:para>Returns the QML type id.</db:para>
<db:para>There are two forms of this template function:</db:para>
<db:programlisting language="cpp">template&lt;typename T&gt;
int qmlRegisterType(const char *uri, int versionMajor, int versionMinor, const char *qmlName);

template&lt;typename T, int metaObjectRevision&gt;
int qmlRegisterType(const char *uri, int versionMajor, int versionMinor, const char *qmlName);
</db:programlisting>
<db:para>The former is the standard form which registers the type <db:emphasis>T</db:emphasis> as a new type. The latter allows a particular revision of a class to be registered in a specified version (see <db:link xlink:href="qtqml-cppintegration-definetypes.xml#type-revisions-and-versions">Type Revisions and Versions</db:link>).</db:para>
<db:para>For example, this registers a C++ class MySliderItem as a QML type named Slider for version 1.0 of a type namespace called &quot;com.mycompany.qmlcomponents&quot;:</db:para>
<db:programlisting language="cpp">qmlRegisterType&lt;MySliderItem&gt;(&quot;com.mycompany.qmlcomponents&quot;, 1, 0, &quot;Slider&quot;);
</db:programlisting>
<db:para>Once this is registered, the type can be used in QML by importing the specified type namespace and version number:</db:para>
<db:programlisting language="qml">import com.mycompany.qmlcomponents 1.0

Slider {
    // ...
}
</db:programlisting>
<db:para>Note that it's perfectly reasonable for a library to register types to older versions than the actual version of the library. Indeed, it is normal for the new library to allow QML written to previous versions to continue to work, even if more advanced versions of some of its types are available.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qqmlintegration-h.xml#QML_ELEMENT">QML_ELEMENT</db:link></db:member>
<db:member><db:link xlink:href="qqmlintegration-h.xml#QML_NAMED_ELEMENT">QML_NAMED_ELEMENT</db:link>()</db:member>
<db:member><db:link xlink:href="qtqml-cppintegration-overview.xml#choosing-the-correct-integration-method-between-c-and-qml">Choosing the Correct Integration Method Between C++ and QML</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="qmlRegisterType-1">
<db:title>int qmlRegisterType(const QUrl &amp;<db:emphasis>url</db:emphasis>, const char *<db:emphasis>uri</db:emphasis>, int <db:emphasis>versionMajor</db:emphasis>, int <db:emphasis>versionMinor</db:emphasis>, const char *<db:emphasis>qmlName</db:emphasis>)</db:title>
<db:para>This function registers a type in the QML system with the name <db:code role="parameter">qmlName</db:code>, in the library imported from <db:code role="parameter">uri</db:code> having the version number composed from <db:code role="parameter">versionMajor</db:code> and <db:code role="parameter">versionMinor</db:code>. The type is defined by the QML file located at <db:code role="parameter">url</db:code>. The url must be an absolute URL, i.e. url.isRelative() == false.</db:para>
<db:para>Normally QML files can be loaded as types directly from other QML files, or using a qmldir file. This function allows registration of files to types from C++ code, such as when the type mapping needs to be procedurally determined at startup.</db:para>
<db:para>Returns -1 if the registration was not successful.</db:para>
</db:section>
<db:section xml:id="qmlRegisterTypeNotAvailable">
<db:title>int qmlRegisterTypeNotAvailable(const char *<db:emphasis>uri</db:emphasis>, int <db:emphasis>versionMajor</db:emphasis>, int <db:emphasis>versionMinor</db:emphasis>, const char *<db:emphasis>qmlName</db:emphasis>, const QString &amp;<db:emphasis>message</db:emphasis>)</db:title>
<db:para>This function registers a type in the QML system with the name <db:code role="parameter">qmlName</db:code>, in the type namespace imported from <db:code role="parameter">uri</db:code> having the version number composed from <db:code role="parameter">versionMajor</db:code> and <db:code role="parameter">versionMinor</db:code>, but any attempt to instantiate the type will produce the given error <db:code role="parameter">message</db:code>.</db:para>
<db:para>Normally, the types exported by a plugin should be fixed. However, if a C++ type is not available, you should at least &quot;reserve&quot; the QML type name, and give the user of the unavailable type a meaningful error message.</db:para>
<db:para>Returns the QML type id.</db:para>
<db:para>Example:</db:para>
<db:programlisting language="cpp">#ifdef NO_GAMES_ALLOWED
qmlRegisterTypeNotAvailable(&quot;MinehuntCore&quot;, 0, 1, &quot;Game&quot;, &quot;Get back to work, slacker!&quot;);
#else
qmlRegisterType&lt;MinehuntGame&gt;(&quot;MinehuntCore&quot;, 0, 1, &quot;Game&quot;);
#endif
</db:programlisting>
<db:para>This will cause any QML which imports the &quot;MinehuntCore&quot; type namespace and attempts to use the type to produce an error message:</db:para>
<db:programlisting language="cpp">fun.qml: Get back to work, slacker!
   Game {
   ^
</db:programlisting>
<db:para>Without this, a generic &quot;Game is not a type&quot; message would be given.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qqmlintegration-h.xml#QML_UNAVAILABLE">QML_UNAVAILABLE</db:link></db:member>
<db:member><db:link xlink:href="qqml-h.xml#qmlRegisterUncreatableType">qmlRegisterUncreatableType</db:link>()</db:member>
<db:member><db:link xlink:href="qtqml-cppintegration-overview.xml#choosing-the-correct-integration-method-between-c-and-qml">Choosing the Correct Integration Method Between C++ and QML</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="qmlRegisterUncreatableMetaObject">
<db:title>int qmlRegisterUncreatableMetaObject(const QMetaObject &amp;<db:emphasis>staticMetaObject</db:emphasis>, const char *<db:emphasis>uri</db:emphasis>, int <db:emphasis>versionMajor</db:emphasis>, int <db:emphasis>versionMinor</db:emphasis>, const char *<db:emphasis>qmlName</db:emphasis>, const QString &amp;<db:emphasis>reason</db:emphasis>)</db:title>
<db:para>This function registers the <db:code role="parameter">staticMetaObject</db:code> and its extension in the QML system with the name <db:code role="parameter">qmlName</db:code> in the library imported from <db:code role="parameter">uri</db:code> having version number composed from <db:code role="parameter">versionMajor</db:code> and <db:code role="parameter">versionMinor</db:code>.</db:para>
<db:para>An instance of the meta object cannot be created. An error message with the given <db:code role="parameter">reason</db:code> is printed if the user attempts to create it.</db:para>
<db:para>This function is useful for registering <db:link xlink:href="qobject.xml#Q_NAMESPACE">Q_NAMESPACE</db:link> namespaces.</db:para>
<db:para>Returns the QML type id.</db:para>
<db:para>For example:</db:para>
<db:programlisting language="cpp">namespace MyNamespace {
  Q_NAMESPACE
  enum MyEnum {
      Key1,
      Key2,
  };
  Q_ENUM_NS(MyEnum)
}

//...
qmlRegisterUncreatableMetaObject(MyNamespace::staticMetaObject, &quot;io.qt&quot;, 1, 0, &quot;MyNamespace&quot;, &quot;Access to enums &amp; flags only&quot;);
</db:programlisting>
<db:para>On the QML side, you can now use the registered enums:</db:para>
<db:programlisting language="cpp">Component.onCompleted: console.log(MyNamespace.Key2)
</db:programlisting>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qqmlintegration-h.xml#QML_ELEMENT">QML_ELEMENT</db:link></db:member>
<db:member><db:link xlink:href="qqmlintegration-h.xml#QML_NAMED_ELEMENT">QML_NAMED_ELEMENT</db:link>()</db:member>
<db:member><db:link xlink:href="qqmlintegration-h.xml#QML_UNCREATABLE">QML_UNCREATABLE</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="qmlRegisterUncreatableType">
<db:title>int qmlRegisterUncreatableType(const char *<db:emphasis>uri</db:emphasis>, int <db:emphasis>versionMajor</db:emphasis>, int <db:emphasis>versionMinor</db:emphasis>, const char *<db:emphasis>qmlName</db:emphasis>, const QString &amp;<db:emphasis>message</db:emphasis>)</db:title>
<db:para>This template function registers the C++ type in the QML system with the name <db:code role="parameter">qmlName</db:code>, in the library imported from <db:code role="parameter">uri</db:code> having the version number composed from <db:code role="parameter">versionMajor</db:code> and <db:code role="parameter">versionMinor</db:code>.</db:para>
<db:para>While the type has a name and a type, it cannot be created, and the given error <db:code role="parameter">message</db:code> will result if creation is attempted.</db:para>
<db:para>This is useful where the type is only intended for providing attached properties or enum values.</db:para>
<db:para>Returns the QML type id.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qqmlintegration-h.xml#QML_UNCREATABLE">QML_UNCREATABLE</db:link>()</db:member>
<db:member><db:link xlink:href="qqml-h.xml#qmlRegisterTypeNotAvailable">qmlRegisterTypeNotAvailable</db:link>()</db:member>
<db:member><db:link xlink:href="qtqml-cppintegration-overview.xml#choosing-the-correct-integration-method-between-c-and-qml">Choosing the Correct Integration Method Between C++ and QML</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="qmlTypeId">
<db:title>int qmlTypeId(const char *<db:emphasis>uri</db:emphasis>, int <db:emphasis>versionMajor</db:emphasis>, int <db:emphasis>versionMinor</db:emphasis>, const char *<db:emphasis>qmlName</db:emphasis>)</db:title>
<db:para>Returns the QML type id of a type that was registered with the name <db:code role="parameter">qmlName</db:code> in a particular <db:code role="parameter">uri</db:code> and a version specified in <db:code role="parameter">versionMajor</db:code> and <db:code role="parameter">versionMinor</db:code>.</db:para>
<db:para>This function returns the same value as the QML type registration functions such as <db:link xlink:href="qqml-h.xml#qmlRegisterType">qmlRegisterType</db:link>() and <db:link xlink:href="qqml-h.xml#qmlRegisterSingletonType">qmlRegisterSingletonType</db:link>().</db:para>
<db:para>If <db:code role="parameter">qmlName</db:code>, <db:code role="parameter">uri</db:code> and <db:code role="parameter">versionMajor</db:code> match a registered type, but the specified minor version in <db:code role="parameter">versionMinor</db:code> is higher, then the id of the type with the closest minor version is returned.</db:para>
<db:para>Returns -1 if no matching type was found or one of the given parameters was invalid.</db:para>
<db:note>
<db:para>: qmlTypeId tries to make modules available, even if they were not accessed by any engine yet. This can introduce overhead the first time a module is accessed. Trying to find types from a module which does not exist always introduces this overhead.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qqmlintegration-h.xml#QML_ELEMENT">QML_ELEMENT</db:link></db:member>
<db:member><db:link xlink:href="qqmlintegration-h.xml#QML_NAMED_ELEMENT">QML_NAMED_ELEMENT</db:link></db:member>
<db:member><db:link xlink:href="qqmlintegration-h.xml#QML_SINGLETON">QML_SINGLETON</db:link></db:member>
<db:member><db:link xlink:href="qqml-h.xml#qmlRegisterType">qmlRegisterType</db:link>()</db:member>
<db:member><db:link xlink:href="qqml-h.xml#qmlRegisterSingletonType">qmlRegisterSingletonType</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="qmlUnregisterModuleImport">
<db:title>void qmlUnregisterModuleImport(const char *<db:emphasis>uri</db:emphasis>, int <db:emphasis>moduleMajor</db:emphasis>, const char *<db:emphasis>import</db:emphasis>, int <db:emphasis>importMajor</db:emphasis> = QQmlModuleImportLatest, int <db:emphasis>importMinor</db:emphasis> = QQmlModuleImportLatest)</db:title>
<db:para>Removes a module import previously registered with <db:link xlink:href="qqml-h.xml#qmlRegisterModuleImport">qmlRegisterModuleImport</db:link>()</db:para>
<db:para>Calling this function makes sure that <db:code role="parameter">import</db:code> of version <db:code role="parameter">importMajor</db:code>.<db:code role="parameter">importMinor</db:code> is not automatically imported anymore when <db:code role="parameter">uri</db:code> of version <db:code role="parameter">moduleMajor</db:code> is. The version resolution works the same way as with <db:link xlink:href="qqml-h.xml#qmlRegisterModuleImport">qmlRegisterModuleImport</db:link>().</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qqml-h.xml#qmlRegisterModuleImport">qmlRegisterModuleImport</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
</db:section>
<db:section xml:id="macro-documentation">
<db:title>Macro Documentation</db:title>
<db:section xml:id="QML_DECLARE_TYPE">
<db:title>QML_DECLARE_TYPE</db:title>
<db:para>Equivalent to Q_DECLARE_METATYPE(TYPE *) and Q_DECLARE_METATYPE(QQmlListProperty&lt;TYPE&gt;)</db:para>
</db:section>
<db:section xml:id="QML_DECLARE_TYPEINFO">
<db:title>QML_DECLARE_TYPEINFO(<db:emphasis>Type</db:emphasis>, <db:emphasis>Flags</db:emphasis>)</db:title>
<db:para>Declares additional properties of the given <db:code role="parameter">Type</db:code> as described by the specified <db:code role="parameter">Flags</db:code>.</db:para>
<db:para>Current the only supported type info is QML_HAS_ATTACHED_PROPERTIES which declares that the <db:code role="parameter">Type</db:code> supports <db:link xlink:href="qtqml-syntax-objectattributes.xml#attached-properties-and-attached-signal-handlers">attached properties</db:link>. QML_DECLARE_TYPEINFO() is not necessary if <db:code role="parameter">Type</db:code> contains the <db:link xlink:href="qqmlintegration-h.xml#QML_ATTACHED">QML_ATTACHED</db:link> macro.</db:para>
</db:section>
</db:section>
</db:article>
