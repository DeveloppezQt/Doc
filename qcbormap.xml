<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en">
<db:info>
<db:title>QCborMap Class</db:title>
<db:productname>QtCore</db:productname>
<db:edition>Qt 5.12.12 Reference Documentation</db:edition>
<db:titleabbrev>Qt Core Reference Documentation</db:titleabbrev>
<db:abstract>
<db:para>The <db:link xlink:href="qcbormap.xml">QCborMap</db:link> class is used to hold an associative container representable in CBOR.</db:para>
<db:para>This class was introduced in Qt 5.12.</db:para>
<db:note>
<db:para>All functions in this class are <db:link xlink:href="threads-reentrancy.xml">reentrant</db:link>.</db:para>
</db:note>
</db:abstract>
<db:pubdate>2024-12-27</db:pubdate>
<db:date>2024-12-27</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:variablelist>
<db:varlistentry>
<db:term>Header</db:term>
<db:listitem>
<db:para>QCborMap</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Since</db:term>
<db:listitem>
<db:para>Qt 5.12</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>qmake</db:term>
<db:listitem>
<db:para>QT += core</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Group</db:term>
<db:listitem>
<db:para>QCborMap is part of <db:simplelist><db:member>cbor</db:member></db:simplelist></db:para>
</db:listitem>
</db:varlistentry>
</db:variablelist>
<db:section xml:id="details">
<db:title>Detailed Description</db:title>
<db:para>This class can be used to hold an associative container in CBOR, a map between a key and a value type. CBOR is the Concise Binary Object Representation, a very compact form of binary data encoding that is a superset of JSON. It was created by the IETF Constrained RESTful Environments (CoRE) WG, which has used it in many new RFCs. It is meant to be used alongside the <db:link xlink:href="https://tools.ietf.org/html/rfc7252">CoAP protocol</db:link>.</db:para>
<db:para>Unlike JSON and <db:link xlink:href="qvariant.xml#QVariantMap-typedef">QVariantMap</db:link>, CBOR map keys can be of any type, not just strings. For that reason, <db:link xlink:href="qcbormap.xml">QCborMap</db:link> is effectively a map between <db:link xlink:href="qcborvalue.xml">QCborValue</db:link> keys to <db:link xlink:href="qcborvalue.xml">QCborValue</db:link> value elements.</db:para>
<db:para>However, for all member functions that take a key parameter, <db:link xlink:href="qcbormap.xml">QCborMap</db:link> provides overloads that will work efficiently with integers and strings. In fact, the use of integer keys is encouraged, since they occupy fewer bytes to transmit and are simpler to encode and decode. Newer protocols designed by the IETF CoRE WG to work specifically with CBOR are known to use them.</db:para>
<db:para><db:link xlink:href="qcbormap.xml">QCborMap</db:link> is not sorted, because of that, searching for keys has linear complexity (O(n)). <db:link xlink:href="qcbormap.xml">QCborMap</db:link> actually keeps the elements in the order that they were inserted, which means that it is possible to make sorted QCborMaps by carefully inserting elements in sorted order. CBOR does not require sorting, but recommends it.</db:para>
<db:para><db:link xlink:href="qcbormap.xml">QCborMap</db:link> can also be converted to and from <db:link xlink:href="qvariant.xml#QVariantMap-typedef">QVariantMap</db:link> and <db:link xlink:href="qjsonobject.xml">QJsonObject</db:link>. However, when performing the conversion, any non-string keys will be stringified using a one-way method that the conversion back to <db:link xlink:href="qcbormap.xml">QCborMap</db:link> will not undo.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qcborarray.xml">QCborArray</db:link></db:member>
<db:member><db:link xlink:href="qcborvalue.xml">QCborValue</db:link></db:member>
<db:member><db:link xlink:href="qjsondocument.xml">QJsonDocument</db:link></db:member>
<db:member><db:link xlink:href="qvariant.xml#QVariantMap-typedef">QVariantMap</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="member-type-documentation">
<db:title>Member Type Documentation</db:title>
<db:section xml:id="const_iterator-typedef">
<db:title>QCborMap::const_iterator</db:title>
<db:typedefsynopsis>
<db:typedefname>const_iterator</db:typedefname>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:typedefsynopsis>
<db:para>A synonym for <db:link xlink:href="qcbormap-constiterator.xml">QCborMap::ConstIterator</db:link></db:para>
</db:section>
<db:section xml:id="iterator-typedef">
<db:title>QCborMap::iterator</db:title>
<db:typedefsynopsis>
<db:typedefname>iterator</db:typedefname>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:typedefsynopsis>
<db:para>A synonym for <db:link xlink:href="qcbormap-iterator.xml">QCborMap::Iterator</db:link>.</db:para>
</db:section>
<db:section xml:id="key_type-typedef">
<db:title>QCborMap::key_type</db:title>
<db:typedefsynopsis>
<db:typedefname>key_type</db:typedefname>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:typedefsynopsis>
<db:para>The key type for this map. Since <db:link xlink:href="qcbormap.xml">QCborMap</db:link> keys can be any CBOR type, this is a <db:link xlink:href="qcborvalue.xml">QCborValue</db:link>.</db:para>
</db:section>
<db:section xml:id="mapped_type-typedef">
<db:title>QCborMap::mapped_type</db:title>
<db:typedefsynopsis>
<db:typedefname>mapped_type</db:typedefname>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:typedefsynopsis>
<db:para>The type that is mapped to (the value), that is, a <db:link xlink:href="qcborvalue.xml">QCborValue</db:link>.</db:para>
</db:section>
<db:section xml:id="size_type-typedef">
<db:title>QCborMap::size_type</db:title>
<db:typedefsynopsis>
<db:typedefname>size_type</db:typedefname>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:typedefsynopsis>
<db:para>The type that <db:link xlink:href="qcbormap.xml">QCborMap</db:link> uses for sizes.</db:para>
</db:section>
<db:section xml:id="value_type-typedef">
<db:title>QCborMap::value_type</db:title>
<db:typedefsynopsis>
<db:typedefname>value_type</db:typedefname>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:typedefsynopsis>
<db:para>The value that is stored in this container: a pair of QCborValues</db:para>
</db:section>
</db:section>
<db:section xml:id="member-function-documentation">
<db:title>Member Function Documentation</db:title>
<db:section xml:id="find">
<db:title>QCborMap::iterator QCborMap::find(qint64 <db:emphasis>key</db:emphasis>)</db:title>
<db:bridgehead renderas="sect2" xml:id="find-4">QCborMap::const_iterator QCborMap::find(qint64 <db:emphasis>key</db:emphasis>) const</db:bridgehead>
<db:para>Returns a map iterator to the key-value pair whose key is <db:code role="parameter">key</db:code>, if the map contains such a pair. If it doesn't, this function returns <db:link xlink:href="qcbormap.xml#end">end</db:link>().</db:para>
<db:para>CBOR recommends using integer keys, since they occupy less space and are simpler to encode and decode.</db:para>
<db:para>If the map contains more than one key equal to <db:code role="parameter">key</db:code>, it is undefined which one this function will find. <db:link xlink:href="qcbormap.xml">QCborMap</db:link> does not allow inserting duplicate keys, but it is possible to create such a map by decoding a CBOR stream with them. They are usually not permitted and having duplicate keys is usually an indication of a problem in the sender.</db:para>
<db:para>value(<db:link xlink:href="qlatin1string.xml">QLatin1String</db:link>), value(const <db:link xlink:href="qstring.xml">QString</db:link> &amp;), value(const <db:link xlink:href="qcborvalue.xml">QCborValue</db:link> &amp;)</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qcbormap.xml#value">value</db:link>(qint64)</db:member>
<db:member><db:link xlink:href="qcbormap.xml#operator-5b-5d">operator[]</db:link>(qint64)</db:member>
<db:member><db:link xlink:href="qcbormap.xml#constFind">constFind</db:link>(qint64)</db:member>
<db:member><db:link xlink:href="qcbormap.xml#remove">remove</db:link>(qint64)</db:member>
<db:member><db:link xlink:href="qcbormap.xml#contains">contains</db:link>(qint64)</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="find-1">
<db:title>QCborMap::iterator QCborMap::find(QLatin1String <db:emphasis>key</db:emphasis>)</db:title>
<db:bridgehead renderas="sect2" xml:id="find-5">QCborMap::const_iterator QCborMap::find(QLatin1String <db:emphasis>key</db:emphasis>) const</db:bridgehead>
<db:para>This is an overloaded function.</db:para>
<db:para>Returns a map iterator to the key-value pair whose key is <db:code role="parameter">key</db:code>, if the map contains such a pair. If it doesn't, this function returns <db:link xlink:href="qcbormap.xml#end">end</db:link>().</db:para>
<db:para>If the map contains more than one key equal to <db:code role="parameter">key</db:code>, it is undefined which one this function will find. <db:link xlink:href="qcbormap.xml">QCborMap</db:link> does not allow inserting duplicate keys, but it is possible to create such a map by decoding a CBOR stream with them. They are usually not permitted and having duplicate keys is usually an indication of a problem in the sender.</db:para>
<db:para>value(qint64), value(const <db:link xlink:href="qstring.xml">QString</db:link> &amp;), value(const <db:link xlink:href="qcborvalue.xml">QCborValue</db:link> &amp;)</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qcbormap.xml#value-1">value</db:link>(QLatin1String)</db:member>
<db:member><db:link xlink:href="qcbormap.xml#operator-5b-5d-1">operator[]</db:link>(QLatin1String)</db:member>
<db:member><db:link xlink:href="qcbormap.xml#constFind-1">constFind</db:link>(QLatin1String)</db:member>
<db:member><db:link xlink:href="qcbormap.xml#remove-1">remove</db:link>(QLatin1String)</db:member>
<db:member><db:link xlink:href="qcbormap.xml#contains-1">contains</db:link>(QLatin1String)</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="find-2">
<db:title>QCborMap::iterator QCborMap::find(const QString &amp;<db:emphasis>key</db:emphasis>)</db:title>
<db:bridgehead renderas="sect2" xml:id="find-6">QCborMap::const_iterator QCborMap::find(const QString &amp;<db:emphasis>key</db:emphasis>) const</db:bridgehead>
<db:para>This is an overloaded function.</db:para>
<db:para>Returns a map iterator to the key-value pair whose key is <db:code role="parameter">key</db:code>, if the map contains such a pair. If it doesn't, this function returns <db:link xlink:href="qcbormap.xml#end">end</db:link>().</db:para>
<db:para>If the map contains more than one key equal to <db:code role="parameter">key</db:code>, it is undefined which one this function will find. <db:link xlink:href="qcbormap.xml">QCborMap</db:link> does not allow inserting duplicate keys, but it is possible to create such a map by decoding a CBOR stream with them. They are usually not permitted and having duplicate keys is usually an indication of a problem in the sender.</db:para>
<db:para>value(qint64), value(<db:link xlink:href="qlatin1string.xml">QLatin1String</db:link>), value(const <db:link xlink:href="qcborvalue.xml">QCborValue</db:link> &amp;)</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qcbormap.xml#value-2">value</db:link>(const QString &amp;)</db:member>
<db:member><db:link xlink:href="qcbormap.xml#operator-5b-5d-2">operator[]</db:link>(const QString &amp;)</db:member>
<db:member><db:link xlink:href="qcbormap.xml#constFind-2">constFind</db:link>(const QString &amp;)</db:member>
<db:member><db:link xlink:href="qcbormap.xml#remove-2">remove</db:link>(const QString &amp;)</db:member>
<db:member><db:link xlink:href="qcbormap.xml#contains-2">contains</db:link>(const QString &amp;)</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="find-3">
<db:title>QCborMap::iterator QCborMap::find(const QCborValue &amp;<db:emphasis>key</db:emphasis>)</db:title>
<db:bridgehead renderas="sect2" xml:id="find-7">QCborMap::const_iterator QCborMap::find(const QCborValue &amp;<db:emphasis>key</db:emphasis>) const</db:bridgehead>
<db:para>This is an overloaded function.</db:para>
<db:para>Returns a map iterator to the key-value pair whose key is <db:code role="parameter">key</db:code>, if the map contains such a pair. If it doesn't, this function returns <db:link xlink:href="qcbormap.xml#end">end</db:link>().</db:para>
<db:para>If the map contains more than one key equal to <db:code role="parameter">key</db:code>, it is undefined which one this function will find. <db:link xlink:href="qcbormap.xml">QCborMap</db:link> does not allow inserting duplicate keys, but it is possible to create such a map by decoding a CBOR stream with them. They are usually not permitted and having duplicate keys is usually an indication of a problem in the sender.</db:para>
<db:para>value(qint64), value(<db:link xlink:href="qlatin1string.xml">QLatin1String</db:link>), value(const <db:link xlink:href="qstring.xml">QString</db:link> &amp;)</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qcbormap.xml#value-3">value</db:link>(const QCborValue &amp;)</db:member>
<db:member><db:link xlink:href="qcbormap.xml#operator-5b-5d-3">operator[]</db:link>(const QCborValue &amp;)</db:member>
<db:member><db:link xlink:href="qcbormap.xml#constFind-3">constFind</db:link>(const QCborValue &amp;)</db:member>
<db:member><db:link xlink:href="qcbormap.xml#remove-3">remove</db:link>(const QCborValue &amp;)</db:member>
<db:member><db:link xlink:href="qcbormap.xml#contains-3">contains</db:link>(const QCborValue &amp;)</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="extract-1">
<db:title>QCborValue QCborMap::extract(QCborMap::const_iterator <db:emphasis>it</db:emphasis>)</db:title>
<db:bridgehead renderas="sect2" xml:id="extract">QCborValue QCborMap::extract(QCborMap::iterator <db:emphasis>it</db:emphasis>)</db:bridgehead>
<db:para>Extracts a value from the map at the position indicated by iterator <db:code role="parameter">it</db:code> and returns the value so extracted.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qcbormap.xml#insert">insert</db:link>()</db:member>
<db:member><db:link xlink:href="qcbormap.xml#erase">erase</db:link>()</db:member>
<db:member><db:link xlink:href="qcbormap.xml#take">take</db:link>()</db:member>
<db:member><db:link xlink:href="qcbormap.xml#remove">remove</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="QCborMap">
<db:title>QCborMap::QCborMap()</db:title>
<db:constructorsynopsis>
<db:methodname>QCborMap</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">constructor</db:synopsisinfo>
<db:synopsisinfo role="signature">QCborMap()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:constructorsynopsis>
<db:para>Constructs an empty CBOR Map object.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qcbormap.xml#isEmpty">isEmpty</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="QCborMap-2">
<db:title>QCborMap::QCborMap(std::initializer_list&lt;value_type&gt; <db:emphasis>args</db:emphasis>)</db:title>
<db:constructorsynopsis>
<db:methodname>QCborMap</db:methodname>
<db:methodparam>
<db:type>std::initializer_list&lt;value_type&gt;</db:type>
<db:parameter>args</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">constructor</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">2</db:synopsisinfo>
<db:synopsisinfo role="signature">QCborMap(std::initializer_list&lt;value_type&gt; args)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:constructorsynopsis>
<db:para>Constructs a <db:link xlink:href="qcbormap.xml">QCborMap</db:link> with items from a brace-initialization list found in <db:code role="parameter">args</db:code>, as in the following example:</db:para>
<db:programlisting language="cpp">QCborMap map = {
    {0, &quot;Hello&quot;},
    {1, &quot;World&quot;},
    {&quot;foo&quot;, nullptr},
    {&quot;bar&quot;, QCborArray{0, 1, 2, 3, 4}}
};
</db:programlisting>
</db:section>
<db:section xml:id="QCborMap-1">
<db:title>QCborMap::QCborMap(const QCborMap &amp;<db:emphasis>other</db:emphasis>)</db:title>
<db:constructorsynopsis>
<db:methodname>QCborMap</db:methodname>
<db:methodparam>
<db:type>const QCborMap &amp;</db:type>
<db:parameter>other</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">copy-constructor</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">QCborMap(const QCborMap &amp;other)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:constructorsynopsis>
<db:para>Creates a <db:link xlink:href="qcbormap.xml">QCborMap</db:link> object that is a copy of <db:code role="parameter">other</db:code>.</db:para>
</db:section>
<db:section xml:id="dtor.QCborMap">
<db:title>QCborMap::~QCborMap()</db:title>
<db:destructorsynopsis>
<db:methodname>~QCborMap</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">destructor</db:synopsisinfo>
<db:synopsisinfo role="signature">~QCborMap()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:destructorsynopsis>
<db:para>Destroys this <db:link xlink:href="qcbormap.xml">QCborMap</db:link> object and frees any associated resources it owns.</db:para>
</db:section>
<db:section xml:id="begin">
<db:title>QCborMap::iterator QCborMap::begin()</db:title>
<db:methodsynopsis>
<db:type>QCborMap::iterator</db:type>
<db:methodname>begin</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QCborMap::iterator begin()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns a map iterator pointing to the first key-value pair of this map. If this map is empty, the returned iterator will be the same as <db:link xlink:href="qcbormap.xml#end">end</db:link>().</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qcbormap.xml#constBegin">constBegin</db:link>()</db:member>
<db:member><db:link xlink:href="qcbormap.xml#end">end</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="begin-1">
<db:title>QCborMap::const_iterator QCborMap::begin() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QCborMap::const_iterator</db:type>
<db:methodname>begin</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">QCborMap::const_iterator begin() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns a map iterator pointing to the first key-value pair of this map. If this map is empty, the returned iterator will be the same as <db:link xlink:href="qcbormap.xml#constEnd">constEnd</db:link>().</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qcbormap.xml#begin">begin</db:link>()</db:member>
<db:member><db:link xlink:href="qcbormap.xml#constEnd">constEnd</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="cbegin">
<db:title>QCborMap::const_iterator QCborMap::cbegin() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QCborMap::const_iterator</db:type>
<db:methodname>cbegin</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QCborMap::const_iterator cbegin() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns a map iterator pointing to the first key-value pair of this map. If this map is empty, the returned iterator will be the same as <db:link xlink:href="qcbormap.xml#constEnd">constEnd</db:link>().</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qcbormap.xml#begin">begin</db:link>()</db:member>
<db:member><db:link xlink:href="qcbormap.xml#constEnd">constEnd</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="cend">
<db:title>QCborMap::const_iterator QCborMap::cend() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QCborMap::const_iterator</db:type>
<db:methodname>cend</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QCborMap::const_iterator cend() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns a map iterator representing an element just past the last element in the map.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qcbormap.xml#begin">begin</db:link>()</db:member>
<db:member><db:link xlink:href="qcbormap.xml#constBegin">constBegin</db:link>()</db:member>
<db:member><db:link xlink:href="qcbormap.xml#find">find</db:link>()</db:member>
<db:member><db:link xlink:href="qcbormap.xml#constFind">constFind</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="clear">
<db:title>void QCborMap::clear()</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>clear</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void clear()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Empties this map.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qcbormap.xml#isEmpty">isEmpty</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="compare">
<db:title>int QCborMap::compare(const QCborMap &amp;<db:emphasis>other</db:emphasis>) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>int</db:type>
<db:methodname>compare</db:methodname>
<db:methodparam>
<db:type>const QCborMap &amp;</db:type>
<db:parameter>other</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">int compare(const QCborMap &amp;other) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Compares this map and <db:code role="parameter">other</db:code>, comparing each element in sequence, and returns an integer that indicates whether this map should be sorted prior to (if the result is negative) or after <db:code role="parameter">other</db:code> (if the result is positive). If this function returns 0, the two maps are equal and contain the same elements.</db:para>
<db:para>Note that CBOR maps are unordered, which means that two maps containing the very same pairs but in different order will still compare differently. To avoid this, it is recommended to insert elements into the map in a predictable order, such as by ascending key value. In fact, maps with keys in sorted order are required for Canonical CBOR representation.</db:para>
<db:para>For more information on CBOR sorting order, see <db:link xlink:href="qcborvalue.xml#compare">QCborValue::compare</db:link>().</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qcborvalue.xml#compare">QCborValue::compare</db:link>()</db:member>
<db:member><db:link xlink:href="qcborarray.xml#compare">QCborArray::compare</db:link>()</db:member>
<db:member><db:link xlink:href="qcbormap.xml#operator-eq-eq">operator==</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="constBegin">
<db:title>QCborMap::const_iterator QCborMap::constBegin() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QCborMap::const_iterator</db:type>
<db:methodname>constBegin</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QCborMap::const_iterator constBegin() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns a map iterator pointing to the first key-value pair of this map. If this map is empty, the returned iterator will be the same as <db:link xlink:href="qcbormap.xml#constEnd">constEnd</db:link>().</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qcbormap.xml#begin">begin</db:link>()</db:member>
<db:member><db:link xlink:href="qcbormap.xml#constEnd">constEnd</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="constEnd">
<db:title>QCborMap::const_iterator QCborMap::constEnd() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QCborMap::const_iterator</db:type>
<db:methodname>constEnd</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QCborMap::const_iterator constEnd() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns a map iterator representing an element just past the last element in the map.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qcbormap.xml#begin">begin</db:link>()</db:member>
<db:member><db:link xlink:href="qcbormap.xml#constBegin">constBegin</db:link>()</db:member>
<db:member><db:link xlink:href="qcbormap.xml#find">find</db:link>()</db:member>
<db:member><db:link xlink:href="qcbormap.xml#constFind">constFind</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="constFind">
<db:title>QCborMap::const_iterator QCborMap::constFind(qint64 <db:emphasis>key</db:emphasis>) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QCborMap::const_iterator</db:type>
<db:methodname>constFind</db:methodname>
<db:methodparam>
<db:type>qint64</db:type>
<db:parameter>key</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QCborMap::const_iterator constFind(qint64 key) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns a map iterator to the key-value pair whose key is <db:code role="parameter">key</db:code>, if the map contains such a pair. If it doesn't, this function returns <db:link xlink:href="qcbormap.xml#constEnd">constEnd</db:link>().</db:para>
<db:para>CBOR recommends using integer keys, since they occupy less space and are simpler to encode and decode.</db:para>
<db:para>If the map contains more than one key equal to <db:code role="parameter">key</db:code>, it is undefined which one this function will find. <db:link xlink:href="qcbormap.xml">QCborMap</db:link> does not allow inserting duplicate keys, but it is possible to create such a map by decoding a CBOR stream with them. They are usually not permitted and having duplicate keys is usually an indication of a problem in the sender.</db:para>
<db:para>value(<db:link xlink:href="qlatin1string.xml">QLatin1String</db:link>), value(const <db:link xlink:href="qstring.xml">QString</db:link> &amp;), value(const <db:link xlink:href="qcborvalue.xml">QCborValue</db:link> &amp;)</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qcbormap.xml#value">value</db:link>(qint64)</db:member>
<db:member><db:link xlink:href="qcbormap.xml#operator-5b-5d">operator[]</db:link>(qint64)</db:member>
<db:member><db:link xlink:href="qcbormap.xml#find">find</db:link>(qint64)</db:member>
<db:member><db:link xlink:href="qcbormap.xml#remove">remove</db:link>(qint64)</db:member>
<db:member><db:link xlink:href="qcbormap.xml#contains">contains</db:link>(qint64)</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="constFind-1">
<db:title>QCborMap::const_iterator QCborMap::constFind(QLatin1String <db:emphasis>key</db:emphasis>) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QCborMap::const_iterator</db:type>
<db:methodname>constFind</db:methodname>
<db:methodparam>
<db:type>QLatin1String</db:type>
<db:parameter>key</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">QCborMap::const_iterator constFind(QLatin1String key) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>Returns a map iterator to the key-value pair whose key is <db:code role="parameter">key</db:code>, if the map contains such a pair. If it doesn't, this function returns <db:link xlink:href="qcbormap.xml#constEnd">constEnd</db:link>().</db:para>
<db:para>If the map contains more than one key equal to <db:code role="parameter">key</db:code>, it is undefined which one this function will find. <db:link xlink:href="qcbormap.xml">QCborMap</db:link> does not allow inserting duplicate keys, but it is possible to create such a map by decoding a CBOR stream with them. They are usually not permitted and having duplicate keys is usually an indication of a problem in the sender.</db:para>
<db:para>value(qint64), value(const <db:link xlink:href="qstring.xml">QString</db:link> &amp;), value(const <db:link xlink:href="qcborvalue.xml">QCborValue</db:link> &amp;)</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qcbormap.xml#value-1">value</db:link>(QLatin1String)</db:member>
<db:member><db:link xlink:href="qcbormap.xml#operator-5b-5d-1">operator[]</db:link>(QLatin1String)</db:member>
<db:member><db:link xlink:href="qcbormap.xml#find-1">find</db:link>(QLatin1String)</db:member>
<db:member><db:link xlink:href="qcbormap.xml#remove-1">remove</db:link>(QLatin1String)</db:member>
<db:member><db:link xlink:href="qcbormap.xml#contains-1">contains</db:link>(QLatin1String)</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="constFind-2">
<db:title>QCborMap::const_iterator QCborMap::constFind(const QString &amp;<db:emphasis>key</db:emphasis>) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QCborMap::const_iterator</db:type>
<db:methodname>constFind</db:methodname>
<db:methodparam>
<db:type>const QString &amp;</db:type>
<db:parameter>key</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">2</db:synopsisinfo>
<db:synopsisinfo role="signature">QCborMap::const_iterator constFind(const QString &amp;key) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>Returns a map iterator to the key-value pair whose key is <db:code role="parameter">key</db:code>, if the map contains such a pair. If it doesn't, this function returns <db:link xlink:href="qcbormap.xml#constEnd">constEnd</db:link>().</db:para>
<db:para>If the map contains more than one key equal to <db:code role="parameter">key</db:code>, it is undefined which one this function will find. <db:link xlink:href="qcbormap.xml">QCborMap</db:link> does not allow inserting duplicate keys, but it is possible to create such a map by decoding a CBOR stream with them. They are usually not permitted and having duplicate keys is usually an indication of a problem in the sender.</db:para>
<db:para>value(qint64), value(<db:link xlink:href="qlatin1string.xml">QLatin1String</db:link>), value(const <db:link xlink:href="qcborvalue.xml">QCborValue</db:link> &amp;)</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qcbormap.xml#value-2">value</db:link>(const QString &amp;)</db:member>
<db:member><db:link xlink:href="qcbormap.xml#operator-5b-5d-2">operator[]</db:link>(const QString &amp;)</db:member>
<db:member><db:link xlink:href="qcbormap.xml#find-2">find</db:link>(const QString &amp;)</db:member>
<db:member><db:link xlink:href="qcbormap.xml#remove-2">remove</db:link>(const QString &amp;)</db:member>
<db:member><db:link xlink:href="qcbormap.xml#contains-2">contains</db:link>(const QString &amp;)</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="constFind-3">
<db:title>QCborMap::const_iterator QCborMap::constFind(const QCborValue &amp;<db:emphasis>key</db:emphasis>) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QCborMap::const_iterator</db:type>
<db:methodname>constFind</db:methodname>
<db:methodparam>
<db:type>const QCborValue &amp;</db:type>
<db:parameter>key</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">3</db:synopsisinfo>
<db:synopsisinfo role="signature">QCborMap::const_iterator constFind(const QCborValue &amp;key) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>Returns a map iterator to the key-value pair whose key is <db:code role="parameter">key</db:code>, if the map contains such a pair. If it doesn't, this function returns <db:link xlink:href="qcbormap.xml#constEnd">constEnd</db:link>().</db:para>
<db:para>If the map contains more than one key equal to <db:code role="parameter">key</db:code>, it is undefined which one this function will find. <db:link xlink:href="qcbormap.xml">QCborMap</db:link> does not allow inserting duplicate keys, but it is possible to create such a map by decoding a CBOR stream with them. They are usually not permitted and having duplicate keys is usually an indication of a problem in the sender.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qcbormap.xml#value-3">value</db:link>(const QCborValue &amp;)</db:member>
<db:member><db:link xlink:href="qcbormap.xml#operator-5b-5d-3">operator[]</db:link>(const QCborValue &amp;)</db:member>
<db:member><db:link xlink:href="qcbormap.xml#find-3">find</db:link>(const QCborValue &amp;)</db:member>
<db:member><db:link xlink:href="qcbormap.xml#remove-3">remove</db:link>(const QCborValue &amp;)</db:member>
<db:member><db:link xlink:href="qcbormap.xml#contains-3">contains</db:link>(const QCborValue &amp;)</db:member>
<db:member><db:link xlink:href="qcbormap.xml#value">value</db:link>(qint64)</db:member>
<db:member><db:link xlink:href="qcbormap.xml#value-1">value</db:link>(QLatin1String)</db:member>
<db:member><db:link xlink:href="qcbormap.xml#value-2">value</db:link>(const QString &amp;)</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="contains">
<db:title>bool QCborMap::contains(qint64 <db:emphasis>key</db:emphasis>) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>bool</db:type>
<db:methodname>contains</db:methodname>
<db:methodparam>
<db:type>qint64</db:type>
<db:parameter>key</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool contains(qint64 key) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns true if this map contains a key-value pair identified by key <db:code role="parameter">key</db:code>. CBOR recommends using integer keys, since they occupy less space and are simpler to encode and decode.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qcbormap.xml#value">value</db:link>(qint64)</db:member>
<db:member><db:link xlink:href="qcbormap.xml#operator-5b-5d">operator[]</db:link>(qint64)</db:member>
<db:member><db:link xlink:href="qcbormap.xml#find">find</db:link>(qint64)</db:member>
<db:member><db:link xlink:href="qcbormap.xml#remove">remove</db:link>(qint64)</db:member>
<db:member><db:link xlink:href="qcbormap.xml#contains-1">contains</db:link>(QLatin1String)</db:member>
<db:member><db:link xlink:href="qcbormap.xml#remove-2">remove</db:link>(const QString &amp;)</db:member>
<db:member><db:link xlink:href="qcbormap.xml#remove-3">remove</db:link>(const QCborValue &amp;)</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="contains-1">
<db:title>bool QCborMap::contains(QLatin1String <db:emphasis>key</db:emphasis>) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>bool</db:type>
<db:methodname>contains</db:methodname>
<db:methodparam>
<db:type>QLatin1String</db:type>
<db:parameter>key</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">bool contains(QLatin1String key) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>Returns true if this map contains a key-value pair identified by key <db:code role="parameter">key</db:code>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qcbormap.xml#value-1">value</db:link>(QLatin1String)</db:member>
<db:member><db:link xlink:href="qcbormap.xml#operator-5b-5d-1">operator[]</db:link>(QLatin1String)</db:member>
<db:member><db:link xlink:href="qcbormap.xml#find-1">find</db:link>(QLatin1String)</db:member>
<db:member><db:link xlink:href="qcbormap.xml#remove-1">remove</db:link>(QLatin1String)</db:member>
<db:member><db:link xlink:href="qcbormap.xml#contains">contains</db:link>(qint64)</db:member>
<db:member><db:link xlink:href="qcbormap.xml#remove-2">remove</db:link>(const QString &amp;)</db:member>
<db:member><db:link xlink:href="qcbormap.xml#remove-3">remove</db:link>(const QCborValue &amp;)</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="contains-2">
<db:title>bool QCborMap::contains(const QString &amp;<db:emphasis>key</db:emphasis>) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>bool</db:type>
<db:methodname>contains</db:methodname>
<db:methodparam>
<db:type>const QString &amp;</db:type>
<db:parameter>key</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">2</db:synopsisinfo>
<db:synopsisinfo role="signature">bool contains(const QString &amp;key) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>Returns true if this map contains a key-value pair identified by key <db:code role="parameter">key</db:code>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qcbormap.xml#value-2">value</db:link>(const QString &amp;)</db:member>
<db:member><db:link xlink:href="qcbormap.xml#operator-5b-5d-2">operator[]</db:link>(const QString &amp;)</db:member>
<db:member><db:link xlink:href="qcbormap.xml#find-2">find</db:link>(const QString &amp;)</db:member>
<db:member><db:link xlink:href="qcbormap.xml#remove-2">remove</db:link>(const QString &amp;)</db:member>
<db:member><db:link xlink:href="qcbormap.xml#contains">contains</db:link>(qint64)</db:member>
<db:member><db:link xlink:href="qcbormap.xml#remove-1">remove</db:link>(QLatin1String)</db:member>
<db:member><db:link xlink:href="qcbormap.xml#remove-3">remove</db:link>(const QCborValue &amp;)</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="contains-3">
<db:title>bool QCborMap::contains(const QCborValue &amp;<db:emphasis>key</db:emphasis>) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>bool</db:type>
<db:methodname>contains</db:methodname>
<db:methodparam>
<db:type>const QCborValue &amp;</db:type>
<db:parameter>key</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">3</db:synopsisinfo>
<db:synopsisinfo role="signature">bool contains(const QCborValue &amp;key) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns true if this map contains a key-value pair identified by key <db:code role="parameter">key</db:code>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qcbormap.xml#value-3">value</db:link>(const QCborValue &amp;)</db:member>
<db:member><db:link xlink:href="qcbormap.xml#operator-5b-5d-3">operator[]</db:link>(const QCborValue &amp;)</db:member>
<db:member><db:link xlink:href="qcbormap.xml#find-3">find</db:link>(const QCborValue &amp;)</db:member>
<db:member><db:link xlink:href="qcbormap.xml#remove-3">remove</db:link>(const QCborValue &amp;)</db:member>
<db:member><db:link xlink:href="qcbormap.xml#contains">contains</db:link>(qint64)</db:member>
<db:member><db:link xlink:href="qcbormap.xml#remove-1">remove</db:link>(QLatin1String)</db:member>
<db:member><db:link xlink:href="qcbormap.xml#remove-2">remove</db:link>(const QString &amp;)</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="empty">
<db:title>bool QCborMap::empty() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>bool</db:type>
<db:methodname>empty</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool empty() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Synonym for <db:link xlink:href="qcbormap.xml#isEmpty">isEmpty</db:link>(). This function is provided for compatibility with generic code that uses the Standard Library API.</db:para>
<db:para>Returns true if this map is empty (<db:link xlink:href="qcbormap.xml#size">size</db:link>() == 0).</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qcbormap.xml#isEmpty">isEmpty</db:link>()</db:member>
<db:member><db:link xlink:href="qcbormap.xml#size">size</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="end">
<db:title>QCborMap::iterator QCborMap::end()</db:title>
<db:methodsynopsis>
<db:type>QCborMap::iterator</db:type>
<db:methodname>end</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QCborMap::iterator end()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns a map iterator representing an element just past the last element in the map.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qcbormap.xml#begin">begin</db:link>()</db:member>
<db:member><db:link xlink:href="qcbormap.xml#constBegin">constBegin</db:link>()</db:member>
<db:member><db:link xlink:href="qcbormap.xml#find">find</db:link>()</db:member>
<db:member><db:link xlink:href="qcbormap.xml#constFind">constFind</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="end-1">
<db:title>QCborMap::const_iterator QCborMap::end() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QCborMap::const_iterator</db:type>
<db:methodname>end</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">QCborMap::const_iterator end() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns a map iterator representing an element just past the last element in the map.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qcbormap.xml#begin">begin</db:link>()</db:member>
<db:member><db:link xlink:href="qcbormap.xml#constBegin">constBegin</db:link>()</db:member>
<db:member><db:link xlink:href="qcbormap.xml#find">find</db:link>()</db:member>
<db:member><db:link xlink:href="qcbormap.xml#constFind">constFind</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="erase">
<db:title>QCborMap::iterator QCborMap::erase(QCborMap::const_iterator <db:emphasis>it</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>QCborMap::iterator</db:type>
<db:methodname>erase</db:methodname>
<db:methodparam>
<db:type>QCborMap::const_iterator</db:type>
<db:parameter>it</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QCborMap::iterator erase(QCborMap::const_iterator it)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Removes the key-value pair pointed to by the map iterator <db:code role="parameter">it</db:code> and returns a pointer to the next element, after removal.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qcbormap.xml#remove">remove</db:link>()</db:member>
<db:member><db:link xlink:href="qcbormap.xml#begin">begin</db:link>()</db:member>
<db:member><db:link xlink:href="qcbormap.xml#end">end</db:link>()</db:member>
<db:member><db:link xlink:href="qcbormap.xml#insert">insert</db:link>()</db:member>
<db:member><db:link xlink:href="qcbormap.xml#extract">extract</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="erase-1">
<db:title>QCborMap::iterator QCborMap::erase(QCborMap::iterator <db:emphasis>it</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>QCborMap::iterator</db:type>
<db:methodname>erase</db:methodname>
<db:methodparam>
<db:type>QCborMap::iterator</db:type>
<db:parameter>it</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">QCborMap::iterator erase(QCborMap::iterator it)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>Removes the key-value pair pointed to by the map iterator <db:code role="parameter">it</db:code> and returns a pointer to the next element, after removal.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qcbormap.xml#remove">remove</db:link>()</db:member>
<db:member><db:link xlink:href="qcbormap.xml#begin">begin</db:link>()</db:member>
<db:member><db:link xlink:href="qcbormap.xml#end">end</db:link>()</db:member>
<db:member><db:link xlink:href="qcbormap.xml#insert">insert</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="fromJsonObject">
<db:title>[static] QCborMap QCborMap::fromJsonObject(const QJsonObject &amp;<db:emphasis>obj</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:modifier>static</db:modifier>
<db:type>QCborMap</db:type>
<db:methodname>fromJsonObject</db:methodname>
<db:methodparam>
<db:type>const QJsonObject &amp;</db:type>
<db:parameter>obj</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QCborMap fromJsonObject(const QJsonObject &amp;obj)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Converts all JSON items found in the <db:code role="parameter">obj</db:code> object to CBOR using QCborValue::fromJson(), and returns the map composed of those elements.</db:para>
<db:para>This conversion is lossless, as the CBOR type system is a superset of JSON's. Moreover, the map returned by this function can be converted back to the original <db:code role="parameter">obj</db:code> by using <db:link xlink:href="qcbormap.xml#toJsonObject">toJsonObject</db:link>().</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qcbormap.xml#toJsonObject">toJsonObject</db:link>()</db:member>
<db:member><db:link xlink:href="qcbormap.xml#toVariantMap">toVariantMap</db:link>()</db:member>
<db:member><db:link xlink:href="qcborvalue.xml#fromJsonValue">QCborValue::fromJsonValue</db:link>()</db:member>
<db:member><db:link xlink:href="qcborarray.xml#fromJsonArray">QCborArray::fromJsonArray</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="fromVariantHash">
<db:title>[static] QCborMap QCborMap::fromVariantHash(const QVariantHash &amp;<db:emphasis>hash</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:modifier>static</db:modifier>
<db:type>QCborMap</db:type>
<db:methodname>fromVariantHash</db:methodname>
<db:methodparam>
<db:type>const QVariantHash &amp;</db:type>
<db:parameter>hash</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QCborMap fromVariantHash(const QVariantHash &amp;hash)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Converts all the items in <db:code role="parameter">hash</db:code> to CBOR using <db:link xlink:href="qcborvalue.xml#fromVariant">QCborValue::fromVariant</db:link>() and returns the map composed of those elements.</db:para>
<db:para>Conversion from <db:link xlink:href="qvariant.xml">QVariant</db:link> is not completely lossless. Please see the documentation in <db:link xlink:href="qcborvalue.xml#fromVariant">QCborValue::fromVariant</db:link>() for more information.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qcbormap.xml#toVariantHash">toVariantHash</db:link>()</db:member>
<db:member><db:link xlink:href="qcbormap.xml#fromVariantMap">fromVariantMap</db:link>()</db:member>
<db:member><db:link xlink:href="qcbormap.xml#fromJsonObject">fromJsonObject</db:link>()</db:member>
<db:member><db:link xlink:href="qcborvalue.xml#fromVariant">QCborValue::fromVariant</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="fromVariantMap">
<db:title>[static] QCborMap QCborMap::fromVariantMap(const QVariantMap &amp;<db:emphasis>map</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:modifier>static</db:modifier>
<db:type>QCborMap</db:type>
<db:methodname>fromVariantMap</db:methodname>
<db:methodparam>
<db:type>const QVariantMap &amp;</db:type>
<db:parameter>map</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QCborMap fromVariantMap(const QVariantMap &amp;map)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Converts all the items in <db:code role="parameter">map</db:code> to CBOR using <db:link xlink:href="qcborvalue.xml#fromVariant">QCborValue::fromVariant</db:link>() and returns the map composed of those elements.</db:para>
<db:para>Conversion from <db:link xlink:href="qvariant.xml">QVariant</db:link> is not completely lossless. Please see the documentation in <db:link xlink:href="qcborvalue.xml#fromVariant">QCborValue::fromVariant</db:link>() for more information.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qcbormap.xml#toVariantMap">toVariantMap</db:link>()</db:member>
<db:member><db:link xlink:href="qcbormap.xml#fromVariantHash">fromVariantHash</db:link>()</db:member>
<db:member><db:link xlink:href="qcbormap.xml#fromJsonObject">fromJsonObject</db:link>()</db:member>
<db:member><db:link xlink:href="qcborvalue.xml#fromVariant">QCborValue::fromVariant</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="insert">
<db:title>QCborMap::iterator QCborMap::insert(qint64 <db:emphasis>key</db:emphasis>, const QCborValue &amp;<db:emphasis>value</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>QCborMap::iterator</db:type>
<db:methodname>insert</db:methodname>
<db:methodparam>
<db:type>qint64</db:type>
<db:parameter>key</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const QCborValue &amp;</db:type>
<db:parameter>value</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QCborMap::iterator insert(qint64 key, const QCborValue &amp;value)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>Inserts the key <db:code role="parameter">key</db:code> and value <db:code role="parameter">value</db:code> into this map and returns a map iterator pointing to the newly inserted pair.</db:para>
<db:para>If the map already had a key equal to <db:code role="parameter">key</db:code>, its value will be overwritten by <db:code role="parameter">value</db:code>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qcbormap.xml#erase">erase</db:link>()</db:member>
<db:member><db:link xlink:href="qcbormap.xml#remove">remove</db:link>(qint64)</db:member>
<db:member><db:link xlink:href="qcbormap.xml#value">value</db:link>(qint64)</db:member>
<db:member><db:link xlink:href="qcbormap.xml#operator-5b-5d">operator[]</db:link>(qint64)</db:member>
<db:member><db:link xlink:href="qcbormap.xml#find">find</db:link>(qint64)</db:member>
<db:member><db:link xlink:href="qcbormap.xml#contains">contains</db:link>(qint64)</db:member>
<db:member><db:link xlink:href="qcbormap.xml#take">take</db:link>(qint64)</db:member>
<db:member><db:link xlink:href="qcbormap.xml#extract">extract</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="insert-1">
<db:title>QCborMap::iterator QCborMap::insert(QLatin1String <db:emphasis>key</db:emphasis>, const QCborValue &amp;<db:emphasis>value</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>QCborMap::iterator</db:type>
<db:methodname>insert</db:methodname>
<db:methodparam>
<db:type>QLatin1String</db:type>
<db:parameter>key</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const QCborValue &amp;</db:type>
<db:parameter>value</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">QCborMap::iterator insert(QLatin1String key, const QCborValue &amp;value)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>Inserts the key <db:code role="parameter">key</db:code> and value <db:code role="parameter">value</db:code> into this map and returns a map iterator pointing to the newly inserted pair.</db:para>
<db:para>If the map already had a key equal to <db:code role="parameter">key</db:code>, its value will be overwritten by <db:code role="parameter">value</db:code>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qcbormap.xml#erase">erase</db:link>()</db:member>
<db:member><db:link xlink:href="qcbormap.xml#remove-1">remove</db:link>(QLatin1String)</db:member>
<db:member><db:link xlink:href="qcbormap.xml#value-1">value</db:link>(QLatin1String)</db:member>
<db:member><db:link xlink:href="qcbormap.xml#operator-5b-5d-1">operator[]</db:link>(QLatin1String)</db:member>
<db:member><db:link xlink:href="qcbormap.xml#find-1">find</db:link>(QLatin1String)</db:member>
<db:member><db:link xlink:href="qcbormap.xml#contains-1">contains</db:link>(QLatin1String)</db:member>
<db:member><db:link xlink:href="qcbormap.xml#take-1">take</db:link>(QLatin1String)</db:member>
<db:member><db:link xlink:href="qcbormap.xml#extract">extract</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="insert-2">
<db:title>QCborMap::iterator QCborMap::insert(const QString &amp;<db:emphasis>key</db:emphasis>, const QCborValue &amp;<db:emphasis>value</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>QCborMap::iterator</db:type>
<db:methodname>insert</db:methodname>
<db:methodparam>
<db:type>const QString &amp;</db:type>
<db:parameter>key</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const QCborValue &amp;</db:type>
<db:parameter>value</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">2</db:synopsisinfo>
<db:synopsisinfo role="signature">QCborMap::iterator insert(const QString &amp;key, const QCborValue &amp;value)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>Inserts the key <db:code role="parameter">key</db:code> and value <db:code role="parameter">value</db:code> into this map and returns a map iterator pointing to the newly inserted pair.</db:para>
<db:para>If the map already had a key equal to <db:code role="parameter">key</db:code>, its value will be overwritten by <db:code role="parameter">value</db:code>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qcbormap.xml#erase">erase</db:link>()</db:member>
<db:member><db:link xlink:href="qcbormap.xml#remove-2">remove</db:link>(const QString &amp;)</db:member>
<db:member><db:link xlink:href="qcbormap.xml#value-2">value</db:link>(const QString &amp;)</db:member>
<db:member><db:link xlink:href="qcbormap.xml#operator-5b-5d-2">operator[]</db:link>(const QString &amp;)</db:member>
<db:member><db:link xlink:href="qcbormap.xml#find-2">find</db:link>(const QString &amp;)</db:member>
<db:member><db:link xlink:href="qcbormap.xml#contains-2">contains</db:link>(const QString &amp;)</db:member>
<db:member><db:link xlink:href="qcbormap.xml#take-2">take</db:link>(const QString &amp;)</db:member>
<db:member><db:link xlink:href="qcbormap.xml#extract">extract</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="insert-3">
<db:title>QCborMap::iterator QCborMap::insert(const QCborValue &amp;<db:emphasis>key</db:emphasis>, const QCborValue &amp;<db:emphasis>value</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>QCborMap::iterator</db:type>
<db:methodname>insert</db:methodname>
<db:methodparam>
<db:type>const QCborValue &amp;</db:type>
<db:parameter>key</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const QCborValue &amp;</db:type>
<db:parameter>value</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">3</db:synopsisinfo>
<db:synopsisinfo role="signature">QCborMap::iterator insert(const QCborValue &amp;key, const QCborValue &amp;value)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>Inserts the key <db:code role="parameter">key</db:code> and value <db:code role="parameter">value</db:code> into this map and returns a map iterator pointing to the newly inserted pair.</db:para>
<db:para>If the map already had a key equal to <db:code role="parameter">key</db:code>, its value will be overwritten by <db:code role="parameter">value</db:code>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qcbormap.xml#erase">erase</db:link>()</db:member>
<db:member><db:link xlink:href="qcbormap.xml#remove-3">remove</db:link>(const QCborValue &amp;)</db:member>
<db:member><db:link xlink:href="qcbormap.xml#value-3">value</db:link>(const QCborValue &amp;)</db:member>
<db:member><db:link xlink:href="qcbormap.xml#operator-5b-5d-3">operator[]</db:link>(const QCborValue &amp;)</db:member>
<db:member><db:link xlink:href="qcbormap.xml#find-3">find</db:link>(const QCborValue &amp;)</db:member>
<db:member><db:link xlink:href="qcbormap.xml#contains-3">contains</db:link>(const QCborValue &amp;)</db:member>
<db:member><db:link xlink:href="qcbormap.xml#take-3">take</db:link>(const QCborValue &amp;)</db:member>
<db:member><db:link xlink:href="qcbormap.xml#extract">extract</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="insert-4">
<db:title>QCborMap::iterator QCborMap::insert(QCborMap::value_type <db:emphasis>v</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>QCborMap::iterator</db:type>
<db:methodname>insert</db:methodname>
<db:methodparam>
<db:type>QCborMap::value_type</db:type>
<db:parameter>v</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">4</db:synopsisinfo>
<db:synopsisinfo role="signature">QCborMap::iterator insert(QCborMap::value_type v)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>Inserts the key-value pair in <db:code role="parameter">v</db:code> into this map and returns a map iterator pointing to the newly inserted pair.</db:para>
<db:para>If the map already had a key equal to v.first, its value will be overwritten by v.second.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qcbormap.xml#operator-5b-5d">operator[]</db:link></db:member>
<db:member><db:link xlink:href="qcbormap.xml#erase">erase</db:link>()</db:member>
<db:member><db:link xlink:href="qcbormap.xml#extract">extract</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="isEmpty">
<db:title>bool QCborMap::isEmpty() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>bool</db:type>
<db:methodname>isEmpty</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool isEmpty() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns true if this map is empty (that is, <db:link xlink:href="qcbormap.xml#size">size</db:link>() is 0).</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qcbormap.xml#size">size</db:link>()</db:member>
<db:member><db:link xlink:href="qcbormap.xml#clear">clear</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="keys">
<db:title>QVector&lt;QCborValue&gt; QCborMap::keys() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QVector&lt;QCborValue&gt;</db:type>
<db:methodname>keys</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QVector&lt;QCborValue&gt; keys() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns a list of all keys in this map.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qmap.xml#keys">QMap::keys</db:link>()</db:member>
<db:member><db:link xlink:href="qhash.xml#keys">QHash::keys</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="remove">
<db:title>void QCborMap::remove(qint64 <db:emphasis>key</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>remove</db:methodname>
<db:methodparam>
<db:type>qint64</db:type>
<db:parameter>key</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void remove(qint64 key)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Removes the key <db:code role="parameter">key</db:code> and the corresponding value from the map, if it is found. If the map contains no such key, this function does nothing.</db:para>
<db:para>If the map contains more than one key equal to <db:code role="parameter">key</db:code>, it is undefined which one this function will remove. <db:link xlink:href="qcbormap.xml">QCborMap</db:link> does not allow inserting duplicate keys, but it is possible to create such a map by decoding a CBOR stream with them. They are usually not permitted and having duplicate keys is usually an indication of a problem in the sender.</db:para>
<db:para>remove(<db:link xlink:href="qlatin1string.xml">QLatin1String</db:link>), remove(const <db:link xlink:href="qstring.xml">QString</db:link> &amp;), remove(const <db:link xlink:href="qcborvalue.xml">QCborValue</db:link> &amp;)</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qcbormap.xml#value">value</db:link>(qint64)</db:member>
<db:member><db:link xlink:href="qcbormap.xml#operator-5b-5d">operator[]</db:link>(qint64)</db:member>
<db:member><db:link xlink:href="qcbormap.xml#find">find</db:link>(qint64)</db:member>
<db:member><db:link xlink:href="qcbormap.xml#contains">contains</db:link>(qint64)</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="remove-1">
<db:title>void QCborMap::remove(QLatin1String <db:emphasis>key</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>remove</db:methodname>
<db:methodparam>
<db:type>QLatin1String</db:type>
<db:parameter>key</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">void remove(QLatin1String key)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>Removes the key <db:code role="parameter">key</db:code> and the corresponding value from the map, if it is found. If the map contains no such key, this function does nothing.</db:para>
<db:para>If the map contains more than one key equal to <db:code role="parameter">key</db:code>, it is undefined which one this function will remove. <db:link xlink:href="qcbormap.xml">QCborMap</db:link> does not allow inserting duplicate keys, but it is possible to create such a map by decoding a CBOR stream with them. They are usually not permitted and having duplicate keys is usually an indication of a problem in the sender.</db:para>
<db:para>remove(qint64), remove(const <db:link xlink:href="qstring.xml">QString</db:link> &amp;), remove(const <db:link xlink:href="qcborvalue.xml">QCborValue</db:link> &amp;)</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qcbormap.xml#value-1">value</db:link>(QLatin1String)</db:member>
<db:member><db:link xlink:href="qcbormap.xml#operator-5b-5d-1">operator[]</db:link>(QLatin1String)</db:member>
<db:member><db:link xlink:href="qcbormap.xml#find-1">find</db:link>(QLatin1String)</db:member>
<db:member><db:link xlink:href="qcbormap.xml#contains-1">contains</db:link>(QLatin1String)</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="remove-2">
<db:title>void QCborMap::remove(const QString &amp;<db:emphasis>key</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>remove</db:methodname>
<db:methodparam>
<db:type>const QString &amp;</db:type>
<db:parameter>key</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">2</db:synopsisinfo>
<db:synopsisinfo role="signature">void remove(const QString &amp;key)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>Removes the key <db:code role="parameter">key</db:code> and the corresponding value from the map, if it is found. If the map contains no such key, this function does nothing.</db:para>
<db:para>If the map contains more than one key equal to <db:code role="parameter">key</db:code>, it is undefined which one this function will remove. <db:link xlink:href="qcbormap.xml">QCborMap</db:link> does not allow inserting duplicate keys, but it is possible to create such a map by decoding a CBOR stream with them. They are usually not permitted and having duplicate keys is usually an indication of a problem in the sender.</db:para>
<db:para>remove(qint64), remove(<db:link xlink:href="qlatin1string.xml">QLatin1String</db:link>), remove(const <db:link xlink:href="qcborvalue.xml">QCborValue</db:link> &amp;)</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qcbormap.xml#value-2">value</db:link>(const QString &amp;)</db:member>
<db:member><db:link xlink:href="qcbormap.xml#operator-5b-5d-2">operator[]</db:link>(const QString &amp;)</db:member>
<db:member><db:link xlink:href="qcbormap.xml#find-2">find</db:link>(const QString &amp;)</db:member>
<db:member><db:link xlink:href="qcbormap.xml#contains-2">contains</db:link>(const QString &amp;)</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="remove-3">
<db:title>void QCborMap::remove(const QCborValue &amp;<db:emphasis>key</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>remove</db:methodname>
<db:methodparam>
<db:type>const QCborValue &amp;</db:type>
<db:parameter>key</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">3</db:synopsisinfo>
<db:synopsisinfo role="signature">void remove(const QCborValue &amp;key)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Removes the key <db:code role="parameter">key</db:code> and the corresponding value from the map, if it is found. If the map contains no such key, this function does nothing.</db:para>
<db:para>If the map contains more than one key equal to <db:code role="parameter">key</db:code>, it is undefined which one this function will remove. <db:link xlink:href="qcbormap.xml">QCborMap</db:link> does not allow inserting duplicate keys, but it is possible to create such a map by decoding a CBOR stream with them. They are usually not permitted and having duplicate keys is usually an indication of a problem in the sender.</db:para>
<db:para>remove(qint64), remove(<db:link xlink:href="qlatin1string.xml">QLatin1String</db:link>), remove(const <db:link xlink:href="qstring.xml">QString</db:link> &amp;)</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qcbormap.xml#value-3">value</db:link>(const QCborValue &amp;)</db:member>
<db:member><db:link xlink:href="qcbormap.xml#operator-5b-5d-3">operator[]</db:link>(const QCborValue &amp;)</db:member>
<db:member><db:link xlink:href="qcbormap.xml#find-3">find</db:link>(const QCborValue &amp;)</db:member>
<db:member><db:link xlink:href="qcbormap.xml#contains-3">contains</db:link>(const QCborValue &amp;)</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="size">
<db:title>qsizetype QCborMap::size() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>qsizetype</db:type>
<db:methodname>size</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">qsizetype size() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the number of elements in this map.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qcbormap.xml#isEmpty">isEmpty</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="swap">
<db:title>void QCborMap::swap(QCborMap &amp;<db:emphasis>other</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>swap</db:methodname>
<db:methodparam>
<db:type>QCborMap &amp;</db:type>
<db:parameter>other</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void swap(QCborMap &amp;other)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Swaps the contents of this map and <db:code role="parameter">other</db:code>.</db:para>
</db:section>
<db:section xml:id="take">
<db:title>QCborValue QCborMap::take(qint64 <db:emphasis>key</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>QCborValue</db:type>
<db:methodname>take</db:methodname>
<db:methodparam>
<db:type>qint64</db:type>
<db:parameter>key</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QCborValue take(qint64 key)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Removes the key <db:code role="parameter">key</db:code> and the corresponding value from the map and returns the value, if it is found. If the map contains no such key, this function does nothing.</db:para>
<db:para>If the map contains more than one key equal to <db:code role="parameter">key</db:code>, it is undefined which one this function will remove. <db:link xlink:href="qcbormap.xml">QCborMap</db:link> does not allow inserting duplicate keys, but it is possible to create such a map by decoding a CBOR stream with them. They are usually not permitted and having duplicate keys is usually an indication of a problem in the sender.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qcbormap.xml#value">value</db:link>(qint64)</db:member>
<db:member><db:link xlink:href="qcbormap.xml#operator-5b-5d">operator[]</db:link>(qint64)</db:member>
<db:member><db:link xlink:href="qcbormap.xml#find">find</db:link>(qint64)</db:member>
<db:member><db:link xlink:href="qcbormap.xml#contains">contains</db:link>(qint64)</db:member>
<db:member><db:link xlink:href="qcbormap.xml#take-1">take</db:link>(QLatin1String)</db:member>
<db:member><db:link xlink:href="qcbormap.xml#take-2">take</db:link>(const QString &amp;)</db:member>
<db:member><db:link xlink:href="qcbormap.xml#take-3">take</db:link>(const QCborValue &amp;)</db:member>
<db:member><db:link xlink:href="qcbormap.xml#insert">insert</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="take-1">
<db:title>QCborValue QCborMap::take(QLatin1String <db:emphasis>key</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>QCborValue</db:type>
<db:methodname>take</db:methodname>
<db:methodparam>
<db:type>QLatin1String</db:type>
<db:parameter>key</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">QCborValue take(QLatin1String key)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Removes the key <db:code role="parameter">key</db:code> and the corresponding value from the map and returns the value, if it is found. If the map contains no such key, this function does nothing.</db:para>
<db:para>If the map contains more than one key equal to <db:code role="parameter">key</db:code>, it is undefined which one this function will remove. <db:link xlink:href="qcbormap.xml">QCborMap</db:link> does not allow inserting duplicate keys, but it is possible to create such a map by decoding a CBOR stream with them. They are usually not permitted and having duplicate keys is usually an indication of a problem in the sender.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qcbormap.xml#value-1">value</db:link>(QLatin1String)</db:member>
<db:member><db:link xlink:href="qcbormap.xml#operator-5b-5d-1">operator[]</db:link>(QLatin1String)</db:member>
<db:member><db:link xlink:href="qcbormap.xml#find-1">find</db:link>(QLatin1String)</db:member>
<db:member><db:link xlink:href="qcbormap.xml#contains-1">contains</db:link>(QLatin1String)</db:member>
<db:member><db:link xlink:href="qcbormap.xml#take">take</db:link>(qint64)</db:member>
<db:member><db:link xlink:href="qcbormap.xml#take-2">take</db:link>(const QString &amp;)</db:member>
<db:member><db:link xlink:href="qcbormap.xml#take-3">take</db:link>(const QCborValue &amp;)</db:member>
<db:member><db:link xlink:href="qcbormap.xml#insert">insert</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="take-2">
<db:title>QCborValue QCborMap::take(const QString &amp;<db:emphasis>key</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>QCborValue</db:type>
<db:methodname>take</db:methodname>
<db:methodparam>
<db:type>const QString &amp;</db:type>
<db:parameter>key</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">2</db:synopsisinfo>
<db:synopsisinfo role="signature">QCborValue take(const QString &amp;key)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Removes the key <db:code role="parameter">key</db:code> and the corresponding value from the map and returns the value, if it is found. If the map contains no such key, this function does nothing.</db:para>
<db:para>If the map contains more than one key equal to <db:code role="parameter">key</db:code>, it is undefined which one this function will remove. <db:link xlink:href="qcbormap.xml">QCborMap</db:link> does not allow inserting duplicate keys, but it is possible to create such a map by decoding a CBOR stream with them. They are usually not permitted and having duplicate keys is usually an indication of a problem in the sender.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qcbormap.xml#value-2">value</db:link>(const QString &amp;)</db:member>
<db:member><db:link xlink:href="qcbormap.xml#operator-5b-5d-2">operator[]</db:link>(const QString &amp;)</db:member>
<db:member><db:link xlink:href="qcbormap.xml#find-2">find</db:link>(const QString &amp;)</db:member>
<db:member><db:link xlink:href="qcbormap.xml#contains-2">contains</db:link>(const QString &amp;)</db:member>
<db:member><db:link xlink:href="qcbormap.xml#take-1">take</db:link>(QLatin1String)</db:member>
<db:member><db:link xlink:href="qcbormap.xml#take">take</db:link>(qint64)</db:member>
<db:member><db:link xlink:href="qcbormap.xml#take-3">take</db:link>(const QCborValue &amp;)</db:member>
<db:member><db:link xlink:href="qcbormap.xml#insert">insert</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="take-3">
<db:title>QCborValue QCborMap::take(const QCborValue &amp;<db:emphasis>key</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>QCborValue</db:type>
<db:methodname>take</db:methodname>
<db:methodparam>
<db:type>const QCborValue &amp;</db:type>
<db:parameter>key</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">3</db:synopsisinfo>
<db:synopsisinfo role="signature">QCborValue take(const QCborValue &amp;key)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Removes the key <db:code role="parameter">key</db:code> and the corresponding value from the map and returns the value, if it is found. If the map contains no such key, this function does nothing.</db:para>
<db:para>If the map contains more than one key equal to <db:code role="parameter">key</db:code>, it is undefined which one this function will remove. <db:link xlink:href="qcbormap.xml">QCborMap</db:link> does not allow inserting duplicate keys, but it is possible to create such a map by decoding a CBOR stream with them. They are usually not permitted and having duplicate keys is usually an indication of a problem in the sender.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qcbormap.xml#value-3">value</db:link>(const QCborValue &amp;)</db:member>
<db:member><db:link xlink:href="qcbormap.xml#operator-5b-5d-3">operator[]</db:link>(const QCborValue &amp;)</db:member>
<db:member><db:link xlink:href="qcbormap.xml#find-3">find</db:link>(const QCborValue &amp;)</db:member>
<db:member><db:link xlink:href="qcbormap.xml#contains-3">contains</db:link>(const QCborValue &amp;)</db:member>
<db:member><db:link xlink:href="qcbormap.xml#take-1">take</db:link>(QLatin1String)</db:member>
<db:member><db:link xlink:href="qcbormap.xml#take-2">take</db:link>(const QString &amp;)</db:member>
<db:member><db:link xlink:href="qcbormap.xml#take">take</db:link>(qint64)</db:member>
<db:member><db:link xlink:href="qcbormap.xml#insert">insert</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="toCborValue">
<db:title>QCborValue QCborMap::toCborValue() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QCborValue</db:type>
<db:methodname>toCborValue</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QCborValue toCborValue() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Explicitly constructs a <db:link xlink:href="qcborvalue.xml">QCborValue</db:link> object that represents this map. This function is usually not necessary since <db:link xlink:href="qcborvalue.xml">QCborValue</db:link> has a constructor for <db:link xlink:href="qcbormap.xml">QCborMap</db:link>, so the conversion is implicit.</db:para>
<db:para>Converting <db:link xlink:href="qcbormap.xml">QCborMap</db:link> to <db:link xlink:href="qcborvalue.xml">QCborValue</db:link> allows it to be used in any context where QCborValues can be used, including as keys and mapped types in <db:link xlink:href="qcbormap.xml">QCborMap</db:link>, as well as <db:link xlink:href="qcborvalue.xml#toCbor">QCborValue::toCbor</db:link>().</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qcborvalue.xml#QCborValue-13">QCborValue::QCborValue</db:link>(const QCborMap &amp;)</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="toJsonObject">
<db:title>QJsonObject QCborMap::toJsonObject() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QJsonObject</db:type>
<db:methodname>toJsonObject</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QJsonObject toJsonObject() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Recursively converts every <db:link xlink:href="qcborvalue.xml">QCborValue</db:link> value in this array to JSON using <db:link xlink:href="qcborvalue.xml#toJsonValue">QCborValue::toJsonValue</db:link>() and creates a string key for all keys that aren't strings, then returns the corresponding <db:link xlink:href="qjsonobject.xml">QJsonObject</db:link> composed of those associations.</db:para>
<db:para>Please note that CBOR contains a richer and wider type set than JSON, so some information may be lost in this conversion. For more details on what conversions are applied, see <db:link xlink:href="qcborvalue.xml#toJsonValue">QCborValue::toJsonValue</db:link>().</db:para>
<db:section xml:id="map-key-conversion-to-string">
<db:title>Map key conversion to string</db:title>
<db:para>JSON objects are defined as having string keys, unlike CBOR, so the conversion of a <db:link xlink:href="qcbormap.xml">QCborMap</db:link> to <db:link xlink:href="qjsonobject.xml">QJsonObject</db:link> will imply a step of &quot;stringification&quot; of the key values. The conversion will use the special handling of tags and extended types from above and will also convert the rest of the types as follows:</db:para>
<db:informaltable style="generic">
<db:thead>
<db:tr>
<db:th>
<db:para>Type</db:para>
</db:th>
<db:th>
<db:para>Transformation</db:para>
</db:th>
</db:tr>
</db:thead>
<db:tr valign="top">
<db:td>
<db:para>Bool</db:para>
</db:td>
<db:td>
<db:para>&quot;true&quot; and &quot;false&quot;</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>Null</db:para>
</db:td>
<db:td>
<db:para>&quot;null&quot;</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>Undefined</db:para>
</db:td>
<db:td>
<db:para>&quot;undefined&quot;</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>Integer</db:para>
</db:td>
<db:td>
<db:para>The decimal string form of the number</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>Double</db:para>
</db:td>
<db:td>
<db:para>The decimal string form of the number</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>Byte array</db:para>
</db:td>
<db:td>
<db:para>Unless tagged differently (see above), encoded as Base64url</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>Array</db:para>
</db:td>
<db:td>
<db:para>Replaced by the compact form of its <db:link xlink:href="qcborvalue.xml#toDiagnosticNotation">Diagnostic notation</db:link></db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>Map</db:para>
</db:td>
<db:td>
<db:para>Replaced by the compact form of its <db:link xlink:href="qcborvalue.xml#toDiagnosticNotation">Diagnostic notation</db:link></db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>Tags and extended types</db:para>
</db:td>
<db:td>
<db:para>Tag number is dropped and the tagged value is converted to string</db:para>
</db:td>
</db:tr>
</db:informaltable>
</db:section>
<db:section>
<db:title>Notes</db:title>
</db:section>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qcbormap.xml#fromJsonObject">fromJsonObject</db:link>()</db:member>
<db:member><db:link xlink:href="qcborvalue.xml#toJsonValue">QCborValue::toJsonValue</db:link>()</db:member>
<db:member><db:link xlink:href="qcborarray.xml#toJsonArray">QCborArray::toJsonArray</db:link>()</db:member>
<db:member><db:link xlink:href="qcbormap.xml#toVariantMap">toVariantMap</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="toVariantHash">
<db:title>QVariantHash QCborMap::toVariantHash() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QVariantHash</db:type>
<db:methodname>toVariantHash</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QVariantHash toVariantHash() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Converts the CBOR values to <db:link xlink:href="qvariant.xml">QVariant</db:link> using <db:link xlink:href="qcborvalue.xml#toVariant">QCborValue::toVariant</db:link>() and &quot;stringifies&quot; all the CBOR keys in this map, returning the <db:link xlink:href="qvariant.xml#QVariantHash-typedef">QVariantHash</db:link> that results from that association list.</db:para>
<db:para>QVariantMaps have string keys, unlike CBOR, so the conversion of a <db:link xlink:href="qcbormap.xml">QCborMap</db:link> to <db:link xlink:href="qvariant.xml#QVariantMap-typedef">QVariantMap</db:link> will imply a step of &quot;stringification&quot; of the key values. See <db:link xlink:href="qcbormap.xml#toJsonObject">QCborMap::toJsonObject</db:link>() for details.</db:para>
<db:para>In addition, the conversion to <db:link xlink:href="qvariant.xml">QVariant</db:link> is not completely lossless. Please see the documentation in <db:link xlink:href="qcborvalue.xml#toVariant">QCborValue::toVariant</db:link>() for more information.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qcbormap.xml#fromVariantHash">fromVariantHash</db:link>()</db:member>
<db:member><db:link xlink:href="qcbormap.xml#toVariantMap">toVariantMap</db:link>()</db:member>
<db:member><db:link xlink:href="qcbormap.xml#toJsonObject">toJsonObject</db:link>()</db:member>
<db:member><db:link xlink:href="qcborvalue.xml#toVariant">QCborValue::toVariant</db:link>()</db:member>
<db:member><db:link xlink:href="qcborarray.xml#toVariantList">QCborArray::toVariantList</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="toVariantMap">
<db:title>QVariantMap QCborMap::toVariantMap() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QVariantMap</db:type>
<db:methodname>toVariantMap</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QVariantMap toVariantMap() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Converts the CBOR values to <db:link xlink:href="qvariant.xml">QVariant</db:link> using <db:link xlink:href="qcborvalue.xml#toVariant">QCborValue::toVariant</db:link>() and &quot;stringifies&quot; all the CBOR keys in this map, returning the <db:link xlink:href="qvariant.xml#QVariantMap-typedef">QVariantMap</db:link> that results from that association list.</db:para>
<db:para>QVariantMaps have string keys, unlike CBOR, so the conversion of a <db:link xlink:href="qcbormap.xml">QCborMap</db:link> to <db:link xlink:href="qvariant.xml#QVariantMap-typedef">QVariantMap</db:link> will imply a step of &quot;stringification&quot; of the key values. See <db:link xlink:href="qcbormap.xml#toJsonObject">QCborMap::toJsonObject</db:link>() for details.</db:para>
<db:para>In addition, the conversion to <db:link xlink:href="qvariant.xml">QVariant</db:link> is not completely lossless. Please see the documentation in <db:link xlink:href="qcborvalue.xml#toVariant">QCborValue::toVariant</db:link>() for more information.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qcbormap.xml#fromVariantMap">fromVariantMap</db:link>()</db:member>
<db:member><db:link xlink:href="qcbormap.xml#toVariantHash">toVariantHash</db:link>()</db:member>
<db:member><db:link xlink:href="qcbormap.xml#toJsonObject">toJsonObject</db:link>()</db:member>
<db:member><db:link xlink:href="qcborvalue.xml#toVariant">QCborValue::toVariant</db:link>()</db:member>
<db:member><db:link xlink:href="qcborarray.xml#toVariantList">QCborArray::toVariantList</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="value">
<db:title>QCborValue QCborMap::value(qint64 <db:emphasis>key</db:emphasis>) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QCborValue</db:type>
<db:methodname>value</db:methodname>
<db:methodparam>
<db:type>qint64</db:type>
<db:parameter>key</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QCborValue value(qint64 key) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the <db:link xlink:href="qcborvalue.xml">QCborValue</db:link> element in this map that corresponds to key <db:code role="parameter">key</db:code>, if there is one. CBOR recommends using integer keys, since they occupy less space and are simpler to encode and decode.</db:para>
<db:para>If the map does not contain key <db:code role="parameter">key</db:code>, this function returns a <db:link xlink:href="qcborvalue.xml">QCborValue</db:link> containing an undefined value. For that reason, it is not possible with this function to tell apart the situation where the key was not present from the situation where the key was mapped to an undefined value.</db:para>
<db:para>If the map contains more than one key equal to <db:code role="parameter">key</db:code>, it is undefined which one the return from function will reference. <db:link xlink:href="qcbormap.xml">QCborMap</db:link> does not allow inserting duplicate keys, but it is possible to create such a map by decoding a CBOR stream with them. They are usually not permitted and having duplicate keys is usually an indication of a problem in the sender.</db:para>
<db:para>value(<db:link xlink:href="qlatin1string.xml">QLatin1String</db:link>), value(const <db:link xlink:href="qstring.xml">QString</db:link> &amp;), value(const <db:link xlink:href="qcborvalue.xml">QCborValue</db:link> &amp;)</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qcbormap.xml#operator-5b-5d">operator[]</db:link>(qint64)</db:member>
<db:member><db:link xlink:href="qcbormap.xml#find">find</db:link>(qint64)</db:member>
<db:member><db:link xlink:href="qcbormap.xml#constFind">constFind</db:link>(qint64)</db:member>
<db:member><db:link xlink:href="qcbormap.xml#remove">remove</db:link>(qint64)</db:member>
<db:member><db:link xlink:href="qcbormap.xml#contains">contains</db:link>(qint64)</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="value-1">
<db:title>QCborValue QCborMap::value(QLatin1String <db:emphasis>key</db:emphasis>) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QCborValue</db:type>
<db:methodname>value</db:methodname>
<db:methodparam>
<db:type>QLatin1String</db:type>
<db:parameter>key</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">QCborValue value(QLatin1String key) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>Returns the <db:link xlink:href="qcborvalue.xml">QCborValue</db:link> element in this map that corresponds to key <db:code role="parameter">key</db:code>, if there is one.</db:para>
<db:para>If the map does not contain key <db:code role="parameter">key</db:code>, this function returns a <db:link xlink:href="qcborvalue.xml">QCborValue</db:link> containing an undefined value. For that reason, it is not possible with this function to tell apart the situation where the key was not present from the situation where the key was mapped to an undefined value.</db:para>
<db:para>If the map contains more than one key equal to <db:code role="parameter">key</db:code>, it is undefined which one this function will return. <db:link xlink:href="qcbormap.xml">QCborMap</db:link> does not allow inserting duplicate keys, but it is possible to create such a map by decoding a CBOR stream with them. They are usually not permitted and having duplicate keys is usually an indication of a problem in the sender.</db:para>
<db:para>value(qint64), value(const <db:link xlink:href="qstring.xml">QString</db:link> &amp;), value(const <db:link xlink:href="qcborvalue.xml">QCborValue</db:link> &amp;)</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qcbormap.xml#operator-5b-5d-1">operator[]</db:link>(QLatin1String)</db:member>
<db:member><db:link xlink:href="qcbormap.xml#find-1">find</db:link>(QLatin1String)</db:member>
<db:member><db:link xlink:href="qcbormap.xml#constFind-1">constFind</db:link>(QLatin1String)</db:member>
<db:member><db:link xlink:href="qcbormap.xml#remove-1">remove</db:link>(QLatin1String)</db:member>
<db:member><db:link xlink:href="qcbormap.xml#contains-1">contains</db:link>(QLatin1String)</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="value-2">
<db:title>QCborValue QCborMap::value(const QString &amp;<db:emphasis>key</db:emphasis>) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QCborValue</db:type>
<db:methodname>value</db:methodname>
<db:methodparam>
<db:type>const QString &amp;</db:type>
<db:parameter>key</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">2</db:synopsisinfo>
<db:synopsisinfo role="signature">QCborValue value(const QString &amp;key) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>Returns the <db:link xlink:href="qcborvalue.xml">QCborValue</db:link> element in this map that corresponds to key <db:code role="parameter">key</db:code>, if there is one.</db:para>
<db:para>If the map does not contain key <db:code role="parameter">key</db:code>, this function returns a <db:link xlink:href="qcborvalue.xml">QCborValue</db:link> containing an undefined value. For that reason, it is not possible with this function to tell apart the situation where the key was not present from the situation where the key was mapped to an undefined value.</db:para>
<db:para>If the map contains more than one key equal to <db:code role="parameter">key</db:code>, it is undefined which one this function will return. <db:link xlink:href="qcbormap.xml">QCborMap</db:link> does not allow inserting duplicate keys, but it is possible to create such a map by decoding a CBOR stream with them. They are usually not permitted and having duplicate keys is usually an indication of a problem in the sender.</db:para>
<db:para>value(qint64), value(<db:link xlink:href="qlatin1string.xml">QLatin1String</db:link>), value(const <db:link xlink:href="qcborvalue.xml">QCborValue</db:link> &amp;)</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qcbormap.xml#operator-5b-5d-2">operator[]</db:link>(const QString &amp;)</db:member>
<db:member><db:link xlink:href="qcbormap.xml#find-2">find</db:link>(const QString &amp;)</db:member>
<db:member><db:link xlink:href="qcbormap.xml#constFind-2">constFind</db:link>(const QString &amp;)</db:member>
<db:member><db:link xlink:href="qcbormap.xml#remove-2">remove</db:link>(const QString &amp;)</db:member>
<db:member><db:link xlink:href="qcbormap.xml#contains-2">contains</db:link>(const QString &amp;)</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="value-3">
<db:title>QCborValue QCborMap::value(const QCborValue &amp;<db:emphasis>key</db:emphasis>) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QCborValue</db:type>
<db:methodname>value</db:methodname>
<db:methodparam>
<db:type>const QCborValue &amp;</db:type>
<db:parameter>key</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">3</db:synopsisinfo>
<db:synopsisinfo role="signature">QCborValue value(const QCborValue &amp;key) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the <db:link xlink:href="qcborvalue.xml">QCborValue</db:link> element in this map that corresponds to key <db:code role="parameter">key</db:code>, if there is one.</db:para>
<db:para>If the map does not contain key <db:code role="parameter">key</db:code>, this function returns a <db:link xlink:href="qcborvalue.xml">QCborValue</db:link> containing an undefined value. For that reason, it is not possible with this function to tell apart the situation where the key was not present from the situation where the key was mapped to an undefined value.</db:para>
<db:para>If the map contains more than one key equal to <db:code role="parameter">key</db:code>, it is undefined which one this function will return. <db:link xlink:href="qcbormap.xml">QCborMap</db:link> does not allow inserting duplicate keys, but it is possible to create such a map by decoding a CBOR stream with them. They are usually not permitted and having duplicate keys is usually an indication of a problem in the sender.</db:para>
<db:para>value(qint64), value(<db:link xlink:href="qlatin1string.xml">QLatin1String</db:link>), value(const <db:link xlink:href="qstring.xml">QString</db:link> &amp;)</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qcbormap.xml#operator-5b-5d-3">operator[]</db:link>(const QCborValue &amp;)</db:member>
<db:member><db:link xlink:href="qcbormap.xml#find-3">find</db:link>(const QCborValue &amp;)</db:member>
<db:member><db:link xlink:href="qcbormap.xml#constFind-3">constFind</db:link>(const QCborValue &amp;)</db:member>
<db:member><db:link xlink:href="qcbormap.xml#remove-3">remove</db:link>(const QCborValue &amp;)</db:member>
<db:member><db:link xlink:href="qcbormap.xml#contains-3">contains</db:link>(const QCborValue &amp;)</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="operator-not-eq">
<db:title>bool QCborMap::operator!=(const QCborMap &amp;<db:emphasis>other</db:emphasis>) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>bool</db:type>
<db:methodname>operator!=</db:methodname>
<db:methodparam>
<db:type>const QCborMap &amp;</db:type>
<db:parameter>other</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool operator!=(const QCborMap &amp;other) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Compares this map and <db:code role="parameter">other</db:code>, comparing each element in sequence, and returns true if the two maps contains any different elements or elements in different orders, false otherwise.</db:para>
<db:para>Note that CBOR maps are unordered, which means that two maps containing the very same pairs but in different order will still compare differently. To avoid this, it is recommended to insert elements into the map in a predictable order, such as by ascending key value. In fact, maps with keys in sorted order are required for Canonical CBOR representation.</db:para>
<db:para>For more information on CBOR equality in Qt, see, <db:link xlink:href="qcborvalue.xml#compare">QCborValue::compare</db:link>().</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qcbormap.xml#compare">compare</db:link>()</db:member>
<db:member><db:link xlink:href="qcborvalue.xml#operator-eq-eq">QCborValue::operator==</db:link>()</db:member>
<db:member><db:link xlink:href="qcbormap.xml#operator-eq-eq">QCborMap::operator==</db:link>()</db:member>
<db:member><db:link xlink:href="qcbormap.xml#operator-eq-eq">operator==</db:link>()</db:member>
<db:member><db:link xlink:href="qcbormap.xml#operator-lt">operator&lt;</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="operator-lt">
<db:title>bool QCborMap::operator&lt;(const QCborMap &amp;<db:emphasis>other</db:emphasis>) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>bool</db:type>
<db:methodname>operator&lt;</db:methodname>
<db:methodparam>
<db:type>const QCborMap &amp;</db:type>
<db:parameter>other</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool operator&lt;(const QCborMap &amp;other) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Compares this map and <db:code role="parameter">other</db:code>, comparing each element in sequence, and returns true if this map should be sorted before <db:code role="parameter">other</db:code>, false otherwise.</db:para>
<db:para>Note that CBOR maps are unordered, which means that two maps containing the very same pairs but in different order will still compare differently. To avoid this, it is recommended to insert elements into the map in a predictable order, such as by ascending key value. In fact, maps with keys in sorted order are required for Canonical CBOR representation.</db:para>
<db:para>For more information on CBOR sorting order, see <db:link xlink:href="qcborvalue.xml#compare">QCborValue::compare</db:link>().</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qcbormap.xml#compare">compare</db:link>()</db:member>
<db:member><db:link xlink:href="qcborvalue.xml#operator-eq-eq">QCborValue::operator==</db:link>()</db:member>
<db:member><db:link xlink:href="qcbormap.xml#operator-eq-eq">QCborMap::operator==</db:link>()</db:member>
<db:member><db:link xlink:href="qcbormap.xml#operator-eq-eq">operator==</db:link>()</db:member>
<db:member><db:link xlink:href="qcbormap.xml#operator-not-eq">operator!=</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="operator-eq">
<db:title>QCborMap &amp;QCborMap::operator=(const QCborMap &amp;<db:emphasis>other</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>QCborMap &amp;</db:type>
<db:methodname>operator=</db:methodname>
<db:methodparam>
<db:type>const QCborMap &amp;</db:type>
<db:parameter>other</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">copy-assign</db:synopsisinfo>
<db:synopsisinfo role="signature">QCborMap &amp; operator=(const QCborMap &amp;other)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Replaces the contents of this object with a copy of <db:code role="parameter">other</db:code>, then returns a reference to this object.</db:para>
</db:section>
<db:section xml:id="operator-eq-eq">
<db:title>bool QCborMap::operator==(const QCborMap &amp;<db:emphasis>other</db:emphasis>) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>bool</db:type>
<db:methodname>operator==</db:methodname>
<db:methodparam>
<db:type>const QCborMap &amp;</db:type>
<db:parameter>other</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool operator==(const QCborMap &amp;other) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Compares this map and <db:code role="parameter">other</db:code>, comparing each element in sequence, and returns true if the two maps contains the same elements in the same order, false otherwise.</db:para>
<db:para>Note that CBOR maps are unordered, which means that two maps containing the very same pairs but in different order will still compare differently. To avoid this, it is recommended to insert elements into the map in a predictable order, such as by ascending key value. In fact, maps with keys in sorted order are required for Canonical CBOR representation.</db:para>
<db:para>For more information on CBOR equality in Qt, see, <db:link xlink:href="qcborvalue.xml#compare">QCborValue::compare</db:link>().</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qcbormap.xml#compare">compare</db:link>()</db:member>
<db:member><db:link xlink:href="qcborvalue.xml#operator-eq-eq">QCborValue::operator==</db:link>()</db:member>
<db:member><db:link xlink:href="">QCborMap::operator==</db:link>()</db:member>
<db:member><db:link xlink:href="qcbormap.xml#operator-not-eq">operator!=</db:link>()</db:member>
<db:member><db:link xlink:href="qcbormap.xml#operator-lt">operator&lt;</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="operator-5b-5d">
<db:title>const QCborValue QCborMap::operator[](qint64 <db:emphasis>key</db:emphasis>) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>const QCborValue</db:type>
<db:methodname>operator[]</db:methodname>
<db:methodparam>
<db:type>qint64</db:type>
<db:parameter>key</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">const QCborValue operator[](qint64 key) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the <db:link xlink:href="qcborvalue.xml">QCborValue</db:link> element in this map that corresponds to key <db:code role="parameter">key</db:code>, if there is one. CBOR recommends using integer keys, since they occupy less space and are simpler to encode and decode.</db:para>
<db:para>If the map does not contain key <db:code role="parameter">key</db:code>, this function returns a <db:link xlink:href="qcborvalue.xml">QCborValue</db:link> containing an undefined value. For that reason, it is not possible with this function to tell apart the situation where the key was not present from the situation where the key was mapped to an undefined value.</db:para>
<db:para>If the map contains more than one key equal to <db:code role="parameter">key</db:code>, it is undefined which one this function will return. <db:link xlink:href="qcbormap.xml">QCborMap</db:link> does not allow inserting duplicate keys, but it is possible to create such a map by decoding a CBOR stream with them. They are usually not permitted and having duplicate keys is usually an indication of a problem in the sender.</db:para>
<db:para>operator[](<db:link xlink:href="qlatin1string.xml">QLatin1String</db:link>), operator[](const <db:link xlink:href="qstring.xml">QString</db:link> &amp;), operator[](const QCborOperator[] &amp;)</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qcbormap.xml#value">value</db:link>(qint64)</db:member>
<db:member><db:link xlink:href="qcbormap.xml#find">find</db:link>(qint64)</db:member>
<db:member><db:link xlink:href="qcbormap.xml#constFind">constFind</db:link>(qint64)</db:member>
<db:member><db:link xlink:href="qcbormap.xml#remove">remove</db:link>(qint64)</db:member>
<db:member><db:link xlink:href="qcbormap.xml#contains">contains</db:link>(qint64)</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="operator-5b-5d-1">
<db:title>const QCborValue QCborMap::operator[](QLatin1String <db:emphasis>key</db:emphasis>) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>const QCborValue</db:type>
<db:methodname>operator[]</db:methodname>
<db:methodparam>
<db:type>QLatin1String</db:type>
<db:parameter>key</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">const QCborValue operator[](QLatin1String key) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>Returns the <db:link xlink:href="qcborvalue.xml">QCborValue</db:link> element in this map that corresponds to key <db:code role="parameter">key</db:code>, if there is one.</db:para>
<db:para>If the map does not contain key <db:code role="parameter">key</db:code>, this function returns a <db:link xlink:href="qcborvalue.xml">QCborValue</db:link> containing an undefined value. For that reason, it is not possible with this function to tell apart the situation where the key was not present from the situation where the key was mapped to an undefined value.</db:para>
<db:para>If the map contains more than one key equal to <db:code role="parameter">key</db:code>, it is undefined which one this function will return. <db:link xlink:href="qcbormap.xml">QCborMap</db:link> does not allow inserting duplicate keys, but it is possible to create such a map by decoding a CBOR stream with them. They are usually not permitted and having duplicate keys is usually an indication of a problem in the sender.</db:para>
<db:para>operator[](qint64), operator[](const <db:link xlink:href="qstring.xml">QString</db:link> &amp;), operator[](const QCborOperator[] &amp;)</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qcbormap.xml#value-1">value</db:link>(QLatin1String)</db:member>
<db:member><db:link xlink:href="qcbormap.xml#find-1">find</db:link>(QLatin1String)</db:member>
<db:member><db:link xlink:href="qcbormap.xml#constFind-1">constFind</db:link>(QLatin1String)</db:member>
<db:member><db:link xlink:href="qcbormap.xml#remove-1">remove</db:link>(QLatin1String)</db:member>
<db:member><db:link xlink:href="qcbormap.xml#contains-1">contains</db:link>(QLatin1String)</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="operator-5b-5d-2">
<db:title>const QCborValue QCborMap::operator[](const QString &amp;<db:emphasis>key</db:emphasis>) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>const QCborValue</db:type>
<db:methodname>operator[]</db:methodname>
<db:methodparam>
<db:type>const QString &amp;</db:type>
<db:parameter>key</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">2</db:synopsisinfo>
<db:synopsisinfo role="signature">const QCborValue operator[](const QString &amp;key) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>Returns the <db:link xlink:href="qcborvalue.xml">QCborValue</db:link> element in this map that corresponds to key <db:code role="parameter">key</db:code>, if there is one.</db:para>
<db:para>If the map does not contain key <db:code role="parameter">key</db:code>, this function returns a <db:link xlink:href="qcborvalue.xml">QCborValue</db:link> containing an undefined value. For that reason, it is not possible with this function to tell apart the situation where the key was not present from the situation where the key was mapped to an undefined value.</db:para>
<db:para>If the map contains more than one key equal to <db:code role="parameter">key</db:code>, it is undefined which one this function will return. <db:link xlink:href="qcbormap.xml">QCborMap</db:link> does not allow inserting duplicate keys, but it is possible to create such a map by decoding a CBOR stream with them. They are usually not permitted and having duplicate keys is usually an indication of a problem in the sender.</db:para>
<db:para>operator[](qint64), operator[](<db:link xlink:href="qlatin1string.xml">QLatin1String</db:link>), operator[](const QCborOperator[] &amp;)</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qcbormap.xml#value-2">value</db:link>(const QString &amp;)</db:member>
<db:member><db:link xlink:href="qcbormap.xml#find-2">find</db:link>(const QString &amp;)</db:member>
<db:member><db:link xlink:href="qcbormap.xml#constFind-2">constFind</db:link>(const QString &amp;)</db:member>
<db:member><db:link xlink:href="qcbormap.xml#remove-2">remove</db:link>(const QString &amp;)</db:member>
<db:member><db:link xlink:href="qcbormap.xml#contains-2">contains</db:link>(const QString &amp;)</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="operator-5b-5d-3">
<db:title>const QCborValue QCborMap::operator[](const QCborValue &amp;<db:emphasis>key</db:emphasis>) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>const QCborValue</db:type>
<db:methodname>operator[]</db:methodname>
<db:methodparam>
<db:type>const QCborValue &amp;</db:type>
<db:parameter>key</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">3</db:synopsisinfo>
<db:synopsisinfo role="signature">const QCborValue operator[](const QCborValue &amp;key) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the <db:link xlink:href="qcborvalue.xml">QCborValue</db:link> element in this map that corresponds to key <db:code role="parameter">key</db:code>, if there is one.</db:para>
<db:para>If the map does not contain key <db:code role="parameter">key</db:code>, this function returns a <db:link xlink:href="qcborvalue.xml">QCborValue</db:link> containing an undefined value. For that reason, it is not possible with this function to tell apart the situation where the key was not present from the situation where the key was mapped to an undefined value.</db:para>
<db:para>If the map contains more than one key equal to <db:code role="parameter">key</db:code>, it is undefined which one this function will return. <db:link xlink:href="qcbormap.xml">QCborMap</db:link> does not allow inserting duplicate keys, but it is possible to create such a map by decoding a CBOR stream with them. They are usually not permitted and having duplicate keys is usually an indication of a problem in the sender.</db:para>
<db:para>operator[](qint64), operator[](<db:link xlink:href="qlatin1string.xml">QLatin1String</db:link>), operator[](const QCborOperator[] &amp;)</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qcbormap.xml#value-3">value</db:link>(const QCborValue &amp;)</db:member>
<db:member><db:link xlink:href="qcbormap.xml#find-3">find</db:link>(const QCborValue &amp;)</db:member>
<db:member><db:link xlink:href="qcbormap.xml#constFind-3">constFind</db:link>(const QCborValue &amp;)</db:member>
<db:member><db:link xlink:href="qcbormap.xml#remove-3">remove</db:link>(const QCborValue &amp;)</db:member>
<db:member><db:link xlink:href="qcbormap.xml#contains-3">contains</db:link>(const QCborValue &amp;)</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="operator-5b-5d-5">
<db:title>QCborValueRef QCborMap::operator[](qint64 <db:emphasis>key</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>QCborValueRef</db:type>
<db:methodname>operator[]</db:methodname>
<db:methodparam>
<db:type>qint64</db:type>
<db:parameter>key</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">5</db:synopsisinfo>
<db:synopsisinfo role="signature">QCborValueRef operator[](qint64 key)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns a <db:link xlink:href="qcborvalue.xml#qcborvalueref">QCborValueRef</db:link> to the value in this map that corresponds to key <db:code role="parameter">key</db:code>. CBOR recommends using integer keys, since they occupy less space and are simpler to encode and decode.</db:para>
<db:para><db:link xlink:href="qcborvalue.xml#qcborvalueref">QCborValueRef</db:link> has the exact same API as <db:link xlink:href="qcborvalue.xml">QCborValue</db:link>, with one important difference: if you assign new values to it, this map will be updated with that new value.</db:para>
<db:para>If the map did not have a key equal to <db:code role="parameter">key</db:code>, one is inserted and this function returns a reference to the new value, which will be a <db:link xlink:href="qcborvalue.xml">QCborValue</db:link> with an undefined value. For that reason, it is not possible with this function to tell apart the situation where the key was not present from the situation where the key was mapped to an undefined value.</db:para>
<db:para>If the map contains more than one key equal to <db:code role="parameter">key</db:code>, it is undefined which one the return will reference. <db:link xlink:href="qcbormap.xml">QCborMap</db:link> does not allow inserting duplicate keys, but it is possible to create such a map by decoding a CBOR stream with them. They are usually not permitted and having duplicate keys is usually an indication of a problem in the sender.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qcbormap.xml#value">value</db:link>(qint64)</db:member>
<db:member><db:link xlink:href="qcbormap.xml#find">find</db:link>(qint64)</db:member>
<db:member><db:link xlink:href="qcbormap.xml#contains">contains</db:link>(qint64)</db:member>
<db:member><db:link xlink:href="qcbormap.xml#remove">remove</db:link>(qint64)</db:member>
<db:member><db:link xlink:href="qcbormap.xml#operator-5b-5d-1">operator[]</db:link>(QLatin1String)</db:member>
<db:member><db:link xlink:href="qcbormap.xml#operator-5b-5d-2">operator[]</db:link>(const QString &amp;)</db:member>
<db:member><db:link xlink:href="qcbormap.xml#operator-5b-5d-3">operator[]</db:link>(const QCborValue &amp;)</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="operator-5b-5d-6">
<db:title>QCborValueRef QCborMap::operator[](QLatin1String <db:emphasis>key</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>QCborValueRef</db:type>
<db:methodname>operator[]</db:methodname>
<db:methodparam>
<db:type>QLatin1String</db:type>
<db:parameter>key</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">6</db:synopsisinfo>
<db:synopsisinfo role="signature">QCborValueRef operator[](QLatin1String key)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>Returns a <db:link xlink:href="qcborvalue.xml#qcborvalueref">QCborValueRef</db:link> to the value in this map that corresponds to key <db:code role="parameter">key</db:code>.</db:para>
<db:para><db:link xlink:href="qcborvalue.xml#qcborvalueref">QCborValueRef</db:link> has the exact same API as <db:link xlink:href="qcborvalue.xml">QCborValue</db:link>, with one important difference: if you assign new values to it, this map will be updated with that new value.</db:para>
<db:para>If the map did not have a key equal to <db:code role="parameter">key</db:code>, one is inserted and this function returns a reference to the new value, which will be a <db:link xlink:href="qcborvalue.xml">QCborValue</db:link> with an undefined value. For that reason, it is not possible with this function to tell apart the situation where the key was not present from the situation where the key was mapped to an undefined value.</db:para>
<db:para>If the map contains more than one key equal to <db:code role="parameter">key</db:code>, it is undefined which one the return will reference. <db:link xlink:href="qcbormap.xml">QCborMap</db:link> does not allow inserting duplicate keys, but it is possible to create such a map by decoding a CBOR stream with them. They are usually not permitted and having duplicate keys is usually an indication of a problem in the sender.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qcbormap.xml#value-1">value</db:link>(QLatin1String)</db:member>
<db:member><db:link xlink:href="qcbormap.xml#find-1">find</db:link>(QLatin1String)</db:member>
<db:member><db:link xlink:href="qcbormap.xml#contains-1">contains</db:link>(QLatin1String)</db:member>
<db:member><db:link xlink:href="qcbormap.xml#remove-1">remove</db:link>(QLatin1String)</db:member>
<db:member><db:link xlink:href="qcbormap.xml#operator-5b-5d">operator[]</db:link>(qint64)</db:member>
<db:member><db:link xlink:href="qcbormap.xml#operator-5b-5d-2">operator[]</db:link>(const QString &amp;)</db:member>
<db:member><db:link xlink:href="qcbormap.xml#operator-5b-5d-3">operator[]</db:link>(const QCborValue &amp;)</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="operator-5b-5d-7">
<db:title>QCborValueRef QCborMap::operator[](const QString &amp;<db:emphasis>key</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>QCborValueRef</db:type>
<db:methodname>operator[]</db:methodname>
<db:methodparam>
<db:type>const QString &amp;</db:type>
<db:parameter>key</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">7</db:synopsisinfo>
<db:synopsisinfo role="signature">QCborValueRef operator[](const QString &amp;key)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>Returns a <db:link xlink:href="qcborvalue.xml#qcborvalueref">QCborValueRef</db:link> to the value in this map that corresponds to key <db:code role="parameter">key</db:code>.</db:para>
<db:para><db:link xlink:href="qcborvalue.xml#qcborvalueref">QCborValueRef</db:link> has the exact same API as <db:link xlink:href="qcborvalue.xml">QCborValue</db:link>, with one important difference: if you assign new values to it, this map will be updated with that new value.</db:para>
<db:para>If the map did not have a key equal to <db:code role="parameter">key</db:code>, one is inserted and this function returns a reference to the new value, which will be a <db:link xlink:href="qcborvalue.xml">QCborValue</db:link> with an undefined value. For that reason, it is not possible with this function to tell apart the situation where the key was not present from the situation where the key was mapped to an undefined value.</db:para>
<db:para>If the map contains more than one key equal to <db:code role="parameter">key</db:code>, it is undefined which one the return will reference. <db:link xlink:href="qcbormap.xml">QCborMap</db:link> does not allow inserting duplicate keys, but it is possible to create such a map by decoding a CBOR stream with them. They are usually not permitted and having duplicate keys is usually an indication of a problem in the sender.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qcbormap.xml#value-2">value</db:link>(const QString &amp;)</db:member>
<db:member><db:link xlink:href="qcbormap.xml#find-2">find</db:link>(const QString &amp;)</db:member>
<db:member><db:link xlink:href="qcbormap.xml#contains-2">contains</db:link>(const QString &amp;)</db:member>
<db:member><db:link xlink:href="qcbormap.xml#remove-2">remove</db:link>(const QString &amp;)</db:member>
<db:member><db:link xlink:href="qcbormap.xml#operator-5b-5d">operator[]</db:link>(qint64)</db:member>
<db:member><db:link xlink:href="qcbormap.xml#operator-5b-5d-1">operator[]</db:link>(QLatin1String)</db:member>
<db:member><db:link xlink:href="qcbormap.xml#operator-5b-5d-3">operator[]</db:link>(const QCborValue &amp;)</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="operator-5b-5d-8">
<db:title>QCborValueRef QCborMap::operator[](const QCborValue &amp;<db:emphasis>key</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>QCborValueRef</db:type>
<db:methodname>operator[]</db:methodname>
<db:methodparam>
<db:type>const QCborValue &amp;</db:type>
<db:parameter>key</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">8</db:synopsisinfo>
<db:synopsisinfo role="signature">QCborValueRef operator[](const QCborValue &amp;key)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>Returns a <db:link xlink:href="qcborvalue.xml#qcborvalueref">QCborValueRef</db:link> to the value in this map that corresponds to key <db:code role="parameter">key</db:code>.</db:para>
<db:para><db:link xlink:href="qcborvalue.xml#qcborvalueref">QCborValueRef</db:link> has the exact same API as <db:link xlink:href="qcborvalue.xml">QCborValue</db:link>, with one important difference: if you assign new values to it, this map will be updated with that new value.</db:para>
<db:para>If the map did not have a key equal to <db:code role="parameter">key</db:code>, one is inserted and this function returns a reference to the new value, which will be a <db:link xlink:href="qcborvalue.xml">QCborValue</db:link> with an undefined value. For that reason, it is not possible with this function to tell apart the situation where the key was not present from the situation where the key was mapped to an undefined value.</db:para>
<db:para>If the map contains more than one key equal to <db:code role="parameter">key</db:code>, it is undefined which one the return will reference. <db:link xlink:href="qcbormap.xml">QCborMap</db:link> does not allow inserting duplicate keys, but it is possible to create such a map by decoding a CBOR stream with them. They are usually not permitted and having duplicate keys is usually an indication of a problem in the sender.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qcbormap.xml#value-3">value</db:link>(const QCborValue &amp;)</db:member>
<db:member><db:link xlink:href="qcbormap.xml#find-3">find</db:link>(const QCborValue &amp;)</db:member>
<db:member><db:link xlink:href="qcbormap.xml#contains-3">contains</db:link>(const QCborValue &amp;)</db:member>
<db:member><db:link xlink:href="qcbormap.xml#remove-3">remove</db:link>(const QCborValue &amp;)</db:member>
<db:member><db:link xlink:href="qcbormap.xml#operator-5b-5d">operator[]</db:link>(qint64)</db:member>
<db:member><db:link xlink:href="qcbormap.xml#operator-5b-5d-1">operator[]</db:link>(QLatin1String)</db:member>
<db:member><db:link xlink:href="qcbormap.xml#operator-5b-5d-2">operator[]</db:link>(const QString &amp;)</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
</db:section>
</db:article>
